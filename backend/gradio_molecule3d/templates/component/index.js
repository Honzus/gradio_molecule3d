function _mergeNamespaces(a, e) {
  for (var r = 0; r < e.length; r++) {
    const n = e[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const s in n)
        if (s !== "default" && !(s in a)) {
          const h = Object.getOwnPropertyDescriptor(n, s);
          h && Object.defineProperty(a, s, h.get ? h : {
            enumerable: !0,
            get: () => n[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }));
}
const {
  SvelteComponent: SvelteComponent$p,
  assign: assign$2,
  children: children$l,
  claim_element: claim_element$e,
  create_slot: create_slot$7,
  detach: detach$o,
  element: element$e,
  get_all_dirty_from_scope: get_all_dirty_from_scope$7,
  get_slot_changes: get_slot_changes$7,
  get_spread_update: get_spread_update$2,
  init: init$p,
  insert_hydration: insert_hydration$o,
  safe_not_equal: safe_not_equal$p,
  set_dynamic_element_data,
  set_style: set_style$8,
  toggle_class: toggle_class$c,
  transition_in: transition_in$e,
  transition_out: transition_out$d,
  update_slot_base: update_slot_base$7
} = window.__gradio__svelte__internal;
function create_dynamic_element(a) {
  let e, r, n;
  const s = (
    /*#slots*/
    a[22].default
  ), h = create_slot$7(
    s,
    a,
    /*$$scope*/
    a[21],
    null
  );
  let b = [
    { "data-testid": (
      /*test_id*/
      a[9]
    ) },
    { id: (
      /*elem_id*/
      a[4]
    ) },
    {
      class: r = "block " + /*elem_classes*/
      a[5].join(" ") + " svelte-1ezsyiy"
    }
  ], g = {};
  for (let _ = 0; _ < b.length; _ += 1)
    g = assign$2(g, b[_]);
  return {
    c() {
      e = element$e(
        /*tag*/
        a[18]
      ), h && h.c(), this.h();
    },
    l(_) {
      e = claim_element$e(
        _,
        /*tag*/
        (a[18] || "null").toUpperCase(),
        {
          "data-testid": !0,
          id: !0,
          class: !0
        }
      );
      var A = children$l(e);
      h && h.l(A), A.forEach(detach$o), this.h();
    },
    h() {
      set_dynamic_element_data(
        /*tag*/
        a[18]
      )(e, g), toggle_class$c(
        e,
        "hidden",
        /*visible*/
        a[12] === !1
      ), toggle_class$c(
        e,
        "padded",
        /*padding*/
        a[8]
      ), toggle_class$c(
        e,
        "flex",
        /*flex*/
        a[17]
      ), toggle_class$c(
        e,
        "border_focus",
        /*border_mode*/
        a[7] === "focus"
      ), toggle_class$c(
        e,
        "border_contrast",
        /*border_mode*/
        a[7] === "contrast"
      ), toggle_class$c(e, "hide-container", !/*explicit_call*/
      a[10] && !/*container*/
      a[11]), set_style$8(
        e,
        "height",
        /*get_dimension*/
        a[19](
          /*height*/
          a[0]
        )
      ), set_style$8(
        e,
        "min-height",
        /*get_dimension*/
        a[19](
          /*min_height*/
          a[1]
        )
      ), set_style$8(
        e,
        "max-height",
        /*get_dimension*/
        a[19](
          /*max_height*/
          a[2]
        )
      ), set_style$8(e, "width", typeof /*width*/
      a[3] == "number" ? `calc(min(${/*width*/
      a[3]}px, 100%))` : (
        /*get_dimension*/
        a[19](
          /*width*/
          a[3]
        )
      )), set_style$8(
        e,
        "border-style",
        /*variant*/
        a[6]
      ), set_style$8(
        e,
        "overflow",
        /*allow_overflow*/
        a[13] ? (
          /*overflow_behavior*/
          a[14]
        ) : "hidden"
      ), set_style$8(
        e,
        "flex-grow",
        /*scale*/
        a[15]
      ), set_style$8(e, "min-width", `calc(min(${/*min_width*/
      a[16]}px, 100%))`), set_style$8(e, "border-width", "var(--block-border-width)");
    },
    m(_, A) {
      insert_hydration$o(_, e, A), h && h.m(e, null), n = !0;
    },
    p(_, A) {
      h && h.p && (!n || A & /*$$scope*/
      2097152) && update_slot_base$7(
        h,
        s,
        _,
        /*$$scope*/
        _[21],
        n ? get_slot_changes$7(
          s,
          /*$$scope*/
          _[21],
          A,
          null
        ) : get_all_dirty_from_scope$7(
          /*$$scope*/
          _[21]
        ),
        null
      ), set_dynamic_element_data(
        /*tag*/
        _[18]
      )(e, g = get_spread_update$2(b, [
        (!n || A & /*test_id*/
        512) && { "data-testid": (
          /*test_id*/
          _[9]
        ) },
        (!n || A & /*elem_id*/
        16) && { id: (
          /*elem_id*/
          _[4]
        ) },
        (!n || A & /*elem_classes*/
        32 && r !== (r = "block " + /*elem_classes*/
        _[5].join(" ") + " svelte-1ezsyiy")) && { class: r }
      ])), toggle_class$c(
        e,
        "hidden",
        /*visible*/
        _[12] === !1
      ), toggle_class$c(
        e,
        "padded",
        /*padding*/
        _[8]
      ), toggle_class$c(
        e,
        "flex",
        /*flex*/
        _[17]
      ), toggle_class$c(
        e,
        "border_focus",
        /*border_mode*/
        _[7] === "focus"
      ), toggle_class$c(
        e,
        "border_contrast",
        /*border_mode*/
        _[7] === "contrast"
      ), toggle_class$c(e, "hide-container", !/*explicit_call*/
      _[10] && !/*container*/
      _[11]), A & /*height*/
      1 && set_style$8(
        e,
        "height",
        /*get_dimension*/
        _[19](
          /*height*/
          _[0]
        )
      ), A & /*min_height*/
      2 && set_style$8(
        e,
        "min-height",
        /*get_dimension*/
        _[19](
          /*min_height*/
          _[1]
        )
      ), A & /*max_height*/
      4 && set_style$8(
        e,
        "max-height",
        /*get_dimension*/
        _[19](
          /*max_height*/
          _[2]
        )
      ), A & /*width*/
      8 && set_style$8(e, "width", typeof /*width*/
      _[3] == "number" ? `calc(min(${/*width*/
      _[3]}px, 100%))` : (
        /*get_dimension*/
        _[19](
          /*width*/
          _[3]
        )
      )), A & /*variant*/
      64 && set_style$8(
        e,
        "border-style",
        /*variant*/
        _[6]
      ), A & /*allow_overflow, overflow_behavior*/
      24576 && set_style$8(
        e,
        "overflow",
        /*allow_overflow*/
        _[13] ? (
          /*overflow_behavior*/
          _[14]
        ) : "hidden"
      ), A & /*scale*/
      32768 && set_style$8(
        e,
        "flex-grow",
        /*scale*/
        _[15]
      ), A & /*min_width*/
      65536 && set_style$8(e, "min-width", `calc(min(${/*min_width*/
      _[16]}px, 100%))`);
    },
    i(_) {
      n || (transition_in$e(h, _), n = !0);
    },
    o(_) {
      transition_out$d(h, _), n = !1;
    },
    d(_) {
      _ && detach$o(e), h && h.d(_);
    }
  };
}
function create_fragment$o(a) {
  let e, r = (
    /*tag*/
    a[18] && create_dynamic_element(a)
  );
  return {
    c() {
      r && r.c();
    },
    l(n) {
      r && r.l(n);
    },
    m(n, s) {
      r && r.m(n, s), e = !0;
    },
    p(n, [s]) {
      /*tag*/
      n[18] && r.p(n, s);
    },
    i(n) {
      e || (transition_in$e(r, n), e = !0);
    },
    o(n) {
      transition_out$d(r, n), e = !1;
    },
    d(n) {
      r && r.d(n);
    }
  };
}
function instance$i(a, e, r) {
  let { $$slots: n = {}, $$scope: s } = e, { height: h = void 0 } = e, { min_height: b = void 0 } = e, { max_height: g = void 0 } = e, { width: _ = void 0 } = e, { elem_id: A = "" } = e, { elem_classes: x = [] } = e, { variant: k = "solid" } = e, { border_mode: $ = "base" } = e, { padding: C = !0 } = e, { type: L = "normal" } = e, { test_id: y = void 0 } = e, { explicit_call: o = !1 } = e, { container: v = !0 } = e, { visible: w = !0 } = e, { allow_overflow: M = !0 } = e, { overflow_behavior: F = "auto" } = e, { scale: m = null } = e, { min_width: E = 0 } = e, { flex: z = !1 } = e, O = L === "fieldset" ? "fieldset" : "div";
  const R = (B) => {
    if (B !== void 0) {
      if (typeof B == "number")
        return B + "px";
      if (typeof B == "string")
        return B;
    }
  };
  return a.$$set = (B) => {
    "height" in B && r(0, h = B.height), "min_height" in B && r(1, b = B.min_height), "max_height" in B && r(2, g = B.max_height), "width" in B && r(3, _ = B.width), "elem_id" in B && r(4, A = B.elem_id), "elem_classes" in B && r(5, x = B.elem_classes), "variant" in B && r(6, k = B.variant), "border_mode" in B && r(7, $ = B.border_mode), "padding" in B && r(8, C = B.padding), "type" in B && r(20, L = B.type), "test_id" in B && r(9, y = B.test_id), "explicit_call" in B && r(10, o = B.explicit_call), "container" in B && r(11, v = B.container), "visible" in B && r(12, w = B.visible), "allow_overflow" in B && r(13, M = B.allow_overflow), "overflow_behavior" in B && r(14, F = B.overflow_behavior), "scale" in B && r(15, m = B.scale), "min_width" in B && r(16, E = B.min_width), "flex" in B && r(17, z = B.flex), "$$scope" in B && r(21, s = B.$$scope);
  }, [
    h,
    b,
    g,
    _,
    A,
    x,
    k,
    $,
    C,
    y,
    o,
    v,
    w,
    M,
    F,
    m,
    E,
    z,
    O,
    R,
    L,
    s,
    n
  ];
}
class Block extends SvelteComponent$p {
  constructor(e) {
    super(), init$p(this, e, instance$i, create_fragment$o, safe_not_equal$p, {
      height: 0,
      min_height: 1,
      max_height: 2,
      width: 3,
      elem_id: 4,
      elem_classes: 5,
      variant: 6,
      border_mode: 7,
      padding: 8,
      type: 20,
      test_id: 9,
      explicit_call: 10,
      container: 11,
      visible: 12,
      allow_overflow: 13,
      overflow_behavior: 14,
      scale: 15,
      min_width: 16,
      flex: 17
    });
  }
}
const color_values = [
  { color: "red", primary: 600, secondary: 100 },
  { color: "green", primary: 600, secondary: 100 },
  { color: "blue", primary: 600, secondary: 100 },
  { color: "yellow", primary: 500, secondary: 100 },
  { color: "purple", primary: 600, secondary: 100 },
  { color: "teal", primary: 600, secondary: 100 },
  { color: "orange", primary: 600, secondary: 100 },
  { color: "cyan", primary: 600, secondary: 100 },
  { color: "lime", primary: 500, secondary: 100 },
  { color: "pink", primary: 600, secondary: 100 }
], tw_colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
color_values.reduce(
  (a, { color: e, primary: r, secondary: n }) => ({
    ...a,
    [e]: {
      primary: tw_colors[e][r],
      secondary: tw_colors[e][n]
    }
  }),
  {}
);
const {
  SvelteComponent: SvelteComponent$o,
  append_hydration: append_hydration$i,
  attr: attr$j,
  children: children$k,
  claim_svg_element: claim_svg_element$9,
  detach: detach$n,
  init: init$o,
  insert_hydration: insert_hydration$n,
  noop: noop$d,
  safe_not_equal: safe_not_equal$o,
  set_style: set_style$7,
  svg_element: svg_element$9
} = window.__gradio__svelte__internal;
function create_fragment$n(a) {
  let e, r, n, s;
  return {
    c() {
      e = svg_element$9("svg"), r = svg_element$9("g"), n = svg_element$9("path"), s = svg_element$9("path"), this.h();
    },
    l(h) {
      e = claim_svg_element$9(h, "svg", {
        width: !0,
        height: !0,
        viewBox: !0,
        version: !0,
        xmlns: !0,
        "xmlns:xlink": !0,
        "xml:space": !0,
        stroke: !0,
        style: !0
      });
      var b = children$k(e);
      r = claim_svg_element$9(b, "g", { transform: !0 });
      var g = children$k(r);
      n = claim_svg_element$9(g, "path", { d: !0, style: !0 }), children$k(n).forEach(detach$n), g.forEach(detach$n), s = claim_svg_element$9(b, "path", { d: !0, style: !0 }), children$k(s).forEach(detach$n), b.forEach(detach$n), this.h();
    },
    h() {
      attr$j(n, "d", "M18,6L6.087,17.913"), set_style$7(n, "fill", "none"), set_style$7(n, "fill-rule", "nonzero"), set_style$7(n, "stroke-width", "2px"), attr$j(r, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)"), attr$j(s, "d", "M4.364,4.364L19.636,19.636"), set_style$7(s, "fill", "none"), set_style$7(s, "fill-rule", "nonzero"), set_style$7(s, "stroke-width", "2px"), attr$j(e, "width", "100%"), attr$j(e, "height", "100%"), attr$j(e, "viewBox", "0 0 24 24"), attr$j(e, "version", "1.1"), attr$j(e, "xmlns", "http://www.w3.org/2000/svg"), attr$j(e, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$j(e, "xml:space", "preserve"), attr$j(e, "stroke", "currentColor"), set_style$7(e, "fill-rule", "evenodd"), set_style$7(e, "clip-rule", "evenodd"), set_style$7(e, "stroke-linecap", "round"), set_style$7(e, "stroke-linejoin", "round");
    },
    m(h, b) {
      insert_hydration$n(h, e, b), append_hydration$i(e, r), append_hydration$i(r, n), append_hydration$i(e, s);
    },
    p: noop$d,
    i: noop$d,
    o: noop$d,
    d(h) {
      h && detach$n(e);
    }
  };
}
class Clear extends SvelteComponent$o {
  constructor(e) {
    super(), init$o(this, e, null, create_fragment$n, safe_not_equal$o, {});
  }
}
const {
  SvelteComponent: SvelteComponent$n,
  append_hydration: append_hydration$h,
  attr: attr$i,
  children: children$j,
  claim_svg_element: claim_svg_element$8,
  detach: detach$m,
  init: init$n,
  insert_hydration: insert_hydration$m,
  noop: noop$c,
  safe_not_equal: safe_not_equal$n,
  svg_element: svg_element$8
} = window.__gradio__svelte__internal;
function create_fragment$m(a) {
  let e, r;
  return {
    c() {
      e = svg_element$8("svg"), r = svg_element$8("path"), this.h();
    },
    l(n) {
      e = claim_svg_element$8(n, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0
      });
      var s = children$j(e);
      r = claim_svg_element$8(s, "path", { fill: !0, d: !0 }), children$j(r).forEach(detach$m), s.forEach(detach$m), this.h();
    },
    h() {
      attr$i(r, "fill", "currentColor"), attr$i(r, "d", "M26 24v4H6v-4H4v4a2 2 0 0 0 2 2h20a2 2 0 0 0 2-2v-4zm0-10l-1.41-1.41L17 20.17V2h-2v18.17l-7.59-7.58L6 14l10 10l10-10z"), attr$i(e, "xmlns", "http://www.w3.org/2000/svg"), attr$i(e, "width", "100%"), attr$i(e, "height", "100%"), attr$i(e, "viewBox", "0 0 32 32");
    },
    m(n, s) {
      insert_hydration$m(n, e, s), append_hydration$h(e, r);
    },
    p: noop$c,
    i: noop$c,
    o: noop$c,
    d(n) {
      n && detach$m(e);
    }
  };
}
class Download extends SvelteComponent$n {
  constructor(e) {
    super(), init$n(this, e, null, create_fragment$m, safe_not_equal$n, {});
  }
}
const {
  SvelteComponent: SvelteComponent$m,
  append_hydration: append_hydration$g,
  attr: attr$h,
  children: children$i,
  claim_svg_element: claim_svg_element$7,
  detach: detach$l,
  init: init$m,
  insert_hydration: insert_hydration$l,
  noop: noop$b,
  safe_not_equal: safe_not_equal$m,
  svg_element: svg_element$7
} = window.__gradio__svelte__internal;
function create_fragment$l(a) {
  let e, r;
  return {
    c() {
      e = svg_element$7("svg"), r = svg_element$7("path"), this.h();
    },
    l(n) {
      e = claim_svg_element$7(n, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var s = children$i(e);
      r = claim_svg_element$7(s, "path", { d: !0 }), children$i(r).forEach(detach$l), s.forEach(detach$l), this.h();
    },
    h() {
      attr$h(r, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"), attr$h(e, "xmlns", "http://www.w3.org/2000/svg"), attr$h(e, "width", "100%"), attr$h(e, "height", "100%"), attr$h(e, "viewBox", "0 0 24 24"), attr$h(e, "fill", "none"), attr$h(e, "stroke", "currentColor"), attr$h(e, "stroke-width", "1.5"), attr$h(e, "stroke-linecap", "round"), attr$h(e, "stroke-linejoin", "round"), attr$h(e, "class", "feather feather-edit-2");
    },
    m(n, s) {
      insert_hydration$l(n, e, s), append_hydration$g(e, r);
    },
    p: noop$b,
    i: noop$b,
    o: noop$b,
    d(n) {
      n && detach$l(e);
    }
  };
}
class Edit extends SvelteComponent$m {
  constructor(e) {
    super(), init$m(this, e, null, create_fragment$l, safe_not_equal$m, {});
  }
}
const {
  SvelteComponent: SvelteComponent$l,
  append_hydration: append_hydration$f,
  attr: attr$g,
  children: children$h,
  claim_svg_element: claim_svg_element$6,
  detach: detach$k,
  init: init$l,
  insert_hydration: insert_hydration$k,
  noop: noop$a,
  safe_not_equal: safe_not_equal$l,
  svg_element: svg_element$6
} = window.__gradio__svelte__internal;
function create_fragment$k(a) {
  let e, r, n;
  return {
    c() {
      e = svg_element$6("svg"), r = svg_element$6("path"), n = svg_element$6("polyline"), this.h();
    },
    l(s) {
      e = claim_svg_element$6(s, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var h = children$h(e);
      r = claim_svg_element$6(h, "path", { d: !0 }), children$h(r).forEach(detach$k), n = claim_svg_element$6(h, "polyline", { points: !0 }), children$h(n).forEach(detach$k), h.forEach(detach$k), this.h();
    },
    h() {
      attr$g(r, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), attr$g(n, "points", "13 2 13 9 20 9"), attr$g(e, "xmlns", "http://www.w3.org/2000/svg"), attr$g(e, "width", "100%"), attr$g(e, "height", "100%"), attr$g(e, "viewBox", "0 0 24 24"), attr$g(e, "fill", "none"), attr$g(e, "stroke", "currentColor"), attr$g(e, "stroke-width", "1.5"), attr$g(e, "stroke-linecap", "round"), attr$g(e, "stroke-linejoin", "round"), attr$g(e, "class", "feather feather-file");
    },
    m(s, h) {
      insert_hydration$k(s, e, h), append_hydration$f(e, r), append_hydration$f(e, n);
    },
    p: noop$a,
    i: noop$a,
    o: noop$a,
    d(s) {
      s && detach$k(e);
    }
  };
}
let File$1 = class extends SvelteComponent$l {
  constructor(e) {
    super(), init$l(this, e, null, create_fragment$k, safe_not_equal$l, {});
  }
};
const {
  SvelteComponent: SvelteComponent$k,
  append_hydration: append_hydration$e,
  attr: attr$f,
  children: children$g,
  claim_svg_element: claim_svg_element$5,
  detach: detach$j,
  init: init$k,
  insert_hydration: insert_hydration$j,
  noop: noop$9,
  safe_not_equal: safe_not_equal$k,
  svg_element: svg_element$5
} = window.__gradio__svelte__internal;
function create_fragment$j(a) {
  let e, r;
  return {
    c() {
      e = svg_element$5("svg"), r = svg_element$5("path"), this.h();
    },
    l(n) {
      e = claim_svg_element$5(n, "svg", { xmlns: !0, viewBox: !0 });
      var s = children$g(e);
      r = claim_svg_element$5(s, "path", { fill: !0, d: !0 }), children$g(r).forEach(detach$j), s.forEach(detach$j), this.h();
    },
    h() {
      attr$f(r, "fill", "currentColor"), attr$f(r, "d", "M13.75 2a2.25 2.25 0 0 1 2.236 2.002V4h1.764A2.25 2.25 0 0 1 20 6.25V11h-1.5V6.25a.75.75 0 0 0-.75-.75h-2.129c-.404.603-1.091 1-1.871 1h-3.5c-.78 0-1.467-.397-1.871-1H6.25a.75.75 0 0 0-.75.75v13.5c0 .414.336.75.75.75h4.78a4 4 0 0 0 .505 1.5H6.25A2.25 2.25 0 0 1 4 19.75V6.25A2.25 2.25 0 0 1 6.25 4h1.764a2.25 2.25 0 0 1 2.236-2zm2.245 2.096L16 4.25q0-.078-.005-.154M13.75 3.5h-3.5a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5M15 12a3 3 0 0 0-3 3v5c0 .556.151 1.077.415 1.524l3.494-3.494a2.25 2.25 0 0 1 3.182 0l3.494 3.494c.264-.447.415-.968.415-1.524v-5a3 3 0 0 0-3-3zm0 11a3 3 0 0 1-1.524-.415l3.494-3.494a.75.75 0 0 1 1.06 0l3.494 3.494A3 3 0 0 1 20 23zm5-7a1 1 0 1 1 0-2 1 1 0 0 1 0 2"), attr$f(e, "xmlns", "http://www.w3.org/2000/svg"), attr$f(e, "viewBox", "0 0 24 24");
    },
    m(n, s) {
      insert_hydration$j(n, e, s), append_hydration$e(e, r);
    },
    p: noop$9,
    i: noop$9,
    o: noop$9,
    d(n) {
      n && detach$j(e);
    }
  };
}
class ImagePaste extends SvelteComponent$k {
  constructor(e) {
    super(), init$k(this, e, null, create_fragment$j, safe_not_equal$k, {});
  }
}
const {
  SvelteComponent: SvelteComponent$j,
  append_hydration: append_hydration$d,
  attr: attr$e,
  children: children$f,
  claim_svg_element: claim_svg_element$4,
  detach: detach$i,
  init: init$j,
  insert_hydration: insert_hydration$i,
  noop: noop$8,
  safe_not_equal: safe_not_equal$j,
  svg_element: svg_element$4
} = window.__gradio__svelte__internal;
function create_fragment$i(a) {
  let e, r, n;
  return {
    c() {
      e = svg_element$4("svg"), r = svg_element$4("polyline"), n = svg_element$4("path"), this.h();
    },
    l(s) {
      e = claim_svg_element$4(s, "svg", {
        "aria-label": !0,
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var h = children$f(e);
      r = claim_svg_element$4(h, "polyline", { points: !0 }), children$f(r).forEach(detach$i), n = claim_svg_element$4(h, "path", { d: !0 }), children$f(n).forEach(detach$i), h.forEach(detach$i), this.h();
    },
    h() {
      attr$e(r, "points", "1 4 1 10 7 10"), attr$e(n, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10"), attr$e(e, "aria-label", "undo"), attr$e(e, "xmlns", "http://www.w3.org/2000/svg"), attr$e(e, "width", "100%"), attr$e(e, "height", "100%"), attr$e(e, "viewBox", "0 0 24 24"), attr$e(e, "fill", "none"), attr$e(e, "stroke", "currentColor"), attr$e(e, "stroke-width", "1.5"), attr$e(e, "stroke-linecap", "round"), attr$e(e, "stroke-linejoin", "round"), attr$e(e, "class", "feather feather-rotate-ccw");
    },
    m(s, h) {
      insert_hydration$i(s, e, h), append_hydration$d(e, r), append_hydration$d(e, n);
    },
    p: noop$8,
    i: noop$8,
    o: noop$8,
    d(s) {
      s && detach$i(e);
    }
  };
}
class Undo extends SvelteComponent$j {
  constructor(e) {
    super(), init$j(this, e, null, create_fragment$i, safe_not_equal$j, {});
  }
}
const {
  SvelteComponent: SvelteComponent$i,
  append_hydration: append_hydration$c,
  attr: attr$d,
  children: children$e,
  claim_svg_element: claim_svg_element$3,
  detach: detach$h,
  init: init$i,
  insert_hydration: insert_hydration$h,
  noop: noop$7,
  safe_not_equal: safe_not_equal$i,
  svg_element: svg_element$3
} = window.__gradio__svelte__internal;
function create_fragment$h(a) {
  let e, r, n, s;
  return {
    c() {
      e = svg_element$3("svg"), r = svg_element$3("path"), n = svg_element$3("polyline"), s = svg_element$3("line"), this.h();
    },
    l(h) {
      e = claim_svg_element$3(h, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var b = children$e(e);
      r = claim_svg_element$3(b, "path", { d: !0 }), children$e(r).forEach(detach$h), n = claim_svg_element$3(b, "polyline", { points: !0 }), children$e(n).forEach(detach$h), s = claim_svg_element$3(b, "line", { x1: !0, y1: !0, x2: !0, y2: !0 }), children$e(s).forEach(detach$h), b.forEach(detach$h), this.h();
    },
    h() {
      attr$d(r, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"), attr$d(n, "points", "17 8 12 3 7 8"), attr$d(s, "x1", "12"), attr$d(s, "y1", "3"), attr$d(s, "x2", "12"), attr$d(s, "y2", "15"), attr$d(e, "xmlns", "http://www.w3.org/2000/svg"), attr$d(e, "width", "90%"), attr$d(e, "height", "90%"), attr$d(e, "viewBox", "0 0 24 24"), attr$d(e, "fill", "none"), attr$d(e, "stroke", "currentColor"), attr$d(e, "stroke-width", "2"), attr$d(e, "stroke-linecap", "round"), attr$d(e, "stroke-linejoin", "round"), attr$d(e, "class", "feather feather-upload");
    },
    m(h, b) {
      insert_hydration$h(h, e, b), append_hydration$c(e, r), append_hydration$c(e, n), append_hydration$c(e, s);
    },
    p: noop$7,
    i: noop$7,
    o: noop$7,
    d(h) {
      h && detach$h(e);
    }
  };
}
let Upload$1 = class extends SvelteComponent$i {
  constructor(e) {
    super(), init$i(this, e, null, create_fragment$h, safe_not_equal$i, {});
  }
};
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, r, n) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = r, this.end = n;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, r) {
    return r ? !e || !e.loc || !r.loc || e.loc.lexer !== r.loc.lexer ? null : new SourceLocation(e.loc.lexer, e.loc.start, r.loc.end) : e && e.loc;
  }
}
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(e, r) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = r;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, r) {
    return new Token(r, SourceLocation.range(this, e));
  }
}
class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, r) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var n = "KaTeX parse error: " + e, s, h, b = r && r.loc;
    if (b && b.start <= b.end) {
      var g = b.lexer.input;
      s = b.start, h = b.end, s === g.length ? n += " at end of input: " : n += " at position " + (s + 1) + ": ";
      var _ = g.slice(s, h).replace(/[^]/g, "$&̲"), A;
      s > 15 ? A = "…" + g.slice(s - 15, s) : A = g.slice(0, s);
      var x;
      h + 15 < g.length ? x = g.slice(h, h + 15) + "…" : x = g.slice(h), n += A + _ + x;
    }
    var k = new Error(n);
    return k.name = "ParseError", k.__proto__ = ParseError.prototype, k.position = s, s != null && h != null && (k.length = h - s), k.rawMessage = e, k;
  }
}
ParseError.prototype.__proto__ = Error.prototype;
var contains = function(e, r) {
  return e.indexOf(r) !== -1;
}, deflt = function(e, r) {
  return e === void 0 ? r : e;
}, uppercase = /([A-Z])/g, hyphenate = function(e) {
  return e.replace(uppercase, "-$1").toLowerCase();
}, ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, ESCAPE_REGEX = /[&><"']/g;
function escape$2(a) {
  return String(a).replace(ESCAPE_REGEX, (e) => ESCAPE_LOOKUP[e]);
}
var getBaseElem = function a(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? a(e.body[0]) : e : e.type === "font" ? a(e.body) : e;
}, isCharacterBox = function(e) {
  var r = getBaseElem(e);
  return r.type === "mathord" || r.type === "textord" || r.type === "atom";
}, assert = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, protocolFromUrl = function(e) {
  var r = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return r ? r[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(r[1]) ? null : r[1].toLowerCase() : "_relative";
}, utils = {
  contains,
  deflt,
  escape: escape$2,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
class Style {
  constructor(e, r, n) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = r, this.cramped = n;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var D = 0, Dc = 1, T = 2, Tc = 3, S = 4, Sc = 5, SS = 6, SSc = 7, styles = [new Style(D, 0, !1), new Style(Dc, 0, !0), new Style(T, 1, !1), new Style(Tc, 1, !0), new Style(S, 2, !1), new Style(Sc, 2, !0), new Style(SS, 3, !1), new Style(SSc, 3, !0)], sup = [S, Sc, S, Sc, SS, SSc, SS, SSc], sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc], fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc], fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc], cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc], text$1$1 = [D, Dc, T, Tc, T, Tc, T, Tc], Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
}, scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(a) {
  for (var e = 0; e < scriptData.length; e++)
    for (var r = scriptData[e], n = 0; n < r.blocks.length; n++) {
      var s = r.blocks[n];
      if (a >= s[0] && a <= s[1])
        return r.name;
    }
  return null;
}
var allBlocks = [];
scriptData.forEach((a) => a.blocks.forEach((e) => allBlocks.push(...e)));
function supportedCodepoint(a) {
  for (var e = 0; e < allBlocks.length; e += 2)
    if (a >= allBlocks[e] && a <= allBlocks[e + 1])
      return !0;
  return !1;
}
var hLinePad = 80, sqrtMain = function(e, r) {
  return "M95," + (622 + e + r) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, sqrtSize1 = function(e, r) {
  return "M263," + (601 + e + r) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, sqrtSize2 = function(e, r) {
  return "M983 " + (10 + e + r) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, sqrtSize3 = function(e, r) {
  return "M424," + (2398 + e + r) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + r + `
h400000v` + (40 + e) + "h-400000z";
}, sqrtSize4 = function(e, r) {
  return "M473," + (2713 + e + r) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "H1017.7z";
}, phasePath = function(e) {
  var r = e / 2;
  return "M400000 " + e + " H0 L" + r + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, sqrtTall = function(e, r, n) {
  var s = n - 54 - r - e;
  return "M702 " + (e + r) + "H400000" + (40 + e) + `
H742v` + s + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + r + "H400000v" + (40 + e) + "H742z";
}, sqrtPath = function(e, r, n) {
  r = 1e3 * r;
  var s = "";
  switch (e) {
    case "sqrtMain":
      s = sqrtMain(r, hLinePad);
      break;
    case "sqrtSize1":
      s = sqrtSize1(r, hLinePad);
      break;
    case "sqrtSize2":
      s = sqrtSize2(r, hLinePad);
      break;
    case "sqrtSize3":
      s = sqrtSize3(r, hLinePad);
      break;
    case "sqrtSize4":
      s = sqrtSize4(r, hLinePad);
      break;
    case "sqrtTall":
      s = sqrtTall(r, hLinePad, n);
  }
  return s;
}, innerPath = function(e, r) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + r + " H291z M291 0 H417 V" + r + " H291z";
    case "∣":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z";
    case "∥":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z" + ("M367 0 H410 V" + r + " H367z M367 0 H410 V" + r + " H367z");
    case "⎟":
      return "M457 0 H583 V" + r + " H457z M457 0 H583 V" + r + " H457z";
    case "⎢":
      return "M319 0 H403 V" + r + " H319z M319 0 H403 V" + r + " H319z";
    case "⎥":
      return "M263 0 H347 V" + r + " H263z M263 0 H347 V" + r + " H263z";
    case "⎪":
      return "M384 0 H504 V" + r + " H384z M384 0 H504 V" + r + " H384z";
    case "⏐":
      return "M312 0 H355 V" + r + " H312z M312 0 H355 V" + r + " H312z";
    case "‖":
      return "M257 0 H300 V" + r + " H257z M257 0 H300 V" + r + " H257z" + ("M478 0 H521 V" + r + " H478z M478 0 H521 V" + r + " H478z");
    default:
      return "";
  }
}, path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, tallDelim = function(e, r) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + r + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + r + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + ` v585 h43z
M367 15 v585 v` + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + r + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v602 h84z
M403 1759 V0 H319 V1759 v` + r + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + r + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (r + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (r + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (r + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (r + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return utils.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), r = 0; r < this.children.length; r++)
      e.appendChild(this.children[r].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (r) => r.toText();
    return this.children.map(e).join("");
  }
}
var fontMetricsData = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, extraCharacterMap = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function getCharacterMetrics(a, e, r) {
  if (!fontMetricsData[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var n = a.charCodeAt(0), s = fontMetricsData[e][n];
  if (!s && a[0] in extraCharacterMap && (n = extraCharacterMap[a[0]].charCodeAt(0), s = fontMetricsData[e][n]), !s && r === "text" && supportedCodepoint(n) && (s = fontMetricsData[e][77]), s)
    return {
      depth: s[0],
      height: s[1],
      italic: s[2],
      skew: s[3],
      width: s[4]
    };
}
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, relativeUnit = {
  ex: !0,
  em: !0,
  mu: !0
}, validUnit = function(e) {
  return typeof e != "string" && (e = e.unit), e in ptPerUnit || e in relativeUnit || e === "ex";
}, calculateSize = function(e, r) {
  var n;
  if (e.unit in ptPerUnit)
    n = ptPerUnit[e.unit] / r.fontMetrics().ptPerEm / r.sizeMultiplier;
  else if (e.unit === "mu")
    n = r.fontMetrics().cssEmPerMu;
  else {
    var s;
    if (r.style.isTight() ? s = r.havingStyle(r.style.text()) : s = r, e.unit === "ex")
      n = s.fontMetrics().xHeight;
    else if (e.unit === "em")
      n = s.fontMetrics().quad;
    else
      throw new ParseError("Invalid unit: '" + e.unit + "'");
    s !== r && (n *= s.sizeMultiplier / r.sizeMultiplier);
  }
  return Math.min(e.number * n, r.maxSize);
}, makeEm = function(e) {
  return +e.toFixed(4) + "em";
}, createClass = function(e) {
  return e.filter((r) => r).join(" ");
}, initNode = function(e, r, n) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = n || {}, r) {
    r.style.isTight() && this.classes.push("mtight");
    var s = r.getColor();
    s && (this.style.color = s);
  }
}, toNode = function(e) {
  var r = document.createElement(e);
  r.className = createClass(this.classes);
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (r.style[n] = this.style[n]);
  for (var s in this.attributes)
    this.attributes.hasOwnProperty(s) && r.setAttribute(s, this.attributes[s]);
  for (var h = 0; h < this.children.length; h++)
    r.appendChild(this.children[h].toNode());
  return r;
}, toMarkup = function(e) {
  var r = "<" + e;
  this.classes.length && (r += ' class="' + utils.escape(createClass(this.classes)) + '"');
  var n = "";
  for (var s in this.style)
    this.style.hasOwnProperty(s) && (n += utils.hyphenate(s) + ":" + this.style[s] + ";");
  n && (r += ' style="' + utils.escape(n) + '"');
  for (var h in this.attributes)
    this.attributes.hasOwnProperty(h) && (r += " " + h + '="' + utils.escape(this.attributes[h]) + '"');
  r += ">";
  for (var b = 0; b < this.children.length; b++)
    r += this.children[b].toMarkup();
  return r += "</" + e + ">", r;
};
class Span {
  constructor(e, r, n, s) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, initNode.call(this, e, n, s), this.children = r || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return utils.contains(this.classes, e);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
class Anchor {
  constructor(e, r, n, s) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, initNode.call(this, r, s), this.children = n || [], this.setAttribute("href", e);
  }
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return utils.contains(this.classes, e);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
}
class Img {
  constructor(e, r, n) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = r, this.src = e, this.classes = ["mord"], this.style = n;
  }
  hasClass(e) {
    return utils.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (e.style[r] = this.style[r]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"'), r = "";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r += utils.hyphenate(n) + ":" + this.style[n] + ";");
    return r && (e += ' style="' + utils.escape(r) + '"'), e += "'/>", e;
  }
}
var iCombinations = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class SymbolNode {
  constructor(e, r, n, s, h, b, g, _) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = r || 0, this.depth = n || 0, this.italic = s || 0, this.skew = h || 0, this.width = b || 0, this.classes = g || [], this.style = _ || {}, this.maxFontSize = 0;
    var A = scriptFromCodepoint(this.text.charCodeAt(0));
    A && this.classes.push(A + "_fallback"), /[îïíì]/.test(this.text) && (this.text = iCombinations[this.text]);
  }
  hasClass(e) {
    return utils.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), r = null;
    this.italic > 0 && (r = document.createElement("span"), r.style.marginRight = makeEm(this.italic)), this.classes.length > 0 && (r = r || document.createElement("span"), r.className = createClass(this.classes));
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r = r || document.createElement("span"), r.style[n] = this.style[n]);
    return r ? (r.appendChild(e), r) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, r = "<span";
    this.classes.length && (e = !0, r += ' class="', r += utils.escape(createClass(this.classes)), r += '"');
    var n = "";
    this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
    for (var s in this.style)
      this.style.hasOwnProperty(s) && (n += utils.hyphenate(s) + ":" + this.style[s] + ";");
    n && (e = !0, r += ' style="' + utils.escape(n) + '"');
    var h = utils.escape(this.text);
    return e ? (r += ">", r += h, r += "</span>", r) : h;
  }
}
class SvgNode {
  constructor(e, r) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = r || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "svg");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    for (var s = 0; s < this.children.length; s++)
      r.appendChild(this.children[s].toNode());
    return r;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + utils.escape(this.attributes[r]) + '"');
    e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</svg>", e;
  }
}
class PathNode {
  constructor(e, r) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = r;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "path");
    return this.alternate ? r.setAttribute("d", this.alternate) : r.setAttribute("d", path[this.pathName]), r;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + utils.escape(this.alternate) + '"/>' : '<path d="' + utils.escape(path[this.pathName]) + '"/>';
  }
}
class LineNode {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "line");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    return r;
  }
  toMarkup() {
    var e = "<line";
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + utils.escape(this.attributes[r]) + '"');
    return e += "/>", e;
  }
}
function assertSymbolDomNode(a) {
  if (a instanceof SymbolNode)
    return a;
  throw new Error("Expected symbolNode but got " + String(a) + ".");
}
function assertSpan(a) {
  if (a instanceof Span)
    return a;
  throw new Error("Expected span<HtmlDomNode> but got " + String(a) + ".");
}
var NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, symbols = {
  math: {},
  text: {}
};
function defineSymbol(a, e, r, n, s, h) {
  symbols[a][s] = {
    font: e,
    group: r,
    replace: n
  }, h && n && (symbols[a][n] = symbols[a][s]);
}
var math = "math", text$a = "text", main = "main", ams = "ams", accent = "accent-token", bin = "bin", close = "close", inner = "inner", mathord = "mathord", op = "op-token", open = "open", punct = "punct", rel = "rel", spacing = "spacing", textord = "textord";
defineSymbol(math, main, rel, "≡", "\\equiv", !0);
defineSymbol(math, main, rel, "≺", "\\prec", !0);
defineSymbol(math, main, rel, "≻", "\\succ", !0);
defineSymbol(math, main, rel, "∼", "\\sim", !0);
defineSymbol(math, main, rel, "⊥", "\\perp");
defineSymbol(math, main, rel, "⪯", "\\preceq", !0);
defineSymbol(math, main, rel, "⪰", "\\succeq", !0);
defineSymbol(math, main, rel, "≃", "\\simeq", !0);
defineSymbol(math, main, rel, "∣", "\\mid", !0);
defineSymbol(math, main, rel, "≪", "\\ll", !0);
defineSymbol(math, main, rel, "≫", "\\gg", !0);
defineSymbol(math, main, rel, "≍", "\\asymp", !0);
defineSymbol(math, main, rel, "∥", "\\parallel");
defineSymbol(math, main, rel, "⋈", "\\bowtie", !0);
defineSymbol(math, main, rel, "⌣", "\\smile", !0);
defineSymbol(math, main, rel, "⊑", "\\sqsubseteq", !0);
defineSymbol(math, main, rel, "⊒", "\\sqsupseteq", !0);
defineSymbol(math, main, rel, "≐", "\\doteq", !0);
defineSymbol(math, main, rel, "⌢", "\\frown", !0);
defineSymbol(math, main, rel, "∋", "\\ni", !0);
defineSymbol(math, main, rel, "∝", "\\propto", !0);
defineSymbol(math, main, rel, "⊢", "\\vdash", !0);
defineSymbol(math, main, rel, "⊣", "\\dashv", !0);
defineSymbol(math, main, rel, "∋", "\\owns");
defineSymbol(math, main, punct, ".", "\\ldotp");
defineSymbol(math, main, punct, "⋅", "\\cdotp");
defineSymbol(math, main, textord, "#", "\\#");
defineSymbol(text$a, main, textord, "#", "\\#");
defineSymbol(math, main, textord, "&", "\\&");
defineSymbol(text$a, main, textord, "&", "\\&");
defineSymbol(math, main, textord, "ℵ", "\\aleph", !0);
defineSymbol(math, main, textord, "∀", "\\forall", !0);
defineSymbol(math, main, textord, "ℏ", "\\hbar", !0);
defineSymbol(math, main, textord, "∃", "\\exists", !0);
defineSymbol(math, main, textord, "∇", "\\nabla", !0);
defineSymbol(math, main, textord, "♭", "\\flat", !0);
defineSymbol(math, main, textord, "ℓ", "\\ell", !0);
defineSymbol(math, main, textord, "♮", "\\natural", !0);
defineSymbol(math, main, textord, "♣", "\\clubsuit", !0);
defineSymbol(math, main, textord, "℘", "\\wp", !0);
defineSymbol(math, main, textord, "♯", "\\sharp", !0);
defineSymbol(math, main, textord, "♢", "\\diamondsuit", !0);
defineSymbol(math, main, textord, "ℜ", "\\Re", !0);
defineSymbol(math, main, textord, "♡", "\\heartsuit", !0);
defineSymbol(math, main, textord, "ℑ", "\\Im", !0);
defineSymbol(math, main, textord, "♠", "\\spadesuit", !0);
defineSymbol(math, main, textord, "§", "\\S", !0);
defineSymbol(text$a, main, textord, "§", "\\S");
defineSymbol(math, main, textord, "¶", "\\P", !0);
defineSymbol(text$a, main, textord, "¶", "\\P");
defineSymbol(math, main, textord, "†", "\\dag");
defineSymbol(text$a, main, textord, "†", "\\dag");
defineSymbol(text$a, main, textord, "†", "\\textdagger");
defineSymbol(math, main, textord, "‡", "\\ddag");
defineSymbol(text$a, main, textord, "‡", "\\ddag");
defineSymbol(text$a, main, textord, "‡", "\\textdaggerdbl");
defineSymbol(math, main, close, "⎱", "\\rmoustache", !0);
defineSymbol(math, main, open, "⎰", "\\lmoustache", !0);
defineSymbol(math, main, close, "⟯", "\\rgroup", !0);
defineSymbol(math, main, open, "⟮", "\\lgroup", !0);
defineSymbol(math, main, bin, "∓", "\\mp", !0);
defineSymbol(math, main, bin, "⊖", "\\ominus", !0);
defineSymbol(math, main, bin, "⊎", "\\uplus", !0);
defineSymbol(math, main, bin, "⊓", "\\sqcap", !0);
defineSymbol(math, main, bin, "∗", "\\ast");
defineSymbol(math, main, bin, "⊔", "\\sqcup", !0);
defineSymbol(math, main, bin, "◯", "\\bigcirc", !0);
defineSymbol(math, main, bin, "∙", "\\bullet", !0);
defineSymbol(math, main, bin, "‡", "\\ddagger");
defineSymbol(math, main, bin, "≀", "\\wr", !0);
defineSymbol(math, main, bin, "⨿", "\\amalg");
defineSymbol(math, main, bin, "&", "\\And");
defineSymbol(math, main, rel, "⟵", "\\longleftarrow", !0);
defineSymbol(math, main, rel, "⇐", "\\Leftarrow", !0);
defineSymbol(math, main, rel, "⟸", "\\Longleftarrow", !0);
defineSymbol(math, main, rel, "⟶", "\\longrightarrow", !0);
defineSymbol(math, main, rel, "⇒", "\\Rightarrow", !0);
defineSymbol(math, main, rel, "⟹", "\\Longrightarrow", !0);
defineSymbol(math, main, rel, "↔", "\\leftrightarrow", !0);
defineSymbol(math, main, rel, "⟷", "\\longleftrightarrow", !0);
defineSymbol(math, main, rel, "⇔", "\\Leftrightarrow", !0);
defineSymbol(math, main, rel, "⟺", "\\Longleftrightarrow", !0);
defineSymbol(math, main, rel, "↦", "\\mapsto", !0);
defineSymbol(math, main, rel, "⟼", "\\longmapsto", !0);
defineSymbol(math, main, rel, "↗", "\\nearrow", !0);
defineSymbol(math, main, rel, "↩", "\\hookleftarrow", !0);
defineSymbol(math, main, rel, "↪", "\\hookrightarrow", !0);
defineSymbol(math, main, rel, "↘", "\\searrow", !0);
defineSymbol(math, main, rel, "↼", "\\leftharpoonup", !0);
defineSymbol(math, main, rel, "⇀", "\\rightharpoonup", !0);
defineSymbol(math, main, rel, "↙", "\\swarrow", !0);
defineSymbol(math, main, rel, "↽", "\\leftharpoondown", !0);
defineSymbol(math, main, rel, "⇁", "\\rightharpoondown", !0);
defineSymbol(math, main, rel, "↖", "\\nwarrow", !0);
defineSymbol(math, main, rel, "⇌", "\\rightleftharpoons", !0);
defineSymbol(math, ams, rel, "≮", "\\nless", !0);
defineSymbol(math, ams, rel, "", "\\@nleqslant");
defineSymbol(math, ams, rel, "", "\\@nleqq");
defineSymbol(math, ams, rel, "⪇", "\\lneq", !0);
defineSymbol(math, ams, rel, "≨", "\\lneqq", !0);
defineSymbol(math, ams, rel, "", "\\@lvertneqq");
defineSymbol(math, ams, rel, "⋦", "\\lnsim", !0);
defineSymbol(math, ams, rel, "⪉", "\\lnapprox", !0);
defineSymbol(math, ams, rel, "⊀", "\\nprec", !0);
defineSymbol(math, ams, rel, "⋠", "\\npreceq", !0);
defineSymbol(math, ams, rel, "⋨", "\\precnsim", !0);
defineSymbol(math, ams, rel, "⪹", "\\precnapprox", !0);
defineSymbol(math, ams, rel, "≁", "\\nsim", !0);
defineSymbol(math, ams, rel, "", "\\@nshortmid");
defineSymbol(math, ams, rel, "∤", "\\nmid", !0);
defineSymbol(math, ams, rel, "⊬", "\\nvdash", !0);
defineSymbol(math, ams, rel, "⊭", "\\nvDash", !0);
defineSymbol(math, ams, rel, "⋪", "\\ntriangleleft");
defineSymbol(math, ams, rel, "⋬", "\\ntrianglelefteq", !0);
defineSymbol(math, ams, rel, "⊊", "\\subsetneq", !0);
defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "⫋", "\\subsetneqq", !0);
defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "≯", "\\ngtr", !0);
defineSymbol(math, ams, rel, "", "\\@ngeqslant");
defineSymbol(math, ams, rel, "", "\\@ngeqq");
defineSymbol(math, ams, rel, "⪈", "\\gneq", !0);
defineSymbol(math, ams, rel, "≩", "\\gneqq", !0);
defineSymbol(math, ams, rel, "", "\\@gvertneqq");
defineSymbol(math, ams, rel, "⋧", "\\gnsim", !0);
defineSymbol(math, ams, rel, "⪊", "\\gnapprox", !0);
defineSymbol(math, ams, rel, "⊁", "\\nsucc", !0);
defineSymbol(math, ams, rel, "⋡", "\\nsucceq", !0);
defineSymbol(math, ams, rel, "⋩", "\\succnsim", !0);
defineSymbol(math, ams, rel, "⪺", "\\succnapprox", !0);
defineSymbol(math, ams, rel, "≆", "\\ncong", !0);
defineSymbol(math, ams, rel, "", "\\@nshortparallel");
defineSymbol(math, ams, rel, "∦", "\\nparallel", !0);
defineSymbol(math, ams, rel, "⊯", "\\nVDash", !0);
defineSymbol(math, ams, rel, "⋫", "\\ntriangleright");
defineSymbol(math, ams, rel, "⋭", "\\ntrianglerighteq", !0);
defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "⊋", "\\supsetneq", !0);
defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "⫌", "\\supsetneqq", !0);
defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "⊮", "\\nVdash", !0);
defineSymbol(math, ams, rel, "⪵", "\\precneqq", !0);
defineSymbol(math, ams, rel, "⪶", "\\succneqq", !0);
defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "⊴", "\\unlhd");
defineSymbol(math, ams, bin, "⊵", "\\unrhd");
defineSymbol(math, ams, rel, "↚", "\\nleftarrow", !0);
defineSymbol(math, ams, rel, "↛", "\\nrightarrow", !0);
defineSymbol(math, ams, rel, "⇍", "\\nLeftarrow", !0);
defineSymbol(math, ams, rel, "⇏", "\\nRightarrow", !0);
defineSymbol(math, ams, rel, "↮", "\\nleftrightarrow", !0);
defineSymbol(math, ams, rel, "⇎", "\\nLeftrightarrow", !0);
defineSymbol(math, ams, rel, "△", "\\vartriangle");
defineSymbol(math, ams, textord, "ℏ", "\\hslash");
defineSymbol(math, ams, textord, "▽", "\\triangledown");
defineSymbol(math, ams, textord, "◊", "\\lozenge");
defineSymbol(math, ams, textord, "Ⓢ", "\\circledS");
defineSymbol(math, ams, textord, "®", "\\circledR");
defineSymbol(text$a, ams, textord, "®", "\\circledR");
defineSymbol(math, ams, textord, "∡", "\\measuredangle", !0);
defineSymbol(math, ams, textord, "∄", "\\nexists");
defineSymbol(math, ams, textord, "℧", "\\mho");
defineSymbol(math, ams, textord, "Ⅎ", "\\Finv", !0);
defineSymbol(math, ams, textord, "⅁", "\\Game", !0);
defineSymbol(math, ams, textord, "‵", "\\backprime");
defineSymbol(math, ams, textord, "▲", "\\blacktriangle");
defineSymbol(math, ams, textord, "▼", "\\blacktriangledown");
defineSymbol(math, ams, textord, "■", "\\blacksquare");
defineSymbol(math, ams, textord, "⧫", "\\blacklozenge");
defineSymbol(math, ams, textord, "★", "\\bigstar");
defineSymbol(math, ams, textord, "∢", "\\sphericalangle", !0);
defineSymbol(math, ams, textord, "∁", "\\complement", !0);
defineSymbol(math, ams, textord, "ð", "\\eth", !0);
defineSymbol(text$a, main, textord, "ð", "ð");
defineSymbol(math, ams, textord, "╱", "\\diagup");
defineSymbol(math, ams, textord, "╲", "\\diagdown");
defineSymbol(math, ams, textord, "□", "\\square");
defineSymbol(math, ams, textord, "□", "\\Box");
defineSymbol(math, ams, textord, "◊", "\\Diamond");
defineSymbol(math, ams, textord, "¥", "\\yen", !0);
defineSymbol(text$a, ams, textord, "¥", "\\yen", !0);
defineSymbol(math, ams, textord, "✓", "\\checkmark", !0);
defineSymbol(text$a, ams, textord, "✓", "\\checkmark");
defineSymbol(math, ams, textord, "ℶ", "\\beth", !0);
defineSymbol(math, ams, textord, "ℸ", "\\daleth", !0);
defineSymbol(math, ams, textord, "ℷ", "\\gimel", !0);
defineSymbol(math, ams, textord, "ϝ", "\\digamma", !0);
defineSymbol(math, ams, textord, "ϰ", "\\varkappa");
defineSymbol(math, ams, open, "┌", "\\@ulcorner", !0);
defineSymbol(math, ams, close, "┐", "\\@urcorner", !0);
defineSymbol(math, ams, open, "└", "\\@llcorner", !0);
defineSymbol(math, ams, close, "┘", "\\@lrcorner", !0);
defineSymbol(math, ams, rel, "≦", "\\leqq", !0);
defineSymbol(math, ams, rel, "⩽", "\\leqslant", !0);
defineSymbol(math, ams, rel, "⪕", "\\eqslantless", !0);
defineSymbol(math, ams, rel, "≲", "\\lesssim", !0);
defineSymbol(math, ams, rel, "⪅", "\\lessapprox", !0);
defineSymbol(math, ams, rel, "≊", "\\approxeq", !0);
defineSymbol(math, ams, bin, "⋖", "\\lessdot");
defineSymbol(math, ams, rel, "⋘", "\\lll", !0);
defineSymbol(math, ams, rel, "≶", "\\lessgtr", !0);
defineSymbol(math, ams, rel, "⋚", "\\lesseqgtr", !0);
defineSymbol(math, ams, rel, "⪋", "\\lesseqqgtr", !0);
defineSymbol(math, ams, rel, "≑", "\\doteqdot");
defineSymbol(math, ams, rel, "≓", "\\risingdotseq", !0);
defineSymbol(math, ams, rel, "≒", "\\fallingdotseq", !0);
defineSymbol(math, ams, rel, "∽", "\\backsim", !0);
defineSymbol(math, ams, rel, "⋍", "\\backsimeq", !0);
defineSymbol(math, ams, rel, "⫅", "\\subseteqq", !0);
defineSymbol(math, ams, rel, "⋐", "\\Subset", !0);
defineSymbol(math, ams, rel, "⊏", "\\sqsubset", !0);
defineSymbol(math, ams, rel, "≼", "\\preccurlyeq", !0);
defineSymbol(math, ams, rel, "⋞", "\\curlyeqprec", !0);
defineSymbol(math, ams, rel, "≾", "\\precsim", !0);
defineSymbol(math, ams, rel, "⪷", "\\precapprox", !0);
defineSymbol(math, ams, rel, "⊲", "\\vartriangleleft");
defineSymbol(math, ams, rel, "⊴", "\\trianglelefteq");
defineSymbol(math, ams, rel, "⊨", "\\vDash", !0);
defineSymbol(math, ams, rel, "⊪", "\\Vvdash", !0);
defineSymbol(math, ams, rel, "⌣", "\\smallsmile");
defineSymbol(math, ams, rel, "⌢", "\\smallfrown");
defineSymbol(math, ams, rel, "≏", "\\bumpeq", !0);
defineSymbol(math, ams, rel, "≎", "\\Bumpeq", !0);
defineSymbol(math, ams, rel, "≧", "\\geqq", !0);
defineSymbol(math, ams, rel, "⩾", "\\geqslant", !0);
defineSymbol(math, ams, rel, "⪖", "\\eqslantgtr", !0);
defineSymbol(math, ams, rel, "≳", "\\gtrsim", !0);
defineSymbol(math, ams, rel, "⪆", "\\gtrapprox", !0);
defineSymbol(math, ams, bin, "⋗", "\\gtrdot");
defineSymbol(math, ams, rel, "⋙", "\\ggg", !0);
defineSymbol(math, ams, rel, "≷", "\\gtrless", !0);
defineSymbol(math, ams, rel, "⋛", "\\gtreqless", !0);
defineSymbol(math, ams, rel, "⪌", "\\gtreqqless", !0);
defineSymbol(math, ams, rel, "≖", "\\eqcirc", !0);
defineSymbol(math, ams, rel, "≗", "\\circeq", !0);
defineSymbol(math, ams, rel, "≜", "\\triangleq", !0);
defineSymbol(math, ams, rel, "∼", "\\thicksim");
defineSymbol(math, ams, rel, "≈", "\\thickapprox");
defineSymbol(math, ams, rel, "⫆", "\\supseteqq", !0);
defineSymbol(math, ams, rel, "⋑", "\\Supset", !0);
defineSymbol(math, ams, rel, "⊐", "\\sqsupset", !0);
defineSymbol(math, ams, rel, "≽", "\\succcurlyeq", !0);
defineSymbol(math, ams, rel, "⋟", "\\curlyeqsucc", !0);
defineSymbol(math, ams, rel, "≿", "\\succsim", !0);
defineSymbol(math, ams, rel, "⪸", "\\succapprox", !0);
defineSymbol(math, ams, rel, "⊳", "\\vartriangleright");
defineSymbol(math, ams, rel, "⊵", "\\trianglerighteq");
defineSymbol(math, ams, rel, "⊩", "\\Vdash", !0);
defineSymbol(math, ams, rel, "∣", "\\shortmid");
defineSymbol(math, ams, rel, "∥", "\\shortparallel");
defineSymbol(math, ams, rel, "≬", "\\between", !0);
defineSymbol(math, ams, rel, "⋔", "\\pitchfork", !0);
defineSymbol(math, ams, rel, "∝", "\\varpropto");
defineSymbol(math, ams, rel, "◀", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "∴", "\\therefore", !0);
defineSymbol(math, ams, rel, "∍", "\\backepsilon");
defineSymbol(math, ams, rel, "▶", "\\blacktriangleright");
defineSymbol(math, ams, rel, "∵", "\\because", !0);
defineSymbol(math, ams, rel, "⋘", "\\llless");
defineSymbol(math, ams, rel, "⋙", "\\gggtr");
defineSymbol(math, ams, bin, "⊲", "\\lhd");
defineSymbol(math, ams, bin, "⊳", "\\rhd");
defineSymbol(math, ams, rel, "≂", "\\eqsim", !0);
defineSymbol(math, main, rel, "⋈", "\\Join");
defineSymbol(math, ams, rel, "≑", "\\Doteq", !0);
defineSymbol(math, ams, bin, "∔", "\\dotplus", !0);
defineSymbol(math, ams, bin, "∖", "\\smallsetminus");
defineSymbol(math, ams, bin, "⋒", "\\Cap", !0);
defineSymbol(math, ams, bin, "⋓", "\\Cup", !0);
defineSymbol(math, ams, bin, "⩞", "\\doublebarwedge", !0);
defineSymbol(math, ams, bin, "⊟", "\\boxminus", !0);
defineSymbol(math, ams, bin, "⊞", "\\boxplus", !0);
defineSymbol(math, ams, bin, "⋇", "\\divideontimes", !0);
defineSymbol(math, ams, bin, "⋉", "\\ltimes", !0);
defineSymbol(math, ams, bin, "⋊", "\\rtimes", !0);
defineSymbol(math, ams, bin, "⋋", "\\leftthreetimes", !0);
defineSymbol(math, ams, bin, "⋌", "\\rightthreetimes", !0);
defineSymbol(math, ams, bin, "⋏", "\\curlywedge", !0);
defineSymbol(math, ams, bin, "⋎", "\\curlyvee", !0);
defineSymbol(math, ams, bin, "⊝", "\\circleddash", !0);
defineSymbol(math, ams, bin, "⊛", "\\circledast", !0);
defineSymbol(math, ams, bin, "⋅", "\\centerdot");
defineSymbol(math, ams, bin, "⊺", "\\intercal", !0);
defineSymbol(math, ams, bin, "⋒", "\\doublecap");
defineSymbol(math, ams, bin, "⋓", "\\doublecup");
defineSymbol(math, ams, bin, "⊠", "\\boxtimes", !0);
defineSymbol(math, ams, rel, "⇢", "\\dashrightarrow", !0);
defineSymbol(math, ams, rel, "⇠", "\\dashleftarrow", !0);
defineSymbol(math, ams, rel, "⇇", "\\leftleftarrows", !0);
defineSymbol(math, ams, rel, "⇆", "\\leftrightarrows", !0);
defineSymbol(math, ams, rel, "⇚", "\\Lleftarrow", !0);
defineSymbol(math, ams, rel, "↞", "\\twoheadleftarrow", !0);
defineSymbol(math, ams, rel, "↢", "\\leftarrowtail", !0);
defineSymbol(math, ams, rel, "↫", "\\looparrowleft", !0);
defineSymbol(math, ams, rel, "⇋", "\\leftrightharpoons", !0);
defineSymbol(math, ams, rel, "↶", "\\curvearrowleft", !0);
defineSymbol(math, ams, rel, "↺", "\\circlearrowleft", !0);
defineSymbol(math, ams, rel, "↰", "\\Lsh", !0);
defineSymbol(math, ams, rel, "⇈", "\\upuparrows", !0);
defineSymbol(math, ams, rel, "↿", "\\upharpoonleft", !0);
defineSymbol(math, ams, rel, "⇃", "\\downharpoonleft", !0);
defineSymbol(math, main, rel, "⊶", "\\origof", !0);
defineSymbol(math, main, rel, "⊷", "\\imageof", !0);
defineSymbol(math, ams, rel, "⊸", "\\multimap", !0);
defineSymbol(math, ams, rel, "↭", "\\leftrightsquigarrow", !0);
defineSymbol(math, ams, rel, "⇉", "\\rightrightarrows", !0);
defineSymbol(math, ams, rel, "⇄", "\\rightleftarrows", !0);
defineSymbol(math, ams, rel, "↠", "\\twoheadrightarrow", !0);
defineSymbol(math, ams, rel, "↣", "\\rightarrowtail", !0);
defineSymbol(math, ams, rel, "↬", "\\looparrowright", !0);
defineSymbol(math, ams, rel, "↷", "\\curvearrowright", !0);
defineSymbol(math, ams, rel, "↻", "\\circlearrowright", !0);
defineSymbol(math, ams, rel, "↱", "\\Rsh", !0);
defineSymbol(math, ams, rel, "⇊", "\\downdownarrows", !0);
defineSymbol(math, ams, rel, "↾", "\\upharpoonright", !0);
defineSymbol(math, ams, rel, "⇂", "\\downharpoonright", !0);
defineSymbol(math, ams, rel, "⇝", "\\rightsquigarrow", !0);
defineSymbol(math, ams, rel, "⇝", "\\leadsto");
defineSymbol(math, ams, rel, "⇛", "\\Rrightarrow", !0);
defineSymbol(math, ams, rel, "↾", "\\restriction");
defineSymbol(math, main, textord, "‘", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text$a, main, textord, "$", "\\$");
defineSymbol(text$a, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text$a, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text$a, main, textord, "_", "\\_");
defineSymbol(text$a, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "∠", "\\angle", !0);
defineSymbol(math, main, textord, "∞", "\\infty", !0);
defineSymbol(math, main, textord, "′", "\\prime");
defineSymbol(math, main, textord, "△", "\\triangle");
defineSymbol(math, main, textord, "Γ", "\\Gamma", !0);
defineSymbol(math, main, textord, "Δ", "\\Delta", !0);
defineSymbol(math, main, textord, "Θ", "\\Theta", !0);
defineSymbol(math, main, textord, "Λ", "\\Lambda", !0);
defineSymbol(math, main, textord, "Ξ", "\\Xi", !0);
defineSymbol(math, main, textord, "Π", "\\Pi", !0);
defineSymbol(math, main, textord, "Σ", "\\Sigma", !0);
defineSymbol(math, main, textord, "Υ", "\\Upsilon", !0);
defineSymbol(math, main, textord, "Φ", "\\Phi", !0);
defineSymbol(math, main, textord, "Ψ", "\\Psi", !0);
defineSymbol(math, main, textord, "Ω", "\\Omega", !0);
defineSymbol(math, main, textord, "A", "Α");
defineSymbol(math, main, textord, "B", "Β");
defineSymbol(math, main, textord, "E", "Ε");
defineSymbol(math, main, textord, "Z", "Ζ");
defineSymbol(math, main, textord, "H", "Η");
defineSymbol(math, main, textord, "I", "Ι");
defineSymbol(math, main, textord, "K", "Κ");
defineSymbol(math, main, textord, "M", "Μ");
defineSymbol(math, main, textord, "N", "Ν");
defineSymbol(math, main, textord, "O", "Ο");
defineSymbol(math, main, textord, "P", "Ρ");
defineSymbol(math, main, textord, "T", "Τ");
defineSymbol(math, main, textord, "X", "Χ");
defineSymbol(math, main, textord, "¬", "\\neg", !0);
defineSymbol(math, main, textord, "¬", "\\lnot");
defineSymbol(math, main, textord, "⊤", "\\top");
defineSymbol(math, main, textord, "⊥", "\\bot");
defineSymbol(math, main, textord, "∅", "\\emptyset");
defineSymbol(math, ams, textord, "∅", "\\varnothing");
defineSymbol(math, main, mathord, "α", "\\alpha", !0);
defineSymbol(math, main, mathord, "β", "\\beta", !0);
defineSymbol(math, main, mathord, "γ", "\\gamma", !0);
defineSymbol(math, main, mathord, "δ", "\\delta", !0);
defineSymbol(math, main, mathord, "ϵ", "\\epsilon", !0);
defineSymbol(math, main, mathord, "ζ", "\\zeta", !0);
defineSymbol(math, main, mathord, "η", "\\eta", !0);
defineSymbol(math, main, mathord, "θ", "\\theta", !0);
defineSymbol(math, main, mathord, "ι", "\\iota", !0);
defineSymbol(math, main, mathord, "κ", "\\kappa", !0);
defineSymbol(math, main, mathord, "λ", "\\lambda", !0);
defineSymbol(math, main, mathord, "μ", "\\mu", !0);
defineSymbol(math, main, mathord, "ν", "\\nu", !0);
defineSymbol(math, main, mathord, "ξ", "\\xi", !0);
defineSymbol(math, main, mathord, "ο", "\\omicron", !0);
defineSymbol(math, main, mathord, "π", "\\pi", !0);
defineSymbol(math, main, mathord, "ρ", "\\rho", !0);
defineSymbol(math, main, mathord, "σ", "\\sigma", !0);
defineSymbol(math, main, mathord, "τ", "\\tau", !0);
defineSymbol(math, main, mathord, "υ", "\\upsilon", !0);
defineSymbol(math, main, mathord, "ϕ", "\\phi", !0);
defineSymbol(math, main, mathord, "χ", "\\chi", !0);
defineSymbol(math, main, mathord, "ψ", "\\psi", !0);
defineSymbol(math, main, mathord, "ω", "\\omega", !0);
defineSymbol(math, main, mathord, "ε", "\\varepsilon", !0);
defineSymbol(math, main, mathord, "ϑ", "\\vartheta", !0);
defineSymbol(math, main, mathord, "ϖ", "\\varpi", !0);
defineSymbol(math, main, mathord, "ϱ", "\\varrho", !0);
defineSymbol(math, main, mathord, "ς", "\\varsigma", !0);
defineSymbol(math, main, mathord, "φ", "\\varphi", !0);
defineSymbol(math, main, bin, "∗", "*", !0);
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "−", "-", !0);
defineSymbol(math, main, bin, "⋅", "\\cdot", !0);
defineSymbol(math, main, bin, "∘", "\\circ", !0);
defineSymbol(math, main, bin, "÷", "\\div", !0);
defineSymbol(math, main, bin, "±", "\\pm", !0);
defineSymbol(math, main, bin, "×", "\\times", !0);
defineSymbol(math, main, bin, "∩", "\\cap", !0);
defineSymbol(math, main, bin, "∪", "\\cup", !0);
defineSymbol(math, main, bin, "∖", "\\setminus", !0);
defineSymbol(math, main, bin, "∧", "\\land");
defineSymbol(math, main, bin, "∨", "\\lor");
defineSymbol(math, main, bin, "∧", "\\wedge", !0);
defineSymbol(math, main, bin, "∨", "\\vee", !0);
defineSymbol(math, main, textord, "√", "\\surd");
defineSymbol(math, main, open, "⟨", "\\langle", !0);
defineSymbol(math, main, open, "∣", "\\lvert");
defineSymbol(math, main, open, "∥", "\\lVert");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "⟩", "\\rangle", !0);
defineSymbol(math, main, close, "∣", "\\rvert");
defineSymbol(math, main, close, "∥", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "≈", "\\approx", !0);
defineSymbol(math, main, rel, "≅", "\\cong", !0);
defineSymbol(math, main, rel, "≥", "\\ge");
defineSymbol(math, main, rel, "≥", "\\geq", !0);
defineSymbol(math, main, rel, "←", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", !0);
defineSymbol(math, main, rel, "∈", "\\in", !0);
defineSymbol(math, main, rel, "", "\\@not");
defineSymbol(math, main, rel, "⊂", "\\subset", !0);
defineSymbol(math, main, rel, "⊃", "\\supset", !0);
defineSymbol(math, main, rel, "⊆", "\\subseteq", !0);
defineSymbol(math, main, rel, "⊇", "\\supseteq", !0);
defineSymbol(math, ams, rel, "⊈", "\\nsubseteq", !0);
defineSymbol(math, ams, rel, "⊉", "\\nsupseteq", !0);
defineSymbol(math, main, rel, "⊨", "\\models");
defineSymbol(math, main, rel, "←", "\\leftarrow", !0);
defineSymbol(math, main, rel, "≤", "\\le");
defineSymbol(math, main, rel, "≤", "\\leq", !0);
defineSymbol(math, main, rel, "<", "\\lt", !0);
defineSymbol(math, main, rel, "→", "\\rightarrow", !0);
defineSymbol(math, main, rel, "→", "\\to");
defineSymbol(math, ams, rel, "≱", "\\ngeq", !0);
defineSymbol(math, ams, rel, "≰", "\\nleq", !0);
defineSymbol(math, main, spacing, " ", "\\ ");
defineSymbol(math, main, spacing, " ", "\\space");
defineSymbol(math, main, spacing, " ", "\\nobreakspace");
defineSymbol(text$a, main, spacing, " ", "\\ ");
defineSymbol(text$a, main, spacing, " ", " ");
defineSymbol(text$a, main, spacing, " ", "\\space");
defineSymbol(text$a, main, spacing, " ", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin, "⊼", "\\barwedge", !0);
defineSymbol(math, ams, bin, "⊻", "\\veebar", !0);
defineSymbol(math, main, bin, "⊙", "\\odot", !0);
defineSymbol(math, main, bin, "⊕", "\\oplus", !0);
defineSymbol(math, main, bin, "⊗", "\\otimes", !0);
defineSymbol(math, main, textord, "∂", "\\partial", !0);
defineSymbol(math, main, bin, "⊘", "\\oslash", !0);
defineSymbol(math, ams, bin, "⊚", "\\circledcirc", !0);
defineSymbol(math, ams, bin, "⊡", "\\boxdot", !0);
defineSymbol(math, main, bin, "△", "\\bigtriangleup");
defineSymbol(math, main, bin, "▽", "\\bigtriangledown");
defineSymbol(math, main, bin, "†", "\\dagger");
defineSymbol(math, main, bin, "⋄", "\\diamond");
defineSymbol(math, main, bin, "⋆", "\\star");
defineSymbol(math, main, bin, "◃", "\\triangleleft");
defineSymbol(math, main, bin, "▹", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text$a, main, textord, "{", "\\{");
defineSymbol(text$a, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text$a, main, textord, "}", "\\}");
defineSymbol(text$a, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack", !0);
defineSymbol(text$a, main, textord, "[", "\\lbrack", !0);
defineSymbol(math, main, close, "]", "\\rbrack", !0);
defineSymbol(text$a, main, textord, "]", "\\rbrack", !0);
defineSymbol(math, main, open, "(", "\\lparen", !0);
defineSymbol(math, main, close, ")", "\\rparen", !0);
defineSymbol(text$a, main, textord, "<", "\\textless", !0);
defineSymbol(text$a, main, textord, ">", "\\textgreater", !0);
defineSymbol(math, main, open, "⌊", "\\lfloor", !0);
defineSymbol(math, main, close, "⌋", "\\rfloor", !0);
defineSymbol(math, main, open, "⌈", "\\lceil", !0);
defineSymbol(math, main, close, "⌉", "\\rceil", !0);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "∣", "|");
defineSymbol(math, main, textord, "∣", "\\vert");
defineSymbol(text$a, main, textord, "|", "\\textbar", !0);
defineSymbol(math, main, textord, "∥", "\\|");
defineSymbol(math, main, textord, "∥", "\\Vert");
defineSymbol(text$a, main, textord, "∥", "\\textbardbl");
defineSymbol(text$a, main, textord, "~", "\\textasciitilde");
defineSymbol(text$a, main, textord, "\\", "\\textbackslash");
defineSymbol(text$a, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "↑", "\\uparrow", !0);
defineSymbol(math, main, rel, "⇑", "\\Uparrow", !0);
defineSymbol(math, main, rel, "↓", "\\downarrow", !0);
defineSymbol(math, main, rel, "⇓", "\\Downarrow", !0);
defineSymbol(math, main, rel, "↕", "\\updownarrow", !0);
defineSymbol(math, main, rel, "⇕", "\\Updownarrow", !0);
defineSymbol(math, main, op, "∐", "\\coprod");
defineSymbol(math, main, op, "⋁", "\\bigvee");
defineSymbol(math, main, op, "⋀", "\\bigwedge");
defineSymbol(math, main, op, "⨄", "\\biguplus");
defineSymbol(math, main, op, "⋂", "\\bigcap");
defineSymbol(math, main, op, "⋃", "\\bigcup");
defineSymbol(math, main, op, "∫", "\\int");
defineSymbol(math, main, op, "∫", "\\intop");
defineSymbol(math, main, op, "∬", "\\iint");
defineSymbol(math, main, op, "∭", "\\iiint");
defineSymbol(math, main, op, "∏", "\\prod");
defineSymbol(math, main, op, "∑", "\\sum");
defineSymbol(math, main, op, "⨂", "\\bigotimes");
defineSymbol(math, main, op, "⨁", "\\bigoplus");
defineSymbol(math, main, op, "⨀", "\\bigodot");
defineSymbol(math, main, op, "∮", "\\oint");
defineSymbol(math, main, op, "∯", "\\oiint");
defineSymbol(math, main, op, "∰", "\\oiiint");
defineSymbol(math, main, op, "⨆", "\\bigsqcup");
defineSymbol(math, main, op, "∫", "\\smallint");
defineSymbol(text$a, main, inner, "…", "\\textellipsis");
defineSymbol(math, main, inner, "…", "\\mathellipsis");
defineSymbol(text$a, main, inner, "…", "\\ldots", !0);
defineSymbol(math, main, inner, "…", "\\ldots", !0);
defineSymbol(math, main, inner, "⋯", "\\@cdots", !0);
defineSymbol(math, main, inner, "⋱", "\\ddots", !0);
defineSymbol(math, main, textord, "⋮", "\\varvdots");
defineSymbol(math, main, accent, "ˊ", "\\acute");
defineSymbol(math, main, accent, "ˋ", "\\grave");
defineSymbol(math, main, accent, "¨", "\\ddot");
defineSymbol(math, main, accent, "~", "\\tilde");
defineSymbol(math, main, accent, "ˉ", "\\bar");
defineSymbol(math, main, accent, "˘", "\\breve");
defineSymbol(math, main, accent, "ˇ", "\\check");
defineSymbol(math, main, accent, "^", "\\hat");
defineSymbol(math, main, accent, "⃗", "\\vec");
defineSymbol(math, main, accent, "˙", "\\dot");
defineSymbol(math, main, accent, "˚", "\\mathring");
defineSymbol(math, main, mathord, "", "\\@imath");
defineSymbol(math, main, mathord, "", "\\@jmath");
defineSymbol(math, main, textord, "ı", "ı");
defineSymbol(math, main, textord, "ȷ", "ȷ");
defineSymbol(text$a, main, textord, "ı", "\\i", !0);
defineSymbol(text$a, main, textord, "ȷ", "\\j", !0);
defineSymbol(text$a, main, textord, "ß", "\\ss", !0);
defineSymbol(text$a, main, textord, "æ", "\\ae", !0);
defineSymbol(text$a, main, textord, "œ", "\\oe", !0);
defineSymbol(text$a, main, textord, "ø", "\\o", !0);
defineSymbol(text$a, main, textord, "Æ", "\\AE", !0);
defineSymbol(text$a, main, textord, "Œ", "\\OE", !0);
defineSymbol(text$a, main, textord, "Ø", "\\O", !0);
defineSymbol(text$a, main, accent, "ˊ", "\\'");
defineSymbol(text$a, main, accent, "ˋ", "\\`");
defineSymbol(text$a, main, accent, "ˆ", "\\^");
defineSymbol(text$a, main, accent, "˜", "\\~");
defineSymbol(text$a, main, accent, "ˉ", "\\=");
defineSymbol(text$a, main, accent, "˘", "\\u");
defineSymbol(text$a, main, accent, "˙", "\\.");
defineSymbol(text$a, main, accent, "¸", "\\c");
defineSymbol(text$a, main, accent, "˚", "\\r");
defineSymbol(text$a, main, accent, "ˇ", "\\v");
defineSymbol(text$a, main, accent, "¨", '\\"');
defineSymbol(text$a, main, accent, "˝", "\\H");
defineSymbol(text$a, main, accent, "◯", "\\textcircled");
var ligatures = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
defineSymbol(text$a, main, textord, "–", "--", !0);
defineSymbol(text$a, main, textord, "–", "\\textendash");
defineSymbol(text$a, main, textord, "—", "---", !0);
defineSymbol(text$a, main, textord, "—", "\\textemdash");
defineSymbol(text$a, main, textord, "‘", "`", !0);
defineSymbol(text$a, main, textord, "‘", "\\textquoteleft");
defineSymbol(text$a, main, textord, "’", "'", !0);
defineSymbol(text$a, main, textord, "’", "\\textquoteright");
defineSymbol(text$a, main, textord, "“", "``", !0);
defineSymbol(text$a, main, textord, "“", "\\textquotedblleft");
defineSymbol(text$a, main, textord, "”", "''", !0);
defineSymbol(text$a, main, textord, "”", "\\textquotedblright");
defineSymbol(math, main, textord, "°", "\\degree", !0);
defineSymbol(text$a, main, textord, "°", "\\degree");
defineSymbol(text$a, main, textord, "°", "\\textdegree", !0);
defineSymbol(math, main, textord, "£", "\\pounds");
defineSymbol(math, main, textord, "£", "\\mathsterling", !0);
defineSymbol(text$a, main, textord, "£", "\\pounds");
defineSymbol(text$a, main, textord, "£", "\\textsterling", !0);
defineSymbol(math, ams, textord, "✠", "\\maltese");
defineSymbol(text$a, ams, textord, "✠", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text$a, main, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math, main, mathord, _ch2, _ch2), defineSymbol(text$a, main, textord, _ch2, _ch2);
}
defineSymbol(math, ams, textord, "C", "ℂ");
defineSymbol(text$a, ams, textord, "C", "ℂ");
defineSymbol(math, ams, textord, "H", "ℍ");
defineSymbol(text$a, ams, textord, "H", "ℍ");
defineSymbol(math, ams, textord, "N", "ℕ");
defineSymbol(text$a, ams, textord, "N", "ℕ");
defineSymbol(math, ams, textord, "P", "ℙ");
defineSymbol(text$a, ams, textord, "P", "ℙ");
defineSymbol(math, ams, textord, "Q", "ℚ");
defineSymbol(text$a, ams, textord, "Q", "ℚ");
defineSymbol(math, ams, textord, "R", "ℝ");
defineSymbol(text$a, ams, textord, "R", "ℝ");
defineSymbol(math, ams, textord, "Z", "ℤ");
defineSymbol(text$a, ams, textord, "Z", "ℤ");
defineSymbol(math, main, mathord, "h", "ℎ");
defineSymbol(text$a, main, mathord, "h", "ℎ");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56372 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56424 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56580 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56684 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56736 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56788 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56840 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56944 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), _i3 < 26 && (wideChar = String.fromCharCode(55349, 56632 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56476 + _i3), defineSymbol(math, main, mathord, _ch3, wideChar), defineSymbol(text$a, main, textord, _ch3, wideChar));
}
wideChar = "𝕜";
defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text$a, main, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4), defineSymbol(math, main, mathord, _ch4, wideChar), defineSymbol(text$a, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57314 + _i4), defineSymbol(math, main, mathord, _ch4, wideChar), defineSymbol(text$a, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57324 + _i4), defineSymbol(math, main, mathord, _ch4, wideChar), defineSymbol(text$a, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57334 + _i4), defineSymbol(math, main, mathord, _ch4, wideChar), defineSymbol(text$a, main, textord, _ch4, wideChar);
}
var extraLatin = "ÐÞþ";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main, mathord, _ch5, _ch5), defineSymbol(text$a, main, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], wideCharacterFont = function(e, r) {
  var n = e.charCodeAt(0), s = e.charCodeAt(1), h = (n - 55296) * 1024 + (s - 56320) + 65536, b = r === "math" ? 0 : 1;
  if (119808 <= h && h < 120484) {
    var g = Math.floor((h - 119808) / 26);
    return [wideLatinLetterData[g][2], wideLatinLetterData[g][b]];
  } else if (120782 <= h && h <= 120831) {
    var _ = Math.floor((h - 120782) / 10);
    return [wideNumeralData[_][2], wideNumeralData[_][b]];
  } else {
    if (h === 120485 || h === 120486)
      return [wideLatinLetterData[0][2], wideLatinLetterData[0][b]];
    if (120486 < h && h < 120782)
      return ["", ""];
    throw new ParseError("Unsupported character: " + e);
  }
}, lookupSymbol = function(e, r, n) {
  return symbols[n][e] && symbols[n][e].replace && (e = symbols[n][e].replace), {
    value: e,
    metrics: getCharacterMetrics(e, r, n)
  };
}, makeSymbol = function(e, r, n, s, h) {
  var b = lookupSymbol(e, r, n), g = b.metrics;
  e = b.value;
  var _;
  if (g) {
    var A = g.italic;
    (n === "text" || s && s.font === "mathit") && (A = 0), _ = new SymbolNode(e, g.height, g.depth, A, g.skew, g.width, h);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + r + "' and mode '" + n + "'")), _ = new SymbolNode(e, 0, 0, 0, 0, 0, h);
  if (s) {
    _.maxFontSize = s.sizeMultiplier, s.style.isTight() && _.classes.push("mtight");
    var x = s.getColor();
    x && (_.style.color = x);
  }
  return _;
}, mathsym = function(e, r, n, s) {
  return s === void 0 && (s = []), n.font === "boldsymbol" && lookupSymbol(e, "Main-Bold", r).metrics ? makeSymbol(e, "Main-Bold", r, n, s.concat(["mathbf"])) : e === "\\" || symbols[r][e].font === "main" ? makeSymbol(e, "Main-Regular", r, n, s) : makeSymbol(e, "AMS-Regular", r, n, s.concat(["amsrm"]));
}, boldsymbol = function(e, r, n, s, h) {
  return h !== "textord" && lookupSymbol(e, "Math-BoldItalic", r).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, makeOrd = function(e, r, n) {
  var s = e.mode, h = e.text, b = ["mord"], g = s === "math" || s === "text" && r.font, _ = g ? r.font : r.fontFamily, A = "", x = "";
  if (h.charCodeAt(0) === 55349 && ([A, x] = wideCharacterFont(h, s)), A.length > 0)
    return makeSymbol(h, A, s, r, b.concat(x));
  if (_) {
    var k, $;
    if (_ === "boldsymbol") {
      var C = boldsymbol(h, s, r, b, n);
      k = C.fontName, $ = [C.fontClass];
    } else g ? (k = fontMap[_].fontName, $ = [_]) : (k = retrieveTextFontName(_, r.fontWeight, r.fontShape), $ = [_, r.fontWeight, r.fontShape]);
    if (lookupSymbol(h, k, s).metrics)
      return makeSymbol(h, k, s, r, b.concat($));
    if (ligatures.hasOwnProperty(h) && k.slice(0, 10) === "Typewriter") {
      for (var L = [], y = 0; y < h.length; y++)
        L.push(makeSymbol(h[y], k, s, r, b.concat($)));
      return makeFragment(L);
    }
  }
  if (n === "mathord")
    return makeSymbol(h, "Math-Italic", s, r, b.concat(["mathnormal"]));
  if (n === "textord") {
    var o = symbols[s][h] && symbols[s][h].font;
    if (o === "ams") {
      var v = retrieveTextFontName("amsrm", r.fontWeight, r.fontShape);
      return makeSymbol(h, v, s, r, b.concat("amsrm", r.fontWeight, r.fontShape));
    } else if (o === "main" || !o) {
      var w = retrieveTextFontName("textrm", r.fontWeight, r.fontShape);
      return makeSymbol(h, w, s, r, b.concat(r.fontWeight, r.fontShape));
    } else {
      var M = retrieveTextFontName(o, r.fontWeight, r.fontShape);
      return makeSymbol(h, M, s, r, b.concat(M, r.fontWeight, r.fontShape));
    }
  } else
    throw new Error("unexpected type: " + n + " in makeOrd");
}, canCombine = (a, e) => {
  if (createClass(a.classes) !== createClass(e.classes) || a.skew !== e.skew || a.maxFontSize !== e.maxFontSize)
    return !1;
  if (a.classes.length === 1) {
    var r = a.classes[0];
    if (r === "mbin" || r === "mord")
      return !1;
  }
  for (var n in a.style)
    if (a.style.hasOwnProperty(n) && a.style[n] !== e.style[n])
      return !1;
  for (var s in e.style)
    if (e.style.hasOwnProperty(s) && a.style[s] !== e.style[s])
      return !1;
  return !0;
}, tryCombineChars = (a) => {
  for (var e = 0; e < a.length - 1; e++) {
    var r = a[e], n = a[e + 1];
    r instanceof SymbolNode && n instanceof SymbolNode && canCombine(r, n) && (r.text += n.text, r.height = Math.max(r.height, n.height), r.depth = Math.max(r.depth, n.depth), r.italic = n.italic, a.splice(e + 1, 1), e--);
  }
  return a;
}, sizeElementFromChildren = function(e) {
  for (var r = 0, n = 0, s = 0, h = 0; h < e.children.length; h++) {
    var b = e.children[h];
    b.height > r && (r = b.height), b.depth > n && (n = b.depth), b.maxFontSize > s && (s = b.maxFontSize);
  }
  e.height = r, e.depth = n, e.maxFontSize = s;
}, makeSpan$2 = function(e, r, n, s) {
  var h = new Span(e, r, n, s);
  return sizeElementFromChildren(h), h;
}, makeSvgSpan = (a, e, r, n) => new Span(a, e, r, n), makeLineSpan = function(e, r, n) {
  var s = makeSpan$2([e], [], r);
  return s.height = Math.max(n || r.fontMetrics().defaultRuleThickness, r.minRuleThickness), s.style.borderBottomWidth = makeEm(s.height), s.maxFontSize = 1, s;
}, makeAnchor = function(e, r, n, s) {
  var h = new Anchor(e, r, n, s);
  return sizeElementFromChildren(h), h;
}, makeFragment = function(e) {
  var r = new DocumentFragment(e);
  return sizeElementFromChildren(r), r;
}, wrapFragment = function(e, r) {
  return e instanceof DocumentFragment ? makeSpan$2([], [e], r) : e;
}, getVListChildrenAndDepth = function(e) {
  if (e.positionType === "individualShift") {
    for (var r = e.children, n = [r[0]], s = -r[0].shift - r[0].elem.depth, h = s, b = 1; b < r.length; b++) {
      var g = -r[b].shift - h - r[b].elem.depth, _ = g - (r[b - 1].elem.height + r[b - 1].elem.depth);
      h = h + g, n.push({
        type: "kern",
        size: _
      }), n.push(r[b]);
    }
    return {
      children: n,
      depth: s
    };
  }
  var A;
  if (e.positionType === "top") {
    for (var x = e.positionData, k = 0; k < e.children.length; k++) {
      var $ = e.children[k];
      x -= $.type === "kern" ? $.size : $.elem.height + $.elem.depth;
    }
    A = x;
  } else if (e.positionType === "bottom")
    A = -e.positionData;
  else {
    var C = e.children[0];
    if (C.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      A = -C.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      A = -C.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: A
  };
}, makeVList = function(e, r) {
  for (var {
    children: n,
    depth: s
  } = getVListChildrenAndDepth(e), h = 0, b = 0; b < n.length; b++) {
    var g = n[b];
    if (g.type === "elem") {
      var _ = g.elem;
      h = Math.max(h, _.maxFontSize, _.height);
    }
  }
  h += 2;
  var A = makeSpan$2(["pstrut"], []);
  A.style.height = makeEm(h);
  for (var x = [], k = s, $ = s, C = s, L = 0; L < n.length; L++) {
    var y = n[L];
    if (y.type === "kern")
      C += y.size;
    else {
      var o = y.elem, v = y.wrapperClasses || [], w = y.wrapperStyle || {}, M = makeSpan$2(v, [A, o], void 0, w);
      M.style.top = makeEm(-h - C - o.depth), y.marginLeft && (M.style.marginLeft = y.marginLeft), y.marginRight && (M.style.marginRight = y.marginRight), x.push(M), C += o.height + o.depth;
    }
    k = Math.min(k, C), $ = Math.max($, C);
  }
  var F = makeSpan$2(["vlist"], x);
  F.style.height = makeEm($);
  var m;
  if (k < 0) {
    var E = makeSpan$2([], []), z = makeSpan$2(["vlist"], [E]);
    z.style.height = makeEm(-k);
    var O = makeSpan$2(["vlist-s"], [new SymbolNode("​")]);
    m = [makeSpan$2(["vlist-r"], [F, O]), makeSpan$2(["vlist-r"], [z])];
  } else
    m = [makeSpan$2(["vlist-r"], [F])];
  var R = makeSpan$2(["vlist-t"], m);
  return m.length === 2 && R.classes.push("vlist-t2"), R.height = $, R.depth = -k, R;
}, makeGlue = (a, e) => {
  var r = makeSpan$2(["mspace"], [], e), n = calculateSize(a, e);
  return r.style.marginRight = makeEm(n), r;
}, retrieveTextFontName = function(e, r, n) {
  var s = "";
  switch (e) {
    case "amsrm":
      s = "AMS";
      break;
    case "textrm":
      s = "Main";
      break;
    case "textsf":
      s = "SansSerif";
      break;
    case "texttt":
      s = "Typewriter";
      break;
    default:
      s = e;
  }
  var h;
  return r === "textbf" && n === "textit" ? h = "BoldItalic" : r === "textbf" ? h = "Bold" : r === "textit" ? h = "Italic" : h = "Regular", s + "-" + h;
}, fontMap = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, staticSvg = function(e, r) {
  var [n, s, h] = svgData[e], b = new PathNode(n), g = new SvgNode([b], {
    width: makeEm(s),
    height: makeEm(h),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + makeEm(s),
    viewBox: "0 0 " + 1e3 * s + " " + 1e3 * h,
    preserveAspectRatio: "xMinYMin"
  }), _ = makeSvgSpan(["overlay"], [g], r);
  return _.height = h, _.style.height = makeEm(h), _.style.width = makeEm(s), _;
}, buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
}, thinspace = {
  number: 3,
  unit: "mu"
}, mediumspace = {
  number: 4,
  unit: "mu"
}, thickspace = {
  number: 5,
  unit: "mu"
}, spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
}, tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
}, _functions = {}, _htmlGroupBuilders = {}, _mathmlGroupBuilders = {};
function defineFunction(a) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: s,
    htmlBuilder: h,
    mathmlBuilder: b
  } = a, g = {
    type: e,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: s
  }, _ = 0; _ < r.length; ++_)
    _functions[r[_]] = g;
  e && (h && (_htmlGroupBuilders[e] = h), b && (_mathmlGroupBuilders[e] = b));
}
function defineFunctionBuilders(a) {
  var {
    type: e,
    htmlBuilder: r,
    mathmlBuilder: n
  } = a;
  defineFunction({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: r,
    mathmlBuilder: n
  });
}
var normalizeArgument = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, ordargument = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, makeSpan$1 = buildCommon.makeSpan, binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"], styleMap$1 = {
  display: Style$1.DISPLAY,
  text: Style$1.TEXT,
  script: Style$1.SCRIPT,
  scriptscript: Style$1.SCRIPTSCRIPT
}, DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, buildExpression$1 = function(e, r, n, s) {
  s === void 0 && (s = [null, null]);
  for (var h = [], b = 0; b < e.length; b++) {
    var g = buildGroup$1(e[b], r);
    if (g instanceof DocumentFragment) {
      var _ = g.children;
      h.push(..._);
    } else
      h.push(g);
  }
  if (buildCommon.tryCombineChars(h), !n)
    return h;
  var A = r;
  if (e.length === 1) {
    var x = e[0];
    x.type === "sizing" ? A = r.havingSize(x.size) : x.type === "styling" && (A = r.havingStyle(styleMap$1[x.style]));
  }
  var k = makeSpan$1([s[0] || "leftmost"], [], r), $ = makeSpan$1([s[1] || "rightmost"], [], r), C = n === "root";
  return traverseNonSpaceNodes(h, (L, y) => {
    var o = y.classes[0], v = L.classes[0];
    o === "mbin" && utils.contains(binRightCanceller, v) ? y.classes[0] = "mord" : v === "mbin" && utils.contains(binLeftCanceller, o) && (L.classes[0] = "mord");
  }, {
    node: k
  }, $, C), traverseNonSpaceNodes(h, (L, y) => {
    var o = getTypeOfDomTree(y), v = getTypeOfDomTree(L), w = o && v ? L.hasClass("mtight") ? tightSpacings[o][v] : spacings[o][v] : null;
    if (w)
      return buildCommon.makeGlue(w, A);
  }, {
    node: k
  }, $, C), h;
}, traverseNonSpaceNodes = function a(e, r, n, s, h) {
  s && e.push(s);
  for (var b = 0; b < e.length; b++) {
    var g = e[b], _ = checkPartialGroup(g);
    if (_) {
      a(_.children, r, n, null, h);
      continue;
    }
    var A = !g.hasClass("mspace");
    if (A) {
      var x = r(g, n.node);
      x && (n.insertAfter ? n.insertAfter(x) : (e.unshift(x), b++));
    }
    A ? n.node = g : h && g.hasClass("newline") && (n.node = makeSpan$1(["leftmost"])), n.insertAfter = /* @__PURE__ */ ((k) => ($) => {
      e.splice(k + 1, 0, $), b++;
    })(b);
  }
  s && e.pop();
}, checkPartialGroup = function(e) {
  return e instanceof DocumentFragment || e instanceof Anchor || e instanceof Span && e.hasClass("enclosing") ? e : null;
}, getOutermostNode = function a(e, r) {
  var n = checkPartialGroup(e);
  if (n) {
    var s = n.children;
    if (s.length) {
      if (r === "right")
        return a(s[s.length - 1], "right");
      if (r === "left")
        return a(s[0], "left");
    }
  }
  return e;
}, getTypeOfDomTree = function(e, r) {
  return e ? (r && (e = getOutermostNode(e, r)), DomEnum[e.classes[0]] || null) : null;
}, makeNullDelimiter = function(e, r) {
  var n = ["nulldelimiter"].concat(e.baseSizingClasses());
  return makeSpan$1(r.concat(n));
}, buildGroup$1 = function(e, r, n) {
  if (!e)
    return makeSpan$1();
  if (_htmlGroupBuilders[e.type]) {
    var s = _htmlGroupBuilders[e.type](e, r);
    if (n && r.size !== n.size) {
      s = makeSpan$1(r.sizingClasses(n), [s], r);
      var h = r.sizeMultiplier / n.sizeMultiplier;
      s.height *= h, s.depth *= h;
    }
    return s;
  } else
    throw new ParseError("Got group of unknown type: '" + e.type + "'");
};
function newDocumentFragment(a) {
  return new DocumentFragment(a);
}
class MathNode {
  constructor(e, r, n) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = r || [], this.classes = n || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && e.setAttribute(r, this.attributes[r]);
    this.classes.length > 0 && (e.className = createClass(this.classes));
    for (var n = 0; n < this.children.length; n++)
      e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="', e += utils.escape(this.attributes[r]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + utils.escape(createClass(this.classes)) + '"'), e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class TextNode {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", makeEm(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + makeEm(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
}, makeText = function(e, r, n) {
  return symbols[r][e] && symbols[r][e].replace && e.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(e) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (e = symbols[r][e].replace), new mathMLTree.TextNode(e);
}, makeRow = function(e) {
  return e.length === 1 ? e[0] : new mathMLTree.MathNode("mrow", e);
}, getVariant = function(e, r) {
  if (r.fontFamily === "texttt")
    return "monospace";
  if (r.fontFamily === "textsf")
    return r.fontShape === "textit" && r.fontWeight === "textbf" ? "sans-serif-bold-italic" : r.fontShape === "textit" ? "sans-serif-italic" : r.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (r.fontShape === "textit" && r.fontWeight === "textbf")
    return "bold-italic";
  if (r.fontShape === "textit")
    return "italic";
  if (r.fontWeight === "textbf")
    return "bold";
  var n = r.font;
  if (!n || n === "mathnormal")
    return null;
  var s = e.mode;
  if (n === "mathit")
    return "italic";
  if (n === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (n === "mathbf")
    return "bold";
  if (n === "mathbb")
    return "double-struck";
  if (n === "mathfrak")
    return "fraktur";
  if (n === "mathscr" || n === "mathcal")
    return "script";
  if (n === "mathsf")
    return "sans-serif";
  if (n === "mathtt")
    return "monospace";
  var h = e.text;
  if (utils.contains(["\\imath", "\\jmath"], h))
    return null;
  symbols[s][h] && symbols[s][h].replace && (h = symbols[s][h].replace);
  var b = buildCommon.fontMap[n].fontName;
  return getCharacterMetrics(h, b, s) ? buildCommon.fontMap[n].variant : null;
}, buildExpression = function(e, r, n) {
  if (e.length === 1) {
    var s = buildGroup(e[0], r);
    return n && s instanceof MathNode && s.type === "mo" && (s.setAttribute("lspace", "0em"), s.setAttribute("rspace", "0em")), [s];
  }
  for (var h = [], b, g = 0; g < e.length; g++) {
    var _ = buildGroup(e[g], r);
    if (_ instanceof MathNode && b instanceof MathNode) {
      if (_.type === "mtext" && b.type === "mtext" && _.getAttribute("mathvariant") === b.getAttribute("mathvariant")) {
        b.children.push(..._.children);
        continue;
      } else if (_.type === "mn" && b.type === "mn") {
        b.children.push(..._.children);
        continue;
      } else if (_.type === "mi" && _.children.length === 1 && b.type === "mn") {
        var A = _.children[0];
        if (A instanceof TextNode && A.text === ".") {
          b.children.push(..._.children);
          continue;
        }
      } else if (b.type === "mi" && b.children.length === 1) {
        var x = b.children[0];
        if (x instanceof TextNode && x.text === "̸" && (_.type === "mo" || _.type === "mi" || _.type === "mn")) {
          var k = _.children[0];
          k instanceof TextNode && k.text.length > 0 && (k.text = k.text.slice(0, 1) + "̸" + k.text.slice(1), h.pop());
        }
      }
    }
    h.push(_), b = _;
  }
  return h;
}, buildExpressionRow = function(e, r, n) {
  return makeRow(buildExpression(e, r, n));
}, buildGroup = function(e, r) {
  if (!e)
    return new mathMLTree.MathNode("mrow");
  if (_mathmlGroupBuilders[e.type]) {
    var n = _mathmlGroupBuilders[e.type](e, r);
    return n;
  } else
    throw new ParseError("Got group of unknown type: '" + e.type + "'");
}, stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, mathMLnode = function(e) {
  var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[e.replace(/^\\/, "")])]);
  return r.setAttribute("stretchy", "true"), r;
}, katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, groupLength = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, svgSpan = function(e, r) {
  function n() {
    var g = 4e5, _ = e.label.slice(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], _)) {
      var A = e, x = groupLength(A.base), k, $, C;
      if (x > 5)
        _ === "widehat" || _ === "widecheck" ? (k = 420, g = 2364, C = 0.42, $ = _ + "4") : (k = 312, g = 2340, C = 0.34, $ = "tilde4");
      else {
        var L = [1, 1, 2, 2, 3, 3][x];
        _ === "widehat" || _ === "widecheck" ? (g = [0, 1062, 2364, 2364, 2364][L], k = [0, 239, 300, 360, 420][L], C = [0, 0.24, 0.3, 0.3, 0.36, 0.42][L], $ = _ + L) : (g = [0, 600, 1033, 2339, 2340][L], k = [0, 260, 286, 306, 312][L], C = [0, 0.26, 0.286, 0.3, 0.306, 0.34][L], $ = "tilde" + L);
      }
      var y = new PathNode($), o = new SvgNode([y], {
        width: "100%",
        height: makeEm(C),
        viewBox: "0 0 " + g + " " + k,
        preserveAspectRatio: "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [o], r),
        minWidth: 0,
        height: C
      };
    } else {
      var v = [], w = katexImagesData[_], [M, F, m] = w, E = m / 1e3, z = M.length, O, R;
      if (z === 1) {
        var B = w[3];
        O = ["hide-tail"], R = [B];
      } else if (z === 2)
        O = ["halfarrow-left", "halfarrow-right"], R = ["xMinYMin", "xMaxYMin"];
      else if (z === 3)
        O = ["brace-left", "brace-center", "brace-right"], R = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + z + " children.");
      for (var P = 0; P < z; P++) {
        var W = new PathNode(M[P]), U = new SvgNode([W], {
          width: "400em",
          height: makeEm(E),
          viewBox: "0 0 " + g + " " + m,
          preserveAspectRatio: R[P] + " slice"
        }), V = buildCommon.makeSvgSpan([O[P]], [U], r);
        if (z === 1)
          return {
            span: V,
            minWidth: F,
            height: E
          };
        V.style.height = makeEm(E), v.push(V);
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], v, r),
        minWidth: F,
        height: E
      };
    }
  }
  var {
    span: s,
    minWidth: h,
    height: b
  } = n();
  return s.height = b, s.style.height = makeEm(b), h > 0 && (s.style.minWidth = makeEm(h)), s;
}, encloseSpan = function(e, r, n, s, h) {
  var b, g = e.height + e.depth + n + s;
  if (/fbox|color|angl/.test(r)) {
    if (b = buildCommon.makeSpan(["stretchy", r], [], h), r === "fbox") {
      var _ = h.color && h.getColor();
      _ && (b.style.borderColor = _);
    }
  } else {
    var A = [];
    /^[bx]cancel$/.test(r) && A.push(new LineNode({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(r) && A.push(new LineNode({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var x = new SvgNode(A, {
      width: "100%",
      height: makeEm(g)
    });
    b = buildCommon.makeSvgSpan([], [x], h);
  }
  return b.height = g, b.style.height = makeEm(g), b;
}, stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(a, e) {
  if (!a || a.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (a ? "node of type " + a.type : String(a)));
  return a;
}
function assertSymbolNodeType(a) {
  var e = checkSymbolNodeType(a);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (a ? "node of type " + a.type : String(a)));
  return e;
}
function checkSymbolNodeType(a) {
  return a && (a.type === "atom" || NON_ATOMS.hasOwnProperty(a.type)) ? a : null;
}
var htmlBuilder$a = (a, e) => {
  var r, n, s;
  a && a.type === "supsub" ? (n = assertNodeType(a.base, "accent"), r = n.base, a.base = r, s = assertSpan(buildGroup$1(a, e)), a.base = n) : (n = assertNodeType(a, "accent"), r = n.base);
  var h = buildGroup$1(r, e.havingCrampedStyle()), b = n.isShifty && utils.isCharacterBox(r), g = 0;
  if (b) {
    var _ = utils.getBaseElem(r), A = buildGroup$1(_, e.havingCrampedStyle());
    g = assertSymbolDomNode(A).skew;
  }
  var x = n.label === "\\c", k = x ? h.height + h.depth : Math.min(h.height, e.fontMetrics().xHeight), $;
  if (n.isStretchy)
    $ = stretchy.svgSpan(n, e), $ = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: h
      }, {
        type: "elem",
        elem: $,
        wrapperClasses: ["svg-align"],
        wrapperStyle: g > 0 ? {
          width: "calc(100% - " + makeEm(2 * g) + ")",
          marginLeft: makeEm(2 * g)
        } : void 0
      }]
    }, e);
  else {
    var C, L;
    n.label === "\\vec" ? (C = buildCommon.staticSvg("vec", e), L = buildCommon.svgData.vec[1]) : (C = buildCommon.makeOrd({
      mode: n.mode,
      text: n.label
    }, e, "textord"), C = assertSymbolDomNode(C), C.italic = 0, L = C.width, x && (k += C.depth)), $ = buildCommon.makeSpan(["accent-body"], [C]);
    var y = n.label === "\\textcircled";
    y && ($.classes.push("accent-full"), k = h.height);
    var o = g;
    y || (o -= L / 2), $.style.left = makeEm(o), n.label === "\\textcircled" && ($.style.top = ".2em"), $ = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: h
      }, {
        type: "kern",
        size: -k
      }, {
        type: "elem",
        elem: $
      }]
    }, e);
  }
  var v = buildCommon.makeSpan(["mord", "accent"], [$], e);
  return s ? (s.children[0] = v, s.height = Math.max(v.height, s.height), s.classes[0] = "mord", s) : v;
}, mathmlBuilder$9 = (a, e) => {
  var r = a.isStretchy ? stretchy.mathMLnode(a.label) : new mathMLTree.MathNode("mo", [makeText(a.label, a.mode)]), n = new mathMLTree.MathNode("mover", [buildGroup(a.base, e), r]);
  return n.setAttribute("accent", "true"), n;
}, NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((a) => "\\" + a).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (a, e) => {
    var r = normalizeArgument(e[0]), n = !NON_STRETCHY_ACCENT_REGEX.test(a.funcName), s = !n || a.funcName === "\\widehat" || a.funcName === "\\widetilde" || a.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: a.parser.mode,
      label: a.funcName,
      isStretchy: n,
      isShifty: s,
      base: r
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (a, e) => {
    var r = e[0], n = a.parser.mode;
    return n === "math" && (a.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + a.funcName + " works only in text mode"), n = "text"), {
      type: "accent",
      mode: n,
      label: a.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: r
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "accentUnder",
      mode: r.mode,
      label: n,
      base: s
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildGroup$1(a.base, e), n = stretchy.svgSpan(a, e), s = a.label === "\\utilde" ? 0.12 : 0, h = buildCommon.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: s
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return buildCommon.makeSpan(["mord", "accentunder"], [h], e);
  },
  mathmlBuilder: (a, e) => {
    var r = stretchy.mathMLnode(a.label), n = new mathMLTree.MathNode("munder", [buildGroup(a.base, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
var paddedNode = (a) => {
  var e = new mathMLTree.MathNode("mpadded", a ? [a] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(a, e, r) {
    var {
      parser: n,
      funcName: s
    } = a;
    return {
      type: "xArrow",
      mode: n.mode,
      label: s,
      body: e[0],
      below: r[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(a, e) {
    var r = e.style, n = e.havingStyle(r.sup()), s = buildCommon.wrapFragment(buildGroup$1(a.body, n, e), e), h = a.label.slice(0, 2) === "\\x" ? "x" : "cd";
    s.classes.push(h + "-arrow-pad");
    var b;
    a.below && (n = e.havingStyle(r.sub()), b = buildCommon.wrapFragment(buildGroup$1(a.below, n, e), e), b.classes.push(h + "-arrow-pad"));
    var g = stretchy.svgSpan(a, e), _ = -e.fontMetrics().axisHeight + 0.5 * g.height, A = -e.fontMetrics().axisHeight - 0.5 * g.height - 0.111;
    (s.depth > 0.25 || a.label === "\\xleftequilibrium") && (A -= s.depth);
    var x;
    if (b) {
      var k = -e.fontMetrics().axisHeight + b.height + 0.5 * g.height + 0.111;
      x = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: s,
          shift: A
        }, {
          type: "elem",
          elem: g,
          shift: _
        }, {
          type: "elem",
          elem: b,
          shift: k
        }]
      }, e);
    } else
      x = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: s,
          shift: A
        }, {
          type: "elem",
          elem: g,
          shift: _
        }]
      }, e);
    return x.children[0].children[0].children[1].classes.push("svg-align"), buildCommon.makeSpan(["mrel", "x-arrow"], [x], e);
  },
  mathmlBuilder(a, e) {
    var r = stretchy.mathMLnode(a.label);
    r.setAttribute("minsize", a.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var n;
    if (a.body) {
      var s = paddedNode(buildGroup(a.body, e));
      if (a.below) {
        var h = paddedNode(buildGroup(a.below, e));
        n = new mathMLTree.MathNode("munderover", [r, h, s]);
      } else
        n = new mathMLTree.MathNode("mover", [r, s]);
    } else if (a.below) {
      var b = paddedNode(buildGroup(a.below, e));
      n = new mathMLTree.MathNode("munder", [r, b]);
    } else
      n = paddedNode(), n = new mathMLTree.MathNode("mover", [r, n]);
    return n;
  }
});
var makeSpan = buildCommon.makeSpan;
function htmlBuilder$9(a, e) {
  var r = buildExpression$1(a.body, e, !0);
  return makeSpan([a.mclass], r, e);
}
function mathmlBuilder$8(a, e) {
  var r, n = buildExpression(a.body, e);
  return a.mclass === "minner" ? r = new mathMLTree.MathNode("mpadded", n) : a.mclass === "mord" ? a.isCharacterBox ? (r = n[0], r.type = "mi") : r = new mathMLTree.MathNode("mi", n) : (a.isCharacterBox ? (r = n[0], r.type = "mo") : r = new mathMLTree.MathNode("mo", n), a.mclass === "mbin" ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : a.mclass === "mpunct" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : a.mclass === "mopen" || a.mclass === "mclose" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : a.mclass === "minner" && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "mclass",
      mode: r.mode,
      mclass: "m" + n.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(s),
      isCharacterBox: utils.isCharacterBox(s)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (a) => {
  var e = a.type === "ordgroup" && a.body.length ? a.body[0] : a;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "mclass",
      mode: r.mode,
      mclass: binrelClass(e[0]),
      body: ordargument(e[1]),
      isCharacterBox: utils.isCharacterBox(e[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = e[1], h = e[0], b;
    n !== "\\stackrel" ? b = binrelClass(s) : b = "mrel";
    var g = {
      type: "op",
      mode: s.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: n !== "\\stackrel",
      body: ordargument(s)
    }, _ = {
      type: "supsub",
      mode: h.mode,
      base: g,
      sup: n === "\\underset" ? null : h,
      sub: n === "\\underset" ? h : null
    };
    return {
      type: "mclass",
      mode: r.mode,
      mclass: b,
      body: [_],
      isCharacterBox: utils.isCharacterBox(_)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "pmb",
      mode: r.mode,
      mclass: binrelClass(e[0]),
      body: ordargument(e[0])
    };
  },
  htmlBuilder(a, e) {
    var r = buildExpression$1(a.body, e, !0), n = buildCommon.makeSpan([a.mclass], r, e);
    return n.style.textShadow = "0.02em 0.01em 0.04px", n;
  },
  mathmlBuilder(a, e) {
    var r = buildExpression(a.body, e), n = new mathMLTree.MathNode("mstyle", r);
    return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, newCell = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), isStartOfArrow = (a) => a.type === "textord" && a.text === "@", isLabelEnd = (a, e) => (a.type === "mathord" || a.type === "atom") && a.text === e;
function cdArrow(a, e, r) {
  var n = cdArrowFunctionName[a];
  switch (n) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return r.callFunction(n, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var s = r.callFunction("\\\\cdleft", [e[0]], []), h = {
        type: "atom",
        text: n,
        mode: "math",
        family: "rel"
      }, b = r.callFunction("\\Big", [h], []), g = r.callFunction("\\\\cdright", [e[1]], []), _ = {
        type: "ordgroup",
        mode: "math",
        body: [s, b, g]
      };
      return r.callFunction("\\\\cdparent", [_], []);
    }
    case "\\\\cdlongequal":
      return r.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var A = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return r.callFunction("\\Big", [A], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(a) {
  var e = [];
  for (a.gullet.beginGroup(), a.gullet.macros.set("\\cr", "\\\\\\relax"), a.gullet.beginGroup(); ; ) {
    e.push(a.parseExpression(!1, "\\\\")), a.gullet.endGroup(), a.gullet.beginGroup();
    var r = a.fetch().text;
    if (r === "&" || r === "\\\\")
      a.consume();
    else if (r === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new ParseError("Expected \\\\ or \\cr or \\end", a.nextToken);
  }
  for (var n = [], s = [n], h = 0; h < e.length; h++) {
    for (var b = e[h], g = newCell(), _ = 0; _ < b.length; _++)
      if (!isStartOfArrow(b[_]))
        g.body.push(b[_]);
      else {
        n.push(g), _ += 1;
        var A = assertSymbolNodeType(b[_]).text, x = new Array(2);
        if (x[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, x[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(A) > -1)) if ("<>AV".indexOf(A) > -1)
          for (var k = 0; k < 2; k++) {
            for (var $ = !0, C = _ + 1; C < b.length; C++) {
              if (isLabelEnd(b[C], A)) {
                $ = !1, _ = C;
                break;
              }
              if (isStartOfArrow(b[C]))
                throw new ParseError("Missing a " + A + " character to complete a CD arrow.", b[C]);
              x[k].body.push(b[C]);
            }
            if ($)
              throw new ParseError("Missing a " + A + " character to complete a CD arrow.", b[_]);
          }
        else
          throw new ParseError('Expected one of "<>AV=|." after @', b[_]);
        var L = cdArrow(A, x, a), y = {
          type: "styling",
          body: [L],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        n.push(y), g = newCell();
      }
    h % 2 === 0 ? n.push(g) : n.shift(), n = [], s.push(n);
  }
  a.gullet.endGroup(), a.gullet.endGroup();
  var o = new Array(s[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: s,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: o,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(s.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a;
    return {
      type: "cdlabel",
      mode: r.mode,
      side: n.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(a, e) {
    var r = e.havingStyle(e.style.sup()), n = buildCommon.wrapFragment(buildGroup$1(a.label, r, e), e);
    return n.classes.push("cd-label-" + a.side), n.style.bottom = makeEm(0.8 - n.depth), n.height = 0, n.depth = 0, n;
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mrow", [buildGroup(a.label, e)]);
    return r = new mathMLTree.MathNode("mpadded", [r]), r.setAttribute("width", "0"), a.side === "left" && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), r = new mathMLTree.MathNode("mstyle", [r]), r.setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "cdlabelparent",
      mode: r.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(a, e) {
    var r = buildCommon.wrapFragment(buildGroup$1(a.fragment, e), e);
    return r.classes.push("cd-vert-arrow"), r;
  },
  mathmlBuilder(a, e) {
    return new mathMLTree.MathNode("mrow", [buildGroup(a.fragment, e)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(a, e) {
    for (var {
      parser: r
    } = a, n = assertNodeType(e[0], "ordgroup"), s = n.body, h = "", b = 0; b < s.length; b++) {
      var g = assertNodeType(s[b], "textord");
      h += g.text;
    }
    var _ = parseInt(h), A;
    if (isNaN(_))
      throw new ParseError("\\@char has non-numeric argument " + h);
    if (_ < 0 || _ >= 1114111)
      throw new ParseError("\\@char with invalid code point " + h);
    return _ <= 65535 ? A = String.fromCharCode(_) : (_ -= 65536, A = String.fromCharCode((_ >> 10) + 55296, (_ & 1023) + 56320)), {
      type: "textord",
      mode: r.mode,
      text: A
    };
  }
});
var htmlBuilder$8 = (a, e) => {
  var r = buildExpression$1(a.body, e.withColor(a.color), !1);
  return buildCommon.makeFragment(r);
}, mathmlBuilder$7 = (a, e) => {
  var r = buildExpression(a.body, e.withColor(a.color)), n = new mathMLTree.MathNode("mstyle", r);
  return n.setAttribute("mathcolor", a.color), n;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(a, e) {
    var {
      parser: r
    } = a, n = assertNodeType(e[0], "color-token").color, s = e[1];
    return {
      type: "color",
      mode: r.mode,
      color: n,
      body: ordargument(s)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(a, e) {
    var {
      parser: r,
      breakOnTokenText: n
    } = a, s = assertNodeType(e[0], "color-token").color;
    r.gullet.macros.set("\\current@color", s);
    var h = r.parseExpression(!0, n);
    return {
      type: "color",
      mode: r.mode,
      color: s,
      body: h
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(a, e, r) {
    var {
      parser: n
    } = a, s = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null, h = !n.settings.displayMode || !n.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: n.mode,
      newLine: h,
      size: s && assertNodeType(s, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(a, e) {
    var r = buildCommon.makeSpan(["mspace"], [], e);
    return a.newLine && (r.classes.push("newline"), a.size && (r.style.marginTop = makeEm(calculateSize(a.size, e)))), r;
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mspace");
    return a.newLine && (r.setAttribute("linebreak", "newline"), a.size && r.setAttribute("height", makeEm(calculateSize(a.size, e)))), r;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, checkControlSequence = (a) => {
  var e = a.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new ParseError("Expected a control sequence", a);
  return e;
}, getRHS = (a) => {
  var e = a.gullet.popToken();
  return e.text === "=" && (e = a.gullet.popToken(), e.text === " " && (e = a.gullet.popToken())), e;
}, letCommand = (a, e, r, n) => {
  var s = a.gullet.macros.get(r.text);
  s == null && (r.noexpand = !0, s = {
    tokens: [r],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !a.gullet.isExpandable(r.text)
  }), a.gullet.macros.set(e, s, n);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a;
    e.consumeSpaces();
    var n = e.fetch();
    if (globalMap[n.text])
      return (r === "\\global" || r === "\\\\globallong") && (n.text = globalMap[n.text]), assertNodeType(e.parseFunction(), "internal");
    throw new ParseError("Invalid token after macro prefix", n);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a, n = e.gullet.popToken(), s = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(s))
      throw new ParseError("Expected a control sequence", n);
    for (var h = 0, b, g = [[]]; e.gullet.future().text !== "{"; )
      if (n = e.gullet.popToken(), n.text === "#") {
        if (e.gullet.future().text === "{") {
          b = e.gullet.future(), g[h].push("{");
          break;
        }
        if (n = e.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new ParseError('Invalid argument number "' + n.text + '"');
        if (parseInt(n.text) !== h + 1)
          throw new ParseError('Argument number "' + n.text + '" out of order');
        h++, g.push([]);
      } else {
        if (n.text === "EOF")
          throw new ParseError("Expected a macro definition");
        g[h].push(n.text);
      }
    var {
      tokens: _
    } = e.gullet.consumeArg();
    return b && _.unshift(b), (r === "\\edef" || r === "\\xdef") && (_ = e.gullet.expandTokens(_), _.reverse()), e.gullet.macros.set(s, {
      tokens: _,
      numArgs: h,
      delimiters: g
    }, r === globalMap[r]), {
      type: "internal",
      mode: e.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a, n = checkControlSequence(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var s = getRHS(e);
    return letCommand(e, n, s, r === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a, n = checkControlSequence(e.gullet.popToken()), s = e.gullet.popToken(), h = e.gullet.popToken();
    return letCommand(e, n, h, r === "\\\\globalfuture"), e.gullet.pushToken(h), e.gullet.pushToken(s), {
      type: "internal",
      mode: e.mode
    };
  }
});
var getMetrics = function(e, r, n) {
  var s = symbols.math[e] && symbols.math[e].replace, h = getCharacterMetrics(s || e, r, n);
  if (!h)
    throw new Error("Unsupported symbol " + e + " and font size " + r + ".");
  return h;
}, styleWrap = function(e, r, n, s) {
  var h = n.havingBaseStyle(r), b = buildCommon.makeSpan(s.concat(h.sizingClasses(n)), [e], n), g = h.sizeMultiplier / n.sizeMultiplier;
  return b.height *= g, b.depth *= g, b.maxFontSize = h.sizeMultiplier, b;
}, centerSpan = function(e, r, n) {
  var s = r.havingBaseStyle(n), h = (1 - r.sizeMultiplier / s.sizeMultiplier) * r.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = makeEm(h), e.height -= h, e.depth += h;
}, makeSmallDelim = function(e, r, n, s, h, b) {
  var g = buildCommon.makeSymbol(e, "Main-Regular", h, s), _ = styleWrap(g, r, s, b);
  return n && centerSpan(_, s, r), _;
}, mathrmSize = function(e, r, n, s) {
  return buildCommon.makeSymbol(e, "Size" + r + "-Regular", n, s);
}, makeLargeDelim = function(e, r, n, s, h, b) {
  var g = mathrmSize(e, r, h, s), _ = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + r], [g], s), Style$1.TEXT, s, b);
  return n && centerSpan(_, s, Style$1.TEXT), _;
}, makeGlyphSpan = function(e, r, n) {
  var s;
  r === "Size1-Regular" ? s = "delim-size1" : s = "delim-size4";
  var h = buildCommon.makeSpan(["delimsizinginner", s], [buildCommon.makeSpan([], [buildCommon.makeSymbol(e, r, n)])]);
  return {
    type: "elem",
    elem: h
  };
}, makeInner = function(e, r, n) {
  var s = fontMetricsData["Size4-Regular"][e.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][e.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][e.charCodeAt(0)][4], h = new PathNode("inner", innerPath(e, Math.round(1e3 * r))), b = new SvgNode([h], {
    width: makeEm(s),
    height: makeEm(r),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + makeEm(s),
    viewBox: "0 0 " + 1e3 * s + " " + Math.round(1e3 * r),
    preserveAspectRatio: "xMinYMin"
  }), g = buildCommon.makeSvgSpan([], [b], n);
  return g.height = r, g.style.height = makeEm(r), g.style.width = makeEm(s), {
    type: "elem",
    elem: g
  };
}, lapInEms = 8e-3, lap = {
  type: "kern",
  size: -1 * lapInEms
}, verts = ["|", "\\lvert", "\\rvert", "\\vert"], doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"], makeStackedDelim = function(e, r, n, s, h, b) {
  var g, _, A, x, k = "", $ = 0;
  g = A = x = e, _ = null;
  var C = "Size1-Regular";
  e === "\\uparrow" ? A = x = "⏐" : e === "\\Uparrow" ? A = x = "‖" : e === "\\downarrow" ? g = A = "⏐" : e === "\\Downarrow" ? g = A = "‖" : e === "\\updownarrow" ? (g = "\\uparrow", A = "⏐", x = "\\downarrow") : e === "\\Updownarrow" ? (g = "\\Uparrow", A = "‖", x = "\\Downarrow") : utils.contains(verts, e) ? (A = "∣", k = "vert", $ = 333) : utils.contains(doubleVerts, e) ? (A = "∥", k = "doublevert", $ = 556) : e === "[" || e === "\\lbrack" ? (g = "⎡", A = "⎢", x = "⎣", C = "Size4-Regular", k = "lbrack", $ = 667) : e === "]" || e === "\\rbrack" ? (g = "⎤", A = "⎥", x = "⎦", C = "Size4-Regular", k = "rbrack", $ = 667) : e === "\\lfloor" || e === "⌊" ? (A = g = "⎢", x = "⎣", C = "Size4-Regular", k = "lfloor", $ = 667) : e === "\\lceil" || e === "⌈" ? (g = "⎡", A = x = "⎢", C = "Size4-Regular", k = "lceil", $ = 667) : e === "\\rfloor" || e === "⌋" ? (A = g = "⎥", x = "⎦", C = "Size4-Regular", k = "rfloor", $ = 667) : e === "\\rceil" || e === "⌉" ? (g = "⎤", A = x = "⎥", C = "Size4-Regular", k = "rceil", $ = 667) : e === "(" || e === "\\lparen" ? (g = "⎛", A = "⎜", x = "⎝", C = "Size4-Regular", k = "lparen", $ = 875) : e === ")" || e === "\\rparen" ? (g = "⎞", A = "⎟", x = "⎠", C = "Size4-Regular", k = "rparen", $ = 875) : e === "\\{" || e === "\\lbrace" ? (g = "⎧", _ = "⎨", x = "⎩", A = "⎪", C = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (g = "⎫", _ = "⎬", x = "⎭", A = "⎪", C = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (g = "⎧", x = "⎩", A = "⎪", C = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (g = "⎫", x = "⎭", A = "⎪", C = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (g = "⎧", x = "⎭", A = "⎪", C = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (g = "⎫", x = "⎩", A = "⎪", C = "Size4-Regular");
  var L = getMetrics(g, C, h), y = L.height + L.depth, o = getMetrics(A, C, h), v = o.height + o.depth, w = getMetrics(x, C, h), M = w.height + w.depth, F = 0, m = 1;
  if (_ !== null) {
    var E = getMetrics(_, C, h);
    F = E.height + E.depth, m = 2;
  }
  var z = y + M + F, O = Math.max(0, Math.ceil((r - z) / (m * v))), R = z + O * m * v, B = s.fontMetrics().axisHeight;
  n && (B *= s.sizeMultiplier);
  var P = R / 2 - B, W = [];
  if (k.length > 0) {
    var U = R - y - M, V = Math.round(R * 1e3), K = tallDelim(k, Math.round(U * 1e3)), q = new PathNode(k, K), H = ($ / 1e3).toFixed(3) + "em", j = (V / 1e3).toFixed(3) + "em", Q = new SvgNode([q], {
      width: H,
      height: j,
      viewBox: "0 0 " + $ + " " + V
    }), J = buildCommon.makeSvgSpan([], [Q], s);
    J.height = V / 1e3, J.style.width = H, J.style.height = j, W.push({
      type: "elem",
      elem: J
    });
  } else {
    if (W.push(makeGlyphSpan(x, C, h)), W.push(lap), _ === null) {
      var Y = R - y - M + 2 * lapInEms;
      W.push(makeInner(A, Y, s));
    } else {
      var ee = (R - y - M - F) / 2 + 2 * lapInEms;
      W.push(makeInner(A, ee, s)), W.push(lap), W.push(makeGlyphSpan(_, C, h)), W.push(lap), W.push(makeInner(A, ee, s));
    }
    W.push(lap), W.push(makeGlyphSpan(g, C, h));
  }
  var fe = s.havingBaseStyle(Style$1.TEXT), me = buildCommon.makeVList({
    positionType: "bottom",
    positionData: P,
    children: W
  }, fe);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [me], fe), Style$1.TEXT, s, b);
}, vbPad = 80, emPad = 0.08, sqrtSvg = function(e, r, n, s, h) {
  var b = sqrtPath(e, s, n), g = new PathNode(e, b), _ = new SvgNode([g], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: makeEm(r),
    viewBox: "0 0 400000 " + n,
    preserveAspectRatio: "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [_], h);
}, makeSqrtImage = function(e, r) {
  var n = r.havingBaseSizing(), s = traverseSequence("\\surd", e * n.sizeMultiplier, stackLargeDelimiterSequence, n), h = n.sizeMultiplier, b = Math.max(0, r.minRuleThickness - r.fontMetrics().sqrtRuleThickness), g, _ = 0, A = 0, x = 0, k;
  return s.type === "small" ? (x = 1e3 + 1e3 * b + vbPad, e < 1 ? h = 1 : e < 1.4 && (h = 0.7), _ = (1 + b + emPad) / h, A = (1 + b) / h, g = sqrtSvg("sqrtMain", _, x, b, r), g.style.minWidth = "0.853em", k = 0.833 / h) : s.type === "large" ? (x = (1e3 + vbPad) * sizeToMaxHeight[s.size], A = (sizeToMaxHeight[s.size] + b) / h, _ = (sizeToMaxHeight[s.size] + b + emPad) / h, g = sqrtSvg("sqrtSize" + s.size, _, x, b, r), g.style.minWidth = "1.02em", k = 1 / h) : (_ = e + b + emPad, A = e + b, x = Math.floor(1e3 * e + b) + vbPad, g = sqrtSvg("sqrtTall", _, x, b, r), g.style.minWidth = "0.742em", k = 1.056), g.height = A, g.style.height = makeEm(_), {
    span: g,
    advanceWidth: k,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (r.fontMetrics().sqrtRuleThickness + b) * h
  };
}, stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3], makeSizedDelim = function(e, r, n, s, h) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), utils.contains(stackLargeDelimiters, e) || utils.contains(stackNeverDelimiters, e))
    return makeLargeDelim(e, r, !1, n, s, h);
  if (utils.contains(stackAlwaysDelimiters, e))
    return makeStackedDelim(e, sizeToMaxHeight[r], !1, n, s, h);
  throw new ParseError("Illegal delimiter: '" + e + "'");
}, stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}], stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], delimTypeToFont = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, traverseSequence = function(e, r, n, s) {
  for (var h = Math.min(2, 3 - s.style.size), b = h; b < n.length && n[b].type !== "stack"; b++) {
    var g = getMetrics(e, delimTypeToFont(n[b]), "math"), _ = g.height + g.depth;
    if (n[b].type === "small") {
      var A = s.havingBaseStyle(n[b].style);
      _ *= A.sizeMultiplier;
    }
    if (_ > r)
      return n[b];
  }
  return n[n.length - 1];
}, makeCustomSizedDelim = function(e, r, n, s, h, b) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var g;
  utils.contains(stackNeverDelimiters, e) ? g = stackNeverDelimiterSequence : utils.contains(stackLargeDelimiters, e) ? g = stackLargeDelimiterSequence : g = stackAlwaysDelimiterSequence;
  var _ = traverseSequence(e, r, g, s);
  return _.type === "small" ? makeSmallDelim(e, _.style, n, s, h, b) : _.type === "large" ? makeLargeDelim(e, _.size, n, s, h, b) : makeStackedDelim(e, r, n, s, h, b);
}, makeLeftRightDelim = function(e, r, n, s, h, b) {
  var g = s.fontMetrics().axisHeight * s.sizeMultiplier, _ = 901, A = 5 / s.fontMetrics().ptPerEm, x = Math.max(r - g, n + g), k = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    x / 500 * _,
    2 * x - A
  );
  return makeCustomSizedDelim(e, k, !0, s, h, b);
}, delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
}, delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(a, e) {
  var r = checkSymbolNodeType(a);
  if (r && utils.contains(delimiters, r.text))
    return r;
  throw r ? new ParseError("Invalid delimiter '" + r.text + "' after '" + e.funcName + "'", a) : new ParseError("Invalid delimiter type '" + a.type + "'", a);
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (a, e) => {
    var r = checkDelimiter(e[0], a);
    return {
      type: "delimsizing",
      mode: a.parser.mode,
      size: delimiterSizes[a.funcName].size,
      mclass: delimiterSizes[a.funcName].mclass,
      delim: r.text
    };
  },
  htmlBuilder: (a, e) => a.delim === "." ? buildCommon.makeSpan([a.mclass]) : delimiter.sizedDelim(a.delim, a.size, e, a.mode, [a.mclass]),
  mathmlBuilder: (a) => {
    var e = [];
    a.delim !== "." && e.push(makeText(a.delim, a.mode));
    var r = new mathMLTree.MathNode("mo", e);
    a.mclass === "mopen" || a.mclass === "mclose" ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
    var n = makeEm(delimiter.sizeToMaxHeight[a.size]);
    return r.setAttribute("minsize", n), r.setAttribute("maxsize", n), r;
  }
});
function assertParsed(a) {
  if (!a.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (a, e) => {
    var r = a.parser.gullet.macros.get("\\current@color");
    if (r && typeof r != "string")
      throw new ParseError("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: a.parser.mode,
      delim: checkDelimiter(e[0], a).text,
      color: r
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (a, e) => {
    var r = checkDelimiter(e[0], a), n = a.parser;
    ++n.leftrightDepth;
    var s = n.parseExpression(!1);
    --n.leftrightDepth, n.expect("\\right", !1);
    var h = assertNodeType(n.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: n.mode,
      body: s,
      left: r.text,
      right: h.delim,
      rightColor: h.color
    };
  },
  htmlBuilder: (a, e) => {
    assertParsed(a);
    for (var r = buildExpression$1(a.body, e, !0, ["mopen", "mclose"]), n = 0, s = 0, h = !1, b = 0; b < r.length; b++)
      r[b].isMiddle ? h = !0 : (n = Math.max(r[b].height, n), s = Math.max(r[b].depth, s));
    n *= e.sizeMultiplier, s *= e.sizeMultiplier;
    var g;
    if (a.left === "." ? g = makeNullDelimiter(e, ["mopen"]) : g = delimiter.leftRightDelim(a.left, n, s, e, a.mode, ["mopen"]), r.unshift(g), h)
      for (var _ = 1; _ < r.length; _++) {
        var A = r[_], x = A.isMiddle;
        x && (r[_] = delimiter.leftRightDelim(x.delim, n, s, x.options, a.mode, []));
      }
    var k;
    if (a.right === ".")
      k = makeNullDelimiter(e, ["mclose"]);
    else {
      var $ = a.rightColor ? e.withColor(a.rightColor) : e;
      k = delimiter.leftRightDelim(a.right, n, s, $, a.mode, ["mclose"]);
    }
    return r.push(k), buildCommon.makeSpan(["minner"], r, e);
  },
  mathmlBuilder: (a, e) => {
    assertParsed(a);
    var r = buildExpression(a.body, e);
    if (a.left !== ".") {
      var n = new mathMLTree.MathNode("mo", [makeText(a.left, a.mode)]);
      n.setAttribute("fence", "true"), r.unshift(n);
    }
    if (a.right !== ".") {
      var s = new mathMLTree.MathNode("mo", [makeText(a.right, a.mode)]);
      s.setAttribute("fence", "true"), a.rightColor && s.setAttribute("mathcolor", a.rightColor), r.push(s);
    }
    return makeRow(r);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (a, e) => {
    var r = checkDelimiter(e[0], a);
    if (!a.parser.leftrightDepth)
      throw new ParseError("\\middle without preceding \\left", r);
    return {
      type: "middle",
      mode: a.parser.mode,
      delim: r.text
    };
  },
  htmlBuilder: (a, e) => {
    var r;
    if (a.delim === ".")
      r = makeNullDelimiter(e, []);
    else {
      r = delimiter.sizedDelim(a.delim, 1, e, a.mode, []);
      var n = {
        delim: a.delim,
        options: e
      };
      r.isMiddle = n;
    }
    return r;
  },
  mathmlBuilder: (a, e) => {
    var r = a.delim === "\\vert" || a.delim === "|" ? makeText("|", "text") : makeText(a.delim, a.mode), n = new mathMLTree.MathNode("mo", [r]);
    return n.setAttribute("fence", "true"), n.setAttribute("lspace", "0.05em"), n.setAttribute("rspace", "0.05em"), n;
  }
});
var htmlBuilder$7 = (a, e) => {
  var r = buildCommon.wrapFragment(buildGroup$1(a.body, e), e), n = a.label.slice(1), s = e.sizeMultiplier, h, b = 0, g = utils.isCharacterBox(a.body);
  if (n === "sout")
    h = buildCommon.makeSpan(["stretchy", "sout"]), h.height = e.fontMetrics().defaultRuleThickness / s, b = -0.5 * e.fontMetrics().xHeight;
  else if (n === "phase") {
    var _ = calculateSize({
      number: 0.6,
      unit: "pt"
    }, e), A = calculateSize({
      number: 0.35,
      unit: "ex"
    }, e), x = e.havingBaseSizing();
    s = s / x.sizeMultiplier;
    var k = r.height + r.depth + _ + A;
    r.style.paddingLeft = makeEm(k / 2 + _);
    var $ = Math.floor(1e3 * k * s), C = phasePath($), L = new SvgNode([new PathNode("phase", C)], {
      width: "400em",
      height: makeEm($ / 1e3),
      viewBox: "0 0 400000 " + $,
      preserveAspectRatio: "xMinYMin slice"
    });
    h = buildCommon.makeSvgSpan(["hide-tail"], [L], e), h.style.height = makeEm(k), b = r.depth + _ + A;
  } else {
    /cancel/.test(n) ? g || r.classes.push("cancel-pad") : n === "angl" ? r.classes.push("anglpad") : r.classes.push("boxpad");
    var y = 0, o = 0, v = 0;
    /box/.test(n) ? (v = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), y = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : v), o = y) : n === "angl" ? (v = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), y = 4 * v, o = Math.max(0, 0.25 - r.depth)) : (y = g ? 0.2 : 0, o = y), h = stretchy.encloseSpan(r, n, y, o, e), /fbox|boxed|fcolorbox/.test(n) ? (h.style.borderStyle = "solid", h.style.borderWidth = makeEm(v)) : n === "angl" && v !== 0.049 && (h.style.borderTopWidth = makeEm(v), h.style.borderRightWidth = makeEm(v)), b = r.depth + o, a.backgroundColor && (h.style.backgroundColor = a.backgroundColor, a.borderColor && (h.style.borderColor = a.borderColor));
  }
  var w;
  if (a.backgroundColor)
    w = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: h,
          shift: b
        },
        {
          type: "elem",
          elem: r,
          shift: 0
        }
      ]
    }, e);
  else {
    var M = /cancel|phase/.test(n) ? ["svg-align"] : [];
    w = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: r,
          shift: 0
        },
        {
          type: "elem",
          elem: h,
          shift: b,
          wrapperClasses: M
        }
      ]
    }, e);
  }
  return /cancel/.test(n) && (w.height = r.height, w.depth = r.depth), /cancel/.test(n) && !g ? buildCommon.makeSpan(["mord", "cancel-lap"], [w], e) : buildCommon.makeSpan(["mord"], [w], e);
}, mathmlBuilder$6 = (a, e) => {
  var r = 0, n = new mathMLTree.MathNode(a.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(a.body, e)]);
  switch (a.label) {
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box");
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (r = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, n.setAttribute("width", "+" + 2 * r + "pt"), n.setAttribute("height", "+" + 2 * r + "pt"), n.setAttribute("lspace", r + "pt"), n.setAttribute("voffset", r + "pt"), a.label === "\\fcolorbox") {
        var s = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        n.setAttribute("style", "border: " + s + "em solid " + String(a.borderColor));
      }
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return a.backgroundColor && n.setAttribute("mathbackground", a.backgroundColor), n;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(a, e, r) {
    var {
      parser: n,
      funcName: s
    } = a, h = assertNodeType(e[0], "color-token").color, b = e[1];
    return {
      type: "enclose",
      mode: n.mode,
      label: s,
      backgroundColor: h,
      body: b
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(a, e, r) {
    var {
      parser: n,
      funcName: s
    } = a, h = assertNodeType(e[0], "color-token").color, b = assertNodeType(e[1], "color-token").color, g = e[2];
    return {
      type: "enclose",
      mode: n.mode,
      label: s,
      backgroundColor: b,
      borderColor: h,
      body: g
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      body: s
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var _environments = {};
function defineEnvironment(a) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: s,
    htmlBuilder: h,
    mathmlBuilder: b
  } = a, g = {
    type: e,
    numArgs: n.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: s
  }, _ = 0; _ < r.length; ++_)
    _environments[r[_]] = g;
  h && (_htmlGroupBuilders[e] = h), b && (_mathmlGroupBuilders[e] = b);
}
var _macros = {};
function defineMacro(a, e) {
  _macros[a] = e;
}
function getHLines(a) {
  var e = [];
  a.consumeSpaces();
  var r = a.fetch().text;
  for (r === "\\relax" && (a.consume(), a.consumeSpaces(), r = a.fetch().text); r === "\\hline" || r === "\\hdashline"; )
    a.consume(), e.push(r === "\\hdashline"), a.consumeSpaces(), r = a.fetch().text;
  return e;
}
var validateAmsEnvironmentContext = (a) => {
  var e = a.parser.settings;
  if (!e.displayMode)
    throw new ParseError("{" + a.envName + "} can be used only in display mode.");
};
function getAutoTag(a) {
  if (a.indexOf("ed") === -1)
    return a.indexOf("*") === -1;
}
function parseArray(a, e, r) {
  var {
    hskipBeforeAndAfter: n,
    addJot: s,
    cols: h,
    arraystretch: b,
    colSeparationType: g,
    autoTag: _,
    singleRow: A,
    emptySingleRow: x,
    maxNumCols: k,
    leqno: $
  } = e;
  if (a.gullet.beginGroup(), A || a.gullet.macros.set("\\cr", "\\\\\\relax"), !b) {
    var C = a.gullet.expandMacroAsText("\\arraystretch");
    if (C == null)
      b = 1;
    else if (b = parseFloat(C), !b || b < 0)
      throw new ParseError("Invalid \\arraystretch: " + C);
  }
  a.gullet.beginGroup();
  var L = [], y = [L], o = [], v = [], w = _ != null ? [] : void 0;
  function M() {
    _ && a.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function F() {
    w && (a.gullet.macros.get("\\df@tag") ? (w.push(a.subparse([new Token("\\df@tag")])), a.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!_ && a.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (M(), v.push(getHLines(a)); ; ) {
    var m = a.parseExpression(!1, A ? "\\end" : "\\\\");
    a.gullet.endGroup(), a.gullet.beginGroup(), m = {
      type: "ordgroup",
      mode: a.mode,
      body: m
    }, r && (m = {
      type: "styling",
      mode: a.mode,
      style: r,
      body: [m]
    }), L.push(m);
    var E = a.fetch().text;
    if (E === "&") {
      if (k && L.length === k) {
        if (A || g)
          throw new ParseError("Too many tab characters: &", a.nextToken);
        a.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      a.consume();
    } else if (E === "\\end") {
      F(), L.length === 1 && m.type === "styling" && m.body[0].body.length === 0 && (y.length > 1 || !x) && y.pop(), v.length < y.length + 1 && v.push([]);
      break;
    } else if (E === "\\\\") {
      a.consume();
      var z = void 0;
      a.gullet.future().text !== " " && (z = a.parseSizeGroup(!0)), o.push(z ? z.value : null), F(), v.push(getHLines(a)), L = [], y.push(L), M();
    } else
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", a.nextToken);
  }
  return a.gullet.endGroup(), a.gullet.endGroup(), {
    type: "array",
    mode: a.mode,
    addJot: s,
    arraystretch: b,
    body: y,
    cols: h,
    rowGaps: o,
    hskipBeforeAndAfter: n,
    hLinesBeforeRow: v,
    colSeparationType: g,
    tags: w,
    leqno: $
  };
}
function dCellStyle(a) {
  return a.slice(0, 1) === "d" ? "display" : "text";
}
var htmlBuilder$6 = function(e, r) {
  var n, s, h = e.body.length, b = e.hLinesBeforeRow, g = 0, _ = new Array(h), A = [], x = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    r.fontMetrics().arrayRuleWidth,
    r.minRuleThickness
    // User override.
  ), k = 1 / r.fontMetrics().ptPerEm, $ = 5 * k;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var C = r.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    $ = 0.2778 * (C / r.sizeMultiplier);
  }
  var L = e.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, r) : 12 * k, y = 3 * k, o = e.arraystretch * L, v = 0.7 * o, w = 0.3 * o, M = 0;
  function F(qe) {
    for (var Ze = 0; Ze < qe.length; ++Ze)
      Ze > 0 && (M += 0.25), A.push({
        pos: M,
        isDashed: qe[Ze]
      });
  }
  for (F(b[0]), n = 0; n < e.body.length; ++n) {
    var m = e.body[n], E = v, z = w;
    g < m.length && (g = m.length);
    var O = new Array(m.length);
    for (s = 0; s < m.length; ++s) {
      var R = buildGroup$1(m[s], r);
      z < R.depth && (z = R.depth), E < R.height && (E = R.height), O[s] = R;
    }
    var B = e.rowGaps[n], P = 0;
    B && (P = calculateSize(B, r), P > 0 && (P += w, z < P && (z = P), P = 0)), e.addJot && (z += y), O.height = E, O.depth = z, M += E, O.pos = M, M += z + P, _[n] = O, F(b[n + 1]);
  }
  var W = M / 2 + r.fontMetrics().axisHeight, U = e.cols || [], V = [], K, q, H = [];
  if (e.tags && e.tags.some((qe) => qe))
    for (n = 0; n < h; ++n) {
      var j = _[n], Q = j.pos - W, J = e.tags[n], Y = void 0;
      J === !0 ? Y = buildCommon.makeSpan(["eqn-num"], [], r) : J === !1 ? Y = buildCommon.makeSpan([], [], r) : Y = buildCommon.makeSpan([], buildExpression$1(J, r, !0), r), Y.depth = j.depth, Y.height = j.height, H.push({
        type: "elem",
        elem: Y,
        shift: Q
      });
    }
  for (
    s = 0, q = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    s < g || q < U.length;
    ++s, ++q
  ) {
    for (var ee = U[q] || {}, fe = !0; ee.type === "separator"; ) {
      if (fe || (K = buildCommon.makeSpan(["arraycolsep"], []), K.style.width = makeEm(r.fontMetrics().doubleRuleSep), V.push(K)), ee.separator === "|" || ee.separator === ":") {
        var me = ee.separator === "|" ? "solid" : "dashed", he = buildCommon.makeSpan(["vertical-separator"], [], r);
        he.style.height = makeEm(M), he.style.borderRightWidth = makeEm(x), he.style.borderRightStyle = me, he.style.margin = "0 " + makeEm(-x / 2);
        var we = M - W;
        we && (he.style.verticalAlign = makeEm(-we)), V.push(he);
      } else
        throw new ParseError("Invalid separator type: " + ee.separator);
      q++, ee = U[q] || {}, fe = !1;
    }
    if (!(s >= g)) {
      var ye = void 0;
      (s > 0 || e.hskipBeforeAndAfter) && (ye = utils.deflt(ee.pregap, $), ye !== 0 && (K = buildCommon.makeSpan(["arraycolsep"], []), K.style.width = makeEm(ye), V.push(K)));
      var ve = [];
      for (n = 0; n < h; ++n) {
        var ce = _[n], be = ce[s];
        if (be) {
          var le = ce.pos - W;
          be.depth = ce.depth, be.height = ce.height, ve.push({
            type: "elem",
            elem: be,
            shift: le
          });
        }
      }
      ve = buildCommon.makeVList({
        positionType: "individualShift",
        children: ve
      }, r), ve = buildCommon.makeSpan(["col-align-" + (ee.align || "c")], [ve]), V.push(ve), (s < g - 1 || e.hskipBeforeAndAfter) && (ye = utils.deflt(ee.postgap, $), ye !== 0 && (K = buildCommon.makeSpan(["arraycolsep"], []), K.style.width = makeEm(ye), V.push(K)));
    }
  }
  if (_ = buildCommon.makeSpan(["mtable"], V), A.length > 0) {
    for (var Se = buildCommon.makeLineSpan("hline", r, x), ge = buildCommon.makeLineSpan("hdashline", r, x), de = [{
      type: "elem",
      elem: _,
      shift: 0
    }]; A.length > 0; ) {
      var De = A.pop(), Be = De.pos - W;
      De.isDashed ? de.push({
        type: "elem",
        elem: ge,
        shift: Be
      }) : de.push({
        type: "elem",
        elem: Se,
        shift: Be
      });
    }
    _ = buildCommon.makeVList({
      positionType: "individualShift",
      children: de
    }, r);
  }
  if (H.length === 0)
    return buildCommon.makeSpan(["mord"], [_], r);
  var Ve = buildCommon.makeVList({
    positionType: "individualShift",
    children: H
  }, r);
  return Ve = buildCommon.makeSpan(["tag"], [Ve], r), buildCommon.makeFragment([_, Ve]);
}, alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
}, mathmlBuilder$5 = function(e, r) {
  for (var n = [], s = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]), h = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]), b = 0; b < e.body.length; b++) {
    for (var g = e.body[b], _ = [], A = 0; A < g.length; A++)
      _.push(new mathMLTree.MathNode("mtd", [buildGroup(g[A], r)]));
    e.tags && e.tags[b] && (_.unshift(s), _.push(s), e.leqno ? _.unshift(h) : _.push(h)), n.push(new mathMLTree.MathNode("mtr", _));
  }
  var x = new mathMLTree.MathNode("mtable", n), k = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  x.setAttribute("rowspacing", makeEm(k));
  var $ = "", C = "";
  if (e.cols && e.cols.length > 0) {
    var L = e.cols, y = "", o = !1, v = 0, w = L.length;
    L[0].type === "separator" && ($ += "top ", v = 1), L[L.length - 1].type === "separator" && ($ += "bottom ", w -= 1);
    for (var M = v; M < w; M++)
      L[M].type === "align" ? (C += alignMap[L[M].align], o && (y += "none "), o = !0) : L[M].type === "separator" && o && (y += L[M].separator === "|" ? "solid " : "dashed ", o = !1);
    x.setAttribute("columnalign", C.trim()), /[sd]/.test(y) && x.setAttribute("columnlines", y.trim());
  }
  if (e.colSeparationType === "align") {
    for (var F = e.cols || [], m = "", E = 1; E < F.length; E++)
      m += E % 2 ? "0em " : "1em ";
    x.setAttribute("columnspacing", m.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? x.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? x.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? x.setAttribute("columnspacing", "0.5em") : x.setAttribute("columnspacing", "1em");
  var z = "", O = e.hLinesBeforeRow;
  $ += O[0].length > 0 ? "left " : "", $ += O[O.length - 1].length > 0 ? "right " : "";
  for (var R = 1; R < O.length - 1; R++)
    z += O[R].length === 0 ? "none " : O[R][0] ? "dashed " : "solid ";
  return /[sd]/.test(z) && x.setAttribute("rowlines", z.trim()), $ !== "" && (x = new mathMLTree.MathNode("menclose", [x]), x.setAttribute("notation", $.trim())), e.arraystretch && e.arraystretch < 1 && (x = new mathMLTree.MathNode("mstyle", [x]), x.setAttribute("scriptlevel", "1")), x;
}, alignedHandler = function(e, r) {
  e.envName.indexOf("ed") === -1 && validateAmsEnvironmentContext(e);
  var n = [], s = e.envName.indexOf("at") > -1 ? "alignat" : "align", h = e.envName === "split", b = parseArray(e.parser, {
    cols: n,
    addJot: !0,
    autoTag: h ? void 0 : getAutoTag(e.envName),
    emptySingleRow: !0,
    colSeparationType: s,
    maxNumCols: h ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), g, _ = 0, A = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (r[0] && r[0].type === "ordgroup") {
    for (var x = "", k = 0; k < r[0].body.length; k++) {
      var $ = assertNodeType(r[0].body[k], "textord");
      x += $.text;
    }
    g = Number(x), _ = g * 2;
  }
  var C = !_;
  b.body.forEach(function(v) {
    for (var w = 1; w < v.length; w += 2) {
      var M = assertNodeType(v[w], "styling"), F = assertNodeType(M.body[0], "ordgroup");
      F.body.unshift(A);
    }
    if (C)
      _ < v.length && (_ = v.length);
    else {
      var m = v.length / 2;
      if (g < m)
        throw new ParseError("Too many math in a row: " + ("expected " + g + ", but got " + m), v[0]);
    }
  });
  for (var L = 0; L < _; ++L) {
    var y = "r", o = 0;
    L % 2 === 1 ? y = "l" : L > 0 && C && (o = 1), n[L] = {
      type: "align",
      align: y,
      pregap: o,
      postgap: 0
    };
  }
  return b.colSeparationType = C ? "align" : "alignat", b;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var r = checkSymbolNodeType(e[0]), n = r ? [e[0]] : assertNodeType(e[0], "ordgroup").body, s = n.map(function(b) {
      var g = assertSymbolNodeType(b), _ = g.text;
      if ("lcr".indexOf(_) !== -1)
        return {
          type: "align",
          align: _
        };
      if (_ === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (_ === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new ParseError("Unknown column alignment: " + _, b);
    }), h = {
      cols: s,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: s.length
    };
    return parseArray(a.parser, h, dCellStyle(a.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[a.envName.replace("*", "")], r = "c", n = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: r
      }]
    };
    if (a.envName.charAt(a.envName.length - 1) === "*") {
      var s = a.parser;
      if (s.consumeSpaces(), s.fetch().text === "[") {
        if (s.consume(), s.consumeSpaces(), r = s.fetch().text, "lcr".indexOf(r) === -1)
          throw new ParseError("Expected l or c or r", s.nextToken);
        s.consume(), s.consumeSpaces(), s.expect("]"), s.consume(), n.cols = [{
          type: "align",
          align: r
        }];
      }
    }
    var h = parseArray(a.parser, n, dCellStyle(a.envName)), b = Math.max(0, ...h.body.map((g) => g.length));
    return h.cols = new Array(b).fill({
      type: "align",
      align: r
    }), e ? {
      type: "leftright",
      mode: a.mode,
      body: [h],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : h;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var e = {
      arraystretch: 0.5
    }, r = parseArray(a.parser, e, "script");
    return r.colSeparationType = "small", r;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var r = checkSymbolNodeType(e[0]), n = r ? [e[0]] : assertNodeType(e[0], "ordgroup").body, s = n.map(function(b) {
      var g = assertSymbolNodeType(b), _ = g.text;
      if ("lc".indexOf(_) !== -1)
        return {
          type: "align",
          align: _
        };
      throw new ParseError("Unknown column alignment: " + _, b);
    });
    if (s.length > 1)
      throw new ParseError("{subarray} can contain only one column");
    var h = {
      cols: s,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (h = parseArray(a.parser, h, "script"), h.body.length > 0 && h.body[0].length > 1)
      throw new ParseError("{subarray} can contain only one column");
    return h;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, r = parseArray(a.parser, e, dCellStyle(a.envName));
    return {
      type: "leftright",
      mode: a.mode,
      body: [r],
      left: a.envName.indexOf("r") > -1 ? "." : "\\{",
      right: a.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(a) {
    utils.contains(["gather", "gather*"], a.envName) && validateAmsEnvironmentContext(a);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: getAutoTag(a.envName),
      emptySingleRow: !0,
      leqno: a.parser.settings.leqno
    };
    return parseArray(a.parser, e, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(a) {
    validateAmsEnvironmentContext(a);
    var e = {
      autoTag: getAutoTag(a.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: a.parser.settings.leqno
    };
    return parseArray(a.parser, e, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(a) {
    return validateAmsEnvironmentContext(a), parseCD(a.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(a, e) {
    throw new ParseError(a.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    if (s.type !== "ordgroup")
      throw new ParseError("Invalid environment name", s);
    for (var h = "", b = 0; b < s.body.length; ++b)
      h += assertNodeType(s.body[b], "textord").text;
    if (n === "\\begin") {
      if (!environments.hasOwnProperty(h))
        throw new ParseError("No such environment: " + h, s);
      var g = environments[h], {
        args: _,
        optArgs: A
      } = r.parseArguments("\\begin{" + h + "}", g), x = {
        mode: r.mode,
        envName: h,
        parser: r
      }, k = g.handler(x, _, A);
      r.expect("\\end", !1);
      var $ = r.nextToken, C = assertNodeType(r.parseFunction(), "environment");
      if (C.name !== h)
        throw new ParseError("Mismatch: \\begin{" + h + "} matched by \\end{" + C.name + "}", $);
      return k;
    }
    return {
      type: "environment",
      mode: r.mode,
      name: h,
      nameGroup: s
    };
  }
});
var htmlBuilder$5 = (a, e) => {
  var r = a.font, n = e.withFont(r);
  return buildGroup$1(a.body, n);
}, mathmlBuilder$4 = (a, e) => {
  var r = a.font, n = e.withFont(r);
  return buildGroup(a.body, n);
}, fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = normalizeArgument(e[0]), h = n;
    return h in fontAliases && (h = fontAliases[h]), {
      type: "font",
      mode: r.mode,
      font: h.slice(1),
      body: s
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[0], s = utils.isCharacterBox(n);
    return {
      type: "mclass",
      mode: r.mode,
      mclass: binrelClass(n),
      body: [{
        type: "font",
        mode: r.mode,
        font: "boldsymbol",
        body: n
      }],
      isCharacterBox: s
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n,
      breakOnTokenText: s
    } = a, {
      mode: h
    } = r, b = r.parseExpression(!0, s), g = "math" + n.slice(1);
    return {
      type: "font",
      mode: h,
      font: g,
      body: {
        type: "ordgroup",
        mode: r.mode,
        body: b
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (a, e) => {
  var r = e;
  return a === "display" ? r = r.id >= Style$1.SCRIPT.id ? r.text() : Style$1.DISPLAY : a === "text" && r.size === Style$1.DISPLAY.size ? r = Style$1.TEXT : a === "script" ? r = Style$1.SCRIPT : a === "scriptscript" && (r = Style$1.SCRIPTSCRIPT), r;
}, htmlBuilder$4 = (a, e) => {
  var r = adjustStyle(a.size, e.style), n = r.fracNum(), s = r.fracDen(), h;
  h = e.havingStyle(n);
  var b = buildGroup$1(a.numer, h, e);
  if (a.continued) {
    var g = 8.5 / e.fontMetrics().ptPerEm, _ = 3.5 / e.fontMetrics().ptPerEm;
    b.height = b.height < g ? g : b.height, b.depth = b.depth < _ ? _ : b.depth;
  }
  h = e.havingStyle(s);
  var A = buildGroup$1(a.denom, h, e), x, k, $;
  a.hasBarLine ? (a.barSize ? (k = calculateSize(a.barSize, e), x = buildCommon.makeLineSpan("frac-line", e, k)) : x = buildCommon.makeLineSpan("frac-line", e), k = x.height, $ = x.height) : (x = null, k = 0, $ = e.fontMetrics().defaultRuleThickness);
  var C, L, y;
  r.size === Style$1.DISPLAY.size || a.size === "display" ? (C = e.fontMetrics().num1, k > 0 ? L = 3 * $ : L = 7 * $, y = e.fontMetrics().denom1) : (k > 0 ? (C = e.fontMetrics().num2, L = $) : (C = e.fontMetrics().num3, L = 3 * $), y = e.fontMetrics().denom2);
  var o;
  if (x) {
    var w = e.fontMetrics().axisHeight;
    C - b.depth - (w + 0.5 * k) < L && (C += L - (C - b.depth - (w + 0.5 * k))), w - 0.5 * k - (A.height - y) < L && (y += L - (w - 0.5 * k - (A.height - y)));
    var M = -(w - 0.5 * k);
    o = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: A,
        shift: y
      }, {
        type: "elem",
        elem: x,
        shift: M
      }, {
        type: "elem",
        elem: b,
        shift: -C
      }]
    }, e);
  } else {
    var v = C - b.depth - (A.height - y);
    v < L && (C += 0.5 * (L - v), y += 0.5 * (L - v)), o = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: A,
        shift: y
      }, {
        type: "elem",
        elem: b,
        shift: -C
      }]
    }, e);
  }
  h = e.havingStyle(r), o.height *= h.sizeMultiplier / e.sizeMultiplier, o.depth *= h.sizeMultiplier / e.sizeMultiplier;
  var F;
  r.size === Style$1.DISPLAY.size ? F = e.fontMetrics().delim1 : r.size === Style$1.SCRIPTSCRIPT.size ? F = e.havingStyle(Style$1.SCRIPT).fontMetrics().delim2 : F = e.fontMetrics().delim2;
  var m, E;
  return a.leftDelim == null ? m = makeNullDelimiter(e, ["mopen"]) : m = delimiter.customSizedDelim(a.leftDelim, F, !0, e.havingStyle(r), a.mode, ["mopen"]), a.continued ? E = buildCommon.makeSpan([]) : a.rightDelim == null ? E = makeNullDelimiter(e, ["mclose"]) : E = delimiter.customSizedDelim(a.rightDelim, F, !0, e.havingStyle(r), a.mode, ["mclose"]), buildCommon.makeSpan(["mord"].concat(h.sizingClasses(e)), [m, buildCommon.makeSpan(["mfrac"], [o]), E], e);
}, mathmlBuilder$3 = (a, e) => {
  var r = new mathMLTree.MathNode("mfrac", [buildGroup(a.numer, e), buildGroup(a.denom, e)]);
  if (!a.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (a.barSize) {
    var n = calculateSize(a.barSize, e);
    r.setAttribute("linethickness", makeEm(n));
  }
  var s = adjustStyle(a.size, e.style);
  if (s.size !== e.style.size) {
    r = new mathMLTree.MathNode("mstyle", [r]);
    var h = s.size === Style$1.DISPLAY.size ? "true" : "false";
    r.setAttribute("displaystyle", h), r.setAttribute("scriptlevel", "0");
  }
  if (a.leftDelim != null || a.rightDelim != null) {
    var b = [];
    if (a.leftDelim != null) {
      var g = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(a.leftDelim.replace("\\", ""))]);
      g.setAttribute("fence", "true"), b.push(g);
    }
    if (b.push(r), a.rightDelim != null) {
      var _ = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(a.rightDelim.replace("\\", ""))]);
      _.setAttribute("fence", "true"), b.push(_);
    }
    return makeRow(b);
  }
  return r;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0], h = e[1], b, g = null, _ = null, A = "auto";
    switch (n) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        b = !0;
        break;
      case "\\\\atopfrac":
        b = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        b = !1, g = "(", _ = ")";
        break;
      case "\\\\bracefrac":
        b = !1, g = "\\{", _ = "\\}";
        break;
      case "\\\\brackfrac":
        b = !1, g = "[", _ = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (n) {
      case "\\dfrac":
      case "\\dbinom":
        A = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        A = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !1,
      numer: s,
      denom: h,
      hasBarLine: b,
      leftDelim: g,
      rightDelim: _,
      size: A,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0], h = e[1];
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !0,
      numer: s,
      denom: h,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r,
      token: n
    } = a, s;
    switch (r) {
      case "\\over":
        s = "\\frac";
        break;
      case "\\choose":
        s = "\\binom";
        break;
      case "\\atop":
        s = "\\\\atopfrac";
        break;
      case "\\brace":
        s = "\\\\bracefrac";
        break;
      case "\\brack":
        s = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: s,
      token: n
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"], delimFromValue = function(e) {
  var r = null;
  return e.length > 0 && (r = e, r = r === "." ? null : r), r;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(a, e) {
    var {
      parser: r
    } = a, n = e[4], s = e[5], h = normalizeArgument(e[0]), b = h.type === "atom" && h.family === "open" ? delimFromValue(h.text) : null, g = normalizeArgument(e[1]), _ = g.type === "atom" && g.family === "close" ? delimFromValue(g.text) : null, A = assertNodeType(e[2], "size"), x, k = null;
    A.isBlank ? x = !0 : (k = A.value, x = k.number > 0);
    var $ = "auto", C = e[3];
    if (C.type === "ordgroup") {
      if (C.body.length > 0) {
        var L = assertNodeType(C.body[0], "textord");
        $ = stylArray[Number(L.text)];
      }
    } else
      C = assertNodeType(C, "textord"), $ = stylArray[Number(C.text)];
    return {
      type: "genfrac",
      mode: r.mode,
      numer: n,
      denom: s,
      continued: !1,
      hasBarLine: x,
      barSize: k,
      leftDelim: b,
      rightDelim: _,
      size: $
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n,
      token: s
    } = a;
    return {
      type: "infix",
      mode: r.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(e[0], "size").value,
      token: s
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0], h = assert(assertNodeType(e[1], "infix").size), b = e[2], g = h.number > 0;
    return {
      type: "genfrac",
      mode: r.mode,
      numer: s,
      denom: b,
      continued: !1,
      hasBarLine: g,
      barSize: h,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (a, e) => {
  var r = e.style, n, s;
  a.type === "supsub" ? (n = a.sup ? buildGroup$1(a.sup, e.havingStyle(r.sup()), e) : buildGroup$1(a.sub, e.havingStyle(r.sub()), e), s = assertNodeType(a.base, "horizBrace")) : s = assertNodeType(a, "horizBrace");
  var h = buildGroup$1(s.base, e.havingBaseStyle(Style$1.DISPLAY)), b = stretchy.svgSpan(s, e), g;
  if (s.isOver ? (g = buildCommon.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: h
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: b
    }]
  }, e), g.children[0].children[0].children[1].classes.push("svg-align")) : (g = buildCommon.makeVList({
    positionType: "bottom",
    positionData: h.depth + 0.1 + b.height,
    children: [{
      type: "elem",
      elem: b
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: h
    }]
  }, e), g.children[0].children[0].children[0].classes.push("svg-align")), n) {
    var _ = buildCommon.makeSpan(["mord", s.isOver ? "mover" : "munder"], [g], e);
    s.isOver ? g = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: _
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: n
      }]
    }, e) : g = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _.depth + 0.2 + n.height + n.depth,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: _
      }]
    }, e);
  }
  return buildCommon.makeSpan(["mord", s.isOver ? "mover" : "munder"], [g], e);
}, mathmlBuilder$2 = (a, e) => {
  var r = stretchy.mathMLnode(a.label);
  return new mathMLTree.MathNode(a.isOver ? "mover" : "munder", [buildGroup(a.base, e), r]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a;
    return {
      type: "horizBrace",
      mode: r.mode,
      label: n,
      isOver: /^\\over/.test(n),
      base: e[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[1], s = assertNodeType(e[0], "url").url;
    return r.settings.isTrusted({
      command: "\\href",
      url: s
    }) ? {
      type: "href",
      mode: r.mode,
      href: s,
      body: ordargument(n)
    } : r.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (a, e) => {
    var r = buildExpression$1(a.body, e, !1);
    return buildCommon.makeAnchor(a.href, [], r, e);
  },
  mathmlBuilder: (a, e) => {
    var r = buildExpressionRow(a.body, e);
    return r instanceof MathNode || (r = new MathNode("mrow", [r])), r.setAttribute("href", a.href), r;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = assertNodeType(e[0], "url").url;
    if (!r.settings.isTrusted({
      command: "\\url",
      url: n
    }))
      return r.formatUnsupportedCmd("\\url");
    for (var s = [], h = 0; h < n.length; h++) {
      var b = n[h];
      b === "~" && (b = "\\textasciitilde"), s.push({
        type: "textord",
        mode: "text",
        text: b
      });
    }
    var g = {
      type: "text",
      mode: r.mode,
      font: "\\texttt",
      body: s
    };
    return {
      type: "href",
      mode: r.mode,
      href: n,
      body: ordargument(g)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "hbox",
      mode: r.mode,
      body: ordargument(e[0])
    };
  },
  htmlBuilder(a, e) {
    var r = buildExpression$1(a.body, e, !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder(a, e) {
    return new mathMLTree.MathNode("mrow", buildExpression(a.body, e));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n,
      token: s
    } = a, h = assertNodeType(e[0], "raw").string, b = e[1];
    r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var g, _ = {};
    switch (n) {
      case "\\htmlClass":
        _.class = h, g = {
          command: "\\htmlClass",
          class: h
        };
        break;
      case "\\htmlId":
        _.id = h, g = {
          command: "\\htmlId",
          id: h
        };
        break;
      case "\\htmlStyle":
        _.style = h, g = {
          command: "\\htmlStyle",
          style: h
        };
        break;
      case "\\htmlData": {
        for (var A = h.split(","), x = 0; x < A.length; x++) {
          var k = A[x].split("=");
          if (k.length !== 2)
            throw new ParseError("Error parsing key-value for \\htmlData");
          _["data-" + k[0].trim()] = k[1].trim();
        }
        g = {
          command: "\\htmlData",
          attributes: _
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return r.settings.isTrusted(g) ? {
      type: "html",
      mode: r.mode,
      attributes: _,
      body: ordargument(b)
    } : r.formatUnsupportedCmd(n);
  },
  htmlBuilder: (a, e) => {
    var r = buildExpression$1(a.body, e, !1), n = ["enclosing"];
    a.attributes.class && n.push(...a.attributes.class.trim().split(/\s+/));
    var s = buildCommon.makeSpan(n, r, e);
    for (var h in a.attributes)
      h !== "class" && a.attributes.hasOwnProperty(h) && s.setAttribute(h, a.attributes[h]);
    return s;
  },
  mathmlBuilder: (a, e) => buildExpressionRow(a.body, e)
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a;
    return {
      type: "htmlmathml",
      mode: r.mode,
      html: ordargument(e[0]),
      mathml: ordargument(e[1])
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildExpression$1(a.html, e, !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder: (a, e) => buildExpressionRow(a.mathml, e)
});
var sizeData = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var r = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!r)
    throw new ParseError("Invalid size: '" + e + "' in \\includegraphics");
  var n = {
    number: +(r[1] + r[2]),
    // sign + magnitude, cast to number
    unit: r[3]
  };
  if (!validUnit(n))
    throw new ParseError("Invalid unit: '" + n.unit + "' in \\includegraphics.");
  return n;
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (a, e, r) => {
    var {
      parser: n
    } = a, s = {
      number: 0,
      unit: "em"
    }, h = {
      number: 0.9,
      unit: "em"
    }, b = {
      number: 0,
      unit: "em"
    }, g = "";
    if (r[0])
      for (var _ = assertNodeType(r[0], "raw").string, A = _.split(","), x = 0; x < A.length; x++) {
        var k = A[x].split("=");
        if (k.length === 2) {
          var $ = k[1].trim();
          switch (k[0].trim()) {
            case "alt":
              g = $;
              break;
            case "width":
              s = sizeData($);
              break;
            case "height":
              h = sizeData($);
              break;
            case "totalheight":
              b = sizeData($);
              break;
            default:
              throw new ParseError("Invalid key: '" + k[0] + "' in \\includegraphics.");
          }
        }
      }
    var C = assertNodeType(e[0], "url").url;
    return g === "" && (g = C, g = g.replace(/^.*[\\/]/, ""), g = g.substring(0, g.lastIndexOf("."))), n.settings.isTrusted({
      command: "\\includegraphics",
      url: C
    }) ? {
      type: "includegraphics",
      mode: n.mode,
      alt: g,
      width: s,
      height: h,
      totalheight: b,
      src: C
    } : n.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (a, e) => {
    var r = calculateSize(a.height, e), n = 0;
    a.totalheight.number > 0 && (n = calculateSize(a.totalheight, e) - r);
    var s = 0;
    a.width.number > 0 && (s = calculateSize(a.width, e));
    var h = {
      height: makeEm(r + n)
    };
    s > 0 && (h.width = makeEm(s)), n > 0 && (h.verticalAlign = makeEm(-n));
    var b = new Img(a.src, a.alt, h);
    return b.height = r, b.depth = n, b;
  },
  mathmlBuilder: (a, e) => {
    var r = new mathMLTree.MathNode("mglyph", []);
    r.setAttribute("alt", a.alt);
    var n = calculateSize(a.height, e), s = 0;
    if (a.totalheight.number > 0 && (s = calculateSize(a.totalheight, e) - n, r.setAttribute("valign", makeEm(-s))), r.setAttribute("height", makeEm(n + s)), a.width.number > 0) {
      var h = calculateSize(a.width, e);
      r.setAttribute("width", makeEm(h));
    }
    return r.setAttribute("src", a.src), r;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = assertNodeType(e[0], "size");
    if (r.settings.strict) {
      var h = n[1] === "m", b = s.value.unit === "mu";
      h ? (b || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " supports only mu units, " + ("not " + s.value.unit + " units")), r.mode !== "math" && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " works only in math mode")) : b && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: r.mode,
      dimension: s.value
    };
  },
  htmlBuilder(a, e) {
    return buildCommon.makeGlue(a.dimension, e);
  },
  mathmlBuilder(a, e) {
    var r = calculateSize(a.dimension, e);
    return new mathMLTree.SpaceNode(r);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "lap",
      mode: r.mode,
      alignment: n.slice(5),
      body: s
    };
  },
  htmlBuilder: (a, e) => {
    var r;
    a.alignment === "clap" ? (r = buildCommon.makeSpan([], [buildGroup$1(a.body, e)]), r = buildCommon.makeSpan(["inner"], [r], e)) : r = buildCommon.makeSpan(["inner"], [buildGroup$1(a.body, e)]);
    var n = buildCommon.makeSpan(["fix"], []), s = buildCommon.makeSpan([a.alignment], [r, n], e), h = buildCommon.makeSpan(["strut"]);
    return h.style.height = makeEm(s.height + s.depth), s.depth && (h.style.verticalAlign = makeEm(-s.depth)), s.children.unshift(h), s = buildCommon.makeSpan(["thinbox"], [s], e), buildCommon.makeSpan(["mord", "vbox"], [s], e);
  },
  mathmlBuilder: (a, e) => {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(a.body, e)]);
    if (a.alignment !== "rlap") {
      var n = a.alignment === "llap" ? "-1" : "-0.5";
      r.setAttribute("lspace", n + "width");
    }
    return r.setAttribute("width", "0px"), r;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(a, e) {
    var {
      funcName: r,
      parser: n
    } = a, s = n.mode;
    n.switchMode("math");
    var h = r === "\\(" ? "\\)" : "$", b = n.parseExpression(!1, h);
    return n.expect(h), n.switchMode(s), {
      type: "styling",
      mode: n.mode,
      style: "text",
      body: b
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(a, e) {
    throw new ParseError("Mismatched " + a.funcName);
  }
});
var chooseMathStyle = (a, e) => {
  switch (e.style.size) {
    case Style$1.DISPLAY.size:
      return a.display;
    case Style$1.TEXT.size:
      return a.text;
    case Style$1.SCRIPT.size:
      return a.script;
    case Style$1.SCRIPTSCRIPT.size:
      return a.scriptscript;
    default:
      return a.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a;
    return {
      type: "mathchoice",
      mode: r.mode,
      display: ordargument(e[0]),
      text: ordargument(e[1]),
      script: ordargument(e[2]),
      scriptscript: ordargument(e[3])
    };
  },
  htmlBuilder: (a, e) => {
    var r = chooseMathStyle(a, e), n = buildExpression$1(r, e, !1);
    return buildCommon.makeFragment(n);
  },
  mathmlBuilder: (a, e) => {
    var r = chooseMathStyle(a, e);
    return buildExpressionRow(r, e);
  }
});
var assembleSupSub = (a, e, r, n, s, h, b) => {
  a = buildCommon.makeSpan([], [a]);
  var g = r && utils.isCharacterBox(r), _, A;
  if (e) {
    var x = buildGroup$1(e, n.havingStyle(s.sup()), n);
    A = {
      elem: x,
      kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - x.depth)
    };
  }
  if (r) {
    var k = buildGroup$1(r, n.havingStyle(s.sub()), n);
    _ = {
      elem: k,
      kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - k.height)
    };
  }
  var $;
  if (A && _) {
    var C = n.fontMetrics().bigOpSpacing5 + _.elem.height + _.elem.depth + _.kern + a.depth + b;
    $ = buildCommon.makeVList({
      positionType: "bottom",
      positionData: C,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: _.elem,
        marginLeft: makeEm(-h)
      }, {
        type: "kern",
        size: _.kern
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: A.kern
      }, {
        type: "elem",
        elem: A.elem,
        marginLeft: makeEm(h)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else if (_) {
    var L = a.height - b;
    $ = buildCommon.makeVList({
      positionType: "top",
      positionData: L,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: _.elem,
        marginLeft: makeEm(-h)
      }, {
        type: "kern",
        size: _.kern
      }, {
        type: "elem",
        elem: a
      }]
    }, n);
  } else if (A) {
    var y = a.depth + b;
    $ = buildCommon.makeVList({
      positionType: "bottom",
      positionData: y,
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: A.kern
      }, {
        type: "elem",
        elem: A.elem,
        marginLeft: makeEm(h)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else
    return a;
  var o = [$];
  if (_ && h !== 0 && !g) {
    var v = buildCommon.makeSpan(["mspace"], [], n);
    v.style.marginRight = makeEm(h), o.unshift(v);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], o, n);
}, noSuccessor = ["\\smallint"], htmlBuilder$2 = (a, e) => {
  var r, n, s = !1, h;
  a.type === "supsub" ? (r = a.sup, n = a.sub, h = assertNodeType(a.base, "op"), s = !0) : h = assertNodeType(a, "op");
  var b = e.style, g = !1;
  b.size === Style$1.DISPLAY.size && h.symbol && !utils.contains(noSuccessor, h.name) && (g = !0);
  var _;
  if (h.symbol) {
    var A = g ? "Size2-Regular" : "Size1-Regular", x = "";
    if ((h.name === "\\oiint" || h.name === "\\oiiint") && (x = h.name.slice(1), h.name = x === "oiint" ? "\\iint" : "\\iiint"), _ = buildCommon.makeSymbol(h.name, A, "math", e, ["mop", "op-symbol", g ? "large-op" : "small-op"]), x.length > 0) {
      var k = _.italic, $ = buildCommon.staticSvg(x + "Size" + (g ? "2" : "1"), e);
      _ = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: _,
          shift: 0
        }, {
          type: "elem",
          elem: $,
          shift: g ? 0.08 : 0
        }]
      }, e), h.name = "\\" + x, _.classes.unshift("mop"), _.italic = k;
    }
  } else if (h.body) {
    var C = buildExpression$1(h.body, e, !0);
    C.length === 1 && C[0] instanceof SymbolNode ? (_ = C[0], _.classes[0] = "mop") : _ = buildCommon.makeSpan(["mop"], C, e);
  } else {
    for (var L = [], y = 1; y < h.name.length; y++)
      L.push(buildCommon.mathsym(h.name[y], h.mode, e));
    _ = buildCommon.makeSpan(["mop"], L, e);
  }
  var o = 0, v = 0;
  return (_ instanceof SymbolNode || h.name === "\\oiint" || h.name === "\\oiiint") && !h.suppressBaseShift && (o = (_.height - _.depth) / 2 - e.fontMetrics().axisHeight, v = _.italic), s ? assembleSupSub(_, r, n, e, b, v, o) : (o && (_.style.position = "relative", _.style.top = makeEm(o)), _);
}, mathmlBuilder$1 = (a, e) => {
  var r;
  if (a.symbol)
    r = new MathNode("mo", [makeText(a.name, a.mode)]), utils.contains(noSuccessor, a.name) && r.setAttribute("largeop", "false");
  else if (a.body)
    r = new MathNode("mo", buildExpression(a.body, e));
  else {
    r = new MathNode("mi", [new TextNode(a.name.slice(1))]);
    var n = new MathNode("mo", [makeText("⁡", "text")]);
    a.parentIsSupSub ? r = new MathNode("mrow", [r, n]) : r = newDocumentFragment([r, n]);
  }
  return r;
}, singleCharBigOps = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = n;
    return s.length === 1 && (s = singleCharBigOps[s]), {
      type: "op",
      mode: r.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: s
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[0];
    return {
      type: "op",
      mode: r.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: ordargument(n)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(a) {
    var {
      parser: e,
      funcName: r
    } = a, n = r;
    return n.length === 1 && (n = singleCharIntegrals[n]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (a, e) => {
  var r, n, s = !1, h;
  a.type === "supsub" ? (r = a.sup, n = a.sub, h = assertNodeType(a.base, "operatorname"), s = !0) : h = assertNodeType(a, "operatorname");
  var b;
  if (h.body.length > 0) {
    for (var g = h.body.map((k) => {
      var $ = k.text;
      return typeof $ == "string" ? {
        type: "textord",
        mode: k.mode,
        text: $
      } : k;
    }), _ = buildExpression$1(g, e.withFont("mathrm"), !0), A = 0; A < _.length; A++) {
      var x = _[A];
      x instanceof SymbolNode && (x.text = x.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    b = buildCommon.makeSpan(["mop"], _, e);
  } else
    b = buildCommon.makeSpan(["mop"], [], e);
  return s ? assembleSupSub(b, r, n, e, e.style, 0, 0) : b;
}, mathmlBuilder = (a, e) => {
  for (var r = buildExpression(a.body, e.withFont("mathrm")), n = !0, s = 0; s < r.length; s++) {
    var h = r[s];
    if (!(h instanceof mathMLTree.SpaceNode)) if (h instanceof mathMLTree.MathNode)
      switch (h.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var b = h.children[0];
          h.children.length === 1 && b instanceof mathMLTree.TextNode ? b.text = b.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : n = !1;
          break;
        }
        default:
          n = !1;
      }
    else
      n = !1;
  }
  if (n) {
    var g = r.map((x) => x.toText()).join("");
    r = [new mathMLTree.TextNode(g)];
  }
  var _ = new mathMLTree.MathNode("mi", r);
  _.setAttribute("mathvariant", "normal");
  var A = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
  return a.parentIsSupSub ? new mathMLTree.MathNode("mrow", [_, A]) : mathMLTree.newDocumentFragment([_, A]);
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (a, e) => {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "operatorname",
      mode: r.mode,
      body: ordargument(s),
      alwaysHandleSupSub: n === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(a, e) {
    return a.semisimple ? buildCommon.makeFragment(buildExpression$1(a.body, e, !1)) : buildCommon.makeSpan(["mord"], buildExpression$1(a.body, e, !0), e);
  },
  mathmlBuilder(a, e) {
    return buildExpressionRow(a.body, e, !0);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(a, e) {
    var {
      parser: r
    } = a, n = e[0];
    return {
      type: "overline",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder(a, e) {
    var r = buildGroup$1(a.body, e.havingCrampedStyle()), n = buildCommon.makeLineSpan("overline-line", e), s = e.fontMetrics().defaultRuleThickness, h = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * s
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: s
      }]
    }, e);
    return buildCommon.makeSpan(["mord", "overline"], [h], e);
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
    r.setAttribute("stretchy", "true");
    var n = new mathMLTree.MathNode("mover", [buildGroup(a.body, e), r]);
    return n.setAttribute("accent", "true"), n;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[0];
    return {
      type: "phantom",
      mode: r.mode,
      body: ordargument(n)
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildExpression$1(a.body, e.withPhantom(), !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder: (a, e) => {
    var r = buildExpression(a.body, e);
    return new mathMLTree.MathNode("mphantom", r);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[0];
    return {
      type: "hphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildCommon.makeSpan([], [buildGroup$1(a.body, e.withPhantom())]);
    if (r.height = 0, r.depth = 0, r.children)
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0, r.children[n].depth = 0;
    return r = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e), buildCommon.makeSpan(["mord"], [r], e);
  },
  mathmlBuilder: (a, e) => {
    var r = buildExpression(ordargument(a.body), e), n = new mathMLTree.MathNode("mphantom", r), s = new mathMLTree.MathNode("mpadded", [n]);
    return s.setAttribute("height", "0px"), s.setAttribute("depth", "0px"), s;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      parser: r
    } = a, n = e[0];
    return {
      type: "vphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildCommon.makeSpan(["inner"], [buildGroup$1(a.body, e.withPhantom())]), n = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [r, n], e);
  },
  mathmlBuilder: (a, e) => {
    var r = buildExpression(ordargument(a.body), e), n = new mathMLTree.MathNode("mphantom", r), s = new mathMLTree.MathNode("mpadded", [n]);
    return s.setAttribute("width", "0px"), s;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r
    } = a, n = assertNodeType(e[0], "size").value, s = e[1];
    return {
      type: "raisebox",
      mode: r.mode,
      dy: n,
      body: s
    };
  },
  htmlBuilder(a, e) {
    var r = buildGroup$1(a.body, e), n = calculateSize(a.dy, e);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -n,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(a.body, e)]), n = a.dy.number + a.dy.unit;
    return r.setAttribute("voffset", n), r;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(a) {
    var {
      parser: e
    } = a;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(a, e, r) {
    var {
      parser: n
    } = a, s = r[0], h = assertNodeType(e[0], "size"), b = assertNodeType(e[1], "size");
    return {
      type: "rule",
      mode: n.mode,
      shift: s && assertNodeType(s, "size").value,
      width: h.value,
      height: b.value
    };
  },
  htmlBuilder(a, e) {
    var r = buildCommon.makeSpan(["mord", "rule"], [], e), n = calculateSize(a.width, e), s = calculateSize(a.height, e), h = a.shift ? calculateSize(a.shift, e) : 0;
    return r.style.borderRightWidth = makeEm(n), r.style.borderTopWidth = makeEm(s), r.style.bottom = makeEm(h), r.width = n, r.height = s + h, r.depth = -h, r.maxFontSize = s * 1.125 * e.sizeMultiplier, r;
  },
  mathmlBuilder(a, e) {
    var r = calculateSize(a.width, e), n = calculateSize(a.height, e), s = a.shift ? calculateSize(a.shift, e) : 0, h = e.color && e.getColor() || "black", b = new mathMLTree.MathNode("mspace");
    b.setAttribute("mathbackground", h), b.setAttribute("width", makeEm(r)), b.setAttribute("height", makeEm(n));
    var g = new mathMLTree.MathNode("mpadded", [b]);
    return s >= 0 ? g.setAttribute("height", makeEm(s)) : (g.setAttribute("height", makeEm(s)), g.setAttribute("depth", makeEm(-s))), g.setAttribute("voffset", makeEm(s)), g;
  }
});
function sizingGroup(a, e, r) {
  for (var n = buildExpression$1(a, e, !1), s = e.sizeMultiplier / r.sizeMultiplier, h = 0; h < n.length; h++) {
    var b = n[h].classes.indexOf("sizing");
    b < 0 ? Array.prototype.push.apply(n[h].classes, e.sizingClasses(r)) : n[h].classes[b + 1] === "reset-size" + e.size && (n[h].classes[b + 1] = "reset-size" + r.size), n[h].height *= s, n[h].depth *= s;
  }
  return buildCommon.makeFragment(n);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], htmlBuilder = (a, e) => {
  var r = e.havingSize(a.size);
  return sizingGroup(a.body, r, e);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (a, e) => {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: s
    } = a, h = s.parseExpression(!1, r);
    return {
      type: "sizing",
      mode: s.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(n) + 1,
      body: h
    };
  },
  htmlBuilder,
  mathmlBuilder: (a, e) => {
    var r = e.havingSize(a.size), n = buildExpression(a.body, r), s = new mathMLTree.MathNode("mstyle", n);
    return s.setAttribute("mathsize", makeEm(r.sizeMultiplier)), s;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (a, e, r) => {
    var {
      parser: n
    } = a, s = !1, h = !1, b = r[0] && assertNodeType(r[0], "ordgroup");
    if (b)
      for (var g = "", _ = 0; _ < b.body.length; ++_) {
        var A = b.body[_];
        if (g = A.text, g === "t")
          s = !0;
        else if (g === "b")
          h = !0;
        else {
          s = !1, h = !1;
          break;
        }
      }
    else
      s = !0, h = !0;
    var x = e[0];
    return {
      type: "smash",
      mode: n.mode,
      body: x,
      smashHeight: s,
      smashDepth: h
    };
  },
  htmlBuilder: (a, e) => {
    var r = buildCommon.makeSpan([], [buildGroup$1(a.body, e)]);
    if (!a.smashHeight && !a.smashDepth)
      return r;
    if (a.smashHeight && (r.height = 0, r.children))
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0;
    if (a.smashDepth && (r.depth = 0, r.children))
      for (var s = 0; s < r.children.length; s++)
        r.children[s].depth = 0;
    var h = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
    return buildCommon.makeSpan(["mord"], [h], e);
  },
  mathmlBuilder: (a, e) => {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(a.body, e)]);
    return a.smashHeight && r.setAttribute("height", "0px"), a.smashDepth && r.setAttribute("depth", "0px"), r;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(a, e, r) {
    var {
      parser: n
    } = a, s = r[0], h = e[0];
    return {
      type: "sqrt",
      mode: n.mode,
      body: h,
      index: s
    };
  },
  htmlBuilder(a, e) {
    var r = buildGroup$1(a.body, e.havingCrampedStyle());
    r.height === 0 && (r.height = e.fontMetrics().xHeight), r = buildCommon.wrapFragment(r, e);
    var n = e.fontMetrics(), s = n.defaultRuleThickness, h = s;
    e.style.id < Style$1.TEXT.id && (h = e.fontMetrics().xHeight);
    var b = s + h / 4, g = r.height + r.depth + b + s, {
      span: _,
      ruleWidth: A,
      advanceWidth: x
    } = delimiter.sqrtImage(g, e), k = _.height - A;
    k > r.height + r.depth + b && (b = (b + k - r.height - r.depth) / 2);
    var $ = _.height - r.height - b - A;
    r.style.paddingLeft = makeEm(x);
    var C = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(r.height + $)
      }, {
        type: "elem",
        elem: _
      }, {
        type: "kern",
        size: A
      }]
    }, e);
    if (a.index) {
      var L = e.havingStyle(Style$1.SCRIPTSCRIPT), y = buildGroup$1(a.index, L, e), o = 0.6 * (C.height - C.depth), v = buildCommon.makeVList({
        positionType: "shift",
        positionData: -o,
        children: [{
          type: "elem",
          elem: y
        }]
      }, e), w = buildCommon.makeSpan(["root"], [v]);
      return buildCommon.makeSpan(["mord", "sqrt"], [w, C], e);
    } else
      return buildCommon.makeSpan(["mord", "sqrt"], [C], e);
  },
  mathmlBuilder(a, e) {
    var {
      body: r,
      index: n
    } = a;
    return n ? new mathMLTree.MathNode("mroot", [buildGroup(r, e), buildGroup(n, e)]) : new mathMLTree.MathNode("msqrt", [buildGroup(r, e)]);
  }
});
var styleMap = {
  display: Style$1.DISPLAY,
  text: Style$1.TEXT,
  script: Style$1.SCRIPT,
  scriptscript: Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(a, e) {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: s
    } = a, h = s.parseExpression(!0, r), b = n.slice(1, n.length - 5);
    return {
      type: "styling",
      mode: s.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: b,
      body: h
    };
  },
  htmlBuilder(a, e) {
    var r = styleMap[a.style], n = e.havingStyle(r).withFont("");
    return sizingGroup(a.body, n, e);
  },
  mathmlBuilder(a, e) {
    var r = styleMap[a.style], n = e.havingStyle(r), s = buildExpression(a.body, n), h = new mathMLTree.MathNode("mstyle", s), b = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, g = b[a.style];
    return h.setAttribute("scriptlevel", g[0]), h.setAttribute("displaystyle", g[1]), h;
  }
});
var htmlBuilderDelegate = function(e, r) {
  var n = e.base;
  if (n)
    if (n.type === "op") {
      var s = n.limits && (r.style.size === Style$1.DISPLAY.size || n.alwaysHandleSupSub);
      return s ? htmlBuilder$2 : null;
    } else if (n.type === "operatorname") {
      var h = n.alwaysHandleSupSub && (r.style.size === Style$1.DISPLAY.size || n.limits);
      return h ? htmlBuilder$1 : null;
    } else {
      if (n.type === "accent")
        return utils.isCharacterBox(n.base) ? htmlBuilder$a : null;
      if (n.type === "horizBrace") {
        var b = !e.sub;
        return b === n.isOver ? htmlBuilder$3 : null;
      } else
        return null;
    }
  else return null;
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(a, e) {
    var r = htmlBuilderDelegate(a, e);
    if (r)
      return r(a, e);
    var {
      base: n,
      sup: s,
      sub: h
    } = a, b = buildGroup$1(n, e), g, _, A = e.fontMetrics(), x = 0, k = 0, $ = n && utils.isCharacterBox(n);
    if (s) {
      var C = e.havingStyle(e.style.sup());
      g = buildGroup$1(s, C, e), $ || (x = b.height - C.fontMetrics().supDrop * C.sizeMultiplier / e.sizeMultiplier);
    }
    if (h) {
      var L = e.havingStyle(e.style.sub());
      _ = buildGroup$1(h, L, e), $ || (k = b.depth + L.fontMetrics().subDrop * L.sizeMultiplier / e.sizeMultiplier);
    }
    var y;
    e.style === Style$1.DISPLAY ? y = A.sup1 : e.style.cramped ? y = A.sup3 : y = A.sup2;
    var o = e.sizeMultiplier, v = makeEm(0.5 / A.ptPerEm / o), w = null;
    if (_) {
      var M = a.base && a.base.type === "op" && a.base.name && (a.base.name === "\\oiint" || a.base.name === "\\oiiint");
      (b instanceof SymbolNode || M) && (w = makeEm(-b.italic));
    }
    var F;
    if (g && _) {
      x = Math.max(x, y, g.depth + 0.25 * A.xHeight), k = Math.max(k, A.sub2);
      var m = A.defaultRuleThickness, E = 4 * m;
      if (x - g.depth - (_.height - k) < E) {
        k = E - (x - g.depth) + _.height;
        var z = 0.8 * A.xHeight - (x - g.depth);
        z > 0 && (x += z, k -= z);
      }
      var O = [{
        type: "elem",
        elem: _,
        shift: k,
        marginRight: v,
        marginLeft: w
      }, {
        type: "elem",
        elem: g,
        shift: -x,
        marginRight: v
      }];
      F = buildCommon.makeVList({
        positionType: "individualShift",
        children: O
      }, e);
    } else if (_) {
      k = Math.max(k, A.sub1, _.height - 0.8 * A.xHeight);
      var R = [{
        type: "elem",
        elem: _,
        marginLeft: w,
        marginRight: v
      }];
      F = buildCommon.makeVList({
        positionType: "shift",
        positionData: k,
        children: R
      }, e);
    } else if (g)
      x = Math.max(x, y, g.depth + 0.25 * A.xHeight), F = buildCommon.makeVList({
        positionType: "shift",
        positionData: -x,
        children: [{
          type: "elem",
          elem: g,
          marginRight: v
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var B = getTypeOfDomTree(b, "right") || "mord";
    return buildCommon.makeSpan([B], [b, buildCommon.makeSpan(["msupsub"], [F])], e);
  },
  mathmlBuilder(a, e) {
    var r = !1, n, s;
    a.base && a.base.type === "horizBrace" && (s = !!a.sup, s === a.base.isOver && (r = !0, n = a.base.isOver)), a.base && (a.base.type === "op" || a.base.type === "operatorname") && (a.base.parentIsSupSub = !0);
    var h = [buildGroup(a.base, e)];
    a.sub && h.push(buildGroup(a.sub, e)), a.sup && h.push(buildGroup(a.sup, e));
    var b;
    if (r)
      b = n ? "mover" : "munder";
    else if (a.sub)
      if (a.sup) {
        var A = a.base;
        A && A.type === "op" && A.limits && e.style === Style$1.DISPLAY || A && A.type === "operatorname" && A.alwaysHandleSupSub && (e.style === Style$1.DISPLAY || A.limits) ? b = "munderover" : b = "msubsup";
      } else {
        var _ = a.base;
        _ && _.type === "op" && _.limits && (e.style === Style$1.DISPLAY || _.alwaysHandleSupSub) || _ && _.type === "operatorname" && _.alwaysHandleSupSub && (_.limits || e.style === Style$1.DISPLAY) ? b = "munder" : b = "msub";
      }
    else {
      var g = a.base;
      g && g.type === "op" && g.limits && (e.style === Style$1.DISPLAY || g.alwaysHandleSupSub) || g && g.type === "operatorname" && g.alwaysHandleSupSub && (g.limits || e.style === Style$1.DISPLAY) ? b = "mover" : b = "msup";
    }
    return new mathMLTree.MathNode(b, h);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(a, e) {
    return buildCommon.mathsym(a.text, a.mode, e, ["m" + a.family]);
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mo", [makeText(a.text, a.mode)]);
    if (a.family === "bin") {
      var n = getVariant(a, e);
      n === "bold-italic" && r.setAttribute("mathvariant", n);
    } else a.family === "punct" ? r.setAttribute("separator", "true") : (a.family === "open" || a.family === "close") && r.setAttribute("stretchy", "false");
    return r;
  }
});
var defaultVariant = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(a, e) {
    return buildCommon.makeOrd(a, e, "mathord");
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mi", [makeText(a.text, a.mode, e)]), n = getVariant(a, e) || "italic";
    return n !== defaultVariant[r.type] && r.setAttribute("mathvariant", n), r;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(a, e) {
    return buildCommon.makeOrd(a, e, "textord");
  },
  mathmlBuilder(a, e) {
    var r = makeText(a.text, a.mode, e), n = getVariant(a, e) || "normal", s;
    return a.mode === "text" ? s = new mathMLTree.MathNode("mtext", [r]) : /[0-9]/.test(a.text) ? s = new mathMLTree.MathNode("mn", [r]) : a.text === "\\prime" ? s = new mathMLTree.MathNode("mo", [r]) : s = new mathMLTree.MathNode("mi", [r]), n !== defaultVariant[s.type] && s.setAttribute("mathvariant", n), s;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(a, e) {
    if (regularSpace.hasOwnProperty(a.text)) {
      var r = regularSpace[a.text].className || "";
      if (a.mode === "text") {
        var n = buildCommon.makeOrd(a, e, "textord");
        return n.classes.push(r), n;
      } else
        return buildCommon.makeSpan(["mspace", r], [buildCommon.mathsym(a.text, a.mode, e)], e);
    } else {
      if (cssSpace.hasOwnProperty(a.text))
        return buildCommon.makeSpan(["mspace", cssSpace[a.text]], [], e);
      throw new ParseError('Unknown type of space "' + a.text + '"');
    }
  },
  mathmlBuilder(a, e) {
    var r;
    if (regularSpace.hasOwnProperty(a.text))
      r = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
    else {
      if (cssSpace.hasOwnProperty(a.text))
        return new mathMLTree.MathNode("mspace");
      throw new ParseError('Unknown type of space "' + a.text + '"');
    }
    return r;
  }
});
var pad = () => {
  var a = new mathMLTree.MathNode("mtd", []);
  return a.setAttribute("width", "50%"), a;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(a.body, e)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(a.tag, e)])])]);
    return r.setAttribute("width", "100%"), r;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
}, optionsWithFont = (a, e) => {
  var r = a.font;
  if (r) {
    if (textFontFamilies[r])
      return e.withTextFontFamily(textFontFamilies[r]);
    if (textFontWeights[r])
      return e.withTextFontWeight(textFontWeights[r]);
    if (r === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(textFontShapes[r]);
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r,
      funcName: n
    } = a, s = e[0];
    return {
      type: "text",
      mode: r.mode,
      body: ordargument(s),
      font: n
    };
  },
  htmlBuilder(a, e) {
    var r = optionsWithFont(a, e), n = buildExpression$1(a.body, r, !0);
    return buildCommon.makeSpan(["mord", "text"], n, r);
  },
  mathmlBuilder(a, e) {
    var r = optionsWithFont(a, e);
    return buildExpressionRow(a.body, r);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "underline",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(a, e) {
    var r = buildGroup$1(a.body, e), n = buildCommon.makeLineSpan("underline-line", e), s = e.fontMetrics().defaultRuleThickness, h = buildCommon.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "kern",
        size: s
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * s
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return buildCommon.makeSpan(["mord", "underline"], [h], e);
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
    r.setAttribute("stretchy", "true");
    var n = new mathMLTree.MathNode("munder", [buildGroup(a.body, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(a, e) {
    var {
      parser: r
    } = a;
    return {
      type: "vcenter",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(a, e) {
    var r = buildGroup$1(a.body, e), n = e.fontMetrics().axisHeight, s = 0.5 * (r.height - n - (r.depth + n));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: s,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(a, e) {
    return new mathMLTree.MathNode("mpadded", [buildGroup(a.body, e)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(a, e, r) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(a, e) {
    for (var r = makeVerb(a), n = [], s = e.havingStyle(e.style.text()), h = 0; h < r.length; h++) {
      var b = r[h];
      b === "~" && (b = "\\textasciitilde"), n.push(buildCommon.makeSymbol(b, "Typewriter-Regular", a.mode, s, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(s.sizingClasses(e)), buildCommon.tryCombineChars(n), s);
  },
  mathmlBuilder(a, e) {
    var r = new mathMLTree.TextNode(makeVerb(a)), n = new mathMLTree.MathNode("mtext", [r]);
    return n.setAttribute("mathvariant", "monospace"), n;
  }
});
var makeVerb = (a) => a.body.replace(/ /g, a.star ? "␣" : " "), functions = _functions;
defineMacro("\\noexpand", function(a) {
  var e = a.popToken();
  return a.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(a) {
  var e = a.popToken();
  return a.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(a) {
  var e = a.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(a) {
  var e = a.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(a) {
  var e = a.consumeArgs(3);
  a.consumeSpaces();
  var r = a.future();
  return e[0].length === 1 && e[0][0].text === r.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(a) {
  var e = a.consumeArgs(2);
  return a.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
defineMacro("\\char", function(a) {
  var e = a.popToken(), r, n = "";
  if (e.text === "'")
    r = 8, e = a.popToken();
  else if (e.text === '"')
    r = 16, e = a.popToken();
  else if (e.text === "`")
    if (e = a.popToken(), e.text[0] === "\\")
      n = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new ParseError("\\char` missing argument");
      n = e.text.charCodeAt(0);
    }
  else
    r = 10;
  if (r) {
    if (n = digitToNumber[e.text], n == null || n >= r)
      throw new ParseError("Invalid base-" + r + " digit " + e.text);
    for (var s; (s = digitToNumber[a.future().text]) != null && s < r; )
      n *= r, n += s, a.popToken();
  }
  return "\\@char{" + n + "}";
});
var newcommand = (a, e, r) => {
  var n = a.consumeArg().tokens;
  if (n.length !== 1)
    throw new ParseError("\\newcommand's first argument must be a macro name");
  var s = n[0].text, h = a.isDefined(s);
  if (h && !e)
    throw new ParseError("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!h && !r)
    throw new ParseError("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var b = 0;
  if (n = a.consumeArg().tokens, n.length === 1 && n[0].text === "[") {
    for (var g = "", _ = a.expandNextToken(); _.text !== "]" && _.text !== "EOF"; )
      g += _.text, _ = a.expandNextToken();
    if (!g.match(/^\s*[0-9]+\s*$/))
      throw new ParseError("Invalid number of arguments: " + g);
    b = parseInt(g), n = a.consumeArg().tokens;
  }
  return a.macros.set(s, {
    tokens: n,
    numArgs: b
  }), "";
};
defineMacro("\\newcommand", (a) => newcommand(a, !1, !0));
defineMacro("\\renewcommand", (a) => newcommand(a, !0, !1));
defineMacro("\\providecommand", (a) => newcommand(a, !0, !0));
defineMacro("\\message", (a) => {
  var e = a.consumeArgs(1)[0];
  return console.log(e.reverse().map((r) => r.text).join("")), "";
});
defineMacro("\\errmessage", (a) => {
  var e = a.consumeArgs(1)[0];
  return console.error(e.reverse().map((r) => r.text).join("")), "";
});
defineMacro("\\show", (a) => {
  var e = a.popToken(), r = e.text;
  return console.log(e, a.macros.get(r), functions[r], symbols.math[r], symbols.text[r]), "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
defineMacro("ℬ", "\\mathscr{B}");
defineMacro("ℰ", "\\mathscr{E}");
defineMacro("ℱ", "\\mathscr{F}");
defineMacro("ℋ", "\\mathscr{H}");
defineMacro("ℐ", "\\mathscr{I}");
defineMacro("ℒ", "\\mathscr{L}");
defineMacro("ℳ", "\\mathscr{M}");
defineMacro("ℛ", "\\mathscr{R}");
defineMacro("ℭ", "\\mathfrak{C}");
defineMacro("ℌ", "\\mathfrak{H}");
defineMacro("ℨ", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("·", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
defineMacro("\\ne", "\\neq");
defineMacro("≠", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
defineMacro("∉", "\\notin");
defineMacro("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
defineMacro("⟂", "\\perp");
defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("∌", "\\notni");
defineMacro("⌜", "\\ulcorner");
defineMacro("⌝", "\\urcorner");
defineMacro("⌞", "\\llcorner");
defineMacro("⌟", "\\lrcorner");
defineMacro("©", "\\copyright");
defineMacro("®", "\\textregistered");
defineMacro("️", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("⋮", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(a) {
  var e = "\\dotso", r = a.expandAfterFuture().text;
  return r in dotsByToken ? e = dotsByToken[r] : (r.slice(0, 4) === "\\not" || r in symbols.math && utils.contains(["bin", "rel"], symbols.math[r].group)) && (e = "\\dotsb"), e;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
defineMacro("\\dotso", function(a) {
  var e = a.future().text;
  return e in spaceAfterDots ? "\\ldots\\," : "\\ldots";
});
defineMacro("\\dotsc", function(a) {
  var e = a.future().text;
  return e in spaceAfterDots && e !== "," ? "\\ldots\\," : "\\ldots";
});
defineMacro("\\cdots", function(a) {
  var e = a.future().text;
  return e in spaceAfterDots ? "\\@cdots\\," : "\\@cdots";
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (a) => {
  if (a.macros.get("\\df@tag"))
    throw new ParseError("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"][84][1] - 0.7 * fontMetricsData["Main-Regular"][65][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("∷", "\\dblcolon");
defineMacro("∹", "\\eqcolon");
defineMacro("≔", "\\coloneqq");
defineMacro("≕", "\\eqqcolon");
defineMacro("⩴", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
defineMacro("⟦", "\\llbracket");
defineMacro("⟧", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
defineMacro("⦃", "\\lBrace");
defineMacro("⦄", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
defineMacro("⦵", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (a) => (e) => {
  var r = e.consumeArg().tokens, n = e.consumeArg().tokens, s = e.consumeArg().tokens, h = e.consumeArg().tokens, b = e.macros.get("|"), g = e.macros.get("\\|");
  e.macros.beginGroup();
  var _ = (k) => ($) => {
    a && ($.macros.set("|", b), s.length && $.macros.set("\\|", g));
    var C = k;
    if (!k && s.length) {
      var L = $.future();
      L.text === "|" && ($.popToken(), C = !0);
    }
    return {
      tokens: C ? s : n,
      numArgs: 0
    };
  };
  e.macros.set("|", _(!1)), s.length && e.macros.set("\\|", _(!0));
  var A = e.consumeArg().tokens, x = e.expandTokens([
    ...h,
    ...A,
    ...r
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: x.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(!1));
defineMacro("\\bra@set", braketHelper(!0));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
typeof document < "u" && document.compatMode !== "CSS1Compat" && typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
function _getDefaults() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
let _defaults = _getDefaults();
function changeDefaults(a) {
  _defaults = a;
}
const escapeTest = /[&<>"']/, escapeReplace = new RegExp(escapeTest.source, "g"), escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g"), escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, getEscapeReplacement = (a) => escapeReplacements[a];
function escape$1(a, e) {
  if (e) {
    if (escapeTest.test(a))
      return a.replace(escapeReplace, getEscapeReplacement);
  } else if (escapeTestNoEncode.test(a))
    return a.replace(escapeReplaceNoEncode, getEscapeReplacement);
  return a;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(a) {
  return a.replace(unescapeTest, (e, r) => (r = r.toLowerCase(), r === "colon" ? ":" : r.charAt(0) === "#" ? r.charAt(1) === "x" ? String.fromCharCode(parseInt(r.substring(2), 16)) : String.fromCharCode(+r.substring(1)) : ""));
}
const caret = /(^|[^\[])\^/g;
function edit(a, e) {
  let r = typeof a == "string" ? a : a.source;
  e = e || "";
  const n = {
    replace: (s, h) => {
      let b = typeof h == "string" ? h : h.source;
      return b = b.replace(caret, "$1"), r = r.replace(s, b), n;
    },
    getRegex: () => new RegExp(r, e)
  };
  return n;
}
function cleanUrl(a) {
  try {
    a = encodeURI(a).replace(/%25/g, "%");
  } catch {
    return null;
  }
  return a;
}
const noopTest = { exec: () => null };
function splitCells(a, e) {
  const r = a.replace(/\|/g, (h, b, g) => {
    let _ = !1, A = b;
    for (; --A >= 0 && g[A] === "\\"; )
      _ = !_;
    return _ ? "|" : " |";
  }), n = r.split(/ \|/);
  let s = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n[n.length - 1].trim() && n.pop(), e)
    if (n.length > e)
      n.splice(e);
    else
      for (; n.length < e; )
        n.push("");
  for (; s < n.length; s++)
    n[s] = n[s].trim().replace(/\\\|/g, "|");
  return n;
}
function rtrim(a, e, r) {
  const n = a.length;
  if (n === 0)
    return "";
  let s = 0;
  for (; s < n; ) {
    const h = a.charAt(n - s - 1);
    if (h === e && !r)
      s++;
    else if (h !== e && r)
      s++;
    else
      break;
  }
  return a.slice(0, n - s);
}
function findClosingBracket(a, e) {
  if (a.indexOf(e[1]) === -1)
    return -1;
  let r = 0;
  for (let n = 0; n < a.length; n++)
    if (a[n] === "\\")
      n++;
    else if (a[n] === e[0])
      r++;
    else if (a[n] === e[1] && (r--, r < 0))
      return n;
  return -1;
}
function outputLink(a, e, r, n) {
  const s = e.href, h = e.title ? escape$1(e.title) : null, b = a[1].replace(/\\([\[\]])/g, "$1");
  if (a[0].charAt(0) !== "!") {
    n.state.inLink = !0;
    const g = {
      type: "link",
      raw: r,
      href: s,
      title: h,
      text: b,
      tokens: n.inlineTokens(b)
    };
    return n.state.inLink = !1, g;
  }
  return {
    type: "image",
    raw: r,
    href: s,
    title: h,
    text: escape$1(b)
  };
}
function indentCodeCompensation(a, e) {
  const r = a.match(/^(\s+)(?:```)/);
  if (r === null)
    return e;
  const n = r[1];
  return e.split(`
`).map((s) => {
    const h = s.match(/^\s+/);
    if (h === null)
      return s;
    const [b] = h;
    return b.length >= n.length ? s.slice(n.length) : s;
  }).join(`
`);
}
class _Tokenizer {
  options;
  rules;
  // set by the lexer
  lexer;
  // set by the lexer
  constructor(e) {
    this.options = e || _defaults;
  }
  space(e) {
    const r = this.rules.block.newline.exec(e);
    if (r && r[0].length > 0)
      return {
        type: "space",
        raw: r[0]
      };
  }
  code(e) {
    const r = this.rules.block.code.exec(e);
    if (r) {
      const n = r[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: r[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? n : rtrim(n, `
`)
      };
    }
  }
  fences(e) {
    const r = this.rules.block.fences.exec(e);
    if (r) {
      const n = r[0], s = indentCodeCompensation(n, r[3] || "");
      return {
        type: "code",
        raw: n,
        lang: r[2] ? r[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : r[2],
        text: s
      };
    }
  }
  heading(e) {
    const r = this.rules.block.heading.exec(e);
    if (r) {
      let n = r[2].trim();
      if (/#$/.test(n)) {
        const s = rtrim(n, "#");
        (this.options.pedantic || !s || / $/.test(s)) && (n = s.trim());
      }
      return {
        type: "heading",
        raw: r[0],
        depth: r[1].length,
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  hr(e) {
    const r = this.rules.block.hr.exec(e);
    if (r)
      return {
        type: "hr",
        raw: r[0]
      };
  }
  blockquote(e) {
    const r = this.rules.block.blockquote.exec(e);
    if (r) {
      let n = r[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`);
      n = rtrim(n.replace(/^ *>[ \t]?/gm, ""), `
`);
      const s = this.lexer.state.top;
      this.lexer.state.top = !0;
      const h = this.lexer.blockTokens(n);
      return this.lexer.state.top = s, {
        type: "blockquote",
        raw: r[0],
        tokens: h,
        text: n
      };
    }
  }
  list(e) {
    let r = this.rules.block.list.exec(e);
    if (r) {
      let n = r[1].trim();
      const s = n.length > 1, h = {
        type: "list",
        raw: "",
        ordered: s,
        start: s ? +n.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      n = s ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = s ? n : "[*+-]");
      const b = new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let g = "", _ = "", A = !1;
      for (; e; ) {
        let x = !1;
        if (!(r = b.exec(e)) || this.rules.block.hr.test(e))
          break;
        g = r[0], e = e.substring(g.length);
        let k = r[2].split(`
`, 1)[0].replace(/^\t+/, (v) => " ".repeat(3 * v.length)), $ = e.split(`
`, 1)[0], C = 0;
        this.options.pedantic ? (C = 2, _ = k.trimStart()) : (C = r[2].search(/[^ ]/), C = C > 4 ? 1 : C, _ = k.slice(C), C += r[1].length);
        let L = !1;
        if (!k && /^ *$/.test($) && (g += $ + `
`, e = e.substring($.length + 1), x = !0), !x) {
          const v = new RegExp(`^ {0,${Math.min(3, C - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), w = new RegExp(`^ {0,${Math.min(3, C - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), M = new RegExp(`^ {0,${Math.min(3, C - 1)}}(?:\`\`\`|~~~)`), F = new RegExp(`^ {0,${Math.min(3, C - 1)}}#`);
          for (; e; ) {
            const m = e.split(`
`, 1)[0];
            if ($ = m, this.options.pedantic && ($ = $.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), M.test($) || F.test($) || v.test($) || w.test(e))
              break;
            if ($.search(/[^ ]/) >= C || !$.trim())
              _ += `
` + $.slice(C);
            else {
              if (L || k.search(/[^ ]/) >= 4 || M.test(k) || F.test(k) || w.test(k))
                break;
              _ += `
` + $;
            }
            !L && !$.trim() && (L = !0), g += m + `
`, e = e.substring(m.length + 1), k = $.slice(C);
          }
        }
        h.loose || (A ? h.loose = !0 : /\n *\n *$/.test(g) && (A = !0));
        let y = null, o;
        this.options.gfm && (y = /^\[[ xX]\] /.exec(_), y && (o = y[0] !== "[ ] ", _ = _.replace(/^\[[ xX]\] +/, ""))), h.items.push({
          type: "list_item",
          raw: g,
          task: !!y,
          checked: o,
          loose: !1,
          text: _,
          tokens: []
        }), h.raw += g;
      }
      h.items[h.items.length - 1].raw = g.trimEnd(), h.items[h.items.length - 1].text = _.trimEnd(), h.raw = h.raw.trimEnd();
      for (let x = 0; x < h.items.length; x++)
        if (this.lexer.state.top = !1, h.items[x].tokens = this.lexer.blockTokens(h.items[x].text, []), !h.loose) {
          const k = h.items[x].tokens.filter((C) => C.type === "space"), $ = k.length > 0 && k.some((C) => /\n.*\n/.test(C.raw));
          h.loose = $;
        }
      if (h.loose)
        for (let x = 0; x < h.items.length; x++)
          h.items[x].loose = !0;
      return h;
    }
  }
  html(e) {
    const r = this.rules.block.html.exec(e);
    if (r)
      return {
        type: "html",
        block: !0,
        raw: r[0],
        pre: r[1] === "pre" || r[1] === "script" || r[1] === "style",
        text: r[0]
      };
  }
  def(e) {
    const r = this.rules.block.def.exec(e);
    if (r) {
      const n = r[1].toLowerCase().replace(/\s+/g, " "), s = r[2] ? r[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", h = r[3] ? r[3].substring(1, r[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : r[3];
      return {
        type: "def",
        tag: n,
        raw: r[0],
        href: s,
        title: h
      };
    }
  }
  table(e) {
    const r = this.rules.block.table.exec(e);
    if (!r || !/[:|]/.test(r[2]))
      return;
    const n = splitCells(r[1]), s = r[2].replace(/^\||\| *$/g, "").split("|"), h = r[3] && r[3].trim() ? r[3].replace(/\n[ \t]*$/, "").split(`
`) : [], b = {
      type: "table",
      raw: r[0],
      header: [],
      align: [],
      rows: []
    };
    if (n.length === s.length) {
      for (const g of s)
        /^ *-+: *$/.test(g) ? b.align.push("right") : /^ *:-+: *$/.test(g) ? b.align.push("center") : /^ *:-+ *$/.test(g) ? b.align.push("left") : b.align.push(null);
      for (const g of n)
        b.header.push({
          text: g,
          tokens: this.lexer.inline(g)
        });
      for (const g of h)
        b.rows.push(splitCells(g, b.header.length).map((_) => ({
          text: _,
          tokens: this.lexer.inline(_)
        })));
      return b;
    }
  }
  lheading(e) {
    const r = this.rules.block.lheading.exec(e);
    if (r)
      return {
        type: "heading",
        raw: r[0],
        depth: r[2].charAt(0) === "=" ? 1 : 2,
        text: r[1],
        tokens: this.lexer.inline(r[1])
      };
  }
  paragraph(e) {
    const r = this.rules.block.paragraph.exec(e);
    if (r) {
      const n = r[1].charAt(r[1].length - 1) === `
` ? r[1].slice(0, -1) : r[1];
      return {
        type: "paragraph",
        raw: r[0],
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  text(e) {
    const r = this.rules.block.text.exec(e);
    if (r)
      return {
        type: "text",
        raw: r[0],
        text: r[0],
        tokens: this.lexer.inline(r[0])
      };
  }
  escape(e) {
    const r = this.rules.inline.escape.exec(e);
    if (r)
      return {
        type: "escape",
        raw: r[0],
        text: escape$1(r[1])
      };
  }
  tag(e) {
    const r = this.rules.inline.tag.exec(e);
    if (r)
      return !this.lexer.state.inLink && /^<a /i.test(r[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(r[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(r[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(r[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: r[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: r[0]
      };
  }
  link(e) {
    const r = this.rules.inline.link.exec(e);
    if (r) {
      const n = r[2].trim();
      if (!this.options.pedantic && /^</.test(n)) {
        if (!/>$/.test(n))
          return;
        const b = rtrim(n.slice(0, -1), "\\");
        if ((n.length - b.length) % 2 === 0)
          return;
      } else {
        const b = findClosingBracket(r[2], "()");
        if (b > -1) {
          const _ = (r[0].indexOf("!") === 0 ? 5 : 4) + r[1].length + b;
          r[2] = r[2].substring(0, b), r[0] = r[0].substring(0, _).trim(), r[3] = "";
        }
      }
      let s = r[2], h = "";
      if (this.options.pedantic) {
        const b = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(s);
        b && (s = b[1], h = b[3]);
      } else
        h = r[3] ? r[3].slice(1, -1) : "";
      return s = s.trim(), /^</.test(s) && (this.options.pedantic && !/>$/.test(n) ? s = s.slice(1) : s = s.slice(1, -1)), outputLink(r, {
        href: s && s.replace(this.rules.inline.anyPunctuation, "$1"),
        title: h && h.replace(this.rules.inline.anyPunctuation, "$1")
      }, r[0], this.lexer);
    }
  }
  reflink(e, r) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      const s = (n[2] || n[1]).replace(/\s+/g, " "), h = r[s.toLowerCase()];
      if (!h) {
        const b = n[0].charAt(0);
        return {
          type: "text",
          raw: b,
          text: b
        };
      }
      return outputLink(n, h, n[0], this.lexer);
    }
  }
  emStrong(e, r, n = "") {
    let s = this.rules.inline.emStrongLDelim.exec(e);
    if (!s || s[3] && n.match(/[\p{L}\p{N}]/u))
      return;
    if (!(s[1] || s[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      const b = [...s[0]].length - 1;
      let g, _, A = b, x = 0;
      const k = s[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (k.lastIndex = 0, r = r.slice(-1 * e.length + b); (s = k.exec(r)) != null; ) {
        if (g = s[1] || s[2] || s[3] || s[4] || s[5] || s[6], !g)
          continue;
        if (_ = [...g].length, s[3] || s[4]) {
          A += _;
          continue;
        } else if ((s[5] || s[6]) && b % 3 && !((b + _) % 3)) {
          x += _;
          continue;
        }
        if (A -= _, A > 0)
          continue;
        _ = Math.min(_, _ + A + x);
        const $ = [...s[0]][0].length, C = e.slice(0, b + s.index + $ + _);
        if (Math.min(b, _) % 2) {
          const y = C.slice(1, -1);
          return {
            type: "em",
            raw: C,
            text: y,
            tokens: this.lexer.inlineTokens(y)
          };
        }
        const L = C.slice(2, -2);
        return {
          type: "strong",
          raw: C,
          text: L,
          tokens: this.lexer.inlineTokens(L)
        };
      }
    }
  }
  codespan(e) {
    const r = this.rules.inline.code.exec(e);
    if (r) {
      let n = r[2].replace(/\n/g, " ");
      const s = /[^ ]/.test(n), h = /^ /.test(n) && / $/.test(n);
      return s && h && (n = n.substring(1, n.length - 1)), n = escape$1(n, !0), {
        type: "codespan",
        raw: r[0],
        text: n
      };
    }
  }
  br(e) {
    const r = this.rules.inline.br.exec(e);
    if (r)
      return {
        type: "br",
        raw: r[0]
      };
  }
  del(e) {
    const r = this.rules.inline.del.exec(e);
    if (r)
      return {
        type: "del",
        raw: r[0],
        text: r[2],
        tokens: this.lexer.inlineTokens(r[2])
      };
  }
  autolink(e) {
    const r = this.rules.inline.autolink.exec(e);
    if (r) {
      let n, s;
      return r[2] === "@" ? (n = escape$1(r[1]), s = "mailto:" + n) : (n = escape$1(r[1]), s = n), {
        type: "link",
        raw: r[0],
        text: n,
        href: s,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  url(e) {
    let r;
    if (r = this.rules.inline.url.exec(e)) {
      let n, s;
      if (r[2] === "@")
        n = escape$1(r[0]), s = "mailto:" + n;
      else {
        let h;
        do
          h = r[0], r[0] = this.rules.inline._backpedal.exec(r[0])?.[0] ?? "";
        while (h !== r[0]);
        n = escape$1(r[0]), r[1] === "www." ? s = "http://" + r[0] : s = r[0];
      }
      return {
        type: "link",
        raw: r[0],
        text: n,
        href: s,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  inlineText(e) {
    const r = this.rules.inline.text.exec(e);
    if (r) {
      let n;
      return this.lexer.state.inRawBlock ? n = r[0] : n = escape$1(r[0]), {
        type: "text",
        raw: r[0],
        text: n
      };
    }
  }
}
const newline = /^(?: *(?:\n|$))+/, blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/, lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, blockText = /^[^\n]+/, _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/, def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex(), _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, html$2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html: html$2,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
}, gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
}, blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br = /^( {2,}|\\)\n(?!\s*$)/, inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, _punctuation = "\\p{P}\\p{S}", punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex(), blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex(), emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex(), anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex(), autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex(), tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex(), nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex(), reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex(), inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
}, inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
}, inlineGfm = {
  ...inlineNormal,
  escape: edit(escape).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
}, inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
class _Lexer {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || _defaults, this.options.tokenizer = this.options.tokenizer || new _Tokenizer(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const r = {
      block: block.normal,
      inline: inline.normal
    };
    this.options.pedantic ? (r.block = block.pedantic, r.inline = inline.pedantic) : this.options.gfm && (r.block = block.gfm, this.options.breaks ? r.inline = inline.breaks : r.inline = inline.gfm), this.tokenizer.rules = r;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, r) {
    return new _Lexer(r).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, r) {
    return new _Lexer(r).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      const n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = []) {
    this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (g, _, A) => _ + "    ".repeat(A.length));
    let n, s, h, b;
    for (; e; )
      if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((g) => (n = g.call({ lexer: this }, e, r)) ? (e = e.substring(n.raw.length), r.push(n), !0) : !1))) {
        if (n = this.tokenizer.space(e)) {
          e = e.substring(n.raw.length), n.raw.length === 1 && r.length > 0 ? r[r.length - 1].raw += `
` : r.push(n);
          continue;
        }
        if (n = this.tokenizer.code(e)) {
          e = e.substring(n.raw.length), s = r[r.length - 1], s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.fences(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.heading(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.hr(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.blockquote(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.list(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.html(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.def(e)) {
          e = e.substring(n.raw.length), s = r[r.length - 1], s && (s.type === "paragraph" || s.type === "text") ? (s.raw += `
` + n.raw, s.text += `
` + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
            href: n.href,
            title: n.title
          });
          continue;
        }
        if (n = this.tokenizer.table(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.lheading(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (h = e, this.options.extensions && this.options.extensions.startBlock) {
          let g = 1 / 0;
          const _ = e.slice(1);
          let A;
          this.options.extensions.startBlock.forEach((x) => {
            A = x.call({ lexer: this }, _), typeof A == "number" && A >= 0 && (g = Math.min(g, A));
          }), g < 1 / 0 && g >= 0 && (h = e.substring(0, g + 1));
        }
        if (this.state.top && (n = this.tokenizer.paragraph(h))) {
          s = r[r.length - 1], b && s.type === "paragraph" ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : r.push(n), b = h.length !== e.length, e = e.substring(n.raw.length);
          continue;
        }
        if (n = this.tokenizer.text(e)) {
          e = e.substring(n.raw.length), s = r[r.length - 1], s && s.type === "text" ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : r.push(n);
          continue;
        }
        if (e) {
          const g = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(g);
            break;
          } else
            throw new Error(g);
        }
      }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, r = []) {
    let n, s, h, b = e, g, _, A;
    if (this.tokens.links) {
      const x = Object.keys(this.tokens.links);
      if (x.length > 0)
        for (; (g = this.tokenizer.rules.inline.reflinkSearch.exec(b)) != null; )
          x.includes(g[0].slice(g[0].lastIndexOf("[") + 1, -1)) && (b = b.slice(0, g.index) + "[" + "a".repeat(g[0].length - 2) + "]" + b.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (g = this.tokenizer.rules.inline.blockSkip.exec(b)) != null; )
      b = b.slice(0, g.index) + "[" + "a".repeat(g[0].length - 2) + "]" + b.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    for (; (g = this.tokenizer.rules.inline.anyPunctuation.exec(b)) != null; )
      b = b.slice(0, g.index) + "++" + b.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; e; )
      if (_ || (A = ""), _ = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((x) => (n = x.call({ lexer: this }, e, r)) ? (e = e.substring(n.raw.length), r.push(n), !0) : !1))) {
        if (n = this.tokenizer.escape(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.tag(e)) {
          e = e.substring(n.raw.length), s = r[r.length - 1], s && n.type === "text" && s.type === "text" ? (s.raw += n.raw, s.text += n.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.link(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.reflink(e, this.tokens.links)) {
          e = e.substring(n.raw.length), s = r[r.length - 1], s && n.type === "text" && s.type === "text" ? (s.raw += n.raw, s.text += n.text) : r.push(n);
          continue;
        }
        if (n = this.tokenizer.emStrong(e, b, A)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.codespan(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.br(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.del(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (n = this.tokenizer.autolink(e)) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (!this.state.inLink && (n = this.tokenizer.url(e))) {
          e = e.substring(n.raw.length), r.push(n);
          continue;
        }
        if (h = e, this.options.extensions && this.options.extensions.startInline) {
          let x = 1 / 0;
          const k = e.slice(1);
          let $;
          this.options.extensions.startInline.forEach((C) => {
            $ = C.call({ lexer: this }, k), typeof $ == "number" && $ >= 0 && (x = Math.min(x, $));
          }), x < 1 / 0 && x >= 0 && (h = e.substring(0, x + 1));
        }
        if (n = this.tokenizer.inlineText(h)) {
          e = e.substring(n.raw.length), n.raw.slice(-1) !== "_" && (A = n.raw.slice(-1)), _ = !0, s = r[r.length - 1], s && s.type === "text" ? (s.raw += n.raw, s.text += n.text) : r.push(n);
          continue;
        }
        if (e) {
          const x = "Infinite loop on byte: " + e.charCodeAt(0);
          if (this.options.silent) {
            console.error(x);
            break;
          } else
            throw new Error(x);
        }
      }
    return r;
  }
}
class _Renderer {
  options;
  constructor(e) {
    this.options = e || _defaults;
  }
  code(e, r, n) {
    const s = (r || "").match(/^\S*/)?.[0];
    return e = e.replace(/\n$/, "") + `
`, s ? '<pre><code class="language-' + escape$1(s) + '">' + (n ? e : escape$1(e, !0)) + `</code></pre>
` : "<pre><code>" + (n ? e : escape$1(e, !0)) + `</code></pre>
`;
  }
  blockquote(e) {
    return `<blockquote>
${e}</blockquote>
`;
  }
  html(e, r) {
    return e;
  }
  heading(e, r, n) {
    return `<h${r}>${e}</h${r}>
`;
  }
  hr() {
    return `<hr>
`;
  }
  list(e, r, n) {
    const s = r ? "ol" : "ul", h = r && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + s + h + `>
` + e + "</" + s + `>
`;
  }
  listitem(e, r, n) {
    return `<li>${e}</li>
`;
  }
  checkbox(e) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(e) {
    return `<p>${e}</p>
`;
  }
  table(e, r) {
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + r + `</table>
`;
  }
  tablerow(e) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e, r) {
    const n = r.header ? "th" : "td";
    return (r.align ? `<${n} align="${r.align}">` : `<${n}>`) + e + `</${n}>
`;
  }
  /**
   * span level renderer
   */
  strong(e) {
    return `<strong>${e}</strong>`;
  }
  em(e) {
    return `<em>${e}</em>`;
  }
  codespan(e) {
    return `<code>${e}</code>`;
  }
  br() {
    return "<br>";
  }
  del(e) {
    return `<del>${e}</del>`;
  }
  link(e, r, n) {
    const s = cleanUrl(e);
    if (s === null)
      return n;
    e = s;
    let h = '<a href="' + e + '"';
    return r && (h += ' title="' + r + '"'), h += ">" + n + "</a>", h;
  }
  image(e, r, n) {
    const s = cleanUrl(e);
    if (s === null)
      return n;
    e = s;
    let h = `<img src="${e}" alt="${n}"`;
    return r && (h += ` title="${r}"`), h += ">", h;
  }
  text(e) {
    return e;
  }
}
class _TextRenderer {
  // no need for block level renderers
  strong(e) {
    return e;
  }
  em(e) {
    return e;
  }
  codespan(e) {
    return e;
  }
  del(e) {
    return e;
  }
  html(e) {
    return e;
  }
  text(e) {
    return e;
  }
  link(e, r, n) {
    return "" + n;
  }
  image(e, r, n) {
    return "" + n;
  }
  br() {
    return "";
  }
}
class _Parser {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || _defaults, this.options.renderer = this.options.renderer || new _Renderer(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(e, r) {
    return new _Parser(r).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, r) {
    return new _Parser(r).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, r = !0) {
    let n = "";
    for (let s = 0; s < e.length; s++) {
      const h = e[s];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type]) {
        const b = h, g = this.options.extensions.renderers[b.type].call({ parser: this }, b);
        if (g !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(b.type)) {
          n += g || "";
          continue;
        }
      }
      switch (h.type) {
        case "space":
          continue;
        case "hr": {
          n += this.renderer.hr();
          continue;
        }
        case "heading": {
          const b = h;
          n += this.renderer.heading(this.parseInline(b.tokens), b.depth, unescape(this.parseInline(b.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const b = h;
          n += this.renderer.code(b.text, b.lang, !!b.escaped);
          continue;
        }
        case "table": {
          const b = h;
          let g = "", _ = "";
          for (let x = 0; x < b.header.length; x++)
            _ += this.renderer.tablecell(this.parseInline(b.header[x].tokens), { header: !0, align: b.align[x] });
          g += this.renderer.tablerow(_);
          let A = "";
          for (let x = 0; x < b.rows.length; x++) {
            const k = b.rows[x];
            _ = "";
            for (let $ = 0; $ < k.length; $++)
              _ += this.renderer.tablecell(this.parseInline(k[$].tokens), { header: !1, align: b.align[$] });
            A += this.renderer.tablerow(_);
          }
          n += this.renderer.table(g, A);
          continue;
        }
        case "blockquote": {
          const b = h, g = this.parse(b.tokens);
          n += this.renderer.blockquote(g);
          continue;
        }
        case "list": {
          const b = h, g = b.ordered, _ = b.start, A = b.loose;
          let x = "";
          for (let k = 0; k < b.items.length; k++) {
            const $ = b.items[k], C = $.checked, L = $.task;
            let y = "";
            if ($.task) {
              const o = this.renderer.checkbox(!!C);
              A ? $.tokens.length > 0 && $.tokens[0].type === "paragraph" ? ($.tokens[0].text = o + " " + $.tokens[0].text, $.tokens[0].tokens && $.tokens[0].tokens.length > 0 && $.tokens[0].tokens[0].type === "text" && ($.tokens[0].tokens[0].text = o + " " + $.tokens[0].tokens[0].text)) : $.tokens.unshift({
                type: "text",
                text: o + " "
              }) : y += o + " ";
            }
            y += this.parse($.tokens, A), x += this.renderer.listitem(y, L, !!C);
          }
          n += this.renderer.list(x, g, _);
          continue;
        }
        case "html": {
          const b = h;
          n += this.renderer.html(b.text, b.block);
          continue;
        }
        case "paragraph": {
          const b = h;
          n += this.renderer.paragraph(this.parseInline(b.tokens));
          continue;
        }
        case "text": {
          let b = h, g = b.tokens ? this.parseInline(b.tokens) : b.text;
          for (; s + 1 < e.length && e[s + 1].type === "text"; )
            b = e[++s], g += `
` + (b.tokens ? this.parseInline(b.tokens) : b.text);
          n += r ? this.renderer.paragraph(g) : g;
          continue;
        }
        default: {
          const b = 'Token with "' + h.type + '" type was not found.';
          if (this.options.silent)
            return console.error(b), "";
          throw new Error(b);
        }
      }
    }
    return n;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, r) {
    r = r || this.renderer;
    let n = "";
    for (let s = 0; s < e.length; s++) {
      const h = e[s];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[h.type]) {
        const b = this.options.extensions.renderers[h.type].call({ parser: this }, h);
        if (b !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(h.type)) {
          n += b || "";
          continue;
        }
      }
      switch (h.type) {
        case "escape": {
          const b = h;
          n += r.text(b.text);
          break;
        }
        case "html": {
          const b = h;
          n += r.html(b.text);
          break;
        }
        case "link": {
          const b = h;
          n += r.link(b.href, b.title, this.parseInline(b.tokens, r));
          break;
        }
        case "image": {
          const b = h;
          n += r.image(b.href, b.title, b.text);
          break;
        }
        case "strong": {
          const b = h;
          n += r.strong(this.parseInline(b.tokens, r));
          break;
        }
        case "em": {
          const b = h;
          n += r.em(this.parseInline(b.tokens, r));
          break;
        }
        case "codespan": {
          const b = h;
          n += r.codespan(b.text);
          break;
        }
        case "br": {
          n += r.br();
          break;
        }
        case "del": {
          const b = h;
          n += r.del(this.parseInline(b.tokens, r));
          break;
        }
        case "text": {
          const b = h;
          n += r.text(b.text);
          break;
        }
        default: {
          const b = 'Token with "' + h.type + '" type was not found.';
          if (this.options.silent)
            return console.error(b), "";
          throw new Error(b);
        }
      }
    }
    return n;
  }
}
class _Hooks {
  options;
  constructor(e) {
    this.options = e || _defaults;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(e) {
    return e;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(e) {
    return e;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(e) {
    return e;
  }
}
class Marked {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.#e(_Lexer.lex, _Parser.parse);
  parseInline = this.#e(_Lexer.lexInline, _Parser.parseInline);
  Parser = _Parser;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...e) {
    this.use(...e);
  }
  /**
   * Run callback for every token
   */
  walkTokens(e, r) {
    let n = [];
    for (const s of e)
      switch (n = n.concat(r.call(this, s)), s.type) {
        case "table": {
          const h = s;
          for (const b of h.header)
            n = n.concat(this.walkTokens(b.tokens, r));
          for (const b of h.rows)
            for (const g of b)
              n = n.concat(this.walkTokens(g.tokens, r));
          break;
        }
        case "list": {
          const h = s;
          n = n.concat(this.walkTokens(h.items, r));
          break;
        }
        default: {
          const h = s;
          this.defaults.extensions?.childTokens?.[h.type] ? this.defaults.extensions.childTokens[h.type].forEach((b) => {
            const g = h[b].flat(1 / 0);
            n = n.concat(this.walkTokens(g, r));
          }) : h.tokens && (n = n.concat(this.walkTokens(h.tokens, r)));
        }
      }
    return n;
  }
  use(...e) {
    const r = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      const s = { ...n };
      if (s.async = this.defaults.async || s.async || !1, n.extensions && (n.extensions.forEach((h) => {
        if (!h.name)
          throw new Error("extension name required");
        if ("renderer" in h) {
          const b = r.renderers[h.name];
          b ? r.renderers[h.name] = function(...g) {
            let _ = h.renderer.apply(this, g);
            return _ === !1 && (_ = b.apply(this, g)), _;
          } : r.renderers[h.name] = h.renderer;
        }
        if ("tokenizer" in h) {
          if (!h.level || h.level !== "block" && h.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const b = r[h.level];
          b ? b.unshift(h.tokenizer) : r[h.level] = [h.tokenizer], h.start && (h.level === "block" ? r.startBlock ? r.startBlock.push(h.start) : r.startBlock = [h.start] : h.level === "inline" && (r.startInline ? r.startInline.push(h.start) : r.startInline = [h.start]));
        }
        "childTokens" in h && h.childTokens && (r.childTokens[h.name] = h.childTokens);
      }), s.extensions = r), n.renderer) {
        const h = this.defaults.renderer || new _Renderer(this.defaults);
        for (const b in n.renderer) {
          if (!(b in h))
            throw new Error(`renderer '${b}' does not exist`);
          if (b === "options")
            continue;
          const g = b, _ = n.renderer[g], A = h[g];
          h[g] = (...x) => {
            let k = _.apply(h, x);
            return k === !1 && (k = A.apply(h, x)), k || "";
          };
        }
        s.renderer = h;
      }
      if (n.tokenizer) {
        const h = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const b in n.tokenizer) {
          if (!(b in h))
            throw new Error(`tokenizer '${b}' does not exist`);
          if (["options", "rules", "lexer"].includes(b))
            continue;
          const g = b, _ = n.tokenizer[g], A = h[g];
          h[g] = (...x) => {
            let k = _.apply(h, x);
            return k === !1 && (k = A.apply(h, x)), k;
          };
        }
        s.tokenizer = h;
      }
      if (n.hooks) {
        const h = this.defaults.hooks || new _Hooks();
        for (const b in n.hooks) {
          if (!(b in h))
            throw new Error(`hook '${b}' does not exist`);
          if (b === "options")
            continue;
          const g = b, _ = n.hooks[g], A = h[g];
          _Hooks.passThroughHooks.has(b) ? h[g] = (x) => {
            if (this.defaults.async)
              return Promise.resolve(_.call(h, x)).then(($) => A.call(h, $));
            const k = _.call(h, x);
            return A.call(h, k);
          } : h[g] = (...x) => {
            let k = _.apply(h, x);
            return k === !1 && (k = A.apply(h, x)), k;
          };
        }
        s.hooks = h;
      }
      if (n.walkTokens) {
        const h = this.defaults.walkTokens, b = n.walkTokens;
        s.walkTokens = function(g) {
          let _ = [];
          return _.push(b.call(this, g)), h && (_ = _.concat(h.call(this, g))), _;
        };
      }
      this.defaults = { ...this.defaults, ...s };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, r) {
    return _Lexer.lex(e, r ?? this.defaults);
  }
  parser(e, r) {
    return _Parser.parse(e, r ?? this.defaults);
  }
  #e(e, r) {
    return (n, s) => {
      const h = { ...s }, b = { ...this.defaults, ...h };
      this.defaults.async === !0 && h.async === !1 && (b.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), b.async = !0);
      const g = this.#t(!!b.silent, !!b.async);
      if (typeof n > "u" || n === null)
        return g(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string")
        return g(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      if (b.hooks && (b.hooks.options = b), b.async)
        return Promise.resolve(b.hooks ? b.hooks.preprocess(n) : n).then((_) => e(_, b)).then((_) => b.hooks ? b.hooks.processAllTokens(_) : _).then((_) => b.walkTokens ? Promise.all(this.walkTokens(_, b.walkTokens)).then(() => _) : _).then((_) => r(_, b)).then((_) => b.hooks ? b.hooks.postprocess(_) : _).catch(g);
      try {
        b.hooks && (n = b.hooks.preprocess(n));
        let _ = e(n, b);
        b.hooks && (_ = b.hooks.processAllTokens(_)), b.walkTokens && this.walkTokens(_, b.walkTokens);
        let A = r(_, b);
        return b.hooks && (A = b.hooks.postprocess(A)), A;
      } catch (_) {
        return g(_);
      }
    };
  }
  #t(e, r) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        const s = "<p>An error occurred:</p><pre>" + escape$1(n.message + "", !0) + "</pre>";
        return r ? Promise.resolve(s) : s;
      }
      if (r)
        return Promise.reject(n);
      throw n;
    };
  }
}
const markedInstance = new Marked();
function marked(a, e) {
  return markedInstance.parse(a, e);
}
marked.options = marked.setOptions = function(a) {
  return markedInstance.setOptions(a), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...a) {
  return markedInstance.use(...a), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.walkTokens = function(a, e) {
  return markedInstance.walkTokens(a, e);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
const regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g, own = Object.hasOwnProperty;
class BananaSlug {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences, this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(e, r) {
    const n = this;
    let s = slug(e, r === !0);
    const h = s;
    for (; own.call(n.occurrences, s); )
      n.occurrences[h]++, s = h + "-" + n.occurrences[h];
    return n.occurrences[s] = 0, s;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
}
function slug(a, e) {
  return typeof a != "string" ? "" : (e || (a = a.toLowerCase()), a.replace(regex, "").replace(/ /g, "-"));
}
new BananaSlug();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var prism = { exports: {} };
(function(a) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var r = function(n) {
    var s = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, h = 0, b = {}, g = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: n.Prism && n.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function w(M) {
          return M instanceof _ ? new _(M.type, w(M.content), M.alias) : Array.isArray(M) ? M.map(w) : M.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(w) {
          return Object.prototype.toString.call(w).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(w) {
          return w.__id || Object.defineProperty(w, "__id", { value: ++h }), w.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function w(M, F) {
          F = F || {};
          var m, E;
          switch (g.util.type(M)) {
            case "Object":
              if (E = g.util.objId(M), F[E])
                return F[E];
              m = /** @type {Record<string, any>} */
              {}, F[E] = m;
              for (var z in M)
                M.hasOwnProperty(z) && (m[z] = w(M[z], F));
              return (
                /** @type {any} */
                m
              );
            case "Array":
              return E = g.util.objId(M), F[E] ? F[E] : (m = [], F[E] = m, /** @type {Array} */
              /** @type {any} */
              M.forEach(function(O, R) {
                m[R] = w(O, F);
              }), /** @type {any} */
              m);
            default:
              return M;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(w) {
          for (; w; ) {
            var M = s.exec(w.className);
            if (M)
              return M[1].toLowerCase();
            w = w.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(w, M) {
          w.className = w.className.replace(RegExp(s, "gi"), ""), w.classList.add("language-" + M);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (m) {
            var w = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(m.stack) || [])[1];
            if (w) {
              var M = document.getElementsByTagName("script");
              for (var F in M)
                if (M[F].src == w)
                  return M[F];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(w, M, F) {
          for (var m = "no-" + M; w; ) {
            var E = w.classList;
            if (E.contains(M))
              return !0;
            if (E.contains(m))
              return !1;
            w = w.parentElement;
          }
          return !!F;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: b,
        plaintext: b,
        text: b,
        txt: b,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(w, M) {
          var F = g.util.clone(g.languages[w]);
          for (var m in M)
            F[m] = M[m];
          return F;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(w, M, F, m) {
          m = m || /** @type {any} */
          g.languages;
          var E = m[w], z = {};
          for (var O in E)
            if (E.hasOwnProperty(O)) {
              if (O == M)
                for (var R in F)
                  F.hasOwnProperty(R) && (z[R] = F[R]);
              F.hasOwnProperty(O) || (z[O] = E[O]);
            }
          var B = m[w];
          return m[w] = z, g.languages.DFS(g.languages, function(P, W) {
            W === B && P != w && (this[P] = z);
          }), z;
        },
        // Traverse a language definition with Depth First Search
        DFS: function w(M, F, m, E) {
          E = E || {};
          var z = g.util.objId;
          for (var O in M)
            if (M.hasOwnProperty(O)) {
              F.call(M, O, M[O], m || O);
              var R = M[O], B = g.util.type(R);
              B === "Object" && !E[z(R)] ? (E[z(R)] = !0, w(R, F, null, E)) : B === "Array" && !E[z(R)] && (E[z(R)] = !0, w(R, F, O, E));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(w, M) {
        g.highlightAllUnder(document, w, M);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(w, M, F) {
        var m = {
          callback: F,
          container: w,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        g.hooks.run("before-highlightall", m), m.elements = Array.prototype.slice.apply(m.container.querySelectorAll(m.selector)), g.hooks.run("before-all-elements-highlight", m);
        for (var E = 0, z; z = m.elements[E++]; )
          g.highlightElement(z, M === !0, m.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(w, M, F) {
        var m = g.util.getLanguage(w), E = g.languages[m];
        g.util.setLanguage(w, m);
        var z = w.parentElement;
        z && z.nodeName.toLowerCase() === "pre" && g.util.setLanguage(z, m);
        var O = w.textContent, R = {
          element: w,
          language: m,
          grammar: E,
          code: O
        };
        function B(W) {
          R.highlightedCode = W, g.hooks.run("before-insert", R), R.element.innerHTML = R.highlightedCode, g.hooks.run("after-highlight", R), g.hooks.run("complete", R), F && F.call(R.element);
        }
        if (g.hooks.run("before-sanity-check", R), z = R.element.parentElement, z && z.nodeName.toLowerCase() === "pre" && !z.hasAttribute("tabindex") && z.setAttribute("tabindex", "0"), !R.code) {
          g.hooks.run("complete", R), F && F.call(R.element);
          return;
        }
        if (g.hooks.run("before-highlight", R), !R.grammar) {
          B(g.util.encode(R.code));
          return;
        }
        if (M && n.Worker) {
          var P = new Worker(g.filename);
          P.onmessage = function(W) {
            B(W.data);
          }, P.postMessage(JSON.stringify({
            language: R.language,
            code: R.code,
            immediateClose: !0
          }));
        } else
          B(g.highlight(R.code, R.grammar, R.language));
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(w, M, F) {
        var m = {
          code: w,
          grammar: M,
          language: F
        };
        if (g.hooks.run("before-tokenize", m), !m.grammar)
          throw new Error('The language "' + m.language + '" has no grammar.');
        return m.tokens = g.tokenize(m.code, m.grammar), g.hooks.run("after-tokenize", m), _.stringify(g.util.encode(m.tokens), m.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(w, M) {
        var F = M.rest;
        if (F) {
          for (var m in F)
            M[m] = F[m];
          delete M.rest;
        }
        var E = new k();
        return $(E, E.head, w), x(w, E, M, E.head, 0), L(E);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(w, M) {
          var F = g.hooks.all;
          F[w] = F[w] || [], F[w].push(M);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(w, M) {
          var F = g.hooks.all[w];
          if (!(!F || !F.length))
            for (var m = 0, E; E = F[m++]; )
              E(M);
        }
      },
      Token: _
    };
    n.Prism = g;
    function _(w, M, F, m) {
      this.type = w, this.content = M, this.alias = F, this.length = (m || "").length | 0;
    }
    _.stringify = function w(M, F) {
      if (typeof M == "string")
        return M;
      if (Array.isArray(M)) {
        var m = "";
        return M.forEach(function(B) {
          m += w(B, F);
        }), m;
      }
      var E = {
        type: M.type,
        content: w(M.content, F),
        tag: "span",
        classes: ["token", M.type],
        attributes: {},
        language: F
      }, z = M.alias;
      z && (Array.isArray(z) ? Array.prototype.push.apply(E.classes, z) : E.classes.push(z)), g.hooks.run("wrap", E);
      var O = "";
      for (var R in E.attributes)
        O += " " + R + '="' + (E.attributes[R] || "").replace(/"/g, "&quot;") + '"';
      return "<" + E.tag + ' class="' + E.classes.join(" ") + '"' + O + ">" + E.content + "</" + E.tag + ">";
    };
    function A(w, M, F, m) {
      w.lastIndex = M;
      var E = w.exec(F);
      if (E && m && E[1]) {
        var z = E[1].length;
        E.index += z, E[0] = E[0].slice(z);
      }
      return E;
    }
    function x(w, M, F, m, E, z) {
      for (var O in F)
        if (!(!F.hasOwnProperty(O) || !F[O])) {
          var R = F[O];
          R = Array.isArray(R) ? R : [R];
          for (var B = 0; B < R.length; ++B) {
            if (z && z.cause == O + "," + B)
              return;
            var P = R[B], W = P.inside, U = !!P.lookbehind, V = !!P.greedy, K = P.alias;
            if (V && !P.pattern.global) {
              var q = P.pattern.toString().match(/[imsuy]*$/)[0];
              P.pattern = RegExp(P.pattern.source, q + "g");
            }
            for (var H = P.pattern || P, j = m.next, Q = E; j !== M.tail && !(z && Q >= z.reach); Q += j.value.length, j = j.next) {
              var J = j.value;
              if (M.length > w.length)
                return;
              if (!(J instanceof _)) {
                var Y = 1, ee;
                if (V) {
                  if (ee = A(H, Q, w, U), !ee || ee.index >= w.length)
                    break;
                  var we = ee.index, fe = ee.index + ee[0].length, me = Q;
                  for (me += j.value.length; we >= me; )
                    j = j.next, me += j.value.length;
                  if (me -= j.value.length, Q = me, j.value instanceof _)
                    continue;
                  for (var he = j; he !== M.tail && (me < fe || typeof he.value == "string"); he = he.next)
                    Y++, me += he.value.length;
                  Y--, J = w.slice(Q, me), ee.index -= Q;
                } else if (ee = A(H, 0, J, U), !ee)
                  continue;
                var we = ee.index, ye = ee[0], ve = J.slice(0, we), ce = J.slice(we + ye.length), be = Q + J.length;
                z && be > z.reach && (z.reach = be);
                var le = j.prev;
                ve && (le = $(M, le, ve), Q += ve.length), C(M, le, Y);
                var Se = new _(O, W ? g.tokenize(ye, W) : ye, K, ye);
                if (j = $(M, le, Se), ce && $(M, j, ce), Y > 1) {
                  var ge = {
                    cause: O + "," + B,
                    reach: be
                  };
                  x(w, M, F, j.prev, Q, ge), z && ge.reach > z.reach && (z.reach = ge.reach);
                }
              }
            }
          }
        }
    }
    function k() {
      var w = { value: null, prev: null, next: null }, M = { value: null, prev: w, next: null };
      w.next = M, this.head = w, this.tail = M, this.length = 0;
    }
    function $(w, M, F) {
      var m = M.next, E = { value: F, prev: M, next: m };
      return M.next = E, m.prev = E, w.length++, E;
    }
    function C(w, M, F) {
      for (var m = M.next, E = 0; E < F && m !== w.tail; E++)
        m = m.next;
      M.next = m, m.prev = M, w.length -= E;
    }
    function L(w) {
      for (var M = [], F = w.head.next; F !== w.tail; )
        M.push(F.value), F = F.next;
      return M;
    }
    if (!n.document)
      return n.addEventListener && (g.disableWorkerMessageHandler || n.addEventListener("message", function(w) {
        var M = JSON.parse(w.data), F = M.language, m = M.code, E = M.immediateClose;
        n.postMessage(g.highlight(m, g.languages[F], F)), E && n.close();
      }, !1)), g;
    var y = g.util.currentScript();
    y && (g.filename = y.src, y.hasAttribute("data-manual") && (g.manual = !0));
    function o() {
      g.manual || g.highlightAll();
    }
    if (!g.manual) {
      var v = document.readyState;
      v === "loading" || v === "interactive" && y && y.defer ? document.addEventListener("DOMContentLoaded", o) : window.requestAnimationFrame ? window.requestAnimationFrame(o) : window.setTimeout(o, 16);
    }
    return g;
  }(e);
  a.exports && (a.exports = r), typeof commonjsGlobal < "u" && (commonjsGlobal.Prism = r), r.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(n) {
    n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(s, h) {
      var b = {};
      b["language-" + h] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: r.languages[h]
      }, b.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var g = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: b
        }
      };
      g["language-" + h] = {
        pattern: /[\s\S]+/,
        inside: r.languages[h]
      };
      var _ = {};
      _[s] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return s;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: g
      }, r.languages.insertBefore("markup", "cdata", _);
    }
  }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(n, s) {
      r.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [s, "language-" + s],
                inside: r.languages[s]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(n) {
    var s = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    n.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + s.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + s.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + s.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + s.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: s,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, n.languages.css.atrule.inside.rest = n.languages.css;
    var h = n.languages.markup;
    h && (h.tag.addInlined("style", "css"), h.tag.addAttribute("style", "css"));
  }(r), r.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, r.languages.javascript = r.languages.extend("clike", {
    "class-name": [
      r.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: r.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: r.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), r.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: r.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), r.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), r.languages.js = r.languages.javascript, function() {
    if (typeof r > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var n = "Loading…", s = function(y, o) {
      return "✖ Error " + y + " while fetching file: " + o;
    }, h = "✖ Error: File does not exist or is empty", b = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, g = "data-src-status", _ = "loading", A = "loaded", x = "failed", k = "pre[data-src]:not([" + g + '="' + A + '"]):not([' + g + '="' + _ + '"])';
    function $(y, o, v) {
      var w = new XMLHttpRequest();
      w.open("GET", y, !0), w.onreadystatechange = function() {
        w.readyState == 4 && (w.status < 400 && w.responseText ? o(w.responseText) : w.status >= 400 ? v(s(w.status, w.statusText)) : v(h));
      }, w.send(null);
    }
    function C(y) {
      var o = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(y || "");
      if (o) {
        var v = Number(o[1]), w = o[2], M = o[3];
        return w ? M ? [v, Number(M)] : [v, void 0] : [v, v];
      }
    }
    r.hooks.add("before-highlightall", function(y) {
      y.selector += ", " + k;
    }), r.hooks.add("before-sanity-check", function(y) {
      var o = (
        /** @type {HTMLPreElement} */
        y.element
      );
      if (o.matches(k)) {
        y.code = "", o.setAttribute(g, _);
        var v = o.appendChild(document.createElement("CODE"));
        v.textContent = n;
        var w = o.getAttribute("data-src"), M = y.language;
        if (M === "none") {
          var F = (/\.(\w+)$/.exec(w) || [, "none"])[1];
          M = b[F] || F;
        }
        r.util.setLanguage(v, M), r.util.setLanguage(o, M);
        var m = r.plugins.autoloader;
        m && m.loadLanguages(M), $(
          w,
          function(E) {
            o.setAttribute(g, A);
            var z = C(o.getAttribute("data-range"));
            if (z) {
              var O = E.split(/\r\n?|\n/g), R = z[0], B = z[1] == null ? O.length : z[1];
              R < 0 && (R += O.length), R = Math.max(0, Math.min(R - 1, O.length)), B < 0 && (B += O.length), B = Math.max(0, Math.min(B, O.length)), E = O.slice(R, B).join(`
`), o.hasAttribute("data-start") || o.setAttribute("data-start", String(R + 1));
            }
            v.textContent = E, r.highlightElement(v);
          },
          function(E) {
            o.setAttribute(g, x), v.textContent = E;
          }
        );
      }
    }), r.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function(o) {
        for (var v = (o || document).querySelectorAll(k), w = 0, M; M = v[w++]; )
          r.highlightElement(M);
      }
    };
    var L = !1;
    r.fileHighlight = function() {
      L || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), L = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(prism);
Prism.languages.python = {
  comment: {
    pattern: /(^|[^\\])#.*/,
    lookbehind: !0,
    greedy: !0
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: !0,
    inside: {
      interpolation: {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: !0,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: !0
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      string: /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: !0,
    alias: "string"
  },
  string: {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: !0
  },
  function: {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: !0
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: !0
  },
  decorator: {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: !0,
    alias: ["annotation", "punctuation"],
    inside: {
      punctuation: /\./
    }
  },
  keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  boolean: /\b(?:False|None|True)\b/,
  number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
(function(a) {
  var e = /\\(?:[^a-z()[\]]|[a-z*]+)/i, r = {
    "equation-command": {
      pattern: e,
      alias: "regex"
    }
  };
  a.languages.latex = {
    comment: /%.*/,
    // the verbatim environment prints whitespace to the document
    cdata: {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: !0
    },
    /*
     * equations can be between $$ $$ or $ $ or \( \) or \[ \]
     * (all are multiline)
     */
    equation: [
      {
        pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
        inside: r,
        alias: "string"
      },
      {
        pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
        lookbehind: !0,
        inside: r,
        alias: "string"
      }
    ],
    /*
     * arguments which are keywords or references are highlighted
     * as keywords
     */
    keyword: {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: !0
    },
    url: {
      pattern: /(\\url\{)[^}]+(?=\})/,
      lookbehind: !0
    },
    /*
     * section or chapter headlines are highlighted as bold so that
     * they stand out more
     */
    headline: {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: !0,
      alias: "class-name"
    },
    function: {
      pattern: e,
      alias: "selector"
    },
    punctuation: /[[\]{}&]/
  }, a.languages.tex = a.languages.latex, a.languages.context = a.languages.latex;
})(Prism);
(function(a) {
  var e = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", r = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: !0,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  }, n = {
    bash: r,
    environment: {
      pattern: RegExp("\\$" + e),
      alias: "constant"
    },
    variable: [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: !0,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          variable: [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: !0
            },
            /^\$\(\(/
          ],
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          punctuation: /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: !0,
        inside: {
          variable: /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: !0,
        inside: {
          operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          punctuation: /[\[\]]/,
          environment: {
            pattern: RegExp("(\\{)" + e),
            lookbehind: !0,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  a.languages.bash = {
    shebang: {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    comment: {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: !0
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: !0,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: !0
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        environment: {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + e),
          lookbehind: !0,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: !0
    },
    // Highlight parameter names as variables
    parameter: {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: !0
    },
    string: [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: !0,
        greedy: !0,
        inside: n
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          bash: r
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: !0,
        greedy: !0,
        inside: n
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: !0,
        greedy: !0
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          entity: n.entity
        }
      }
    ],
    environment: {
      pattern: RegExp("\\$?" + e),
      alias: "constant"
    },
    variable: n.variable,
    function: {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    keyword: {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    builtin: {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: !0,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    boolean: {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    operator: {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    number: {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: !0
    }
  }, r.inside = a.languages.bash;
  for (var s = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ], h = n.variable[1].inside, b = 0; b < s.length; b++)
    h[s[b]] = a.languages.bash[s[b]];
  a.languages.sh = a.languages.bash, a.languages.shell = a.languages.bash;
})(Prism);
new BananaSlug();
const mergeMaps = (a) => {
  const e = {};
  for (let r = 0, n = a.length; r < n; r++) {
    const s = a[r];
    for (const h in s)
      e[h] ? e[h] = e[h].concat(s[h]) : e[h] = s[h];
  }
  return e;
}, HTML_ELEMENTS_ALLOW = [
  "a",
  "abbr",
  "acronym",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "bdi",
  "bdo",
  "bgsound",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "listing",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "nav",
  "nobr",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "popup",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "section",
  "select",
  "selectmenu",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
], SVG_ELEMENTS_ALLOW = [
  "svg",
  "a",
  "altglyph",
  "altglyphdef",
  "altglyphitem",
  "animatecolor",
  "animatemotion",
  "animatetransform",
  "circle",
  "clippath",
  "defs",
  "desc",
  "ellipse",
  "filter",
  "font",
  "g",
  "glyph",
  "glyphref",
  "hkern",
  "image",
  "line",
  "lineargradient",
  "marker",
  "mask",
  "metadata",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialgradient",
  "rect",
  "stop",
  "style",
  "switch",
  "symbol",
  "text",
  "textpath",
  "title",
  "tref",
  "tspan",
  "view",
  "vkern",
  /* FILTERS */
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence"
], MATH_ELEMENTS_ALLOW = [
  "math",
  "menclose",
  "merror",
  "mfenced",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msup",
  "msubsup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover"
], HTML_ATTRIBUTES_ALLOW = [
  "abbr",
  "accept",
  "accept-charset",
  "accesskey",
  "action",
  "align",
  "alink",
  "allow",
  "allowfullscreen",
  "alt",
  "anchor",
  "archive",
  "as",
  "async",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "autopictureinpicture",
  "autoplay",
  "axis",
  "background",
  "behavior",
  "bgcolor",
  "border",
  "bordercolor",
  "capture",
  "cellpadding",
  "cellspacing",
  "challenge",
  "char",
  "charoff",
  "charset",
  "checked",
  "cite",
  "class",
  "classid",
  "clear",
  "code",
  "codebase",
  "codetype",
  "color",
  "cols",
  "colspan",
  "compact",
  "content",
  "contenteditable",
  "controls",
  "controlslist",
  "conversiondestination",
  "coords",
  "crossorigin",
  "csp",
  "data",
  "datetime",
  "declare",
  "decoding",
  "default",
  "defer",
  "dir",
  "direction",
  "dirname",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "disallowdocumentaccess",
  "download",
  "draggable",
  "elementtiming",
  "enctype",
  "end",
  "enterkeyhint",
  "event",
  "exportparts",
  "face",
  "for",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "frame",
  "frameborder",
  "headers",
  "height",
  "hidden",
  "high",
  "href",
  "hreflang",
  "hreftranslate",
  "hspace",
  "http-equiv",
  "id",
  "imagesizes",
  "imagesrcset",
  "importance",
  "impressiondata",
  "impressionexpiry",
  "incremental",
  "inert",
  "inputmode",
  "integrity",
  "invisible",
  "ismap",
  "keytype",
  "kind",
  "label",
  "lang",
  "language",
  "latencyhint",
  "leftmargin",
  "link",
  "list",
  "loading",
  "longdesc",
  "loop",
  "low",
  "lowsrc",
  "manifest",
  "marginheight",
  "marginwidth",
  "max",
  "maxlength",
  "mayscript",
  "media",
  "method",
  "min",
  "minlength",
  "multiple",
  "muted",
  "name",
  "nohref",
  "nomodule",
  "nonce",
  "noresize",
  "noshade",
  "novalidate",
  "nowrap",
  "object",
  "open",
  "optimum",
  "part",
  "pattern",
  "ping",
  "placeholder",
  "playsinline",
  "policy",
  "poster",
  "preload",
  "pseudo",
  "readonly",
  "referrerpolicy",
  "rel",
  "reportingorigin",
  "required",
  "resources",
  "rev",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "rules",
  "sandbox",
  "scheme",
  "scope",
  "scopes",
  "scrollamount",
  "scrolldelay",
  "scrolling",
  "select",
  "selected",
  "shadowroot",
  "shadowrootdelegatesfocus",
  "shape",
  "size",
  "sizes",
  "slot",
  "span",
  "spellcheck",
  "src",
  "srclang",
  "srcset",
  "standby",
  "start",
  "step",
  "style",
  "summary",
  "tabindex",
  "target",
  "text",
  "title",
  "topmargin",
  "translate",
  "truespeed",
  "trusttoken",
  "type",
  "usemap",
  "valign",
  "value",
  "valuetype",
  "version",
  "virtualkeyboardpolicy",
  "vlink",
  "vspace",
  "webkitdirectory",
  "width",
  "wrap"
], SVG_ATTRIBUTES_ALLOW = [
  "accent-height",
  "accumulate",
  "additive",
  "alignment-baseline",
  "ascent",
  "attributename",
  "attributetype",
  "azimuth",
  "basefrequency",
  "baseline-shift",
  "begin",
  "bias",
  "by",
  "class",
  "clip",
  "clippathunits",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "diffuseconstant",
  "direction",
  "display",
  "divisor",
  "dominant-baseline",
  "dur",
  "edgemode",
  "elevation",
  "end",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "filterunits",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyph-name",
  "glyphref",
  "gradientunits",
  "gradienttransform",
  "height",
  "href",
  "id",
  "image-rendering",
  "in",
  "in2",
  "k",
  "k1",
  "k2",
  "k3",
  "k4",
  "kerning",
  "keypoints",
  "keysplines",
  "keytimes",
  "lang",
  "lengthadjust",
  "letter-spacing",
  "kernelmatrix",
  "kernelunitlength",
  "lighting-color",
  "local",
  "marker-end",
  "marker-mid",
  "marker-start",
  "markerheight",
  "markerunits",
  "markerwidth",
  "maskcontentunits",
  "maskunits",
  "max",
  "mask",
  "media",
  "method",
  "mode",
  "min",
  "name",
  "numoctaves",
  "offset",
  "operator",
  "opacity",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "paint-order",
  "path",
  "pathlength",
  "patterncontentunits",
  "patterntransform",
  "patternunits",
  "points",
  "preservealpha",
  "preserveaspectratio",
  "primitiveunits",
  "r",
  "rx",
  "ry",
  "radius",
  "refx",
  "refy",
  "repeatcount",
  "repeatdur",
  "restart",
  "result",
  "rotate",
  "scale",
  "seed",
  "shape-rendering",
  "specularconstant",
  "specularexponent",
  "spreadmethod",
  "startoffset",
  "stddeviation",
  "stitchtiles",
  "stop-color",
  "stop-opacity",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke",
  "stroke-width",
  "style",
  "surfacescale",
  "systemlanguage",
  "tabindex",
  "targetx",
  "targety",
  "transform",
  "transform-origin",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "textlength",
  "type",
  "u1",
  "u2",
  "unicode",
  "values",
  "viewbox",
  "visibility",
  "version",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "width",
  "word-spacing",
  "wrap",
  "writing-mode",
  "xchannelselector",
  "ychannelselector",
  "x",
  "x1",
  "x2",
  "xmlns",
  "y",
  "y1",
  "y2",
  "z",
  "zoomandpan"
], MATH_ATTRIBUTES_ALLOW = [
  "accent",
  "accentunder",
  "align",
  "bevelled",
  "close",
  "columnsalign",
  "columnlines",
  "columnspan",
  "denomalign",
  "depth",
  "dir",
  "display",
  "displaystyle",
  "encoding",
  "fence",
  "frame",
  "height",
  "href",
  "id",
  "largeop",
  "length",
  "linethickness",
  "lspace",
  "lquote",
  "mathbackground",
  "mathcolor",
  "mathsize",
  "mathvariant",
  "maxsize",
  "minsize",
  "movablelimits",
  "notation",
  "numalign",
  "open",
  "rowalign",
  "rowlines",
  "rowspacing",
  "rowspan",
  "rspace",
  "rquote",
  "scriptlevel",
  "scriptminsize",
  "scriptsizemultiplier",
  "selection",
  "separator",
  "separators",
  "stretchy",
  "subscriptshift",
  "supscriptshift",
  "symmetric",
  "voffset",
  "width",
  "xmlns"
];
[
  ...HTML_ELEMENTS_ALLOW,
  ...SVG_ELEMENTS_ALLOW.map((a) => `svg:${a}`),
  ...MATH_ELEMENTS_ALLOW.map((a) => `math:${a}`)
], mergeMaps([
  Object.fromEntries(HTML_ATTRIBUTES_ALLOW.map((a) => [a, ["*"]])),
  Object.fromEntries(SVG_ATTRIBUTES_ALLOW.map((a) => [a, ["svg:*"]])),
  Object.fromEntries(MATH_ATTRIBUTES_ALLOW.map((a) => [a, ["math:*"]]))
]);
function t() {
}
const u = typeof window < "u";
let c = u ? () => window.performance.now() : () => Date.now(), f = u ? (a) => requestAnimationFrame(a) : t;
const p = /* @__PURE__ */ new Set();
function l(a) {
  p.forEach((e) => {
    e.c(a) || (p.delete(e), e.f());
  }), p.size !== 0 && f(l);
}
function d(a) {
  let e;
  return p.size === 0 && f(l), { promise: new Promise((r) => {
    p.add(e = { c: a, f: r });
  }), abort() {
    p.delete(e);
  } };
}
const X = [];
function Z(a, e = t) {
  let r;
  const n = /* @__PURE__ */ new Set();
  function s(b) {
    if (_ = b, ((g = a) != g ? _ == _ : g !== _ || g && typeof g == "object" || typeof g == "function") && (a = b, r)) {
      const A = !X.length;
      for (const x of n) x[1](), X.push(x, a);
      if (A) {
        for (let x = 0; x < X.length; x += 2) X[x][0](X[x + 1]);
        X.length = 0;
      }
    }
    var g, _;
  }
  function h(b) {
    s(b(a));
  }
  return { set: s, update: h, subscribe: function(b, g = t) {
    const _ = [b, g];
    return n.add(_), n.size === 1 && (r = e(s, h) || t), b(a), () => {
      n.delete(_), n.size === 0 && r && (r(), r = null);
    };
  } };
}
function et(a) {
  return Object.prototype.toString.call(a) === "[object Date]";
}
function rt(a, e, r, n) {
  if (typeof r == "number" || et(r)) {
    const s = n - r, h = (r - e) / (a.dt || 1 / 60), b = (h + (a.opts.stiffness * s - a.opts.damping * h) * a.inv_mass) * a.dt;
    return Math.abs(b) < a.opts.precision && Math.abs(s) < a.opts.precision ? n : (a.settled = !1, et(r) ? new Date(r.getTime() + b) : r + b);
  }
  if (Array.isArray(r)) return r.map((s, h) => rt(a, e[h], r[h], n[h]));
  if (typeof r == "object") {
    const s = {};
    for (const h in r) s[h] = rt(a, e[h], r[h], n[h]);
    return s;
  }
  throw new Error(`Cannot spring ${typeof r} values`);
}
function ot(a, e = {}) {
  const r = Z(a), { stiffness: n = 0.15, damping: s = 0.8, precision: h = 0.01 } = e;
  let b, g, _, A = a, x = a, k = 1, $ = 0, C = !1;
  function L(o, v = {}) {
    x = o;
    const w = _ = {};
    return a == null || v.hard || y.stiffness >= 1 && y.damping >= 1 ? (C = !0, b = c(), A = o, r.set(a = x), Promise.resolve()) : (v.soft && ($ = 1 / (60 * (v.soft === !0 ? 0.5 : +v.soft)), k = 0), g || (b = c(), C = !1, g = d((M) => {
      if (C) return C = !1, g = null, !1;
      k = Math.min(k + $, 1);
      const F = { inv_mass: k, opts: y, settled: !0, dt: 60 * (M - b) / 1e3 }, m = rt(F, A, a, x);
      return b = M, A = a, r.set(a = m), F.settled && (g = null), !F.settled;
    })), new Promise((M) => {
      g.promise.then(() => {
        w === _ && M();
      });
    }));
  }
  const y = { set: L, update: (o, v) => L(o(x, a), v), subscribe: r.subscribe, stiffness: n, damping: s, precision: h };
  return y;
}
/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object, {
  apply,
  construct
} = typeof Reflect < "u" && Reflect;
freeze || (freeze = function(e) {
  return e;
});
seal || (seal = function(e) {
  return e;
});
apply || (apply = function(e, r, n) {
  return e.apply(r, n);
});
construct || (construct = function(e, r) {
  return new e(...r);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(a) {
  return function(e) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
      n[s - 1] = arguments[s];
    return apply(a, e, n);
  };
}
function unconstruct(a) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return construct(a, r);
  };
}
function addToSet(a, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(a, null);
  let n = e.length;
  for (; n--; ) {
    let s = e[n];
    if (typeof s == "string") {
      const h = r(s);
      h !== s && (isFrozen(e) || (e[n] = h), s = h);
    }
    a[s] = !0;
  }
  return a;
}
function cleanArray(a) {
  for (let e = 0; e < a.length; e++)
    objectHasOwnProperty(a, e) || (a[e] = null);
  return a;
}
function clone(a) {
  const e = create(null);
  for (const [r, n] of entries(a))
    objectHasOwnProperty(a, r) && (Array.isArray(n) ? e[r] = cleanArray(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = clone(n) : e[r] = n);
  return e;
}
function lookupGetter(a, e) {
  for (; a !== null; ) {
    const n = getOwnPropertyDescriptor(a, e);
    if (n) {
      if (n.get)
        return unapply(n.get);
      if (typeof n.value == "function")
        return unapply(n.value);
    }
    a = getPrototypeOf(a);
  }
  function r() {
    return null;
  }
  return r;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$9 = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i), CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME,
  CUSTOM_ELEMENT
});
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
}, getGlobal = function() {
  return typeof window > "u" ? null : window;
}, _createTrustedTypesPolicy = function(e, r) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const s = "data-tt-policy-suffix";
  r && r.hasAttribute(s) && (n = r.getAttribute(s));
  const h = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(h, {
      createHTML(b) {
        return b;
      },
      createScriptURL(b) {
        return b;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + h + " could not be created."), null;
  }
};
function createDOMPurify() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const e = (ct) => createDOMPurify(ct);
  if (e.version = "3.1.7", e.removed = [], !a || !a.document || a.document.nodeType !== NODE_TYPE.document)
    return e.isSupported = !1, e;
  let {
    document: r
  } = a;
  const n = r, s = n.currentScript, {
    DocumentFragment: h,
    HTMLTemplateElement: b,
    Node: g,
    Element: _,
    NodeFilter: A,
    NamedNodeMap: x = a.NamedNodeMap || a.MozNamedAttrMap,
    HTMLFormElement: k,
    DOMParser: $,
    trustedTypes: C
  } = a, L = _.prototype, y = lookupGetter(L, "cloneNode"), o = lookupGetter(L, "remove"), v = lookupGetter(L, "nextSibling"), w = lookupGetter(L, "childNodes"), M = lookupGetter(L, "parentNode");
  if (typeof b == "function") {
    const ct = r.createElement("template");
    ct.content && ct.content.ownerDocument && (r = ct.content.ownerDocument);
  }
  let F, m = "";
  const {
    implementation: E,
    createNodeIterator: z,
    createDocumentFragment: O,
    getElementsByTagName: R
  } = r, {
    importNode: B
  } = n;
  let P = {};
  e.isSupported = typeof entries == "function" && typeof M == "function" && E && E.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: W,
    ERB_EXPR: U,
    TMPLIT_EXPR: V,
    DATA_ATTR: K,
    ARIA_ATTR: q,
    IS_SCRIPT_OR_DATA: H,
    ATTR_WHITESPACE: j,
    CUSTOM_ELEMENT: Q
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: J
  } = EXPRESSIONS, Y = null;
  const ee = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text$9]);
  let fe = null;
  const me = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let he = Object.seal(create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), we = null, ye = null, ve = !0, ce = !0, be = !1, le = !0, Se = !1, ge = !0, de = !1, De = !1, Be = !1, Ve = !1, qe = !1, Ze = !1, Ye = !0, Xe = !1;
  const Ge = "user-content-";
  let Ke = !0, Pe = !1, it = {}, nt = null;
  const ne = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let se = null;
  const ue = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let $e = null;
  const Ae = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), je = "http://www.w3.org/1998/Math/MathML", ze = "http://www.w3.org/2000/svg", re = "http://www.w3.org/1999/xhtml";
  let xe = re, Le = !1, He = null;
  const Me = addToSet({}, [je, ze, re], stringToString);
  let Re = null;
  const ie = ["application/xhtml+xml", "text/html"], We = "text/html";
  let Qe = null, G = null;
  const Fe = r.createElement("form"), Te = function(ke) {
    return ke instanceof RegExp || ke instanceof Function;
  }, ae = function() {
    let ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(G && G === ke)) {
      if ((!ke || typeof ke != "object") && (ke = {}), ke = clone(ke), Re = // eslint-disable-next-line unicorn/prefer-includes
      ie.indexOf(ke.PARSER_MEDIA_TYPE) === -1 ? We : ke.PARSER_MEDIA_TYPE, Qe = Re === "application/xhtml+xml" ? stringToString : stringToLowerCase, Y = objectHasOwnProperty(ke, "ALLOWED_TAGS") ? addToSet({}, ke.ALLOWED_TAGS, Qe) : ee, fe = objectHasOwnProperty(ke, "ALLOWED_ATTR") ? addToSet({}, ke.ALLOWED_ATTR, Qe) : me, He = objectHasOwnProperty(ke, "ALLOWED_NAMESPACES") ? addToSet({}, ke.ALLOWED_NAMESPACES, stringToString) : Me, $e = objectHasOwnProperty(ke, "ADD_URI_SAFE_ATTR") ? addToSet(
        clone(Ae),
        // eslint-disable-line indent
        ke.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Qe
        // eslint-disable-line indent
      ) : Ae, se = objectHasOwnProperty(ke, "ADD_DATA_URI_TAGS") ? addToSet(
        clone(ue),
        // eslint-disable-line indent
        ke.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Qe
        // eslint-disable-line indent
      ) : ue, nt = objectHasOwnProperty(ke, "FORBID_CONTENTS") ? addToSet({}, ke.FORBID_CONTENTS, Qe) : ne, we = objectHasOwnProperty(ke, "FORBID_TAGS") ? addToSet({}, ke.FORBID_TAGS, Qe) : {}, ye = objectHasOwnProperty(ke, "FORBID_ATTR") ? addToSet({}, ke.FORBID_ATTR, Qe) : {}, it = objectHasOwnProperty(ke, "USE_PROFILES") ? ke.USE_PROFILES : !1, ve = ke.ALLOW_ARIA_ATTR !== !1, ce = ke.ALLOW_DATA_ATTR !== !1, be = ke.ALLOW_UNKNOWN_PROTOCOLS || !1, le = ke.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Se = ke.SAFE_FOR_TEMPLATES || !1, ge = ke.SAFE_FOR_XML !== !1, de = ke.WHOLE_DOCUMENT || !1, Ve = ke.RETURN_DOM || !1, qe = ke.RETURN_DOM_FRAGMENT || !1, Ze = ke.RETURN_TRUSTED_TYPE || !1, Be = ke.FORCE_BODY || !1, Ye = ke.SANITIZE_DOM !== !1, Xe = ke.SANITIZE_NAMED_PROPS || !1, Ke = ke.KEEP_CONTENT !== !1, Pe = ke.IN_PLACE || !1, J = ke.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, xe = ke.NAMESPACE || re, he = ke.CUSTOM_ELEMENT_HANDLING || {}, ke.CUSTOM_ELEMENT_HANDLING && Te(ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (he.tagNameCheck = ke.CUSTOM_ELEMENT_HANDLING.tagNameCheck), ke.CUSTOM_ELEMENT_HANDLING && Te(ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (he.attributeNameCheck = ke.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), ke.CUSTOM_ELEMENT_HANDLING && typeof ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (he.allowCustomizedBuiltInElements = ke.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Se && (ce = !1), qe && (Ve = !0), it && (Y = addToSet({}, text$9), fe = [], it.html === !0 && (addToSet(Y, html$1), addToSet(fe, html)), it.svg === !0 && (addToSet(Y, svg$1), addToSet(fe, svg), addToSet(fe, xml)), it.svgFilters === !0 && (addToSet(Y, svgFilters), addToSet(fe, svg), addToSet(fe, xml)), it.mathMl === !0 && (addToSet(Y, mathMl$1), addToSet(fe, mathMl), addToSet(fe, xml))), ke.ADD_TAGS && (Y === ee && (Y = clone(Y)), addToSet(Y, ke.ADD_TAGS, Qe)), ke.ADD_ATTR && (fe === me && (fe = clone(fe)), addToSet(fe, ke.ADD_ATTR, Qe)), ke.ADD_URI_SAFE_ATTR && addToSet($e, ke.ADD_URI_SAFE_ATTR, Qe), ke.FORBID_CONTENTS && (nt === ne && (nt = clone(nt)), addToSet(nt, ke.FORBID_CONTENTS, Qe)), Ke && (Y["#text"] = !0), de && addToSet(Y, ["html", "head", "body"]), Y.table && (addToSet(Y, ["tbody"]), delete we.tbody), ke.TRUSTED_TYPES_POLICY) {
        if (typeof ke.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof ke.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        F = ke.TRUSTED_TYPES_POLICY, m = F.createHTML("");
      } else
        F === void 0 && (F = _createTrustedTypesPolicy(C, s)), F !== null && typeof m == "string" && (m = F.createHTML(""));
      freeze && freeze(ke), G = ke;
    }
  }, Ee = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), Ie = addToSet({}, ["annotation-xml"]), lt = addToSet({}, ["title", "style", "font", "a", "script"]), st = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), at = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), gt = function(ke) {
    let tt = M(ke);
    (!tt || !tt.tagName) && (tt = {
      namespaceURI: xe,
      tagName: "template"
    });
    const dt = stringToLowerCase(ke.tagName), Tt = stringToLowerCase(tt.tagName);
    return He[ke.namespaceURI] ? ke.namespaceURI === ze ? tt.namespaceURI === re ? dt === "svg" : tt.namespaceURI === je ? dt === "svg" && (Tt === "annotation-xml" || Ee[Tt]) : !!st[dt] : ke.namespaceURI === je ? tt.namespaceURI === re ? dt === "math" : tt.namespaceURI === ze ? dt === "math" && Ie[Tt] : !!at[dt] : ke.namespaceURI === re ? tt.namespaceURI === ze && !Ie[Tt] || tt.namespaceURI === je && !Ee[Tt] ? !1 : !at[dt] && (lt[dt] || !st[dt]) : !!(Re === "application/xhtml+xml" && He[ke.namespaceURI]) : !1;
  }, Ot = function(ke) {
    arrayPush(e.removed, {
      element: ke
    });
    try {
      M(ke).removeChild(ke);
    } catch {
      o(ke);
    }
  }, vt = function(ke, tt) {
    try {
      arrayPush(e.removed, {
        attribute: tt.getAttributeNode(ke),
        from: tt
      });
    } catch {
      arrayPush(e.removed, {
        attribute: null,
        from: tt
      });
    }
    if (tt.removeAttribute(ke), ke === "is" && !fe[ke])
      if (Ve || qe)
        try {
          Ot(tt);
        } catch {
        }
      else
        try {
          tt.setAttribute(ke, "");
        } catch {
        }
  }, yt = function(ke) {
    let tt = null, dt = null;
    if (Be)
      ke = "<remove></remove>" + ke;
    else {
      const Ut = stringMatch(ke, /^[\r\n\t ]+/);
      dt = Ut && Ut[0];
    }
    Re === "application/xhtml+xml" && xe === re && (ke = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ke + "</body></html>");
    const Tt = F ? F.createHTML(ke) : ke;
    if (xe === re)
      try {
        tt = new $().parseFromString(Tt, Re);
      } catch {
      }
    if (!tt || !tt.documentElement) {
      tt = E.createDocument(xe, "template", null);
      try {
        tt.documentElement.innerHTML = Le ? m : Tt;
      } catch {
      }
    }
    const Wt = tt.body || tt.documentElement;
    return ke && dt && Wt.insertBefore(r.createTextNode(dt), Wt.childNodes[0] || null), xe === re ? R.call(tt, de ? "html" : "body")[0] : de ? tt.documentElement : Wt;
  }, _t = function(ke) {
    return z.call(
      ke.ownerDocument || ke,
      ke,
      // eslint-disable-next-line no-bitwise
      A.SHOW_ELEMENT | A.SHOW_COMMENT | A.SHOW_TEXT | A.SHOW_PROCESSING_INSTRUCTION | A.SHOW_CDATA_SECTION,
      null
    );
  }, Bt = function(ke) {
    return ke instanceof k && (typeof ke.nodeName != "string" || typeof ke.textContent != "string" || typeof ke.removeChild != "function" || !(ke.attributes instanceof x) || typeof ke.removeAttribute != "function" || typeof ke.setAttribute != "function" || typeof ke.namespaceURI != "string" || typeof ke.insertBefore != "function" || typeof ke.hasChildNodes != "function");
  }, Ct = function(ke) {
    return typeof g == "function" && ke instanceof g;
  }, Gt = function(ke, tt, dt) {
    P[ke] && arrayForEach(P[ke], (Tt) => {
      Tt.call(e, tt, dt, G);
    });
  }, Zt = function(ke) {
    let tt = null;
    if (Gt("beforeSanitizeElements", ke, null), Bt(ke))
      return Ot(ke), !0;
    const dt = Qe(ke.nodeName);
    if (Gt("uponSanitizeElement", ke, {
      tagName: dt,
      allowedTags: Y
    }), ke.hasChildNodes() && !Ct(ke.firstElementChild) && regExpTest(/<[/\w]/g, ke.innerHTML) && regExpTest(/<[/\w]/g, ke.textContent) || ke.nodeType === NODE_TYPE.progressingInstruction || ge && ke.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, ke.data))
      return Ot(ke), !0;
    if (!Y[dt] || we[dt]) {
      if (!we[dt] && It(dt) && (he.tagNameCheck instanceof RegExp && regExpTest(he.tagNameCheck, dt) || he.tagNameCheck instanceof Function && he.tagNameCheck(dt)))
        return !1;
      if (Ke && !nt[dt]) {
        const Tt = M(ke) || ke.parentNode, Wt = w(ke) || ke.childNodes;
        if (Wt && Tt) {
          const Ut = Wt.length;
          for (let Ht = Ut - 1; Ht >= 0; --Ht) {
            const Xt = y(Wt[Ht], !0);
            Xt.__removalCount = (ke.__removalCount || 0) + 1, Tt.insertBefore(Xt, v(ke));
          }
        }
      }
      return Ot(ke), !0;
    }
    return ke instanceof _ && !gt(ke) || (dt === "noscript" || dt === "noembed" || dt === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, ke.innerHTML) ? (Ot(ke), !0) : (Se && ke.nodeType === NODE_TYPE.text && (tt = ke.textContent, arrayForEach([W, U, V], (Tt) => {
      tt = stringReplace(tt, Tt, " ");
    }), ke.textContent !== tt && (arrayPush(e.removed, {
      element: ke.cloneNode()
    }), ke.textContent = tt)), Gt("afterSanitizeElements", ke, null), !1);
  }, zt = function(ke, tt, dt) {
    if (Ye && (tt === "id" || tt === "name") && (dt in r || dt in Fe))
      return !1;
    if (!(ce && !ye[tt] && regExpTest(K, tt))) {
      if (!(ve && regExpTest(q, tt))) {
        if (!fe[tt] || ye[tt]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(It(ke) && (he.tagNameCheck instanceof RegExp && regExpTest(he.tagNameCheck, ke) || he.tagNameCheck instanceof Function && he.tagNameCheck(ke)) && (he.attributeNameCheck instanceof RegExp && regExpTest(he.attributeNameCheck, tt) || he.attributeNameCheck instanceof Function && he.attributeNameCheck(tt)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            tt === "is" && he.allowCustomizedBuiltInElements && (he.tagNameCheck instanceof RegExp && regExpTest(he.tagNameCheck, dt) || he.tagNameCheck instanceof Function && he.tagNameCheck(dt)))
          ) return !1;
        } else if (!$e[tt]) {
          if (!regExpTest(J, stringReplace(dt, j, ""))) {
            if (!((tt === "src" || tt === "xlink:href" || tt === "href") && ke !== "script" && stringIndexOf(dt, "data:") === 0 && se[ke])) {
              if (!(be && !regExpTest(H, stringReplace(dt, j, "")))) {
                if (dt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, It = function(ke) {
    return ke !== "annotation-xml" && stringMatch(ke, Q);
  }, Lt = function(ke) {
    Gt("beforeSanitizeAttributes", ke, null);
    const {
      attributes: tt
    } = ke;
    if (!tt)
      return;
    const dt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: fe
    };
    let Tt = tt.length;
    for (; Tt--; ) {
      const Wt = tt[Tt], {
        name: Ut,
        namespaceURI: Ht,
        value: Xt
      } = Wt, rr = Qe(Ut);
      let jt = Ut === "value" ? Xt : stringTrim(Xt);
      if (dt.attrName = rr, dt.attrValue = jt, dt.keepAttr = !0, dt.forceKeepAttr = void 0, Gt("uponSanitizeAttribute", ke, dt), jt = dt.attrValue, dt.forceKeepAttr || (vt(Ut, ke), !dt.keepAttr))
        continue;
      if (!le && regExpTest(/\/>/i, jt)) {
        vt(Ut, ke);
        continue;
      }
      Se && arrayForEach([W, U, V], (Or) => {
        jt = stringReplace(jt, Or, " ");
      });
      const Fr = Qe(ke.nodeName);
      if (zt(Fr, rr, jt)) {
        if (Xe && (rr === "id" || rr === "name") && (vt(Ut, ke), jt = Ge + jt), ge && regExpTest(/((--!?|])>)|<\/(style|title)/i, jt)) {
          vt(Ut, ke);
          continue;
        }
        if (F && typeof C == "object" && typeof C.getAttributeType == "function" && !Ht)
          switch (C.getAttributeType(Fr, rr)) {
            case "TrustedHTML": {
              jt = F.createHTML(jt);
              break;
            }
            case "TrustedScriptURL": {
              jt = F.createScriptURL(jt);
              break;
            }
          }
        try {
          Ht ? ke.setAttributeNS(Ht, Ut, jt) : ke.setAttribute(Ut, jt), Bt(ke) ? Ot(ke) : arrayPop(e.removed);
        } catch {
        }
      }
    }
    Gt("afterSanitizeAttributes", ke, null);
  }, Kt = function ct(ke) {
    let tt = null;
    const dt = _t(ke);
    for (Gt("beforeSanitizeShadowDOM", ke, null); tt = dt.nextNode(); )
      Gt("uponSanitizeShadowNode", tt, null), !Zt(tt) && (tt.content instanceof h && ct(tt.content), Lt(tt));
    Gt("afterSanitizeShadowDOM", ke, null);
  };
  return e.sanitize = function(ct) {
    let ke = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, tt = null, dt = null, Tt = null, Wt = null;
    if (Le = !ct, Le && (ct = "<!-->"), typeof ct != "string" && !Ct(ct))
      if (typeof ct.toString == "function") {
        if (ct = ct.toString(), typeof ct != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!e.isSupported)
      return ct;
    if (De || ae(ke), e.removed = [], typeof ct == "string" && (Pe = !1), Pe) {
      if (ct.nodeName) {
        const Xt = Qe(ct.nodeName);
        if (!Y[Xt] || we[Xt])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (ct instanceof g)
      tt = yt("<!---->"), dt = tt.ownerDocument.importNode(ct, !0), dt.nodeType === NODE_TYPE.element && dt.nodeName === "BODY" || dt.nodeName === "HTML" ? tt = dt : tt.appendChild(dt);
    else {
      if (!Ve && !Se && !de && // eslint-disable-next-line unicorn/prefer-includes
      ct.indexOf("<") === -1)
        return F && Ze ? F.createHTML(ct) : ct;
      if (tt = yt(ct), !tt)
        return Ve ? null : Ze ? m : "";
    }
    tt && Be && Ot(tt.firstChild);
    const Ut = _t(Pe ? ct : tt);
    for (; Tt = Ut.nextNode(); )
      Zt(Tt) || (Tt.content instanceof h && Kt(Tt.content), Lt(Tt));
    if (Pe)
      return ct;
    if (Ve) {
      if (qe)
        for (Wt = O.call(tt.ownerDocument); tt.firstChild; )
          Wt.appendChild(tt.firstChild);
      else
        Wt = tt;
      return (fe.shadowroot || fe.shadowrootmode) && (Wt = B.call(n, Wt, !0)), Wt;
    }
    let Ht = de ? tt.outerHTML : tt.innerHTML;
    return de && Y["!doctype"] && tt.ownerDocument && tt.ownerDocument.doctype && tt.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, tt.ownerDocument.doctype.name) && (Ht = "<!DOCTYPE " + tt.ownerDocument.doctype.name + `>
` + Ht), Se && arrayForEach([W, U, V], (Xt) => {
      Ht = stringReplace(Ht, Xt, " ");
    }), F && Ze ? F.createHTML(Ht) : Ht;
  }, e.setConfig = function() {
    let ct = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ae(ct), De = !0;
  }, e.clearConfig = function() {
    G = null, De = !1;
  }, e.isValidAttribute = function(ct, ke, tt) {
    G || ae({});
    const dt = Qe(ct), Tt = Qe(ke);
    return zt(dt, Tt, tt);
  }, e.addHook = function(ct, ke) {
    typeof ke == "function" && (P[ct] = P[ct] || [], arrayPush(P[ct], ke));
  }, e.removeHook = function(ct) {
    if (P[ct])
      return arrayPop(P[ct]);
  }, e.removeHooks = function(ct) {
    P[ct] && (P[ct] = []);
  }, e.removeAllHooks = function() {
    P = {};
  }, e;
}
createDOMPurify();
const {
  SvelteComponent: SvelteComponent$h,
  append_hydration: append_hydration$b,
  attr: attr$c,
  children: children$d,
  claim_component: claim_component$9,
  claim_element: claim_element$d,
  claim_space: claim_space$b,
  claim_text: claim_text$8,
  create_component: create_component$9,
  destroy_component: destroy_component$9,
  detach: detach$g,
  element: element$d,
  init: init$h,
  insert_hydration: insert_hydration$g,
  mount_component: mount_component$9,
  safe_not_equal: safe_not_equal$h,
  set_data: set_data$7,
  space: space$b,
  text: text$8,
  toggle_class: toggle_class$b,
  transition_in: transition_in$d,
  transition_out: transition_out$c
} = window.__gradio__svelte__internal;
function create_fragment$g(a) {
  let e, r, n, s, h, b;
  return n = new /*Icon*/
  a[1]({}), {
    c() {
      e = element$d("label"), r = element$d("span"), create_component$9(n.$$.fragment), s = space$b(), h = text$8(
        /*label*/
        a[0]
      ), this.h();
    },
    l(g) {
      e = claim_element$d(g, "LABEL", {
        for: !0,
        "data-testid": !0,
        class: !0
      });
      var _ = children$d(e);
      r = claim_element$d(_, "SPAN", { class: !0 });
      var A = children$d(r);
      claim_component$9(n.$$.fragment, A), A.forEach(detach$g), s = claim_space$b(_), h = claim_text$8(
        _,
        /*label*/
        a[0]
      ), _.forEach(detach$g), this.h();
    },
    h() {
      attr$c(r, "class", "svelte-168uj4v"), attr$c(e, "for", ""), attr$c(e, "data-testid", "block-label"), attr$c(e, "class", "svelte-168uj4v"), toggle_class$b(e, "hide", !/*show_label*/
      a[2]), toggle_class$b(e, "sr-only", !/*show_label*/
      a[2]), toggle_class$b(
        e,
        "float",
        /*float*/
        a[4]
      ), toggle_class$b(
        e,
        "hide-label",
        /*disable*/
        a[3]
      );
    },
    m(g, _) {
      insert_hydration$g(g, e, _), append_hydration$b(e, r), mount_component$9(n, r, null), append_hydration$b(e, s), append_hydration$b(e, h), b = !0;
    },
    p(g, [_]) {
      (!b || _ & /*label*/
      1) && set_data$7(
        h,
        /*label*/
        g[0]
      ), (!b || _ & /*show_label*/
      4) && toggle_class$b(e, "hide", !/*show_label*/
      g[2]), (!b || _ & /*show_label*/
      4) && toggle_class$b(e, "sr-only", !/*show_label*/
      g[2]), (!b || _ & /*float*/
      16) && toggle_class$b(
        e,
        "float",
        /*float*/
        g[4]
      ), (!b || _ & /*disable*/
      8) && toggle_class$b(
        e,
        "hide-label",
        /*disable*/
        g[3]
      );
    },
    i(g) {
      b || (transition_in$d(n.$$.fragment, g), b = !0);
    },
    o(g) {
      transition_out$c(n.$$.fragment, g), b = !1;
    },
    d(g) {
      g && detach$g(e), destroy_component$9(n);
    }
  };
}
function instance$h(a, e, r) {
  let { label: n = null } = e, { Icon: s } = e, { show_label: h = !0 } = e, { disable: b = !1 } = e, { float: g = !0 } = e;
  return a.$$set = (_) => {
    "label" in _ && r(0, n = _.label), "Icon" in _ && r(1, s = _.Icon), "show_label" in _ && r(2, h = _.show_label), "disable" in _ && r(3, b = _.disable), "float" in _ && r(4, g = _.float);
  }, [n, s, h, b, g];
}
class BlockLabel extends SvelteComponent$h {
  constructor(e) {
    super(), init$h(this, e, instance$h, create_fragment$g, safe_not_equal$h, {
      label: 0,
      Icon: 1,
      show_label: 2,
      disable: 3,
      float: 4
    });
  }
}
const {
  SvelteComponent: SvelteComponent$g,
  append_hydration: append_hydration$a,
  attr: attr$b,
  bubble: bubble$2,
  check_outros: check_outros$9,
  children: children$c,
  claim_component: claim_component$8,
  claim_element: claim_element$c,
  claim_space: claim_space$a,
  claim_text: claim_text$7,
  construct_svelte_component,
  create_component: create_component$8,
  destroy_component: destroy_component$8,
  detach: detach$f,
  element: element$c,
  group_outros: group_outros$9,
  init: init$g,
  insert_hydration: insert_hydration$f,
  listen: listen$4,
  mount_component: mount_component$8,
  safe_not_equal: safe_not_equal$g,
  set_data: set_data$6,
  set_style: set_style$6,
  space: space$a,
  text: text$7,
  toggle_class: toggle_class$a,
  transition_in: transition_in$c,
  transition_out: transition_out$b
} = window.__gradio__svelte__internal;
function create_if_block$b(a) {
  let e, r;
  return {
    c() {
      e = element$c("span"), r = text$7(
        /*label*/
        a[1]
      ), this.h();
    },
    l(n) {
      e = claim_element$c(n, "SPAN", { class: !0 });
      var s = children$c(e);
      r = claim_text$7(
        s,
        /*label*/
        a[1]
      ), s.forEach(detach$f), this.h();
    },
    h() {
      attr$b(e, "class", "svelte-vk34kx");
    },
    m(n, s) {
      insert_hydration$f(n, e, s), append_hydration$a(e, r);
    },
    p(n, s) {
      s & /*label*/
      2 && set_data$6(
        r,
        /*label*/
        n[1]
      );
    },
    d(n) {
      n && detach$f(e);
    }
  };
}
function create_fragment$f(a) {
  let e, r, n, s, h, b, g, _ = (
    /*show_label*/
    a[2] && create_if_block$b(a)
  );
  var A = (
    /*Icon*/
    a[0]
  );
  function x(k, $) {
    return {};
  }
  return A && (s = construct_svelte_component(A, x())), {
    c() {
      e = element$c("button"), _ && _.c(), r = space$a(), n = element$c("div"), s && create_component$8(s.$$.fragment), this.h();
    },
    l(k) {
      e = claim_element$c(k, "BUTTON", {
        "aria-label": !0,
        "aria-haspopup": !0,
        title: !0,
        class: !0
      });
      var $ = children$c(e);
      _ && _.l($), r = claim_space$a($), n = claim_element$c($, "DIV", { class: !0 });
      var C = children$c(n);
      s && claim_component$8(s.$$.fragment, C), C.forEach(detach$f), $.forEach(detach$f), this.h();
    },
    h() {
      attr$b(n, "class", "svelte-vk34kx"), toggle_class$a(
        n,
        "small",
        /*size*/
        a[4] === "small"
      ), toggle_class$a(
        n,
        "large",
        /*size*/
        a[4] === "large"
      ), toggle_class$a(
        n,
        "medium",
        /*size*/
        a[4] === "medium"
      ), e.disabled = /*disabled*/
      a[7], attr$b(
        e,
        "aria-label",
        /*label*/
        a[1]
      ), attr$b(
        e,
        "aria-haspopup",
        /*hasPopup*/
        a[8]
      ), attr$b(
        e,
        "title",
        /*label*/
        a[1]
      ), attr$b(e, "class", "svelte-vk34kx"), toggle_class$a(
        e,
        "pending",
        /*pending*/
        a[3]
      ), toggle_class$a(
        e,
        "padded",
        /*padded*/
        a[5]
      ), toggle_class$a(
        e,
        "highlight",
        /*highlight*/
        a[6]
      ), toggle_class$a(
        e,
        "transparent",
        /*transparent*/
        a[9]
      ), set_style$6(e, "color", !/*disabled*/
      a[7] && /*_color*/
      a[11] ? (
        /*_color*/
        a[11]
      ) : "var(--block-label-text-color)"), set_style$6(e, "--bg-color", /*disabled*/
      a[7] ? "auto" : (
        /*background*/
        a[10]
      ));
    },
    m(k, $) {
      insert_hydration$f(k, e, $), _ && _.m(e, null), append_hydration$a(e, r), append_hydration$a(e, n), s && mount_component$8(s, n, null), h = !0, b || (g = listen$4(
        e,
        "click",
        /*click_handler*/
        a[13]
      ), b = !0);
    },
    p(k, [$]) {
      if (/*show_label*/
      k[2] ? _ ? _.p(k, $) : (_ = create_if_block$b(k), _.c(), _.m(e, r)) : _ && (_.d(1), _ = null), $ & /*Icon*/
      1 && A !== (A = /*Icon*/
      k[0])) {
        if (s) {
          group_outros$9();
          const C = s;
          transition_out$b(C.$$.fragment, 1, 0, () => {
            destroy_component$8(C, 1);
          }), check_outros$9();
        }
        A ? (s = construct_svelte_component(A, x()), create_component$8(s.$$.fragment), transition_in$c(s.$$.fragment, 1), mount_component$8(s, n, null)) : s = null;
      }
      (!h || $ & /*size*/
      16) && toggle_class$a(
        n,
        "small",
        /*size*/
        k[4] === "small"
      ), (!h || $ & /*size*/
      16) && toggle_class$a(
        n,
        "large",
        /*size*/
        k[4] === "large"
      ), (!h || $ & /*size*/
      16) && toggle_class$a(
        n,
        "medium",
        /*size*/
        k[4] === "medium"
      ), (!h || $ & /*disabled*/
      128) && (e.disabled = /*disabled*/
      k[7]), (!h || $ & /*label*/
      2) && attr$b(
        e,
        "aria-label",
        /*label*/
        k[1]
      ), (!h || $ & /*hasPopup*/
      256) && attr$b(
        e,
        "aria-haspopup",
        /*hasPopup*/
        k[8]
      ), (!h || $ & /*label*/
      2) && attr$b(
        e,
        "title",
        /*label*/
        k[1]
      ), (!h || $ & /*pending*/
      8) && toggle_class$a(
        e,
        "pending",
        /*pending*/
        k[3]
      ), (!h || $ & /*padded*/
      32) && toggle_class$a(
        e,
        "padded",
        /*padded*/
        k[5]
      ), (!h || $ & /*highlight*/
      64) && toggle_class$a(
        e,
        "highlight",
        /*highlight*/
        k[6]
      ), (!h || $ & /*transparent*/
      512) && toggle_class$a(
        e,
        "transparent",
        /*transparent*/
        k[9]
      ), $ & /*disabled, _color*/
      2176 && set_style$6(e, "color", !/*disabled*/
      k[7] && /*_color*/
      k[11] ? (
        /*_color*/
        k[11]
      ) : "var(--block-label-text-color)"), $ & /*disabled, background*/
      1152 && set_style$6(e, "--bg-color", /*disabled*/
      k[7] ? "auto" : (
        /*background*/
        k[10]
      ));
    },
    i(k) {
      h || (s && transition_in$c(s.$$.fragment, k), h = !0);
    },
    o(k) {
      s && transition_out$b(s.$$.fragment, k), h = !1;
    },
    d(k) {
      k && detach$f(e), _ && _.d(), s && destroy_component$8(s), b = !1, g();
    }
  };
}
function instance$g(a, e, r) {
  let n, { Icon: s } = e, { label: h = "" } = e, { show_label: b = !1 } = e, { pending: g = !1 } = e, { size: _ = "small" } = e, { padded: A = !0 } = e, { highlight: x = !1 } = e, { disabled: k = !1 } = e, { hasPopup: $ = !1 } = e, { color: C = "var(--block-label-text-color)" } = e, { transparent: L = !1 } = e, { background: y = "var(--block-background-fill)" } = e;
  function o(v) {
    bubble$2.call(this, a, v);
  }
  return a.$$set = (v) => {
    "Icon" in v && r(0, s = v.Icon), "label" in v && r(1, h = v.label), "show_label" in v && r(2, b = v.show_label), "pending" in v && r(3, g = v.pending), "size" in v && r(4, _ = v.size), "padded" in v && r(5, A = v.padded), "highlight" in v && r(6, x = v.highlight), "disabled" in v && r(7, k = v.disabled), "hasPopup" in v && r(8, $ = v.hasPopup), "color" in v && r(12, C = v.color), "transparent" in v && r(9, L = v.transparent), "background" in v && r(10, y = v.background);
  }, a.$$.update = () => {
    a.$$.dirty & /*highlight, color*/
    4160 && r(11, n = x ? "var(--color-accent)" : C);
  }, [
    s,
    h,
    b,
    g,
    _,
    A,
    x,
    k,
    $,
    L,
    y,
    n,
    C,
    o
  ];
}
class IconButton extends SvelteComponent$g {
  constructor(e) {
    super(), init$g(this, e, instance$g, create_fragment$f, safe_not_equal$g, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 12,
      transparent: 9,
      background: 10
    });
  }
}
const {
  SvelteComponent: SvelteComponent$f,
  append_hydration: append_hydration$9,
  attr: attr$a,
  binding_callbacks: binding_callbacks$4,
  children: children$b,
  claim_element: claim_element$b,
  create_slot: create_slot$6,
  detach: detach$e,
  element: element$b,
  get_all_dirty_from_scope: get_all_dirty_from_scope$6,
  get_slot_changes: get_slot_changes$6,
  init: init$f,
  insert_hydration: insert_hydration$e,
  safe_not_equal: safe_not_equal$f,
  toggle_class: toggle_class$9,
  transition_in: transition_in$b,
  transition_out: transition_out$a,
  update_slot_base: update_slot_base$6
} = window.__gradio__svelte__internal;
function create_fragment$e(a) {
  let e, r, n;
  const s = (
    /*#slots*/
    a[5].default
  ), h = create_slot$6(
    s,
    a,
    /*$$scope*/
    a[4],
    null
  );
  return {
    c() {
      e = element$b("div"), r = element$b("div"), h && h.c(), this.h();
    },
    l(b) {
      e = claim_element$b(b, "DIV", { class: !0, "aria-label": !0 });
      var g = children$b(e);
      r = claim_element$b(g, "DIV", { class: !0 });
      var _ = children$b(r);
      h && h.l(_), _.forEach(detach$e), g.forEach(detach$e), this.h();
    },
    h() {
      attr$a(r, "class", "icon svelte-3w3rth"), attr$a(e, "class", "empty svelte-3w3rth"), attr$a(e, "aria-label", "Empty value"), toggle_class$9(
        e,
        "small",
        /*size*/
        a[0] === "small"
      ), toggle_class$9(
        e,
        "large",
        /*size*/
        a[0] === "large"
      ), toggle_class$9(
        e,
        "unpadded_box",
        /*unpadded_box*/
        a[1]
      ), toggle_class$9(
        e,
        "small_parent",
        /*parent_height*/
        a[3]
      );
    },
    m(b, g) {
      insert_hydration$e(b, e, g), append_hydration$9(e, r), h && h.m(r, null), a[6](e), n = !0;
    },
    p(b, [g]) {
      h && h.p && (!n || g & /*$$scope*/
      16) && update_slot_base$6(
        h,
        s,
        b,
        /*$$scope*/
        b[4],
        n ? get_slot_changes$6(
          s,
          /*$$scope*/
          b[4],
          g,
          null
        ) : get_all_dirty_from_scope$6(
          /*$$scope*/
          b[4]
        ),
        null
      ), (!n || g & /*size*/
      1) && toggle_class$9(
        e,
        "small",
        /*size*/
        b[0] === "small"
      ), (!n || g & /*size*/
      1) && toggle_class$9(
        e,
        "large",
        /*size*/
        b[0] === "large"
      ), (!n || g & /*unpadded_box*/
      2) && toggle_class$9(
        e,
        "unpadded_box",
        /*unpadded_box*/
        b[1]
      ), (!n || g & /*parent_height*/
      8) && toggle_class$9(
        e,
        "small_parent",
        /*parent_height*/
        b[3]
      );
    },
    i(b) {
      n || (transition_in$b(h, b), n = !0);
    },
    o(b) {
      transition_out$a(h, b), n = !1;
    },
    d(b) {
      b && detach$e(e), h && h.d(b), a[6](null);
    }
  };
}
function instance$f(a, e, r) {
  let n, { $$slots: s = {}, $$scope: h } = e, { size: b = "small" } = e, { unpadded_box: g = !1 } = e, _;
  function A(k) {
    var $;
    if (!k) return !1;
    const { height: C } = k.getBoundingClientRect(), { height: L } = (($ = k.parentElement) === null || $ === void 0 ? void 0 : $.getBoundingClientRect()) || { height: C };
    return C > L + 2;
  }
  function x(k) {
    binding_callbacks$4[k ? "unshift" : "push"](() => {
      _ = k, r(2, _);
    });
  }
  return a.$$set = (k) => {
    "size" in k && r(0, b = k.size), "unpadded_box" in k && r(1, g = k.unpadded_box), "$$scope" in k && r(4, h = k.$$scope);
  }, a.$$.update = () => {
    a.$$.dirty & /*el*/
    4 && r(3, n = A(_));
  }, [b, g, _, n, h, s, x];
}
class Empty extends SvelteComponent$f {
  constructor(e) {
    super(), init$f(this, e, instance$f, create_fragment$e, safe_not_equal$f, { size: 0, unpadded_box: 1 });
  }
}
const RE_HEADING = /^(#\s*)(.+)$/m;
function inject(a) {
  const e = a.trim(), r = e.match(RE_HEADING);
  if (!r)
    return [!1, e || !1];
  const [n, , s] = r, h = s.trim();
  if (e === n)
    return [h, !1];
  const b = r.index !== void 0 ? r.index + n.length : 0, _ = e.substring(b).trim() || !1;
  return [h, _];
}
const {
  SvelteComponent: SvelteComponent$e,
  append_hydration: append_hydration$8,
  attr: attr$9,
  check_outros: check_outros$8,
  children: children$a,
  claim_component: claim_component$7,
  claim_element: claim_element$a,
  claim_space: claim_space$9,
  claim_text: claim_text$6,
  create_component: create_component$7,
  destroy_component: destroy_component$7,
  detach: detach$d,
  element: element$a,
  empty: empty$6,
  group_outros: group_outros$8,
  init: init$e,
  insert_hydration: insert_hydration$d,
  mount_component: mount_component$7,
  safe_not_equal: safe_not_equal$e,
  set_data: set_data$5,
  space: space$9,
  text: text$6,
  toggle_class: toggle_class$8,
  transition_in: transition_in$a,
  transition_out: transition_out$9
} = window.__gradio__svelte__internal;
function create_else_block_1$1(a) {
  let e, r;
  return e = new Upload$1({}), {
    c() {
      create_component$7(e.$$.fragment);
    },
    l(n) {
      claim_component$7(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$7(e, n, s), r = !0;
    },
    i(n) {
      r || (transition_in$a(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$9(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$7(e, n);
    }
  };
}
function create_if_block_4$2(a) {
  let e, r;
  return e = new ImagePaste({}), {
    c() {
      create_component$7(e.$$.fragment);
    },
    l(n) {
      claim_component$7(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$7(e, n, s), r = !0;
    },
    i(n) {
      r || (transition_in$a(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$9(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$7(e, n);
    }
  };
}
function create_else_block$8(a) {
  let e = (
    /*i18n*/
    a[1](
      /*defs*/
      a[7][
        /*type*/
        a[0]
      ] || /*defs*/
      a[7].file
    ) + ""
  ), r, n, s, h = (
    /*mode*/
    a[3] !== "short" && create_if_block_3$2(a)
  );
  return {
    c() {
      r = text$6(e), n = space$9(), h && h.c(), s = empty$6();
    },
    l(b) {
      r = claim_text$6(b, e), n = claim_space$9(b), h && h.l(b), s = empty$6();
    },
    m(b, g) {
      insert_hydration$d(b, r, g), insert_hydration$d(b, n, g), h && h.m(b, g), insert_hydration$d(b, s, g);
    },
    p(b, g) {
      g & /*i18n, type*/
      3 && e !== (e = /*i18n*/
      b[1](
        /*defs*/
        b[7][
          /*type*/
          b[0]
        ] || /*defs*/
        b[7].file
      ) + "") && set_data$5(r, e), /*mode*/
      b[3] !== "short" ? h ? h.p(b, g) : (h = create_if_block_3$2(b), h.c(), h.m(s.parentNode, s)) : h && (h.d(1), h = null);
    },
    d(b) {
      b && (detach$d(r), detach$d(n), detach$d(s)), h && h.d(b);
    }
  };
}
function create_if_block$a(a) {
  let e, r, n = (
    /*heading*/
    a[6] && create_if_block_2$4(a)
  ), s = (
    /*paragraph*/
    a[5] && create_if_block_1$9(a)
  );
  return {
    c() {
      n && n.c(), e = space$9(), s && s.c(), r = empty$6();
    },
    l(h) {
      n && n.l(h), e = claim_space$9(h), s && s.l(h), r = empty$6();
    },
    m(h, b) {
      n && n.m(h, b), insert_hydration$d(h, e, b), s && s.m(h, b), insert_hydration$d(h, r, b);
    },
    p(h, b) {
      /*heading*/
      h[6] ? n ? n.p(h, b) : (n = create_if_block_2$4(h), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null), /*paragraph*/
      h[5] ? s ? s.p(h, b) : (s = create_if_block_1$9(h), s.c(), s.m(r.parentNode, r)) : s && (s.d(1), s = null);
    },
    d(h) {
      h && (detach$d(e), detach$d(r)), n && n.d(h), s && s.d(h);
    }
  };
}
function create_if_block_3$2(a) {
  let e, r, n = (
    /*i18n*/
    a[1]("common.or") + ""
  ), s, h, b, g = (
    /*message*/
    (a[2] || /*i18n*/
    a[1]("upload_text.click_to_upload")) + ""
  ), _;
  return {
    c() {
      e = element$a("span"), r = text$6("- "), s = text$6(n), h = text$6(" -"), b = space$9(), _ = text$6(g), this.h();
    },
    l(A) {
      e = claim_element$a(A, "SPAN", { class: !0 });
      var x = children$a(e);
      r = claim_text$6(x, "- "), s = claim_text$6(x, n), h = claim_text$6(x, " -"), x.forEach(detach$d), b = claim_space$9(A), _ = claim_text$6(A, g), this.h();
    },
    h() {
      attr$9(e, "class", "or svelte-1xg7h5n");
    },
    m(A, x) {
      insert_hydration$d(A, e, x), append_hydration$8(e, r), append_hydration$8(e, s), append_hydration$8(e, h), insert_hydration$d(A, b, x), insert_hydration$d(A, _, x);
    },
    p(A, x) {
      x & /*i18n*/
      2 && n !== (n = /*i18n*/
      A[1]("common.or") + "") && set_data$5(s, n), x & /*message, i18n*/
      6 && g !== (g = /*message*/
      (A[2] || /*i18n*/
      A[1]("upload_text.click_to_upload")) + "") && set_data$5(_, g);
    },
    d(A) {
      A && (detach$d(e), detach$d(b), detach$d(_));
    }
  };
}
function create_if_block_2$4(a) {
  let e, r;
  return {
    c() {
      e = element$a("h2"), r = text$6(
        /*heading*/
        a[6]
      ), this.h();
    },
    l(n) {
      e = claim_element$a(n, "H2", { class: !0 });
      var s = children$a(e);
      r = claim_text$6(
        s,
        /*heading*/
        a[6]
      ), s.forEach(detach$d), this.h();
    },
    h() {
      attr$9(e, "class", "svelte-1xg7h5n");
    },
    m(n, s) {
      insert_hydration$d(n, e, s), append_hydration$8(e, r);
    },
    p(n, s) {
      s & /*heading*/
      64 && set_data$5(
        r,
        /*heading*/
        n[6]
      );
    },
    d(n) {
      n && detach$d(e);
    }
  };
}
function create_if_block_1$9(a) {
  let e, r;
  return {
    c() {
      e = element$a("p"), r = text$6(
        /*paragraph*/
        a[5]
      ), this.h();
    },
    l(n) {
      e = claim_element$a(n, "P", { class: !0 });
      var s = children$a(e);
      r = claim_text$6(
        s,
        /*paragraph*/
        a[5]
      ), s.forEach(detach$d), this.h();
    },
    h() {
      attr$9(e, "class", "svelte-1xg7h5n");
    },
    m(n, s) {
      insert_hydration$d(n, e, s), append_hydration$8(e, r);
    },
    p(n, s) {
      s & /*paragraph*/
      32 && set_data$5(
        r,
        /*paragraph*/
        n[5]
      );
    },
    d(n) {
      n && detach$d(e);
    }
  };
}
function create_fragment$d(a) {
  let e, r, n, s, h, b;
  const g = [create_if_block_4$2, create_else_block_1$1], _ = [];
  function A(C, L) {
    return (
      /*type*/
      C[0] === "clipboard" ? 0 : 1
    );
  }
  n = A(a), s = _[n] = g[n](a);
  function x(C, L) {
    return (
      /*heading*/
      C[6] || /*paragraph*/
      C[5] ? create_if_block$a : create_else_block$8
    );
  }
  let k = x(a), $ = k(a);
  return {
    c() {
      e = element$a("div"), r = element$a("span"), s.c(), h = space$9(), $.c(), this.h();
    },
    l(C) {
      e = claim_element$a(C, "DIV", { class: !0 });
      var L = children$a(e);
      r = claim_element$a(L, "SPAN", { class: !0 });
      var y = children$a(r);
      s.l(y), y.forEach(detach$d), h = claim_space$9(L), $.l(L), L.forEach(detach$d), this.h();
    },
    h() {
      attr$9(r, "class", "icon-wrap svelte-1xg7h5n"), toggle_class$8(
        r,
        "hovered",
        /*hovered*/
        a[4]
      ), attr$9(e, "class", "wrap svelte-1xg7h5n");
    },
    m(C, L) {
      insert_hydration$d(C, e, L), append_hydration$8(e, r), _[n].m(r, null), append_hydration$8(e, h), $.m(e, null), b = !0;
    },
    p(C, [L]) {
      let y = n;
      n = A(C), n !== y && (group_outros$8(), transition_out$9(_[y], 1, 1, () => {
        _[y] = null;
      }), check_outros$8(), s = _[n], s || (s = _[n] = g[n](C), s.c()), transition_in$a(s, 1), s.m(r, null)), (!b || L & /*hovered*/
      16) && toggle_class$8(
        r,
        "hovered",
        /*hovered*/
        C[4]
      ), k === (k = x(C)) && $ ? $.p(C, L) : ($.d(1), $ = k(C), $ && ($.c(), $.m(e, null)));
    },
    i(C) {
      b || (transition_in$a(s), b = !0);
    },
    o(C) {
      transition_out$9(s), b = !1;
    },
    d(C) {
      C && detach$d(e), _[n].d(), $.d();
    }
  };
}
function instance$e(a, e, r) {
  let n, s, { type: h = "file" } = e, { i18n: b } = e, { message: g = void 0 } = e, { mode: _ = "full" } = e, { hovered: A = !1 } = e, { placeholder: x = void 0 } = e;
  const k = {
    image: "upload_text.drop_image",
    video: "upload_text.drop_video",
    audio: "upload_text.drop_audio",
    file: "upload_text.drop_file",
    csv: "upload_text.drop_csv",
    gallery: "upload_text.drop_gallery",
    clipboard: "upload_text.paste_clipboard"
  };
  return a.$$set = ($) => {
    "type" in $ && r(0, h = $.type), "i18n" in $ && r(1, b = $.i18n), "message" in $ && r(2, g = $.message), "mode" in $ && r(3, _ = $.mode), "hovered" in $ && r(4, A = $.hovered), "placeholder" in $ && r(8, x = $.placeholder);
  }, a.$$.update = () => {
    a.$$.dirty & /*placeholder*/
    256 && r(6, [n, s] = x ? inject(x) : [!1, !1], n, (r(5, s), r(8, x)));
  }, [h, b, g, _, A, s, n, k, x];
}
class UploadText extends SvelteComponent$e {
  constructor(e) {
    super(), init$e(this, e, instance$e, create_fragment$d, safe_not_equal$e, {
      type: 0,
      i18n: 1,
      message: 2,
      mode: 3,
      hovered: 4,
      placeholder: 8
    });
  }
}
const {
  SvelteComponent: SvelteComponent$d,
  attr: attr$8,
  children: children$9,
  claim_element: claim_element$9,
  create_slot: create_slot$5,
  detach: detach$c,
  element: element$9,
  get_all_dirty_from_scope: get_all_dirty_from_scope$5,
  get_slot_changes: get_slot_changes$5,
  init: init$d,
  insert_hydration: insert_hydration$c,
  null_to_empty: null_to_empty$1,
  safe_not_equal: safe_not_equal$d,
  transition_in: transition_in$9,
  transition_out: transition_out$8,
  update_slot_base: update_slot_base$5
} = window.__gradio__svelte__internal;
function create_fragment$c(a) {
  let e, r, n;
  const s = (
    /*#slots*/
    a[2].default
  ), h = create_slot$5(
    s,
    a,
    /*$$scope*/
    a[1],
    null
  );
  return {
    c() {
      e = element$9("div"), h && h.c(), this.h();
    },
    l(b) {
      e = claim_element$9(b, "DIV", { class: !0 });
      var g = children$9(e);
      h && h.l(g), g.forEach(detach$c), this.h();
    },
    h() {
      attr$8(e, "class", r = null_to_empty$1(`icon-button-wrapper ${/*top_panel*/
      a[0] ? "top-panel" : ""}`) + " svelte-171ybii");
    },
    m(b, g) {
      insert_hydration$c(b, e, g), h && h.m(e, null), n = !0;
    },
    p(b, [g]) {
      h && h.p && (!n || g & /*$$scope*/
      2) && update_slot_base$5(
        h,
        s,
        b,
        /*$$scope*/
        b[1],
        n ? get_slot_changes$5(
          s,
          /*$$scope*/
          b[1],
          g,
          null
        ) : get_all_dirty_from_scope$5(
          /*$$scope*/
          b[1]
        ),
        null
      ), (!n || g & /*top_panel*/
      1 && r !== (r = null_to_empty$1(`icon-button-wrapper ${/*top_panel*/
      b[0] ? "top-panel" : ""}`) + " svelte-171ybii")) && attr$8(e, "class", r);
    },
    i(b) {
      n || (transition_in$9(h, b), n = !0);
    },
    o(b) {
      transition_out$8(h, b), n = !1;
    },
    d(b) {
      b && detach$c(e), h && h.d(b);
    }
  };
}
function instance$d(a, e, r) {
  let { $$slots: n = {}, $$scope: s } = e, { top_panel: h = !0 } = e;
  return a.$$set = (b) => {
    "top_panel" in b && r(0, h = b.top_panel), "$$scope" in b && r(1, s = b.$$scope);
  }, [h, s, n];
}
class IconButtonWrapper extends SvelteComponent$d {
  constructor(e) {
    super(), init$d(this, e, instance$d, create_fragment$c, safe_not_equal$d, { top_panel: 0 });
  }
}
var _3Dmol$1 = { exports: {} };
/*!
 * 3dmol v2.4.0
 * JavaScript/TypeScript molecular visualization library
 * Author: David Koes and contributors
 */
(function(module, exports) {
  (function(e, r) {
    module.exports = r();
  })(commonjsGlobal, () => (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        "./node_modules/iobuffer/lib-esm/IOBuffer.js": (
          /*!***************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/IOBuffer.js ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              IOBuffer: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var n = r(
              /*! ./text */
              "./node_modules/iobuffer/lib-esm/text.browser.js"
            );
            const s = 1024 * 8, h = (() => {
              const _ = new Uint8Array(4), A = new Uint32Array(_.buffer);
              return !((A[0] = 1) & _[0]);
            })(), b = {
              int8: globalThis.Int8Array,
              uint8: globalThis.Uint8Array,
              int16: globalThis.Int16Array,
              uint16: globalThis.Uint16Array,
              int32: globalThis.Int32Array,
              uint32: globalThis.Uint32Array,
              uint64: globalThis.BigUint64Array,
              int64: globalThis.BigInt64Array,
              float32: globalThis.Float32Array,
              float64: globalThis.Float64Array
            };
            class g {
              /**
               * @param data - The data to construct the IOBuffer with.
               * If data is a number, it will be the new buffer's length<br>
               * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
               * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
               * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
               * @param options
               */
              constructor(A = s, x = {}) {
                let k = !1;
                typeof A == "number" ? A = new ArrayBuffer(A) : (k = !0, this.lastWrittenByte = A.byteLength);
                const $ = x.offset ? x.offset >>> 0 : 0, C = A.byteLength - $;
                let L = $;
                (ArrayBuffer.isView(A) || A instanceof g) && (A.byteLength !== A.buffer.byteLength && (L = A.byteOffset + $), A = A.buffer), k ? this.lastWrittenByte = C : this.lastWrittenByte = 0, this.buffer = A, this.length = C, this.byteLength = C, this.byteOffset = L, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, L, C), this._mark = 0, this._marks = [];
              }
              /**
               * Checks if the memory allocated to the buffer is sufficient to store more
               * bytes after the offset.
               * @param byteLength - The needed memory in bytes.
               * @returns `true` if there is sufficient space and `false` otherwise.
               */
              available(A = 1) {
                return this.offset + A <= this.length;
              }
              /**
               * Check if little-endian mode is used for reading and writing multi-byte
               * values.
               * @returns `true` if little-endian mode is used, `false` otherwise.
               */
              isLittleEndian() {
                return this.littleEndian;
              }
              /**
               * Set little-endian mode for reading and writing multi-byte values.
               */
              setLittleEndian() {
                return this.littleEndian = !0, this;
              }
              /**
               * Check if big-endian mode is used for reading and writing multi-byte values.
               * @returns `true` if big-endian mode is used, `false` otherwise.
               */
              isBigEndian() {
                return !this.littleEndian;
              }
              /**
               * Switches to big-endian mode for reading and writing multi-byte values.
               */
              setBigEndian() {
                return this.littleEndian = !1, this;
              }
              /**
               * Move the pointer n bytes forward.
               * @param n - Number of bytes to skip.
               */
              skip(A = 1) {
                return this.offset += A, this;
              }
              /**
               * Move the pointer n bytes backward.
               * @param n - Number of bytes to move back.
               */
              back(A = 1) {
                return this.offset -= A, this;
              }
              /**
               * Move the pointer to the given offset.
               * @param offset
               */
              seek(A) {
                return this.offset = A, this;
              }
              /**
               * Store the current pointer offset.
               * @see {@link IOBuffer#reset}
               */
              mark() {
                return this._mark = this.offset, this;
              }
              /**
               * Move the pointer back to the last pointer offset set by mark.
               * @see {@link IOBuffer#mark}
               */
              reset() {
                return this.offset = this._mark, this;
              }
              /**
               * Push the current pointer offset to the mark stack.
               * @see {@link IOBuffer#popMark}
               */
              pushMark() {
                return this._marks.push(this.offset), this;
              }
              /**
               * Pop the last pointer offset from the mark stack, and set the current
               * pointer offset to the popped value.
               * @see {@link IOBuffer#pushMark}
               */
              popMark() {
                const A = this._marks.pop();
                if (A === void 0)
                  throw new Error("Mark stack empty");
                return this.seek(A), this;
              }
              /**
               * Move the pointer offset back to 0.
               */
              rewind() {
                return this.offset = 0, this;
              }
              /**
               * Make sure the buffer has sufficient memory to write a given byteLength at
               * the current pointer offset.
               * If the buffer's memory is insufficient, this method will create a new
               * buffer (a copy) with a length that is twice (byteLength + current offset).
               * @param byteLength
               */
              ensureAvailable(A = 1) {
                if (!this.available(A)) {
                  const k = (this.offset + A) * 2, $ = new Uint8Array(k);
                  $.set(new Uint8Array(this.buffer)), this.buffer = $.buffer, this.length = this.byteLength = k, this._data = new DataView(this.buffer);
                }
                return this;
              }
              /**
               * Read a byte and return false if the byte's value is 0, or true otherwise.
               * Moves pointer forward by one byte.
               */
              readBoolean() {
                return this.readUint8() !== 0;
              }
              /**
               * Read a signed 8-bit integer and move pointer forward by 1 byte.
               */
              readInt8() {
                return this._data.getInt8(this.offset++);
              }
              /**
               * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
               */
              readUint8() {
                return this._data.getUint8(this.offset++);
              }
              /**
               * Alias for {@link IOBuffer#readUint8}.
               */
              readByte() {
                return this.readUint8();
              }
              /**
               * Read `n` bytes and move pointer forward by `n` bytes.
               */
              readBytes(A = 1) {
                return this.readArray(A, "uint8");
              }
              /**
               * Creates an array of corresponding to the type `type` and size `size`.
               * For example type `uint8` will create a `Uint8Array`.
               * @param size - size of the resulting array
               * @param type - number type of elements to read
               */
              readArray(A, x) {
                const k = b[x].BYTES_PER_ELEMENT * A, $ = this.byteOffset + this.offset, C = this.buffer.slice($, $ + k);
                if (this.littleEndian === h && x !== "uint8" && x !== "int8") {
                  const y = new Uint8Array(this.buffer.slice($, $ + k));
                  y.reverse();
                  const o = new b[x](y.buffer);
                  return this.offset += k, o.reverse(), o;
                }
                const L = new b[x](C);
                return this.offset += k, L;
              }
              /**
               * Read a 16-bit signed integer and move pointer forward by 2 bytes.
               */
              readInt16() {
                const A = this._data.getInt16(this.offset, this.littleEndian);
                return this.offset += 2, A;
              }
              /**
               * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
               */
              readUint16() {
                const A = this._data.getUint16(this.offset, this.littleEndian);
                return this.offset += 2, A;
              }
              /**
               * Read a 32-bit signed integer and move pointer forward by 4 bytes.
               */
              readInt32() {
                const A = this._data.getInt32(this.offset, this.littleEndian);
                return this.offset += 4, A;
              }
              /**
               * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
               */
              readUint32() {
                const A = this._data.getUint32(this.offset, this.littleEndian);
                return this.offset += 4, A;
              }
              /**
               * Read a 32-bit floating number and move pointer forward by 4 bytes.
               */
              readFloat32() {
                const A = this._data.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4, A;
              }
              /**
               * Read a 64-bit floating number and move pointer forward by 8 bytes.
               */
              readFloat64() {
                const A = this._data.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8, A;
              }
              /**
               * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
               */
              readBigInt64() {
                const A = this._data.getBigInt64(this.offset, this.littleEndian);
                return this.offset += 8, A;
              }
              /**
               * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
               */
              readBigUint64() {
                const A = this._data.getBigUint64(this.offset, this.littleEndian);
                return this.offset += 8, A;
              }
              /**
               * Read a 1-byte ASCII character and move pointer forward by 1 byte.
               */
              readChar() {
                return String.fromCharCode(this.readInt8());
              }
              /**
               * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
               */
              readChars(A = 1) {
                let x = "";
                for (let k = 0; k < A; k++)
                  x += this.readChar();
                return x;
              }
              /**
               * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
               * forward by `n` bytes.
               */
              readUtf8(A = 1) {
                return (0, n.decode)(this.readBytes(A));
              }
              /**
               * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
               * forward by `n` bytes.
               * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
               */
              decodeText(A = 1, x = "utf-8") {
                return (0, n.decode)(this.readBytes(A), x);
              }
              /**
               * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
               * forward by 1 byte.
               */
              writeBoolean(A) {
                return this.writeUint8(A ? 255 : 0), this;
              }
              /**
               * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
               */
              writeInt8(A) {
                return this.ensureAvailable(1), this._data.setInt8(this.offset++, A), this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
               * byte.
               */
              writeUint8(A) {
                return this.ensureAvailable(1), this._data.setUint8(this.offset++, A), this._updateLastWrittenByte(), this;
              }
              /**
               * An alias for {@link IOBuffer#writeUint8}.
               */
              writeByte(A) {
                return this.writeUint8(A);
              }
              /**
               * Write all elements of `bytes` as uint8 values and move pointer forward by
               * `bytes.length` bytes.
               */
              writeBytes(A) {
                this.ensureAvailable(A.length);
                for (let x = 0; x < A.length; x++)
                  this._data.setUint8(this.offset++, A[x]);
                return this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit signed integer and move pointer forward by 2
               * bytes.
               */
              writeInt16(A) {
                return this.ensureAvailable(2), this._data.setInt16(this.offset, A, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
               * bytes.
               */
              writeUint16(A) {
                return this.ensureAvailable(2), this._data.setUint16(this.offset, A, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit signed integer and move pointer forward by 4
               * bytes.
               */
              writeInt32(A) {
                return this.ensureAvailable(4), this._data.setInt32(this.offset, A, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
               * bytes.
               */
              writeUint32(A) {
                return this.ensureAvailable(4), this._data.setUint32(this.offset, A, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit floating number and move pointer forward by 4
               * bytes.
               */
              writeFloat32(A) {
                return this.ensureAvailable(4), this._data.setFloat32(this.offset, A, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit floating number and move pointer forward by 8
               * bytes.
               */
              writeFloat64(A) {
                return this.ensureAvailable(8), this._data.setFloat64(this.offset, A, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit signed bigint and move pointer forward by 8
               * bytes.
               */
              writeBigInt64(A) {
                return this.ensureAvailable(8), this._data.setBigInt64(this.offset, A, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
               * bytes.
               */
              writeBigUint64(A) {
                return this.ensureAvailable(8), this._data.setBigUint64(this.offset, A, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write the charCode of `str`'s first character as an 8-bit unsigned integer
               * and move pointer forward by 1 byte.
               */
              writeChar(A) {
                return this.writeUint8(A.charCodeAt(0));
              }
              /**
               * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
               * and move pointer forward by `str.length` bytes.
               */
              writeChars(A) {
                for (let x = 0; x < A.length; x++)
                  this.writeUint8(A.charCodeAt(x));
                return this;
              }
              /**
               * UTF-8 encode and write `str` to the current pointer offset and move pointer
               * forward according to the encoded length.
               */
              writeUtf8(A) {
                return this.writeBytes((0, n.encode)(A));
              }
              /**
               * Export a Uint8Array view of the internal buffer.
               * The view starts at the byte offset and its length
               * is calculated to stop at the last written byte or the original length.
               */
              toArray() {
                return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
              }
              /**
               * Update the last written byte offset
               * @private
               */
              _updateLastWrittenByte() {
                this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
              }
            }
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js": (
          /*!*****************************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js ***!
            \*****************************************************************/
          /***/
          function() {
            (function(a) {
              if (a.TextEncoder && a.TextDecoder)
                return !1;
              function e(n = "utf-8") {
                if (n !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${n}') is invalid.`);
              }
              Object.defineProperty(e.prototype, "encoding", {
                value: "utf-8"
              }), e.prototype.encode = function(n, s = { stream: !1 }) {
                if (s.stream)
                  throw new Error("Failed to encode: the 'stream' option is unsupported.");
                let h = 0;
                const b = n.length;
                let g = 0, _ = Math.max(32, b + (b >> 1) + 7), A = new Uint8Array(_ >> 3 << 3);
                for (; h < b; ) {
                  let x = n.charCodeAt(h++);
                  if (x >= 55296 && x <= 56319) {
                    if (h < b) {
                      const k = n.charCodeAt(h);
                      (k & 64512) === 56320 && (++h, x = ((x & 1023) << 10) + (k & 1023) + 65536);
                    }
                    if (x >= 55296 && x <= 56319)
                      continue;
                  }
                  if (g + 4 > A.length) {
                    _ += 8, _ *= 1 + h / n.length * 2, _ = _ >> 3 << 3;
                    const k = new Uint8Array(_);
                    k.set(A), A = k;
                  }
                  if (x & 4294967168)
                    if (!(x & 4294965248))
                      A[g++] = x >> 6 & 31 | 192;
                    else if (!(x & 4294901760))
                      A[g++] = x >> 12 & 15 | 224, A[g++] = x >> 6 & 63 | 128;
                    else if (!(x & 4292870144))
                      A[g++] = x >> 18 & 7 | 240, A[g++] = x >> 12 & 63 | 128, A[g++] = x >> 6 & 63 | 128;
                    else
                      continue;
                  else {
                    A[g++] = x;
                    continue;
                  }
                  A[g++] = x & 63 | 128;
                }
                return A.slice(0, g);
              };
              function r(n = "utf-8", s = { fatal: !1 }) {
                if (n !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${n}') is invalid.`);
                if (s.fatal)
                  throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
              }
              Object.defineProperty(r.prototype, "encoding", {
                value: "utf-8"
              }), Object.defineProperty(r.prototype, "fatal", { value: !1 }), Object.defineProperty(r.prototype, "ignoreBOM", {
                value: !1
              }), r.prototype.decode = function(n, s = { stream: !1 }) {
                if (s.stream)
                  throw new Error("Failed to decode: the 'stream' option is unsupported.");
                const h = new Uint8Array(n);
                let b = 0;
                const g = h.length, _ = [];
                for (; b < g; ) {
                  const A = h[b++];
                  if (A === 0)
                    break;
                  if (!(A & 128))
                    _.push(A);
                  else if ((A & 224) === 192) {
                    const x = h[b++] & 63;
                    _.push((A & 31) << 6 | x);
                  } else if ((A & 240) === 224) {
                    const x = h[b++] & 63, k = h[b++] & 63;
                    _.push((A & 31) << 12 | x << 6 | k);
                  } else if ((A & 248) === 240) {
                    const x = h[b++] & 63, k = h[b++] & 63, $ = h[b++] & 63;
                    let C = (A & 7) << 18 | x << 12 | k << 6 | $;
                    C > 65535 && (C -= 65536, _.push(C >>> 10 & 1023 | 55296), C = 56320 | C & 1023), _.push(C);
                  }
                }
                return String.fromCharCode.apply(null, _);
              }, a.TextEncoder = e, a.TextDecoder = r;
            })(typeof window < "u" ? window : typeof self < "u" ? self : this);
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text.browser.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text.browser.js ***!
            \*******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              decode: () => (
                /* binding */
                n
              ),
              /* harmony export */
              encode: () => (
                /* binding */
                h
              )
              /* harmony export */
            }), r(
              /*! ./text-encoding-polyfill */
              "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js"
            );
            function n(b, g = "utf8") {
              return new TextDecoder(g).decode(b);
            }
            const s = new TextEncoder();
            function h(b) {
              return s.encode(b);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/data.js": (
          /*!***********************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/data.js ***!
            \***********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              nonRecord: () => (
                /* binding */
                s
              ),
              /* harmony export */
              record: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            );
            function s(b, g) {
              const _ = (0, n.str2num)(g.type), A = g.size / (0, n.num2bytes)(_), x = new Array(A);
              for (let k = 0; k < A; k++)
                x[k] = (0, n.readType)(b, _, 1);
              return x;
            }
            function h(b, g, _) {
              const A = (0, n.str2num)(g.type), x = g.size ? g.size / (0, n.num2bytes)(A) : 1, k = _.length, $ = new Array(k), C = _.recordStep;
              if (C)
                for (let L = 0; L < k; L++) {
                  const y = b.offset;
                  $[L] = (0, n.readType)(b, A, x), b.seek(y + C);
                }
              else
                throw new Error("recordDimension.recordStep is undefined");
              return $;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/header.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/header.js ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              header: () => (
                /* binding */
                x
              )
              /* harmony export */
            });
            var n = r(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            ), s = r(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            const h = 0, b = 10, g = 11, _ = 12, A = 0;
            function x(L, y) {
              const o = { version: y }, v = {
                length: L.readUint32()
              }, w = k(L);
              Array.isArray(w) || (v.id = w.recordId, v.name = w.recordName, o.dimensions = w.dimensions), o.globalAttributes = $(L);
              const M = C(L, v?.id, y);
              return Array.isArray(M) || (o.variables = M.variables, v.recordStep = M.recordStep), o.recordDimension = v, o;
            }
            function k(L) {
              const y = {};
              let o, v;
              const w = L.readUint32();
              let M;
              if (w === h)
                return (0, s.notNetcdf)(L.readUint32() !== h, "wrong empty tag for list of dimensions"), [];
              {
                (0, s.notNetcdf)(w !== b, "wrong tag for list of dimensions");
                const F = L.readUint32();
                M = new Array(F);
                for (let m = 0; m < F; m++) {
                  const E = (0, s.readName)(L), z = L.readUint32();
                  z === A && (o = m, v = E), M[m] = {
                    name: E,
                    size: z
                  };
                }
              }
              return o !== void 0 && (y.recordId = o), v !== void 0 && (y.recordName = v), y.dimensions = M, y;
            }
            function $(L) {
              const y = L.readUint32();
              let o;
              if (y === h)
                return (0, s.notNetcdf)(L.readUint32() !== h, "wrong empty tag for list of attributes"), [];
              {
                (0, s.notNetcdf)(y !== _, "wrong tag for list of attributes");
                const v = L.readUint32();
                o = new Array(v);
                for (let w = 0; w < v; w++) {
                  const M = (0, s.readName)(L), F = L.readUint32();
                  (0, s.notNetcdf)(F < 1 || F > 6, `non valid type ${F}`);
                  const m = L.readUint32(), E = (0, n.readType)(L, F, m);
                  (0, s.padding)(L), o[w] = {
                    name: M,
                    type: (0, n.num2str)(F),
                    value: E
                  };
                }
              }
              return o;
            }
            function C(L, y, o) {
              const v = L.readUint32();
              let w = 0, M;
              if (v === h)
                return (0, s.notNetcdf)(L.readUint32() !== h, "wrong empty tag for list of variables"), [];
              {
                (0, s.notNetcdf)(v !== g, "wrong tag for list of variables");
                const F = L.readUint32();
                M = new Array(F);
                for (let m = 0; m < F; m++) {
                  const E = (0, s.readName)(L), z = L.readUint32(), O = new Array(z);
                  for (let V = 0; V < z; V++)
                    O[V] = L.readUint32();
                  const R = $(L), B = L.readUint32();
                  (0, s.notNetcdf)(B < 1 && B > 6, `non valid type ${B}`);
                  const P = L.readUint32();
                  let W = L.readUint32();
                  o === 2 && ((0, s.notNetcdf)(W > 0, "offsets larger than 4GB not supported"), W = L.readUint32());
                  let U = !1;
                  typeof y < "u" && O[0] === y && (w += P, U = !0), M[m] = {
                    name: E,
                    dimensions: O,
                    attributes: R,
                    type: (0, n.num2str)(B),
                    size: P,
                    offset: W,
                    record: U
                  };
                }
              }
              return {
                variables: M,
                recordStep: w
              };
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/index.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/index.js ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              NetCDFReader: () => (
                /* reexport safe */
                n.NetCDFReader
              )
              /* harmony export */
            });
            var n = r(
              /*! ./parser */
              "./node_modules/netcdfjs/lib-esm/parser.js"
            );
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/parser.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/parser.js ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              NetCDFReader: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! iobuffer */
              "./node_modules/iobuffer/lib-esm/IOBuffer.js"
            ), s = r(
              /*! ./data */
              "./node_modules/netcdfjs/lib-esm/data.js"
            ), h = r(
              /*! ./header */
              "./node_modules/netcdfjs/lib-esm/header.js"
            ), b = r(
              /*! ./toString */
              "./node_modules/netcdfjs/lib-esm/toString.js"
            ), g = r(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            class _ {
              constructor(x) {
                this.toString = b.toString;
                const k = new n.IOBuffer(x);
                k.setBigEndian(), (0, g.notNetcdf)(k.readChars(3) !== "CDF", "should start with CDF");
                const $ = k.readByte();
                (0, g.notNetcdf)($ > 2, "unknown version"), this.header = (0, h.header)(k, $), this.buffer = k;
              }
              /**
               * @return - Version for the NetCDF format
               */
              get version() {
                return this.header.version === 1 ? "classic format" : "64-bit offset format";
              }
              /**
               * @return {object} - Metadata for the record dimension
               *  * `length`: Number of elements in the record dimension
               *  * `id`: Id number in the list of dimensions for the record dimension
               *  * `name`: String with the name of the record dimension
               *  * `recordStep`: Number with the record variables step size
               */
              get recordDimension() {
                return this.header.recordDimension;
              }
              /**
               * @return - Array - List of dimensions with:
               *  * `name`: String with the name of the dimension
               *  * `size`: Number with the size of the dimension
               */
              get dimensions() {
                return this.header.dimensions;
              }
              /**
               * @return - Array - List of global attributes with:
               *  * `name`: String with the name of the attribute
               *  * `type`: String with the type of the attribute
               *  * `value`: A number or string with the value of the attribute
               */
              get globalAttributes() {
                return this.header.globalAttributes;
              }
              /**
               * Returns the value of an attribute
               * @param - AttributeName
               * @return - Value of the attributeName or null
               */
              getAttribute(x) {
                const k = this.globalAttributes.find(($) => $.name === x);
                return k ? k.value : null;
              }
              /**
               * Returns the value of a variable as a string
               * @param - variableName
               * @return - Value of the variable as a string or null
               */
              getDataVariableAsString(x) {
                const k = this.getDataVariable(x);
                return k ? k.join("") : null;
              }
              get variables() {
                return this.header.variables;
              }
              /**
               * Retrieves the data for a given variable
               * @param variableName - Name of the variable to search or variable object
               * @return The variable values
               */
              getDataVariable(x) {
                let k;
                if (typeof x == "string" ? k = this.header.variables.find(($) => $.name === x) : k = x, k === void 0)
                  throw new Error("Not a valid NetCDF v3.x file: variable not found");
                return this.buffer.seek(k.offset), k.record ? (0, s.record)(this.buffer, k, this.header.recordDimension) : (0, s.nonRecord)(this.buffer, k);
              }
              /**
               * Check if a dataVariable exists
               * @param variableName - Name of the variable to find
               * @return boolean
               */
              dataVariableExists(x) {
                return this.header.variables.find(($) => $.name === x) !== void 0;
              }
              /**
               * Check if an attribute exists
               * @param attributeName - Name of the attribute to find
               * @return boolean
               */
              attributeExists(x) {
                return this.globalAttributes.find(($) => $.name === x) !== void 0;
              }
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/toString.js": (
          /*!***************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/toString.js ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              toString: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n() {
              const s = [];
              s.push("DIMENSIONS");
              for (const b of this.dimensions)
                s.push(`  ${b.name.padEnd(30)} = size: ${b.size}`);
              s.push(""), s.push("GLOBAL ATTRIBUTES");
              for (const b of this.globalAttributes)
                s.push(`  ${b.name.padEnd(30)} = ${b.value}`);
              const h = JSON.parse(JSON.stringify(this.variables));
              s.push(""), s.push("VARIABLES:");
              for (const b of h) {
                b.value = this.getDataVariable(b);
                let g = JSON.stringify(b.value);
                g.length > 50 && (g = g.substring(0, 50)), isNaN(b.value.length) || (g += ` (length: ${b.value.length})`), s.push(`  ${b.name.padEnd(30)} = ${g}`);
              }
              return s.join(`
`);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/types.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/types.js ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              num2bytes: () => (
                /* binding */
                h
              ),
              /* harmony export */
              num2str: () => (
                /* binding */
                s
              ),
              /* harmony export */
              readType: () => (
                /* binding */
                _
              ),
              /* harmony export */
              str2num: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            const n = {
              BYTE: 1,
              CHAR: 2,
              SHORT: 3,
              INT: 4,
              FLOAT: 5,
              DOUBLE: 6
            };
            function s(x) {
              switch (Number(x)) {
                case n.BYTE:
                  return "byte";
                case n.CHAR:
                  return "char";
                case n.SHORT:
                  return "short";
                case n.INT:
                  return "int";
                case n.FLOAT:
                  return "float";
                case n.DOUBLE:
                  return "double";
                default:
                  return "undefined";
              }
            }
            function h(x) {
              switch (Number(x)) {
                case n.BYTE:
                  return 1;
                case n.CHAR:
                  return 1;
                case n.SHORT:
                  return 2;
                case n.INT:
                  return 4;
                case n.FLOAT:
                  return 4;
                case n.DOUBLE:
                  return 8;
                default:
                  return -1;
              }
            }
            function b(x) {
              switch (String(x)) {
                case "byte":
                  return n.BYTE;
                case "char":
                  return n.CHAR;
                case "short":
                  return n.SHORT;
                case "int":
                  return n.INT;
                case "float":
                  return n.FLOAT;
                case "double":
                  return n.DOUBLE;
                default:
                  return -1;
              }
            }
            function g(x, k) {
              if (x !== 1) {
                const $ = new Array(x);
                for (let C = 0; C < x; C++)
                  $[C] = k();
                return $;
              } else
                return k();
            }
            function _(x, k, $) {
              switch (k) {
                case n.BYTE:
                  return Array.from(x.readBytes($));
                case n.CHAR:
                  return A(x.readChars($));
                case n.SHORT:
                  return g($, x.readInt16.bind(x));
                case n.INT:
                  return g($, x.readInt32.bind(x));
                case n.FLOAT:
                  return g($, x.readFloat32.bind(x));
                case n.DOUBLE:
                  return g($, x.readFloat64.bind(x));
                default:
                  throw new Error(`non valid type ${k}`);
              }
            }
            function A(x) {
              return x.charCodeAt(x.length - 1) === 0 ? x.substring(0, x.length - 1) : x;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/utils.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/utils.js ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              notNetcdf: () => (
                /* binding */
                n
              ),
              /* harmony export */
              padding: () => (
                /* binding */
                s
              ),
              /* harmony export */
              readName: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            function n(b, g) {
              if (b)
                throw new TypeError(`Not a valid NetCDF v3.x file: ${g}`);
            }
            function s(b) {
              b.offset % 4 !== 0 && b.skip(4 - b.offset % 4);
            }
            function h(b) {
              const g = b.readUint32(), _ = b.readChars(g);
              return s(b), _;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.frag": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.frag ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 viewMatrix;
uniform float opacity;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
varying vec3 vColor;
//DEFINEFRAGCOLOR
void main() {
    gl_FragColor = vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.vert": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.vert ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

attribute vec3 position;
attribute vec3 color;

varying vec3 vColor;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/blur/blur.frag": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/blur/blur.frag ***!
            \**********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `const float INV_TOTAL_SAMPLES_FACTOR = 1.0 / 9.0;
uniform highp sampler2D inTex;
varying highp vec2 vTexCoords;
    
void main() {
 
 vec2 texelSize = 1.0 / vec2(textureSize(inTex,0));
 float blurred_visibility_factor = 0.0f;
 for (int t = -1; t <= 1; ++t) {
  for (int s = -1; s <= 1; ++s) {
   vec2 offset = vec2(float(s), float(t)) * texelSize;
   blurred_visibility_factor += texture2D(inTex, vTexCoords + offset).r;
  }
 }
    
 gl_FragDepthEXT = blurred_visibility_factor * INV_TOTAL_SAMPLES_FACTOR;
 
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/blur/blur.vert": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/blur/blur.vert ***!
            \**********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.frag": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.frag ***!
            \********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
#ifdef SHADED
uniform highp sampler2D shading;
#endif
varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif

#ifdef SHADED
    ivec2 dim = textureSize(shading,0);
    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;
    vColor *= shadowFactor;
#endif
    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.vert": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.vert ***!
            \********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 offset;
attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.frag ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
#ifdef SHADED
uniform highp sampler2D shading;
#endif
varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif
#ifdef SHADED
    ivec2 dim = textureSize(shading,0);
    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;
    vColor *= shadowFactor;
#endif
    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.vert ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag ***!
            \****************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `
#ifdef SHADED
uniform highp sampler2D shading;
#endif

uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vLightBack;

varying vec3 vColor;


//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    if ( gl_FrontFacing )
       gl_FragColor.xyz *= vLightFront;
    else
       gl_FragColor.xyz *= vLightBack;
    #endif

    vec3 color = vColor;
#ifdef SHADED
    ivec2 dim = textureSize(shading,0);
    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;
    color *= shadowFactor;
#endif
    gl_FragColor = gl_FragColor * vec4( color, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert ***!
            \****************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;
varying vec3 vLightBack;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );
    vLightBack = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;
    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.frag ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
//DEFINEFRAGCOLOR

void main() {
    gl_FragColor = vec4( outlineColor, 1 );

    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );    
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.vert ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;
uniform float vWidth;
uniform float vHeight;
uniform float outlineMaxPixels;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

void main() {

    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    mvPosition.xy += norm.xy*outlineWidth;
    vec4 outpos = projectionMatrix * mvPosition;

    if(outlineMaxPixels > 0.0) {
        vec4 unadjusted = projectionMatrix*modelViewMatrix * vec4( position, 1.0 );
        float w = outpos.w;
        //normalize homogeneous coords
        unadjusted /= unadjusted.w;
        outpos /= outpos.w;
        vec2 diff = outpos.xy-unadjusted.xy;
        //put into pixels
        diff.x *= vWidth;
        diff.y *= vHeight;
        if ( length(diff) > outlineMaxPixels) {
            vec2 ndiff = normalize(diff)*outlineMaxPixels;
            ndiff.x /= vWidth;
            ndiff.y /= vHeight;
            outpos.xy = unadjusted.xy;
            outpos.xy += ndiff;
        }
        outpos *= w; //if I don't do this things blow up
    }
    gl_Position = outpos;
    mvPosition.z -= outlinePushback; //go backwards in model space
    vec4 pushpos = projectionMatrix*mvPosition; //project to get z in projection space, I'm probably missing some simple math to do the same thing..
    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.frag ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform sampler2D colormap;
varying highp vec2 vTexCoords;
uniform vec2 dimensions;
//DEFINEFRAGCOLOR
void main (void) {
   gl_FragColor = texture2D(colormap, vTexCoords);

   //gl_FragColor.g = gl_FragColor.b =  gl_FragColor.r; //debug shading 
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.vert ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.frag": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.frag ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform highp sampler2D colormap;
varying highp vec2 vTexCoords;


// Basic FXAA implementation based on the code on geeks3d.com 
#define FXAA_REDUCE_MIN (1.0/ 128.0)
#define FXAA_REDUCE_MUL (1.0 / 8.0)
#define FXAA_SPAN_MAX 8.0


vec4 applyFXAA(vec2 fragCoord, highp sampler2D tex)
{
    vec4 color;
    ivec2 dim = textureSize(tex,0);
    vec2 dimensions = vec2(float(dim.x),float(dim.y));
    vec2 inverseVP = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);
    vec3 rgbNW = texture2D(tex, fragCoord + vec2(-1.0, -1.0) * inverseVP).xyz;
    vec3 rgbNE = texture2D(tex, fragCoord + vec2(1.0, -1.0) * inverseVP).xyz;
    vec3 rgbSW = texture2D(tex, fragCoord + vec2(-1.0, 1.0) * inverseVP).xyz;
    vec3 rgbSE = texture2D(tex, fragCoord + vec2(1.0, 1.0) * inverseVP).xyz;
    vec4 rgbM  = texture2D(tex, fragCoord  * inverseVP);
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM.xyz,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
            dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
        texture2D(tex, fragCoord + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture2D(tex, fragCoord  + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture2D(tex, fragCoord  + dir * -0.5).xyz +
        texture2D(tex, fragCoord  + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, rgbM.w);
    else
        color = vec4(rgbB, rgbM.w);
    return color;
}


//DEFINEFRAGCOLOR
void main (void) {
    ivec2 dim = textureSize(colormap,0);

  gl_FragColor = applyFXAA(vTexCoords, colormap);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.vert": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.vert ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag ***!
            \******************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `
uniform mat4 viewMatrix;
uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform float uDepth;
uniform vec3 directionalLightColor[ 1 ];

varying vec3 vColor;
varying vec2 mapping;
varying float rval;
varying vec3 vLight;
varying vec3 center;

#ifdef SHADED
uniform highp sampler2D shading;
#endif

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));
    float dotProduct = dot( norm, vLight );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;
    vec3 color = vLight*vColor;
#ifdef SHADED
    ivec2 dim = textureSize(shading,0);
    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;
    color *= shadowFactor;
#endif    
    gl_FragColor = vec4(color, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, gl_FragDepthEXT/gl_FragCoord.w );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );


}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert ***!
            \******************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying vec3 vColor;
varying float rval;
varying vec3 vLight;
varying vec3 center;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz );
    mapping = normal.xy;
    rval = abs(normal.x);
    gl_Position = projPosition+adjust;

}
`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag ***!
            \********************************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform mat4 projectionMatrix;
varying vec2 mapping;
varying float rval;
varying vec3 center;

uniform float outlinePushback;

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragColor = vec4(outlineColor, 1 );
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert ***!
            \********************************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;
uniform float outlineMaxPixels;
uniform float vWidth;
uniform float vHeight;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying float rval;
varying vec3 center;

void main() {

    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);

    vec4 adjust = projectionMatrix* vec4(norm,normal.z,1.0); 
    mapping = norm.xy;
    rval = abs(norm.x);
    gl_Position = projPosition+vec4(adjust.xy,0.0,0.0);

    if(outlineMaxPixels > 0.0) {
        vec4 unadjusted = projectionMatrix*vec4(center.x+normal.x, center.y,center.z,1.0); 
        vec4 ccoord = projectionMatrix*vec4(center.xyz,1.0);
        adjust = projectionMatrix* vec4(center.x+norm.x,center.y,center.z,1.0); 
        //subtract center 
        unadjusted.xyz -= ccoord.xyz;
        adjust.xyz -= ccoord.xyz;
        unadjusted /= unadjusted.w;
        adjust /= adjust.w;
        float diff = abs(adjust.x-unadjusted.x);
        diff *= vWidth;
        if(diff > outlineMaxPixels) {
            
            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth;
            //adjsut reval by ratio of lengths
            rval *= fixlen/abs(adjust.x);
        }

    }
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.frag ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform vec3 color;
uniform sampler2D map;
uniform float opacity;

uniform int fogType;
uniform vec3 fogColor;
uniform float fogDensity;
uniform float fogNear;
uniform float fogFar;
uniform float alphaTest;

varying vec2 vUV;
//DEFINEFRAGCOLOR

void main() {

    vec4 texture = texture2D(map, vUV);

    if (texture.a <= alphaTest) discard;

    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);

    if (fogType > 0) {

        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float fogFactor = 0.0;

        if (fogType == 1) {
            fogFactor = smoothstep(fogNear, fogFar, depth);
        }

        else {
            const float LOG2 = 1.442695;
            float fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);
            fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);
        }

        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);

    }
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.vert ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform int useScreenCoordinates;
uniform vec3 screenPosition;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float rotation;
uniform vec2 scale;
uniform vec2 alignment;
uniform vec2 uvOffset;
uniform vec2 uvScale;

attribute vec2 position;
attribute vec2 uv;

varying vec2 vUV;

void main() {

    vUV = uvOffset + uv * uvScale;

    vec2 alignedPosition = position + alignment;

    vec2 rotatedPosition;
    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;
    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;

    vec4 finalPosition;

    if(useScreenCoordinates != 0) {
        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);
    }

    else {
        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;
        finalPosition.xy += rotatedPosition; 
    }

    gl_Position = finalPosition;

}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/ssao/ssao.frag": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/ssao/ssao.frag ***!
            \**********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform sampler2D depthmap;
varying highp vec2 vTexCoords;
uniform float vWidth;
uniform float vHeight;
uniform float total_strength;
uniform float radius;
uniform mat4 projinv;
uniform mat4 projectionMatrix;

//code for pseudorandom vector from chatgpt
float hash(vec3 p) {
    p = fract(p * vec3(0.1031, 0.1030, 0.0973));
    p += dot(p, p.yzx + 33.33);
    return fract((p.x + p.y) * p.z);
}

// Generate a pseudorandom vec3 from a seed vec3
vec3 pseudorandomVec3(vec3 seed) {
    vec3 randomVec;
    randomVec.x = hash(seed);
    randomVec.y = hash(seed + vec3(1.0, 0.0, 17.1));
    randomVec.z = hash(seed + vec3(0.0, 13.23, 0.0));
    return randomVec;
}

void main(void)
{   
   const float base = 0.2;
   const float area = 0.75;
   const int cycles = 1;

   const int samples = 64;
   vec3 sample_sphere[64] = vec3[](
      vec3(0.091258,-0.510164,0.000000),
      vec3(-0.204347,-0.872967,0.187199),
      vec3(0.009690,-0.263696,-0.110414),
      vec3(0.175208,-0.563987,0.228527),
      vec3(-0.001824,-0.003113,-0.000323),
      vec3(0.411134,-0.719869,-0.261530),
      vec3(-0.074272,-0.377368,0.276290),
      vec3(-0.147773,-0.381587,-0.284529),
      vec3(0.173317,-0.199635,0.063295),
      vec3(-0.186452,-0.199460,0.076965),
      vec3(0.143985,-0.308160,-0.307687),
      vec3(0.053194,-0.148286,0.169589),
      vec3(-0.547656,-0.486476,-0.317378),
      vec3(0.020804,-0.015092,-0.004574),
      vec3(-0.038006,-0.043165,0.054059),
      vec3(-0.094795,-0.443908,-0.731525),
      vec3(0.547552,-0.396466,0.461477),
      vec3(-0.176886,-0.089989,0.007315),
      vec3(0.074401,-0.048840,-0.074039),
      vec3(-0.008240,-0.075697,0.178197),
      vec3(-0.307880,-0.185053,-0.368943),
      vec3(0.309520,-0.108483,0.041646),
      vec3(-0.773478,-0.292946,0.538166),
      vec3(0.184487,-0.231594,-0.820065),
      vec3(0.207318,-0.100531,0.361797),
      vec3(-0.173306,-0.037737,-0.055289),
      vec3(0.548102,-0.105342,-0.253237),
      vec3(-0.119342,-0.043907,0.285162),
      vec3(-0.270247,-0.087861,-0.751357),
      vec3(0.449312,-0.039777,0.236146),
      vec3(-0.743773,-0.036095,0.196056),
      vec3(0.148819,-0.004300,-0.231448),
      vec3(0.008773,0.000809,0.051047),
      vec3(-0.461467,0.027390,-0.357386),
      vec3(0.169626,0.013338,-0.014053),
      vec3(-0.043786,0.007095,0.047331),
      vec3(0.004821,0.140371,-0.988260),
      vec3(0.092402,0.023994,0.101860),
      vec3(-0.295335,0.061530,-0.027372),
      vec3(0.024903,0.007537,-0.018901),
      vec3(-0.081463,0.125402,0.447794),
      vec3(-0.397119,0.231805,-0.631062),
      vec3(0.163853,0.059014,0.044905),
      vec3(-0.495220,0.214357,0.254139),
      vec3(0.306123,0.373687,-0.825715),
      vec3(0.021665,0.026737,0.053220),
      vec3(-0.208231,0.117129,-0.098685),
      vec3(0.139749,0.080968,-0.043086),
      vec3(-0.153599,0.182814,0.262090),
      vec3(-0.159673,0.496777,-0.743568),
      vec3(0.134797,0.117152,0.095753),
      vec3(-0.155626,0.120533,0.019395),
      vec3(0.042311,0.054462,-0.049709),
      vec3(0.001257,0.031288,0.034468),
      vec3(-0.002271,0.003199,-0.002304),
      vec3(0.662104,0.717307,0.033854),
      vec3(-0.373100,0.576021,0.308274),
      vec3(0.024233,0.231316,-0.173688),
      vec3(0.161311,0.420217,0.234273),
      vec3(-0.045248,0.078031,-0.010411),
      vec3(0.167453,0.376942,-0.094872),
      vec3(-0.056194,0.433247,0.173218),
      vec3(-0.016224,0.123149,-0.035569),
      vec3(0.067127,0.407641,0.028479)
   );

   float depth = texture2D(depthmap, vTexCoords).r;
   if(depth == 1.0) {
      discard;
   }

   vec4 screen_position = vec4(vTexCoords, depth,1.0);
   vec4 pos = projinv*screen_position;
   pos /= pos.w;
   vec3 position = pos.xyz;

   //approximate the normal from the depth map; I find this simpler
   //than trying to recompute the exact normal within every possible object shader

   //pixel offset positions in screen space
   ivec2 dim = textureSize(depthmap,0);
   vec2 offset1 = vec2(0.0,1.0/float(dim.y));
   vec2 offset2 = vec2(1.0/float(dim.x),0.0);
   float depth1 = texture2D(depthmap, vTexCoords + offset1).r;
   float depth2 = texture2D(depthmap, vTexCoords + offset2).r;
   
   vec3 p1 = vec3(screen_position.xy+offset1, depth1 - depth);
   vec3 p2 = vec3(screen_position.xy+offset2, depth2 - depth);

   //convert to model space
   vec4 pos1 = projinv*vec4(p1,1);
   pos1 /= pos1.w;
   vec4 pos2 = projinv*vec4(p2,1);
   pos2 /= pos2.w;

   vec3 normal = normalize(cross(pos1.xyz-position, pos2.xyz-position)); //model normal, important we normalize in model space

   //pseudo random number

   float occlusion = 0.0;
   for(int c = 0; c < cycles; c++) {
   vec3 random = normalize(pseudorandomVec3(position+float(c)));
   for(int i=0; i < samples; i++) {

      vec3 ray = radius * reflect(sample_sphere[i],random);
      vec3 hemi_ray = position + sign(dot(ray,normal)) * ray; //model space
      vec4 hemi_screen = projectionMatrix*vec4(hemi_ray,1.0);
      hemi_screen /= hemi_screen.w;
      
      float occ_depth = texture2D(depthmap, clamp(hemi_screen.xy,0.0,1.0)).r;
      float difference = hemi_screen.z - occ_depth;
      
      occlusion += step(0.0, difference) * (1.0-smoothstep(0.0, area, difference));
   }
   }
   float ao = 1.0 - total_strength * occlusion * (1.0 / float(cycles*samples));
   gl_FragDepthEXT = clamp(ao+base,0.0,1.0);

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/ssao/ssao.vert": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/ssao/ssao.vert ***!
            \**********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag": (
          /*!************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag ***!
            \************************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `    float dotProduct = dot( norm, vLight );
    vec3 light = vec3( max( dotProduct, 0.0 ) );
    color *= light;
#ifdef SHADED
    ivec2 dim = textureSize(shading,0);
    float shadowFactor = texture2D(shading,vec2(gl_FragCoord.x/float(dim.x),gl_FragCoord.y/float(dim.y))).r;
    color *= shadowFactor;
#endif    
    gl_FragColor = vec4(color, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.vert ***!
            \****************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = color; vColor.z = abs(vColor.z); //z indicates which vertex and so would vary
    r = abs(radius);
    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }
    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p1);
         float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
         mvPosition.xyz = p1+t*pnorm; 
       } else { //orthographic
         mvPosition.xyz = p1;
       }
    } else {
      if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p2);
         float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
         mvPosition.xyz = p2+t*pnorm;
       } else { //orthographic
         mvPosition.xyz = p2;
       } 
       mult *= -1.0;
    }
    vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;
    mvPosition.xyz +=  mult*(cr + doublecr).xyz;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz )*directionalLightColor[0]; //not really sure this is right, but color is always white so..
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag": (
          /*!**************************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag ***!
            \**************************************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLight;
varying vec3 vColor;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

#ifdef SHADED
uniform highp sampler2D shading;
#endif

//DEFINEFRAGCOLOR

//cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf
//also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl
//with a bit more care (caps) this could be a general cylinder imposter (see also outline)
void main() {
    vec3 color = abs(vColor);
    vec3 pos = cposition;
    vec3 p = pos; //ray point
    vec3 v = vec3(0.0,0.0,-1.0); //ray normal - orthographic
    if(projectionMatrix[3][3] == 0.0) v = normalize(pos); //ray normal - perspective
    vec3 pa = p1; //cyl start
    vec3 va = normalize(p2-p1); //cyl norm
    vec3 tmp1 = v-(dot(v,va)*va);
    vec3 deltap = p-pa;
    float A = dot(tmp1,tmp1);
    if(A == 0.0) discard;
    vec3 tmp2 = deltap-(dot(deltap,va)*va);
    float B = 2.0*dot(tmp1, tmp2);
    float C = dot(tmp2,tmp2)-r*r;
//quadratic equation!
    float det = (B*B) - (4.0*A*C);
    if(det < 0.0) discard;
    float sqrtDet = sqrt(det);
    float posT = (-B+sqrtDet)/(2.0*A);
    float negT = (-B-sqrtDet)/(2.0*A);
    float intersectionT = min(posT,negT);
    vec3 qi = p+v*intersectionT;
    float dotp1 = dot(va,qi-p1);
    float dotp2 = dot(va,qi-p2);
    vec3 norm;
    if( dotp1 < 0.0 || dotp2 > 0.0) { //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0
       vec3 cp;
       if( dotp1 < 0.0) {  
//        if(vColor.x < 0.0 ) discard; //color sign bit indicates if we should cap or not
        cp = p1;
       } else {
//          if(vColor.y < 0.0 ) discard;
          cp = p2;
       }
       vec3 diff = p-cp;
       A = dot(v,v);
       B = dot(diff,v)*2.0;
       C = dot(diff,diff)-r*r;
       det = (B*B) - (4.0*C);
       if(det < 0.0) discard;
       sqrtDet = sqrt(det);
       posT = (-B+sqrtDet)/(2.0);
       negT = (-B-sqrtDet)/(2.0);
       float t = min(posT,negT);
       qi = p+v*t; 
       norm = normalize(qi-cp); 
    } else {
       norm = normalize(qi-(dotp1*va + p1));
    }
    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragDepthEXT = depth;`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert": (
          /*!******************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert ***!
            \******************************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];
uniform vec3 outlineColor;
uniform float outlineWidth;
uniform float outlinePushback;
uniform float outlineMaxPixels;
uniform float vWidth;
uniform mat4 projinv;


attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = outlineColor;
    float rad = radius+sign(radius)*outlineWidth;
    r = abs(rad);

    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
//pushback
    float scale = 1.0;
    if(projectionMatrix[3][3] != 0.0) { //orthographic
        to.z -= outlinePushback;
        pt.z -= outlinePushback;
    } else { //perspective
        vec4 midbefore = pt;
        if(length(to.xyz) < length(pt)) {
            midbefore = to;
        }
        vec4 midafter = midbefore;
        midafter.xyz += normalize(midbefore.xyz)*outlinePushback;

        to.xyz += normalize(to.xyz)*outlinePushback;
        pt.xyz += normalize(pt.xyz)*outlinePushback;

        //figure out a scaling factor for radius to account for perspective setback
        vec4 midbeforer = vec4(midbefore.x+rad,midbefore.y, midbefore.z, midbefore.w);
        vec4 midafterr = vec4(midafter.x+rad,midafter.y, midafter.z, midafter.w);

        vec4 mb = projectionMatrix*midbefore;
        vec4 mbr = projectionMatrix*midbeforer;
        vec4 ma = projectionMatrix*midafter;
        vec4 mar = projectionMatrix*midafterr;
        mb /= mb.w;
        mbr /= mbr.w;
        ma /= ma.w;
        mar /= mar.w;
        scale = abs((mbr.x-mb.x)/(mar.x-ma.x));
        rad *= scale;
        r = abs(rad);
    }
    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }

    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       vec3 pnorm = normalize(p1);
       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
       mvPosition.xyz = p1+t*pnorm;
    } else {
       vec3 pnorm = normalize(p2);
       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
       mvPosition.xyz = p2+t*pnorm;
       mult *= -1.0;
    }

    if(outlineMaxPixels > 0.0) {
        vec4 cpos = mvPosition;
        vec4 unadjusted = projectionMatrix*vec4(cpos.x+abs(scale*radius), cpos.y,cpos.z,cpos.w); 
        vec4 ccoord = projectionMatrix*cpos;
        vec4 adjust = projectionMatrix*vec4(cpos.x+r,cpos.y,cpos.z,cpos.w); 
        unadjusted /= unadjusted.w;
        adjust /= adjust.w;
        unadjusted.xyz -= ccoord.xyz/ccoord.w;
        adjust.xyz -= ccoord.xyz/ccoord.w;
        float diff = abs(adjust.x-unadjusted.x);
        diff *= vWidth; //this should now be in pixels
        if(diff > outlineMaxPixels) {
            float fixlen = abs(unadjusted.x) + outlineMaxPixels/vWidth; 
            vec4 pcoord = ccoord;
            pcoord.x += fixlen*pcoord.w;
            vec4 altc = projinv*pcoord;
            r= abs(altc.x-cpos.x);
        }
    }

    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;
    mvPosition.xy +=  mult*(cr + doublecr).xy;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vLight = vec3(1.0,1.0,1.0);
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.frag": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.frag ***!
            \**********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `
uniform highp sampler3D data;
uniform highp sampler2D colormap;
uniform highp sampler2D depthmap;


uniform mat4 textmat;
uniform mat4 projinv;
uniform mat4 projectionMatrix;

uniform float step;
uniform float subsamples;
uniform float maxdepth;
uniform float transfermin;
uniform float transfermax;
in  vec4 mvPosition;
out vec4 color;
void main(void) {

   vec4 pos = mvPosition;
   bool seengood = false;
   float i = 0.0;
   color = vec4(1,1,1,0);
   float increment = 1.0/subsamples;
   float maxsteps = (maxdepth*subsamples/step);
//there's probably a better way to do this..
//calculate farthest possible point in model coordinates
   vec4 maxpos = vec4(pos.x,pos.y,pos.z-maxdepth,1.0);
// convert to projection
   maxpos = projectionMatrix*maxpos;
   vec4 startp = projectionMatrix*pos;
// homogonize
   maxpos /= maxpos.w;
   startp /= startp.w;
//take x,y from start and z from max
   maxpos = vec4(startp.x,startp.y,maxpos.z,1.0);
//convert back to model space
   maxpos = projinv*maxpos;
   maxpos /= maxpos.w;
   float incr = step/subsamples;
//get depth from depthmap
//startp is apparently [-1,1]
   vec2 tpos = startp.xy/2.0+0.5;
   float depth = texture(depthmap, tpos).r;
//compute vector between start and end
   vec4 direction = maxpos-pos;
   for( i = 0.0; i <= maxsteps; i++) {
      vec4 pt = (pos+(i/maxsteps)*direction);
      vec4 ppt = projectionMatrix*pt;
      float ptdepth = ppt.z/ppt.w;
      ptdepth = ((gl_DepthRange.diff * ptdepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
      if(ptdepth > depth) break;
      pt = textmat*pt;
//       pt /= pt.w;
      if(pt.x >= -0.01 && pt.y >= -0.01 && pt.z >= -0.01 && pt.x <= 1.01 && pt.y <= 1.01 && pt.z <= 1.01) {
         seengood = true;
      } else if(seengood) {
         break;
      }
      if( pt.x < -0.01 || pt.x > 1.01 || pt.y < -0.01 || pt.y > 1.01 || pt.z < -0.01 || pt.z > 1.01  ){
          color.a = 0.0;
          continue;
      }
      else {
         float val = texture(data, pt.zyx).r;
         if(isinf(val)) continue; //masked out
         float cval = (val-transfermin)/(transfermax-transfermin); //scale to texture 0-1 range
         vec4 val_color = texture(colormap, vec2(cval,0.5));
         color.rgb = color.rgb*color.a + (1.0-color.a)*val_color.a*val_color.rgb;
         color.a += (1.0 - color.a) * val_color.a; 
         if(color.a > 0.0) color.rgb /= color.a;
//          color = vec4(pt.x, pt.y, pt.z, 1.0);
      }
//       color = vec4(pt.x, pt.y, pt.z, 0.0)
    }
}

        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.vert": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.vert ***!
            \**********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              default: () => n
              /* harmony export */
            });
            const n = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;

in vec3 position;
out vec4 mvPosition;
void main() {

    mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix*mvPosition;
}
`;
          }
        ),
        /***/
        "./src/GLDraw.ts": (
          /*!***********************!*\
            !*** ./src/GLDraw.ts ***!
            \***********************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CAP: () => (
                /* binding */
                s
              ),
              /* harmony export */
              GLDraw: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), s;
            (function(b) {
              b[b.NONE = 0] = "NONE", b[b.FLAT = 1] = "FLAT", b[b.ROUND = 2] = "ROUND";
            })(s || (s = {}));
            var h;
            (function(b) {
              function g(y, o, v) {
                var w = Math.hypot(y, o), M, F, m, E, z;
                w < 1e-4 ? (F = 0, m = 1) : (F = -y / w, m = o / w), o = -F * y + m * o, M = Math.hypot(o, v), M < 1e-4 ? (E = 0, z = 1) : (E = v / M, z = o / M);
                var O = new Float32Array(9);
                return O[0] = m, O[1] = F, O[2] = 0, O[3] = -F * z, O[4] = m * z, O[5] = E, O[6] = F * E, O[7] = -m * E, O[8] = z, O;
              }
              class _ {
                constructor() {
                  this.cache = {};
                  let o = [], v = 4, w = Math.pow(2, v), M = 2, F = Math.pow(2, M), m = w / F, E;
                  for (o[0] = new n.Vector3(-1, 0, 0), o[m] = new n.Vector3(0, 0, 1), o[m * 2] = new n.Vector3(1, 0, 0), o[m * 3] = new n.Vector3(0, 0, -1), M = 3; M <= v; M++) {
                    for (F = Math.pow(2, M - 1), m = w / F, E = 0; E < F - 1; E++)
                      o[m / 2 + E * m] = o[E * m].clone().add(o[(E + 1) * m]).normalize();
                    E = F - 1, o[m / 2 + E * m] = o[E * m].clone().add(o[0]).normalize();
                  }
                  this.basisVectors = o;
                }
                getVerticesForRadius(o, v, w) {
                  if (typeof this.cache < "u" && this.cache[o] !== void 0 && this.cache[o][v + w] !== void 0)
                    return this.cache[o][v + w];
                  for (var M = this.basisVectors.length, F = [], m = [], E, z = 0; z < M; z++)
                    F.push(this.basisVectors[z].clone().multiplyScalar(o)), F.push(this.basisVectors[z].clone().multiplyScalar(o)), E = this.basisVectors[z].clone().normalize(), m.push(E), m.push(E);
                  var O = [], R = 10, B = M, P = 0, W = Math.PI * 2, U = 0, V = Math.PI, K, q, H = !1, j = !1;
                  for (q = 0; q <= R; q++) {
                    H = q === 0 || q === R, j = q === R / 2;
                    var Q = [], J = [];
                    for (K = 0; K <= B; K++) {
                      if (j) {
                        var Y = K < B ? 2 * K : 0;
                        J.push(Y + 1), Q.push(Y);
                        continue;
                      }
                      var ee = K / B, fe = q / R;
                      if (!H || K === 0)
                        if (K < B) {
                          var me = new n.Vector3();
                          me.x = -o * Math.cos(P + ee * W) * Math.sin(U + fe * V), v == 1 ? me.y = 0 : me.y = o * Math.cos(U + fe * V), me.z = o * Math.sin(P + ee * W) * Math.sin(U + fe * V), Math.abs(me.x) < 1e-5 && (me.x = 0), Math.abs(me.y) < 1e-5 && (me.y = 0), Math.abs(me.z) < 1e-5 && (me.z = 0), v == s.FLAT ? (E = new n.Vector3(0, Math.cos(U + fe * V), 0), E.normalize()) : (E = new n.Vector3(me.x, me.y, me.z), E.normalize()), F.push(me), m.push(E), Q.push(F.length - 1);
                        } else
                          Q.push(F.length - B);
                      else H && Q.push(F.length - 1);
                    }
                    j && O.push(J), O.push(Q);
                  }
                  var he = {
                    vertices: F,
                    normals: m,
                    verticesRows: O,
                    w: B,
                    h: R
                  };
                  return o in this.cache || (this.cache[o] = {}), this.cache[o][v + w] = he, he;
                }
              }
              var A = new _();
              function x(y, o, v, w, M, F = 0, m = 0) {
                if (!o || !v)
                  return;
                let E = function(Ie) {
                  if (typeof Ie == "string") {
                    let lt = Ie;
                    return lt.toLowerCase() == "flat" ? s.FLAT : lt.toLowerCase() == "round" ? s.ROUND : s.NONE;
                  } else
                    return Ie;
                };
                F = E(F), m = E(m);
                var z = m || F;
                M = M || { r: 0, g: 0, b: 0 };
                var O = g(v.x - o.x, v.y - o.y, v.z - o.z), R = A.getVerticesForRadius(w, m, "to"), B = R.w, P = R.h, W = z ? P * B + 2 : 2 * B, U = y.updateGeoGroup(W), V = R.vertices, K = R.normals, q = R.verticesRows, H = q[P / 2], j = q[P / 2 + 1], Q = U.vertices, J, Y, ee, fe, me, he, we = U.vertexArray, ye = U.normalArray, ve = U.colorArray, ce = U.faceArray;
                for (ee = 0; ee < B; ++ee) {
                  var be = 2 * ee;
                  fe = O[0] * V[be].x + O[3] * V[be].y + O[6] * V[be].z, me = O[1] * V[be].x + O[4] * V[be].y + O[7] * V[be].z, he = O[5] * V[be].y + O[8] * V[be].z, J = 3 * (Q + be), Y = U.faceidx, we[J] = fe + o.x, we[J + 1] = me + o.y, we[J + 2] = he + o.z, we[J + 3] = fe + v.x, we[J + 4] = me + v.y, we[J + 5] = he + v.z, ye[J] = fe, ye[J + 3] = fe, ye[J + 1] = me, ye[J + 4] = me, ye[J + 2] = he, ye[J + 5] = he, ve[J] = M.r, ve[J + 3] = M.r, ve[J + 1] = M.g, ve[J + 4] = M.g, ve[J + 2] = M.b, ve[J + 5] = M.b, ce[Y] = j[ee] + Q, ce[Y + 1] = j[ee + 1] + Q, ce[Y + 2] = H[ee] + Q, ce[Y + 3] = H[ee] + Q, ce[Y + 4] = j[ee + 1] + Q, ce[Y + 5] = H[ee + 1] + Q, U.faceidx += 6;
                }
                if (z) {
                  var le = m ? 0 : P / 2, Se = F ? P + 1 : P / 2 + 1, ge, de, De, Be, Ve, qe, Ze, Ye, Xe, Ge, Ke, Pe, it, nt, ne, se, ue, $e, Ae, je, ze, re, xe, Le, He, Me, Re, ie, We, Qe, G, Fe;
                  for (me = le; me < Se; me++)
                    if (me !== P / 2) {
                      var Te = me <= P / 2 ? v : o, ae = A.getVerticesForRadius(w, m, "to"), Ee = A.getVerticesForRadius(w, F, "from");
                      for (Te === v ? (V = ae.vertices, K = ae.normals, q = ae.verticesRows) : Te == o && (V = Ee.vertices, K = Ee.normals, q = Ee.verticesRows), fe = 0; fe < B; fe++)
                        Y = U.faceidx, ge = q[me][fe + 1], We = (ge + Q) * 3, de = q[me][fe], Qe = (de + Q) * 3, De = q[me + 1][fe], G = (De + Q) * 3, Be = q[me + 1][fe + 1], Fe = (Be + Q) * 3, Ve = O[0] * V[ge].x + O[3] * V[ge].y + O[6] * V[ge].z, qe = O[0] * V[de].x + O[3] * V[de].y + O[6] * V[de].z, Ze = O[0] * V[De].x + O[3] * V[De].y + O[6] * V[De].z, Ye = O[0] * V[Be].x + O[3] * V[Be].y + O[6] * V[Be].z, Xe = O[1] * V[ge].x + O[4] * V[ge].y + O[7] * V[ge].z, Ge = O[1] * V[de].x + O[4] * V[de].y + O[7] * V[de].z, Ke = O[1] * V[De].x + O[4] * V[De].y + O[7] * V[De].z, Pe = O[1] * V[Be].x + O[4] * V[Be].y + O[7] * V[Be].z, it = O[5] * V[ge].y + O[8] * V[ge].z, nt = O[5] * V[de].y + O[8] * V[de].z, ne = O[5] * V[De].y + O[8] * V[De].z, se = O[5] * V[Be].y + O[8] * V[Be].z, we[We] = Ve + Te.x, we[Qe] = qe + Te.x, we[G] = Ze + Te.x, we[Fe] = Ye + Te.x, we[We + 1] = Xe + Te.y, we[Qe + 1] = Ge + Te.y, we[G + 1] = Ke + Te.y, we[Fe + 1] = Pe + Te.y, we[We + 2] = it + Te.z, we[Qe + 2] = nt + Te.z, we[G + 2] = ne + Te.z, we[Fe + 2] = se + Te.z, ve[We] = M.r, ve[Qe] = M.r, ve[G] = M.r, ve[Fe] = M.r, ve[We + 1] = M.g, ve[Qe + 1] = M.g, ve[G + 1] = M.g, ve[Fe + 1] = M.g, ve[We + 2] = M.b, ve[Qe + 2] = M.b, ve[G + 2] = M.b, ve[Fe + 2] = M.b, ue = O[0] * K[ge].x + O[3] * K[ge].y + O[6] * K[ge].z, $e = O[0] * K[de].x + O[3] * K[de].y + O[6] * K[de].z, Ae = O[0] * K[De].x + O[3] * K[De].y + O[6] * K[De].z, je = O[0] * K[Be].x + O[3] * K[Be].y + O[6] * K[Be].z, ze = O[1] * K[ge].x + O[4] * K[ge].y + O[7] * K[ge].z, re = O[1] * K[de].x + O[4] * K[de].y + O[7] * K[de].z, xe = O[1] * K[De].x + O[4] * K[De].y + O[7] * K[De].z, Le = O[1] * K[Be].x + O[4] * K[Be].y + O[7] * K[Be].z, He = O[5] * K[ge].y + O[8] * K[ge].z, Me = O[5] * K[de].y + O[8] * K[de].z, Re = O[5] * K[De].y + O[8] * K[De].z, ie = O[5] * K[Be].y + O[8] * K[Be].z, me === 0 ? (ye[We] = ue, ye[G] = Ae, ye[Fe] = je, ye[We + 1] = ze, ye[G + 1] = xe, ye[Fe + 1] = Le, ye[We + 2] = He, ye[G + 2] = Re, ye[Fe + 2] = ie, ce[Y] = ge + Q, ce[Y + 1] = De + Q, ce[Y + 2] = Be + Q, U.faceidx += 3) : me === Se - 1 ? (ye[We] = ue, ye[Qe] = $e, ye[G] = Ae, ye[We + 1] = ze, ye[Qe + 1] = re, ye[G + 1] = xe, ye[We + 2] = He, ye[Qe + 2] = Me, ye[G + 2] = Re, ce[Y] = ge + Q, ce[Y + 1] = de + Q, ce[Y + 2] = De + Q, U.faceidx += 3) : (ye[We] = ue, ye[Qe] = $e, ye[Fe] = je, ye[We + 1] = ze, ye[Qe + 1] = re, ye[Fe + 1] = Le, ye[We + 2] = He, ye[Qe + 2] = Me, ye[Fe + 2] = ie, ye[Qe] = $e, ye[G] = Ae, ye[Fe] = je, ye[Qe + 1] = re, ye[G + 1] = xe, ye[Fe + 1] = Le, ye[Qe + 2] = Me, ye[G + 2] = Re, ye[Fe + 2] = ie, ce[Y] = ge + Q, ce[Y + 1] = de + Q, ce[Y + 2] = Be + Q, ce[Y + 3] = de + Q, ce[Y + 4] = De + Q, ce[Y + 5] = Be + Q, U.faceidx += 6);
                    }
                }
                U.vertices += W;
              }
              b.drawCylinder = x;
              function k(y, o, v, w, M) {
                if (!o || !v)
                  return;
                M = M || { r: 0, g: 0, b: 0 };
                let F = new n.Vector3(v.x - o.x, v.y - o.y, v.z - o.z);
                var m = g(F.x, F.y, F.z);
                F = F.normalize();
                var E = A.basisVectors.length, z = A.basisVectors, O = E + 2, R = y.updateGeoGroup(O), B = R.vertices, P, W, U, V, K, q, H = R.vertexArray, j = R.normalArray, Q = R.colorArray, J = R.faceArray;
                for (P = B * 3, H[P] = o.x, H[P + 1] = o.y, H[P + 2] = o.z, j[P] = -F.x, j[P + 1] = -F.y, j[P + 2] = -F.z, Q[P] = M.r, Q[P + 1] = M.g, Q[P + 2] = M.b, H[P + 3] = v.x, H[P + 4] = v.y, H[P + 5] = v.z, j[P + 3] = F.x, j[P + 4] = F.y, j[P + 5] = F.z, Q[P + 3] = M.r, Q[P + 4] = M.g, Q[P + 5] = M.b, P += 6, U = 0; U < E; ++U) {
                  var Y = z[U].clone();
                  Y.multiplyScalar(w), V = m[0] * Y.x + m[3] * Y.y + m[6] * Y.z, K = m[1] * Y.x + m[4] * Y.y + m[7] * Y.z, q = m[5] * Y.y + m[8] * Y.z, H[P] = V + o.x, H[P + 1] = K + o.y, H[P + 2] = q + o.z, j[P] = V, j[P + 1] = K, j[P + 2] = q, Q[P] = M.r, Q[P + 1] = M.g, Q[P + 2] = M.b, P += 3;
                }
                for (R.vertices += E + 2, W = R.faceidx, U = 0; U < E; U++) {
                  var ee = B + 2 + U, fe = B + 2 + (U + 1) % E;
                  J[W] = ee, J[W + 1] = fe, J[W + 2] = B, W += 3, J[W] = ee, J[W + 1] = fe, J[W + 2] = B + 1, W += 3;
                }
                R.faceidx += 6 * E;
              }
              b.drawCone = k;
              class $ {
                constructor() {
                  this.cache = /* @__PURE__ */ new Map();
                }
                getVerticesForRadius(o, v) {
                  v = v || 2, this.cache.has(v) || this.cache.set(v, /* @__PURE__ */ new Map());
                  let w = this.cache.get(v);
                  if (w.has(o))
                    return w.get(o);
                  var M = {
                    vertices: [],
                    verticesRows: [],
                    normals: []
                  }, F = 16 * v, m = 10 * v;
                  o < 1 && (F = 10 * v, m = 8 * v);
                  var E = 0, z = Math.PI * 2, O = 0, R = Math.PI, B, P;
                  for (P = 0; P <= m; P++) {
                    let U = [];
                    for (B = 0; B <= F; B++) {
                      let V = B / F, K = P / m, q = -o * Math.cos(E + V * z) * Math.sin(O + K * R), H = o * Math.cos(O + K * R), j = o * Math.sin(E + V * z) * Math.sin(O + K * R);
                      var W = new n.Vector3(q, H, j);
                      W.normalize(), M.vertices.push({ x: q, y: H, z: j }), M.normals.push(W), U.push(M.vertices.length - 1);
                    }
                    M.verticesRows.push(U);
                  }
                  return w.set(o, M), M;
                }
              }
              var C = new $();
              function L(y, o, v, w, M) {
                var F = C.getVerticesForRadius(v, M), m = F.vertices, E = F.normals, z = y.updateGeoGroup(m.length), O = z.vertices, R = z.vertexArray, B = z.colorArray, P = z.faceArray, W = z.lineArray, U = z.normalArray;
                for (let q = 0, H = m.length; q < H; ++q) {
                  let j = 3 * (O + q), Q = m[q];
                  R[j] = Q.x + o.x, R[j + 1] = Q.y + o.y, R[j + 2] = Q.z + o.z, B[j] = w.r, B[j + 1] = w.g, B[j + 2] = w.b;
                }
                z.vertices += m.length;
                let V = F.verticesRows, K = V.length - 1;
                for (let q = 0; q < K; q++) {
                  let H = V[q].length - 1;
                  for (let j = 0; j < H; j++) {
                    let Q = z.faceidx, J = z.lineidx, Y = V[q][j + 1] + O, ee = Y * 3, fe = V[q][j] + O, me = fe * 3, he = V[q + 1][j] + O, we = he * 3, ye = V[q + 1][j + 1] + O, ve = ye * 3, ce = E[Y - O], be = E[fe - O], le = E[he - O], Se = E[ye - O];
                    Math.abs(m[Y - O].y) === v ? (U[ee] = ce.x, U[we] = le.x, U[ve] = Se.x, U[ee + 1] = ce.y, U[we + 1] = le.y, U[ve + 1] = Se.y, U[ee + 2] = ce.z, U[we + 2] = le.z, U[ve + 2] = Se.z, P[Q] = Y, P[Q + 1] = he, P[Q + 2] = ye, W[J] = Y, W[J + 1] = he, W[J + 2] = Y, W[J + 3] = ye, W[J + 4] = he, W[J + 5] = ye, z.faceidx += 3, z.lineidx += 6) : Math.abs(m[he - O].y) === v ? (U[ee] = ce.x, U[me] = be.x, U[we] = le.x, U[ee + 1] = ce.y, U[me + 1] = be.y, U[we + 1] = le.y, U[ee + 2] = ce.z, U[me + 2] = be.z, U[we + 2] = le.z, P[Q] = Y, P[Q + 1] = fe, P[Q + 2] = he, W[J] = Y, W[J + 1] = fe, W[J + 2] = Y, W[J + 3] = he, W[J + 4] = fe, W[J + 5] = he, z.faceidx += 3, z.lineidx += 6) : (U[ee] = ce.x, U[me] = be.x, U[ve] = Se.x, U[ee + 1] = ce.y, U[me + 1] = be.y, U[ve + 1] = Se.y, U[ee + 2] = ce.z, U[me + 2] = be.z, U[ve + 2] = Se.z, U[me] = be.x, U[we] = le.x, U[ve] = Se.x, U[me + 1] = be.y, U[we + 1] = le.y, U[ve + 1] = Se.y, U[me + 2] = be.z, U[we + 2] = le.z, U[ve + 2] = Se.z, P[Q] = Y, P[Q + 1] = fe, P[Q + 2] = ye, P[Q + 3] = fe, P[Q + 4] = he, P[Q + 5] = ye, W[J] = Y, W[J + 1] = fe, W[J + 2] = Y, W[J + 3] = ye, W[J + 4] = fe, W[J + 5] = he, W[J + 6] = he, W[J + 7] = ye, z.faceidx += 6, z.lineidx += 8);
                  }
                }
              }
              b.drawSphere = L;
            })(h || (h = {}));
          }
        ),
        /***/
        "./src/GLModel.ts": (
          /*!************************!*\
            !*** ./src/GLModel.ts ***!
            \************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              GLModel: () => (
                /* binding */
                L
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), h = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), b = r(
              /*! ./colors */
              "./src/colors.ts"
            ), g = r(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), _ = r(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), A = r(
              /*! ./utilities */
              "./src/utilities.ts"
            ), x = r(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), k = r(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), $ = r(
              /*! netcdfjs */
              "./node_modules/netcdfjs/lib-esm/index.js"
            ), C = r(
              /*! ./parsers/utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            class L {
              // class functions
              // return true if a and b represent the same style
              static sameObj(o, v) {
                return o && v ? JSON.stringify(o) == JSON.stringify(v) : o == v;
              }
              constructor(o, v) {
                this.atoms = [], this.frames = [], this.box = null, this.atomdfs = null, this.id = 0, this.hidden = !1, this.molObj = null, this.renderedMolObj = null, this.lastColors = null, this.modelData = {}, this.modelDatas = null, this.idMatrix = new h.Matrix4(), this.dontDuplicateAtoms = !0, this.defaultColor = b.elementColors.defaultColor, this.defaultStickRadius = 0.25, this.options = v || {}, this.ElementColors = this.options.defaultcolors ? this.options.defaultcolors : b.elementColors.defaultColors, this.defaultSphereRadius = this.options.defaultSphereRadius ? this.options.defaultSphereRadius : 1.5, this.defaultCartoonQuality = this.options.cartoonQuality ? this.options.cartoonQuality : 10, this.id = o;
              }
              // return proper radius for atom given style
              /**
               *
               * @param {AtomSpec} atom
               * @param {atomstyle} style
               * @return {number}
               *
               */
              getRadiusFromStyle(o, v) {
                var w = this.defaultSphereRadius;
                if (typeof v.radius < "u")
                  w = v.radius;
                else if (L.vdwRadii[o.elem])
                  w = L.vdwRadii[o.elem];
                else if (o.elem.length > 1) {
                  let M = o.elem;
                  M = M[0].toUpperCase() + M[1].toLowerCase(), L.vdwRadii[M] && (w = L.vdwRadii[M]);
                }
                return typeof v.scale < "u" && (w *= v.scale), w;
              }
              // cross drawing
              /**
               *
               * @param {AtomSpec} atom
               * @param {Record<number, Geometry>} geos
               */
              drawAtomCross(o, v) {
                if (o.style.cross) {
                  var w = o.style.cross;
                  if (!w.hidden) {
                    var M = w.linewidth || L.defaultlineWidth;
                    v[M] || (v[M] = new n.Geometry());
                    var F = v[M].updateGeoGroup(6), m = this.getRadiusFromStyle(o, w), E = [
                      [m, 0, 0],
                      [-m, 0, 0],
                      [0, m, 0],
                      [0, -m, 0],
                      [0, 0, m],
                      [0, 0, -m]
                    ], z = o.clickable || o.hoverable;
                    z && o.intersectionShape === void 0 && (o.intersectionShape = { sphere: [], cylinder: [], line: [] });
                    for (var O = (0, A.getColorFromStyle)(o, w), R = F.vertexArray, B = F.colorArray, P = 0; P < 6; P++) {
                      var W = F.vertices * 3;
                      if (F.vertices++, R[W] = o.x + E[P][0], R[W + 1] = o.y + E[P][1], R[W + 2] = o.z + E[P][2], B[W] = O.r, B[W + 1] = O.g, B[W + 2] = O.b, z) {
                        var U = new h.Vector3(E[P][0], E[P][1], E[P][2]);
                        U.multiplyScalar(0.1), U.set(U.x + o.x, U.y + o.y, U.z + o.z), o.intersectionShape.line.push(U);
                      }
                    }
                  }
                }
              }
              getGoodCross(o, v, w, M) {
                for (var F = null, m = -1, E = 0, z = o.bonds.length; E < z; E++)
                  if (o.bonds[E] != v.index) {
                    let R = o.bonds[E], B = this.atoms[R], W = new h.Vector3(B.x, B.y, B.z).clone();
                    W.sub(w);
                    let U = W.clone();
                    U.cross(M);
                    var O = U.lengthSq();
                    if (O > m && (m = O, F = U, m > 0.1))
                      return F;
                  }
                return F;
              }
              //from atom, return a normalized vector v that is orthogonal and along which
              //it is appropraite to draw multiple bonds
              getSideBondV(o, v, w) {
                var M, F, m, E, z, O = new h.Vector3(o.x, o.y, o.z), R = new h.Vector3(v.x, v.y, v.z), B = R.clone(), P = null;
                if (B.sub(O), o.bonds.length === 1)
                  v.bonds.length === 1 ? (P = B.clone(), Math.abs(P.x) > 1e-4 ? P.y += 1 : P.x += 1) : (M = (w + 1) % v.bonds.length, F = v.bonds[M], m = this.atoms[F], m.index == o.index && (M = (M + 1) % v.bonds.length, F = v.bonds[M], m = this.atoms[F]), E = new h.Vector3(m.x, m.y, m.z), z = E.clone(), z.sub(O), P = z.clone(), P.cross(B));
                else if (P = this.getGoodCross(o, v, O, B), P.lengthSq() < 0.01) {
                  var W = this.getGoodCross(v, o, O, B);
                  W != null && (P = W);
                }
                return P.lengthSq() < 0.01 && (P = B.clone(), Math.abs(P.x) > 1e-4 ? P.y += 1 : P.x += 1), P.cross(B), P.normalize(), P;
              }
              addLine(o, v, w, M, F, m) {
                o[w] = M.x, o[w + 1] = M.y, o[w + 2] = M.z, v[w] = m.r, v[w + 1] = m.g, v[w + 2] = m.b, o[w + 3] = F.x, o[w + 4] = F.y, o[w + 5] = F.z, v[w + 3] = m.r, v[w + 4] = m.g, v[w + 5] = m.b;
              }
              // bonds - both atoms must match bond style
              // standardize on only drawing for lowest to highest
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSpec[]} atoms
               * @param {Record<number,Geometry>} geos
               */
              drawBondLines(o, v, w) {
                if (o.style.line) {
                  var M = o.style.line;
                  if (!M.hidden) {
                    var F, m, E, z, O = M.linewidth || L.defaultlineWidth;
                    w[O] || (w[O] = new n.Geometry());
                    for (var R = w[O].updateGeoGroup(6 * o.bonds.length), B = R.vertexArray, P = R.colorArray, W = 0; W < o.bonds.length; W++) {
                      var U = o.bonds[W], V = v[U];
                      if (V.style.line && !(o.index >= V.index)) {
                        var K = new h.Vector3(o.x, o.y, o.z), q = new h.Vector3(V.x, V.y, V.z), H = K.clone().add(q).multiplyScalar(0.5), j = !1, Q = o.clickable || o.hoverable, J = V.clickable || V.hoverable;
                        (Q || J) && (Q && (o.intersectionShape === void 0 && (o.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), o.intersectionShape.line.push(K), o.intersectionShape.line.push(H)), J && (V.intersectionShape === void 0 && (V.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), V.intersectionShape.line.push(H), V.intersectionShape.line.push(q)));
                        var Y = (0, A.getColorFromStyle)(o, o.style.line), ee = (0, A.getColorFromStyle)(V, V.style.line);
                        if (o.bondStyles && o.bondStyles[W]) {
                          var fe = o.bondStyles[W];
                          if (!fe.iswire)
                            continue;
                          fe.singleBond && (j = !0), typeof fe.color1 < "u" && (Y = b.CC.color(fe.color1)), typeof fe.color2 < "u" && (ee = b.CC.color(fe.color2));
                        }
                        var me = R.vertices * 3, he, we;
                        if (o.bondOrder[W] > 1 && o.bondOrder[W] < 4 && !j) {
                          var ye = this.getSideBondV(o, V, W), ve = q.clone();
                          ve.sub(K), o.bondOrder[W] == 2 ? (ye.multiplyScalar(0.1), F = K.clone(), F.add(ye), m = K.clone(), m.sub(ye), E = F.clone(), E.add(ve), z = m.clone(), z.add(ve), Y == ee ? (R.vertices += 4, this.addLine(B, P, me, F, E, Y), this.addLine(B, P, me + 6, m, z, Y)) : (R.vertices += 8, ve.multiplyScalar(0.5), he = F.clone(), he.add(ve), we = m.clone(), we.add(ve), this.addLine(B, P, me, F, he, Y), this.addLine(B, P, me + 6, he, E, ee), this.addLine(B, P, me + 12, m, we, Y), this.addLine(B, P, me + 18, we, z, ee))) : o.bondOrder[W] == 3 && (ye.multiplyScalar(0.1), F = K.clone(), F.add(ye), m = K.clone(), m.sub(ye), E = F.clone(), E.add(ve), z = m.clone(), z.add(ve), Y == ee ? (R.vertices += 6, this.addLine(B, P, me, K, q, Y), this.addLine(B, P, me + 6, F, E, Y), this.addLine(B, P, me + 12, m, z, Y)) : (R.vertices += 12, ve.multiplyScalar(0.5), he = F.clone(), he.add(ve), we = m.clone(), we.add(ve), this.addLine(B, P, me, K, H, Y), this.addLine(B, P, me + 6, H, q, ee), this.addLine(B, P, me + 12, F, he, Y), this.addLine(B, P, me + 18, he, E, ee), this.addLine(B, P, me + 24, m, we, Y), this.addLine(B, P, me + 30, we, z, ee)));
                        } else
                          Y == ee ? (R.vertices += 2, this.addLine(B, P, me, K, q, Y)) : (R.vertices += 4, this.addLine(B, P, me, K, H, Y), this.addLine(B, P, me + 6, H, q, ee));
                      }
                    }
                  }
                }
              }
              //sphere drawing
              //See also: drawCylinder
              /**
               *
               * @param {AtomSpec} atom
               * @param {Geometry} geo
               */
              drawAtomSphere(o, v) {
                if (o.style.sphere) {
                  var w = o.style.sphere;
                  if (!w.hidden) {
                    var M = (0, A.getColorFromStyle)(o, w), F = this.getRadiusFromStyle(o, w);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var m = new h.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new s.Sphere(m, F));
                    }
                    g.GLDraw.drawSphere(v, o, F, M);
                  }
                }
              }
              /** Register atom shaped click handlers */
              drawAtomClickSphere(o) {
                if (o.style.clicksphere) {
                  var v = o.style.clicksphere;
                  if (!v.hidden) {
                    var w = this.getRadiusFromStyle(o, v);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var M = new h.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new s.Sphere(M, w));
                    }
                  }
                }
              }
              drawAtomInstanced(o, v) {
                if (o.style.sphere) {
                  var w = o.style.sphere;
                  if (!w.hidden) {
                    var M = this.getRadiusFromStyle(o, w), F = (0, A.getColorFromStyle)(o, w), m = v.updateGeoGroup(1), E = m.vertices, z = E * 3, O = m.vertexArray, R = m.colorArray, B = m.radiusArray;
                    if (O[z] = o.x, O[z + 1] = o.y, O[z + 2] = o.z, R[z] = F.r, R[z + 1] = F.g, R[z + 2] = F.b, B[E] = M, (o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var P = new h.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new s.Sphere(P, M));
                    }
                    m.vertices += 1;
                  }
                }
              }
              drawSphereImposter(o, v, w, M) {
                var F = o.updateGeoGroup(4), m, E = F.vertices, z = E * 3, O = F.vertexArray, R = F.colorArray;
                for (m = 0; m < 4; m++)
                  O[z + 3 * m] = v.x, O[z + 3 * m + 1] = v.y, O[z + 3 * m + 2] = v.z;
                var B = F.normalArray;
                for (m = 0; m < 4; m++)
                  R[z + 3 * m] = M.r, R[z + 3 * m + 1] = M.g, R[z + 3 * m + 2] = M.b;
                B[z + 0] = -w, B[z + 1] = w, B[z + 2] = 0, B[z + 3] = -w, B[z + 4] = -w, B[z + 5] = 0, B[z + 6] = w, B[z + 7] = -w, B[z + 8] = 0, B[z + 9] = w, B[z + 10] = w, B[z + 11] = 0, F.vertices += 4;
                var P = F.faceArray, W = F.faceidx;
                P[W + 0] = E, P[W + 1] = E + 1, P[W + 2] = E + 2, P[W + 3] = E + 2, P[W + 4] = E + 3, P[W + 5] = E, F.faceidx += 6;
              }
              //dkoes -  code for sphere imposters
              drawAtomImposter(o, v) {
                if (o.style.sphere) {
                  var w = o.style.sphere;
                  if (!w.hidden) {
                    var M = this.getRadiusFromStyle(o, w), F = (0, A.getColorFromStyle)(o, w);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var m = new h.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new s.Sphere(m, M));
                    }
                    this.drawSphereImposter(v, o, M, F);
                  }
                }
              }
              calculateDashes(o, v, w, M, F) {
                var m = Math.sqrt(Math.pow(o.x - v.x, 2) + Math.pow(o.y - v.y, 2) + Math.pow(o.z - v.z, 2));
                w = Math.max(w, 0), F = Math.max(F, 0) + 2 * w, M = Math.max(M, 1e-3), M + F > m && (M = m, F = 0);
                var E = Math.floor((m - M) / (M + F)) + 1, z = E * M;
                F = (m - z) / E;
                for (var O, R = new h.Vector3(o.x, o.y, o.z), B = new h.Vector3((v.x - o.x) / (m / F), (v.y - o.y) / (m / F), (v.z - o.z) / (m / F)), P = new h.Vector3((v.x - o.x) / (m / M), (v.y - o.y) / (m / M), (v.z - o.z) / (m / M)), W = [], U = 0; U < E; U++)
                  O = new h.Vector3(R.x + P.x, R.y + P.y, R.z + P.z), W.push({ from: R, to: O }), R = new h.Vector3(O.x + B.x, O.y + B.y, O.z + B.z);
                return W;
              }
              static drawStickImposter(o, v, w, M, F, m = 0, E = 0) {
                for (var z = o.updateGeoGroup(4), O = z.vertices, R = O * 3, B = z.vertexArray, P = z.colorArray, W = z.radiusArray, U = z.normalArray, V = F.r, K = F.g, q = F.b, H = function(ee) {
                  var fe = -ee;
                  return fe == 0 && (fe = -1e-4), fe;
                }, j = R, Q = 0; Q < 4; Q++)
                  B[j] = v.x, U[j] = w.x, P[j] = V, j++, B[j] = v.y, U[j] = w.y, P[j] = K, j++, B[j] = v.z, U[j] = w.z, Q < 2 ? P[j] = q : P[j] = H(q), j++;
                z.vertices += 4, W[O] = -M, W[O + 1] = M, W[O + 2] = -M, W[O + 3] = M;
                var J = z.faceArray, Y = z.faceidx;
                J[Y + 0] = O, J[Y + 1] = O + 1, J[Y + 2] = O + 2, J[Y + 3] = O + 2, J[Y + 4] = O + 3, J[Y + 5] = O, z.faceidx += 6;
              }
              // draws cylinders and small spheres (at bond radius)
              drawBondSticks(o, v, w) {
                var M, F;
                if (o.style.stick) {
                  var m = o.style.stick;
                  if (!m.hidden) {
                    var E = m.radius || this.defaultStickRadius, z = m.doubleBondScaling || 0.4, O = m.tripleBondScaling || 0.25, R = ((M = m.dashedBondConfig) === null || M === void 0 ? void 0 : M.dashLength) || 0.1, B = ((F = m.dashedBondConfig) === null || F === void 0 ? void 0 : F.gapLength) || 0.25, P = E, W = m.singleBonds || !1, U = m.dashedBonds || !1, V = 0, K = 0, q, H, j, Q, J, Y, ee, fe, me, he, we, ye = (0, A.getColorFromStyle)(o, m), ve, ce, be;
                    !o.capDrawn && o.bonds.length < 4 && (V = 2);
                    var le = (xe) => {
                      var Le = w.imposter ? L.drawStickImposter : g.GLDraw.drawCylinder;
                      return !U && xe >= 1 ? Le : (He, Me, Re, ie, We, Qe = 0, G = 0, Fe = 0.1, Te = 0.25) => {
                        var ae = this.calculateDashes(Me, Re, ie, Fe, Te);
                        ae.forEach((Ee) => {
                          Le(He, Ee.from, Ee.to, ie, We, Qe, G);
                        });
                      };
                    };
                    for (j = 0; j < o.bonds.length; j++) {
                      var Se = le(o.bondOrder[j]), ge = o.bonds[j], de = v[ge];
                      if (ve = ce = be = null, o.index < de.index) {
                        var De = de.style;
                        if (!De.stick || De.stick.hidden)
                          continue;
                        var Be = (0, A.getColorFromStyle)(de, De.stick);
                        if (P = E, Q = W, o.bondStyles && o.bondStyles[j]) {
                          if (J = o.bondStyles[j], J.iswire)
                            continue;
                          J.radius && (P = J.radius), J.singleBond && (Q = !0), typeof J.color1 < "u" && (ye = b.CC.color(J.color1)), typeof J.color2 < "u" && (Be = b.CC.color(J.color2));
                        }
                        var Ve = new h.Vector3(o.x, o.y, o.z), qe = new h.Vector3(de.x, de.y, de.z);
                        if (o.bondOrder[j] <= 1 || Q || o.bondOrder[j] > 3) {
                          if (o.bondOrder[j] < 1 && (P *= o.bondOrder[j]), !de.capDrawn && de.bonds.length < 4 && (K = 2), ye != Be ? (ve = new h.Vector3().addVectors(Ve, qe).multiplyScalar(0.5), Se(w, Ve, ve, P, ye, V, 0, R, B), Se(w, ve, qe, P, Be, 0, K, R, B)) : Se(w, Ve, qe, P, ye, V, K, R, B), q = o.clickable || o.hoverable, H = de.clickable || de.hoverable, q || H) {
                            if (ve || (ve = new h.Vector3().addVectors(Ve, qe).multiplyScalar(0.5)), q) {
                              var Ze = new s.Cylinder(Ve, ve, P), Ye = new s.Sphere(Ve, P);
                              o.intersectionShape.cylinder.push(Ze), o.intersectionShape.sphere.push(Ye);
                            }
                            if (H) {
                              var Xe = new s.Cylinder(qe, ve, P), Ge = new s.Sphere(qe, P);
                              de.intersectionShape.cylinder.push(Xe), de.intersectionShape.sphere.push(Ge);
                            }
                          }
                        } else if (o.bondOrder[j] > 1) {
                          var Ke = 0, Pe = 0;
                          P != E && (Ke = 2, Pe = 2);
                          var it = qe.clone(), nt = null;
                          it.sub(Ve);
                          var ne, se, ue, $e, Ae;
                          nt = this.getSideBondV(o, de, j), o.bondOrder[j] == 2 ? (ne = P * z, nt.multiplyScalar(ne * 1.5), se = Ve.clone(), se.add(nt), ue = Ve.clone(), ue.sub(nt), $e = se.clone(), $e.add(it), Ae = ue.clone(), Ae.add(it), ye != Be ? (ve = new h.Vector3().addVectors(se, $e).multiplyScalar(0.5), ce = new h.Vector3().addVectors(ue, Ae).multiplyScalar(0.5), Se(w, se, ve, ne, ye, Ke, 0), Se(w, ve, $e, ne, Be, 0, Pe), Se(w, ue, ce, ne, ye, Ke, 0), Se(w, ce, Ae, ne, Be, 0, Pe)) : (Se(w, se, $e, ne, ye, Ke, Pe), Se(w, ue, Ae, ne, ye, Ke, Pe)), q = o.clickable || o.hoverable, H = de.clickable || de.hoverable, (q || H) && (ve || (ve = new h.Vector3().addVectors(se, $e).multiplyScalar(0.5)), ce || (ce = new h.Vector3().addVectors(ue, Ae).multiplyScalar(0.5)), q && (Y = new s.Cylinder(se, ve, ne), ee = new s.Cylinder(ue, ce, ne), o.intersectionShape.cylinder.push(Y), o.intersectionShape.cylinder.push(ee)), H && (me = new s.Cylinder($e, ve, ne), he = new s.Cylinder(Ae, ce, ne), de.intersectionShape.cylinder.push(me), de.intersectionShape.cylinder.push(he)))) : o.bondOrder[j] == 3 && (ne = P * O, nt.cross(it), nt.normalize(), nt.multiplyScalar(ne * 3), se = Ve.clone(), se.add(nt), ue = Ve.clone(), ue.sub(nt), $e = se.clone(), $e.add(it), Ae = ue.clone(), Ae.add(it), ye != Be ? (ve = new h.Vector3().addVectors(se, $e).multiplyScalar(0.5), ce = new h.Vector3().addVectors(ue, Ae).multiplyScalar(0.5), be = new h.Vector3().addVectors(Ve, qe).multiplyScalar(0.5), Se(w, se, ve, ne, ye, Ke, 0), Se(w, ve, $e, ne, Be, 0, Pe), Se(w, Ve, be, ne, ye, V, 0), Se(w, be, qe, ne, Be, 0, K), Se(w, ue, ce, ne, ye, Ke, 0), Se(w, ce, Ae, ne, Be, 0, Pe)) : (Se(w, se, $e, ne, ye, Ke, Pe), Se(w, Ve, qe, ne, ye, V, K), Se(w, ue, Ae, ne, ye, Ke, Pe)), q = o.clickable || o.hoverable, H = de.clickable || de.hoverable, (q || H) && (ve || (ve = new h.Vector3().addVectors(se, $e).multiplyScalar(0.5)), ce || (ce = new h.Vector3().addVectors(ue, Ae).multiplyScalar(0.5)), be || (be = new h.Vector3().addVectors(Ve, qe).multiplyScalar(0.5)), q && (Y = new s.Cylinder(se.clone(), ve.clone(), ne), ee = new s.Cylinder(ue.clone(), ce.clone(), ne), fe = new s.Cylinder(Ve.clone(), be.clone(), ne), o.intersectionShape.cylinder.push(Y), o.intersectionShape.cylinder.push(ee), o.intersectionShape.cylinder.push(fe)), H && (me = new s.Cylinder($e.clone(), ve.clone(), ne), he = new s.Cylinder(Ae.clone(), ce.clone(), ne), we = new s.Cylinder(qe.clone(), be.clone(), ne), de.intersectionShape.cylinder.push(me), de.intersectionShape.cylinder.push(he), de.intersectionShape.cylinder.push(we))));
                        }
                      }
                    }
                    var je = !1, ze = 0, re = !1;
                    for (j = 0; j < o.bonds.length; j++)
                      Q = W, o.bondStyles && o.bondStyles[j] && (J = o.bondStyles[j], J.singleBond && (Q = !0), J.radius && J.radius != E && (re = !0)), (Q || o.bondOrder[j] == 1) && ze++;
                    re ? ze > 0 && (je = !0) : ze == 0 && (o.bonds.length > 0 || m.showNonBonded) && (je = !0), je && (P = E, w.imposter ? this.drawSphereImposter(w.sphereGeometry, o, P, ye) : g.GLDraw.drawSphere(w, o, P, ye));
                  }
                }
              }
              // go through all the atoms and regenerate their geometries
              // we try to have one geometry for each style since this is much much
              // faster
              // at some point we should optimize this to avoid unnecessary
              // recalculation
              /** param {AtomSpec[]} atoms */
              createMolObj(o, v) {
                v = v || {};
                var w = new n.Object3D(), M = [], F = {}, m = {}, E = this.drawAtomSphere, z = null, O = null;
                v.supportsImposters ? (E = this.drawAtomImposter, z = new n.Geometry(!0), z.imposter = !0, O = new n.Geometry(!0, !0), O.imposter = !0, O.sphereGeometry = new n.Geometry(!0), O.sphereGeometry.imposter = !0, O.drawnCaps = {}) : v.supportsAIA ? (E = this.drawAtomInstanced, z = new n.Geometry(!1, !0, !0), z.instanced = !0, O = new n.Geometry(!0)) : (z = new n.Geometry(!0), O = new n.Geometry(!0));
                var R, B, P, W, U = {}, V = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (R = 0, P = o.length; R < P; R++) {
                  var K = o[R];
                  if (K && K.style) {
                    (K.clickable || K.hoverable) && K.intersectionShape === void 0 && (K.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), W = { line: void 0, cross: void 0, stick: void 0, sphere: void 0 };
                    for (B in W)
                      K.style[B] ? K.style[B].opacity ? W[B] = parseFloat(K.style[B].opacity) : W[B] = 1 : W[B] = void 0, U[B] ? W[B] != null && U[B] != W[B] && (console.log("Warning: " + B + " opacity is ambiguous"), U[B] = 1) : U[B] = W[B];
                    E.call(this, K, z), this.drawAtomClickSphere(K), this.drawAtomCross(K, m), this.drawBondLines(K, o, F), this.drawBondSticks(K, o, O), typeof K.style.cartoon < "u" && !K.style.cartoon.hidden && (K.style.cartoon.color === "spectrum" && typeof K.resi == "number" && !K.hetflag && (K.resi < V[0] && (V[0] = K.resi), K.resi > V[1] && (V[1] = K.resi)), M.push(K));
                  }
                }
                if (M.length > 0 && (0, _.drawCartoon)(w, M, V, this.defaultCartoonQuality), z && z.vertices > 0) {
                  z.initTypedArrays();
                  var q = null, H = null;
                  z.imposter ? q = new n.SphereImposterMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }) : z.instanced ? (H = new n.Geometry(!0), g.GLDraw.drawSphere(H, { x: 0, y: 0, z: 0 }, 1, new b.Color(0.5, 0.5, 0.5)), H.initTypedArrays(), q = new n.InstancedMaterial({
                    sphereMaterial: new n.MeshLambertMaterial({
                      ambient: 0,
                      vertexColors: !0,
                      reflectivity: 0
                    }),
                    sphere: H
                  })) : q = new n.MeshLambertMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }), U.sphere < 1 && U.sphere >= 0 && (q.transparent = !0, q.opacity = U.sphere), H = new n.Mesh(z, q), w.add(H);
                }
                if (O.vertices > 0) {
                  var j = null, Q = null, J = O.sphereGeometry;
                  (!J || typeof J.vertices > "u" || J.vertices == 0) && (J = null), O.initTypedArrays(), J && J.initTypedArrays();
                  var Y = { ambient: 0, vertexColors: !0, reflectivity: 0 };
                  O.imposter ? (j = new n.StickImposterMaterial(Y), Q = new n.SphereImposterMaterial(Y)) : (j = new n.MeshLambertMaterial(Y), Q = new n.MeshLambertMaterial(Y), j.wireframe && (O.setUpWireframe(), J && J.setUpWireframe())), U.stick < 1 && U.stick >= 0 && (j.transparent = !0, j.opacity = U.stick, Q.transparent = !0, Q.opacity = U.stick);
                  var ee = new n.Mesh(O, j);
                  if (w.add(ee), J) {
                    var fe = new n.Mesh(J, Q);
                    w.add(fe);
                  }
                }
                var me;
                for (R in F)
                  if (F.hasOwnProperty(R)) {
                    me = R;
                    var he = new n.LineBasicMaterial({
                      linewidth: me,
                      vertexColors: !0
                    });
                    U.line < 1 && U.line >= 0 && (he.transparent = !0, he.opacity = U.line), F[R].initTypedArrays();
                    var we = new n.Line(F[R], he, n.LineStyle.LinePieces);
                    w.add(we);
                  }
                for (R in m)
                  if (m.hasOwnProperty(R)) {
                    me = R;
                    var ye = new n.LineBasicMaterial({
                      linewidth: me,
                      vertexColors: !0
                    });
                    U.cross < 1 && U.cross >= 0 && (ye.transparent = !0, ye.opacity = U.cross), m[R].initTypedArrays();
                    var ve = new n.Line(m[R], ye, n.LineStyle.LinePieces);
                    w.add(ve);
                  }
                if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {
                  var ce = new n.Object3D(), be;
                  for (be = 0; be < this.modelData.symmetries.length; be++) {
                    var le = new n.Object3D();
                    le = w.clone(), le.matrix.copy(this.modelData.symmetries[be]), le.matrixAutoUpdate = !1, ce.add(le);
                  }
                  return ce;
                }
                return w;
              }
              /**
               * Return object representing internal state of
               * the model appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                return {
                  atoms: this.atoms,
                  frames: this.frames
                };
              }
              /**
               * Overwrite the internal model state with the passed state.
               *
              */
              setInternalState(o) {
                this.atoms = o.atoms, this.frames = o.frames, this.molObj = null;
              }
              /**
               * Returns crystallographic information if present.
               *
               *
               */
              getCrystData() {
                if (this.modelData.cryst) {
                  if (!this.modelData.cryst.matrix) {
                    const o = this.modelData.cryst;
                    this.modelData.cryst.matrix = (0, h.conversionMatrix3)(o.a, o.b, o.c, o.alpha, o.beta, o.gamma);
                  }
                  return this.modelData.cryst;
                } else
                  return null;
              }
              /**
              	     * Set crystallographic information using three angles and three lengths
              	     *
              	     * @param {number} a - length of unit cell side
              	     * @param {number} b - length of unit cell side
              	     * @param {number} c - length of unit cell side
              	     * @param {number} alpha - unit cell angle in degrees (default 90)
              	     * @param {number} beta - unit cell angle in degrees (default 90)
              	     * @param {number} gamma - unit cell angle in degrees (default 90)
              
              	     */
              setCrystData(o, v, w, M, F, m) {
                o = o || 1, v = v || 1, w = w || 1, M = M || 90, F = F || 90, m = m || 90;
                const E = (0, h.conversionMatrix3)(o, v, w, M, F, m);
                this.modelData.cryst = {
                  a: o,
                  b: v,
                  c: w,
                  alpha: M,
                  beta: F,
                  gamma: m,
                  matrix: E
                };
              }
              /**
               * Set the crystallographic matrix to the given matrix.
               *
               * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from
               * the crystal data.
               *
               * @param {Matrix3} matrix - unit cell matrix
               */
              setCrystMatrix(o) {
                o = o || new h.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1), this.modelData.cryst = {
                  matrix: o
                };
              }
              /**
               * Returns list of rotational/translational matrices if there is BIOMT data
               * Otherwise returns a list of just the ID matrix
               *
               * @return {Array<Matrix4>}
               *
               */
              getSymmetries() {
                return typeof this.modelData.symmetries > "u" && (this.modelData.symmetries = [this.idMatrix]), this.modelData.symmetries;
              }
              /**
               * Sets symmetries based on specified matrices in list
               *
               * @param {Array<Matrix4>} list
               *
               */
              setSymmetries(o) {
                typeof o > "u" ? this.modelData.symmetries = [this.idMatrix] : this.modelData.symmetries = o;
              }
              /**
               * Returns model id number
               *
               * @return {number} Model ID
               */
              getID() {
                return this.id;
              }
              /**
               * Returns model's frames property, a list of atom lists
               *
               * @return {number}
               */
              getNumFrames() {
                return this.frames.numFrames != null ? this.frames.numFrames : this.frames.length;
              }
              adjustCoord(o, v, w, M) {
                var F = v - o;
                return F < -w ? v + M : F > w ? v - M : v;
              }
              //go over current atoms in depth first order and ensure that connected
              //attoms aren't split across the box
              adjustCoordinatesToBox() {
                if (this.box && this.atomdfs)
                  for (var o = this.box[0], v = this.box[1], w = this.box[2], M = o * 0.9, F = v * 0.9, m = w * 0.9, E = 0; E < this.atomdfs.length; E++)
                    for (var z = this.atomdfs[E], O = 1; O < z.length; O++) {
                      var R = this.atoms[z[O][0]], B = this.atoms[z[O][1]];
                      R.x = this.adjustCoord(B.x, R.x, M, o), R.y = this.adjustCoord(B.y, R.y, F, v), R.z = this.adjustCoord(B.z, R.z, m, w);
                    }
              }
              /**
               * Sets model's atomlist to specified frame
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - model's atoms are set to this index in frames list
               * @return {Promise}
               */
              setFrame(o, v) {
                var w = this.getNumFrames();
                let M = this;
                return new Promise(function(F, m) {
                  if (w == 0 && F(), (o < 0 || o >= w) && (o = w - 1), M.frames.url != null) {
                    var E = M.frames.url;
                    (0, A.getbin)(E + "/traj/frame/" + o + "/" + M.frames.path, void 0, "POST", void 0).then(function(z) {
                      for (var O = new Float32Array(z, 44), R = 0, B = 0; B < M.atoms.length; B++)
                        M.atoms[B].x = O[R++], M.atoms[B].y = O[R++], M.atoms[B].z = O[R++];
                      M.box && M.atomdfs && M.adjustCoordinatesToBox(), F();
                    }).catch(m);
                  } else
                    M.atoms = M.frames[o], F();
                  M.molObj = null, M.modelDatas && o < M.modelDatas.length && (M.modelData = M.modelDatas[o], M.unitCellObjects && v && (v.removeUnitCell(M), v.addUnitCell(M)));
                });
              }
              /**
               * Add atoms as frames of model
               *
               * @param {AtomSpec[]} atoms - atoms to be added
               */
              addFrame(o) {
                this.frames.push(o);
              }
              /**
              	     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.
              	     * Model can then be animated
              	     *
              	     * @param {number} numFrames - number of frames to be created, default to 10
              	     * @param {number} amplitude - amplitude of distortion, default to 1 (full)
              	     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
              	     * @param {GLViewer} viewer - required if arrowSpec is provided
              	     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
              	     *@example
              
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.vibrate(10, 1);
              	        viewer.animate({loop: "forward",reps: 1});
              
              	        viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              vibrate(o = 10, v = 1, w = !1, M, F) {
                var m = 0, E = o;
                w && (m = -o, E = o), this.frames !== void 0 && this.frames.origIndex !== void 0 ? this.setFrame(this.frames.origIndex) : this.setFrame(0), m < E && (this.frames = []), w && (this.frames.origIndex = o);
                for (var z = m; z < E; z++) {
                  var O = [], R = this.frames.length;
                  if (z == 0 && !F) {
                    this.frames.push(this.atoms);
                    continue;
                  }
                  for (var B = 0; B < this.atoms.length; B++) {
                    var P = (0, A.getAtomProperty)(this.atoms[B], "dx"), W = (0, A.getAtomProperty)(this.atoms[B], "dy"), U = (0, A.getAtomProperty)(this.atoms[B], "dz"), V = new h.Vector3(P, W, U), K = new h.Vector3(this.atoms[B].x, this.atoms[B].y, this.atoms[B].z), q = z * v / o;
                    V.multiplyScalar(q), K.add(V);
                    var H = {};
                    for (var j in this.atoms[B])
                      H[j] = this.atoms[B][j];
                    if (H.x = K.x, H.y = K.y, H.z = K.z, O.push(H), M && F) {
                      var Q = (0, A.extend)({}, F), J = new h.Vector3(P, W, U);
                      if (J.multiplyScalar(v), J.add(K), Q.start = K, Q.end = J, Q.frame = R, !Q.color) {
                        var Y = H.style.sphere;
                        Y || (Y = H.style.stick), Y || (Y = H.style.line), Q.color = (0, A.getColorFromStyle)(H, Y);
                      }
                      M.addArrow(Q);
                    }
                  }
                  this.frames.push(O);
                }
              }
              // set default style and colors for atoms
              setAtomDefaults(o) {
                for (let v = 0; v < o.length; v++) {
                  let w = o[v];
                  w && (w.style = w.style || (0, A.deepCopy)(L.defaultAtomStyle), w.color = w.color || this.ElementColors[w.elem] || this.defaultColor, w.model = this.id, (w.clickable || w.hoverable) && (w.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }));
                }
              }
              /** add atoms to this model from molecular data string
               *
               * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer
               * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)
               * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format
               */
              addMolData(o, v, w = {}) {
                var M = L.parseMolData(o, v, w);
                this.dontDuplicateAtoms = !w.duplicateAssemblyAtoms;
                var F = M.modelData;
                if (F && (Array.isArray(F) ? (this.modelData = F[0], w.frames && (this.modelDatas = F)) : this.modelData = F), M.box ? this.box = M.box : this.box = null, this.frames.length == 0) {
                  for (let E = 0; E < M.length; E++)
                    M[E].length != 0 && this.frames.push(M[E]);
                  this.frames[0] && (this.atoms = this.frames[0]);
                } else if (w.frames)
                  for (let E = 0; E < M.length; E++)
                    this.frames.push(M[E]);
                else
                  for (var m = 0; m < M.length; m++)
                    this.addAtoms(M[m]);
                for (let E = 0; E < this.frames.length; E++)
                  this.setAtomDefaults(this.frames[E]);
                w.vibrate && w.vibrate.frames && w.vibrate.amplitude && this.vibrate(w.vibrate.frames, w.vibrate.amplitude), w.style && this.setStyle({}, w.style);
              }
              setDontDuplicateAtoms(o) {
                this.dontDuplicateAtoms = o;
              }
              setModelData(o) {
                this.modelData = o;
              }
              //return true if atom value matches property val
              propertyMatches(o, v) {
                if (o == v)
                  return !0;
                if (typeof v == "string" && typeof o == "number") {
                  var w = v.match(/(-?\d+)\s*-\s*(-?\d+)/);
                  if (w) {
                    var M = parseInt(w[1]), F = parseInt(w[2]);
                    if (w && o >= M && o <= F)
                      return !0;
                  }
                }
                return !1;
              }
              // make a deep copy of a selection object and create caches of expensive
              // selections.  We create a copy so caches are not attached to user
              // supplied objects where the user might change them invalidating the cache.
              // This does not support arbitrary
              // javascript objects, but support enough for eveything that is
              // used in selections: number, string, boolean, functions; as well
              // as arrays and nested objects with values of the aformentioned
              // types.
              static deepCopyAndCache(o, v) {
                if (typeof o != "object" || o == null || o.__cache_created)
                  return o;
                const w = {};
                for (const M in o) {
                  const F = o[M];
                  if (Array.isArray(F)) {
                    w[M] = [];
                    for (let m = 0; m < F.length; m++)
                      w[M].push(L.deepCopyAndCache(F[m], v));
                  } else typeof F == "object" && M != "properties" && M != "model" ? w[M] = L.deepCopyAndCache(F, v) : w[M] = F;
                  if (M == "and" || M == "or") {
                    const m = [];
                    for (const E of w[M]) {
                      const z = /* @__PURE__ */ new Set();
                      for (const O of v.selectedAtoms(E))
                        z.add(O.index);
                      m.push(z);
                    }
                    if (M == "and") {
                      const E = function(O, R) {
                        const B = /* @__PURE__ */ new Set();
                        for (const P of R)
                          O.has(P) && B.add(P);
                        return B;
                      };
                      let z = new Set(m[0]);
                      for (const O of m.splice(1))
                        z = E(z, O);
                      w[M].__cached_results = z;
                    } else if (M == "or") {
                      const E = /* @__PURE__ */ new Set();
                      for (const z of m)
                        for (const O of z)
                          E.add(O);
                      w[M].__cached_results = E;
                    }
                  }
                }
                return w.__cache_created = !0, w;
              }
              /** given a selection specification, return true if atom is selected.
               * Does not support context-aware selectors like expand/within/byres.
               *
               * @param {AtomSpec} atom
               * @param {AtomSelectionSpec} sel
               * @return {boolean}
               */
              atomIsSelected(o, v) {
                if (typeof v > "u")
                  return !0;
                var w = !!v.invert, M = !0;
                for (var F in v)
                  if (F == "and" || F == "or" || F == "not") {
                    if (F == "not") {
                      if (this.atomIsSelected(o, v[F])) {
                        M = !1;
                        break;
                      }
                    } else if (v[F].__cached_results === void 0 && (v = L.deepCopyAndCache(v, this)), M = v[F].__cached_results.has(o.index), !M)
                      break;
                  } else if (F === "predicate") {
                    if (!v.predicate(o)) {
                      M = !1;
                      break;
                    }
                  } else if (F == "properties" && o[F]) {
                    for (var m in v.properties)
                      if (!m.startsWith("__cache")) {
                        if (typeof o.properties[m] > "u") {
                          M = !1;
                          break;
                        }
                        if (o.properties[m] != v.properties[m]) {
                          M = !1;
                          break;
                        }
                      }
                  } else if (v.hasOwnProperty(F) && !L.ignoredKeys.has(F) && !F.startsWith("__cache")) {
                    if (typeof o[F] > "u") {
                      M = !1;
                      break;
                    }
                    var E = !1;
                    if (F === "bonds") {
                      var z = v[F];
                      if (z != o.bonds.length) {
                        M = !1;
                        break;
                      }
                    } else if (Array.isArray(v[F])) {
                      var O = v[F], R = o[F];
                      for (let B = 0; B < O.length; B++)
                        if (this.propertyMatches(R, O[B])) {
                          E = !0;
                          break;
                        }
                      if (!E) {
                        M = !1;
                        break;
                      }
                    } else {
                      let B = v[F];
                      if (!this.propertyMatches(o[F], B)) {
                        M = !1;
                        break;
                      }
                    }
                  }
                return w ? !M : M;
              }
              static squaredDistance(o, v) {
                var w = v.x - o.x, M = v.y - o.y, F = v.z - o.z;
                return w * w + M * M + F * F;
              }
              /** returns a list of atoms in the expanded bounding box, but not in the current one
               *
               *  Bounding box:
               *
               *    [ [ xmin, ymin, zmin ],
               *      [ xmax, ymax, zmax ],
               *      [ xctr, yctr, zctr ] ]
               *
               **/
              expandAtomList(o, v) {
                if (v <= 0)
                  return o;
                for (var w = (0, A.getExtent)(o, void 0), M = [[], [], []], F = 0; F < 3; F++)
                  M[0][F] = w[0][F] - v, M[1][F] = w[1][F] + v, M[2][F] = w[2][F];
                var m = [];
                for (let R = 0; R < this.atoms.length; R++) {
                  var E = this.atoms[R].x, z = this.atoms[R].y, O = this.atoms[R].z;
                  E >= M[0][0] && E <= M[1][0] && z >= M[0][1] && z <= M[1][1] && O >= M[0][2] && O <= M[1][2] && (E >= w[0][0] && E <= w[1][0] && z >= w[0][1] && z <= w[1][1] && O >= w[0][2] && O <= w[1][2] || m.push(this.atoms[R]));
                }
                return m;
              }
              static getFloat(o) {
                return typeof o == "number" ? o : parseFloat(o);
              }
              /** return list of atoms selected by sel, this is specific to glmodel
               *
               * @param {AtomSelectionSpec} sel
               * @return {Object[]}
               * @example
               $3Dmol.download("pdb:4wwy",viewer,{},function(){
                        var atoms = viewer.selectedAtoms({chain:'A'});
                        for(var i = 0, n = atoms.length; i < n; i++) {
                           atoms[i].b = 0.0;
                        }
                        viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});
                        viewer.render();
                    });
               */
              selectedAtoms(o, v) {
                var w = [];
                o = L.deepCopyAndCache(o || {}, this), v || (v = this.atoms);
                for (var M = v.length, F = 0; F < M; F++) {
                  var m = v[F];
                  m && this.atomIsSelected(m, o) && w.push(m);
                }
                if (o.hasOwnProperty("expand")) {
                  const H = L.getFloat(o.expand);
                  let j = this.expandAtomList(w, H), Q = w.length;
                  const J = H * H;
                  for (let Y = 0; Y < j.length; Y++)
                    for (let ee = 0; ee < Q; ee++) {
                      var E = L.squaredDistance(j[Y], w[ee]);
                      E < J && E > 0 && w.push(j[Y]);
                    }
                }
                if (o.hasOwnProperty("within") && o.within.hasOwnProperty("sel") && o.within.hasOwnProperty("distance")) {
                  var z = this.selectedAtoms(o.within.sel, this.atoms), O = {};
                  const H = L.getFloat(o.within.distance), j = H * H;
                  for (let Q = 0; Q < z.length; Q++)
                    for (let J = 0; J < w.length; J++) {
                      let Y = L.squaredDistance(z[Q], w[J]);
                      Y < j && Y > 0 && (O[J] = 1);
                    }
                  var R = [];
                  if (o.within.invert)
                    for (let Q = 0; Q < w.length; Q++)
                      O[Q] || R.push(w[Q]);
                  else
                    for (let Q in O)
                      R.push(w[Q]);
                  w = R;
                }
                if (o.hasOwnProperty("byres")) {
                  var B = {}, P = [], W = [];
                  for (let H = 0; H < w.length; H++) {
                    let j = w[H];
                    var U = j.chain, V = j.resi;
                    if (B[U] === void 0 && (B[U] = {}), j.hasOwnProperty("resi") && B[U][V] === void 0) {
                      for (B[U][V] = !0, W.push(j); W.length > 0; )
                        if (j = W.pop(), U = j.chain, V = j.resi, P[j.index] === void 0) {
                          P[j.index] = !0;
                          for (var K = 0; K < j.bonds.length; K++) {
                            var q = this.atoms[j.bonds[K]];
                            P[q.index] === void 0 && q.hasOwnProperty("resi") && q.chain == U && q.resi == V && (W.push(q), w.push(q));
                          }
                        }
                    }
                  }
                }
                return w;
              }
              /** Add list of new atoms to model.  Adjusts bonds appropriately.
              	     *
              	     * @param {AtomSpec[]} newatoms
              	     * @example
              	     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];
              
              	        viewer.setBackgroundColor(0xffffffff);
              	        var m = viewer.addModel();
              	        m.addAtoms(atoms);
              	        m.setStyle({},{stick:{}});
              	        viewer.zoomTo();
              	        viewer.render();
              	     */
              addAtoms(o) {
                this.molObj = null;
                var v = this.atoms.length, w = [], M;
                for (M = 0; M < o.length; M++)
                  typeof o[M].index > "u" && (o[M].index = M), typeof o[M].serial > "u" && (o[M].serial = M), w[o[M].index] = v + M;
                for (M = 0; M < o.length; M++) {
                  var F = o[M], m = w[F.index], E = (0, A.extend)({}, F);
                  E.index = m, E.bonds = [], E.bondOrder = [], E.model = this.id, E.style = E.style || (0, A.deepCopy)(L.defaultAtomStyle), typeof E.color > "u" && (E.color = this.ElementColors[E.elem] || this.defaultColor);
                  for (var z = F.bonds ? F.bonds.length : 0, O = 0; O < z; O++) {
                    var R = w[F.bonds[O]];
                    typeof R < "u" && (E.bonds.push(R), E.bondOrder.push(F.bondOrder ? F.bondOrder[O] : 1));
                  }
                  this.atoms.push(E);
                }
              }
              /** Assign bonds based on atomic coordinates.
               *  This currently uses a primitive distance-based algorithm that does not
               * consider valence constraints and will only create single bonds.
               */
              assignBonds() {
                (0, C.assignBonds)(this.atoms, { assignBonds: !0 });
              }
              /** Remove specified atoms from model
               *
               * @param {AtomSpec[]} badatoms - list of atoms
               */
              removeAtoms(o) {
                this.molObj = null;
                var v = [], w;
                for (w = 0; w < o.length; w++)
                  v[o[w].index] = !0;
                var M = [];
                for (w = 0; w < this.atoms.length; w++) {
                  var F = this.atoms[w];
                  v[F.index] || M.push(F);
                }
                this.atoms = [], this.addAtoms(M);
              }
              /** Set atom style of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel
              	     * @param {AtomStyleSpec} style
              	     * @param {boolean} add - if true, add to current style, don't replace
              	     @example
              	    $3Dmol.download("pdb:4UB9",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              
              	              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.render();
              	          });
              	     */
              setStyle(o, v, w) {
                typeof v > "u" && typeof w > "u" && (v = o, o = {}), o = o, typeof v == "string" && (v = (0, A.specStringToObject)(v));
                var M = !1, F = this, m = function(z) {
                  var O = F.selectedAtoms(o, z);
                  for (let R = 0; R < z.length; R++)
                    z[R] && (z[R].capDrawn = !1);
                  for (let R = 0; R < O.length; R++) {
                    M = !0, (O[R].clickable || O[R].hoverable) && (O[R].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), w || (O[R].style = {});
                    for (let B in v)
                      v.hasOwnProperty(B) && (O[R].style[B] = O[R].style[B] || {}, Object.assign(O[R].style[B], v[B]));
                  }
                };
                if (o.frame !== void 0 && o.frame < this.frames.length) {
                  let z = o.frame;
                  z < 0 && (z = this.frames.length + z), m(this.frames[z]);
                } else {
                  m(this.atoms);
                  for (var E = 0; E < this.frames.length; E++)
                    this.frames[E] !== this.atoms && m(this.frames[E]);
                }
                M && (this.molObj = null);
              }
              /** Set clickable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked
              
              	     */
              setClickable(o, v, w) {
                if (v = !!v, w = (0, A.makeFunction)(w), w === null) {
                  console.log("Callback is not a function");
                  return;
                }
                var M = this.selectedAtoms(o, this.atoms), F = M.length;
                for (let m = 0; m < F; m++)
                  M[m].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, M[m].clickable = v, w && (M[m].callback = w);
                F > 0 && (this.molObj = null);
              }
              /** Set hoverable and callback of selected atoms
              *
              * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              * @param {function} hover_callback - function called when an atom in the selection is hovered over
              * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              */
              setHoverable(o, v, w, M) {
                if (v = !!v, w = (0, A.makeFunction)(w), M = (0, A.makeFunction)(M), w === null) {
                  console.log("Hover_callback is not a function");
                  return;
                }
                if (M === null) {
                  console.log("Unhover_callback is not a function");
                  return;
                }
                var F = this.selectedAtoms(o, this.atoms), m = F.length;
                for (let E = 0; E < m; E++)
                  F[E].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, F[E].hoverable = v, w && (F[E].hover_callback = w), M && (F[E].unhover_callback = M);
                m > 0 && (this.molObj = null);
              }
              /** enable context menu of selected atoms
               *
               * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
               * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
               */
              enableContextMenu(o, v) {
                v = !!v;
                var w, M = this.selectedAtoms(o, this.atoms), F = M.length;
                for (w = 0; w < F; w++)
                  M[w].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, M[w].contextMenuEnabled = v;
                F > 0 && (this.molObj = null);
              }
              /** given a mapping from element to color, set atom colors
               *
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(o, v) {
                if (!(this.molObj !== null && L.sameObj(v, this.lastColors))) {
                  this.lastColors = v;
                  var w = this.selectedAtoms(o, w);
                  w.length > 0 && (this.molObj = null);
                  for (var M = 0; M < w.length; M++) {
                    var F = w[M];
                    typeof v[F.elem] < "u" && (F.color = v[F.elem]);
                  }
                }
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               */
              setColorByProperty(o, v, w, M) {
                var F, m, E = this.selectedAtoms(o, E);
                for (this.lastColors = null, E.length > 0 && (this.molObj = null), typeof w == "string" && typeof x.Gradient.builtinGradients[w] < "u" && (w = new x.Gradient.builtinGradients[w]()), w = w, M || (M = w.range()), M || (M = (0, A.getPropertyRange)(E, v)), F = 0; F < E.length; F++) {
                  m = E[F];
                  var z = (0, A.getAtomProperty)(m, v);
                  z != null && (m.color = w.valueToHex(parseFloat(m.properties[v]), M));
                }
              }
              /**
              	     * @deprecated use setStyle and colorfunc attribute
              	     * @param {AtomSelectionSpec} sel - selection object
              	     * @param {function} func - function to be used to set the color
              	     @example
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              	              var colorAsSnake = function(atom) {
              	                return atom.resi % 2 ? 'white': 'green'
              	              };
              
              	              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});
              
              	              viewer.render();
              	          });
              
              	     */
              setColorByFunction(o, v) {
                var w = this.selectedAtoms(o, w);
                if (typeof v == "function") {
                  this.lastColors = null, w.length > 0 && (this.molObj = null);
                  for (let M = 0; M < w.length; M++) {
                    let F = w[M];
                    F.color = v(F);
                  }
                }
              }
              /** Convert the model into an object in the format of a ChemDoodle JSON model.
               *
               * @param {boolean} whether or not to include style information. Defaults to false.
               * @return {Object}
               */
              toCDObject(o = !1) {
                var v = { a: [], b: [] };
                o && (v.s = []);
                for (let M = 0; M < this.atoms.length; M++) {
                  let F = {}, m = this.atoms[M];
                  if (F.x = m.x, F.y = m.y, F.z = m.z, m.elem != "C" && (F.l = m.elem), o) {
                    for (var w = 0; w < v.s.length && JSON.stringify(m.style) !== JSON.stringify(v.s[w]); )
                      w++;
                    w === v.s.length && v.s.push(m.style), w !== 0 && (F.s = w);
                  }
                  v.a.push(F);
                  for (let E = 0; E < m.bonds.length; E++) {
                    let z = M, O = m.bonds[E];
                    if (z >= O)
                      continue;
                    let R = {
                      b: z,
                      e: O
                    }, B = m.bondOrder[E];
                    B != 1 && (R.o = B), v.b.push(R);
                  }
                }
                return v;
              }
              /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add
               *
               * @param {Object3D} group
               * @param Object options
               */
              globj(o, v) {
                (this.molObj === null || v.regen) && (this.molObj = this.createMolObj(this.atoms, v), this.renderedMolObj && (o.remove(this.renderedMolObj), this.renderedMolObj = null), this.renderedMolObj = this.molObj.clone(), this.hidden && (this.renderedMolObj.setVisible(!1), this.molObj.setVisible(!1)), o.add(this.renderedMolObj));
              }
              /** return a VRML string representation of the model.  Does not include VRML header information
               * @return VRML
               */
              exportVRML() {
                var o = this.createMolObj(this.atoms, { supportsImposters: !1, supportsAIA: !1 });
                return o.vrml();
              }
              /** Remove any renderable mol object from scene
               *
               * @param {Object3D} group
               */
              removegl(o) {
                this.renderedMolObj && (this.renderedMolObj.geometry !== void 0 && this.renderedMolObj.geometry.dispose(), this.renderedMolObj.material !== void 0 && this.renderedMolObj.material.dispose(), o.remove(this.renderedMolObj), this.renderedMolObj = null), this.molObj = null;
              }
              /**
              	     * Don't show this model in future renderings. Keep all styles and state
              	     * so it can be efficiencly shown again.
              	     *
              	     * * @see GLModel#show
              
              	     * @example
              	        $3Dmol.download("pdb:3ucr",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.getModel().hide();
              	        viewer.render();
              	        });
              	     */
              hide() {
                this.hidden = !0, this.renderedMolObj && this.renderedMolObj.setVisible(!1), this.molObj && this.molObj.setVisible(!1);
              }
              /**
               * Unhide a hidden model
               * @see GLModel#hide
               * @example
                  $3Dmol.download("pdb:3ucr",viewer,{},function(){
                  viewer.setStyle({},{stick:{}});
                  viewer.getModel().hide();
                  viewer.render(  )
                  viewer.getModel().show()
                  viewer.render();
                  });
               */
              show() {
                this.hidden = !1, this.renderedMolObj && this.renderedMolObj.setVisible(!0), this.molObj && this.molObj.setVisible(!0);
              }
              /** Create labels for atoms that show the value of the passed property.
               *
               * @param {String} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               */
              addPropertyLabels(o, v, w, M) {
                for (var F = this.selectedAtoms(v, F), m = (0, A.deepCopy)(M), E = 0; E < F.length; E++) {
                  var z = F[E], O = null;
                  typeof z[o] < "u" ? O = String(z[o]) : typeof z.properties[o] < "u" && (O = String(z.properties[o])), O != null && (m.position = z, w.addLabel(O, m));
                }
              }
              /** Create labels for residues of selected atoms.
               * Will create a single label at the center of mass of all atoms
               * with the same chain,resn, and resi.
               *
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already
               */
              addResLabels(o, v, w, M = !1) {
                var F = [], m = function(z, O) {
                  for (var R = z.selectedAtoms(o, R), B = {}, P = 0; P < R.length; P++) {
                    var W = R[P], U = W.chain, V = W.resn, K = W.resi, q = V + "" + K;
                    B[U] || (B[U] = {}), B[U][q] || (B[U][q] = []), B[U][q].push(W);
                  }
                  var H = (0, A.deepCopy)(w);
                  for (let Q in B)
                    if (B.hasOwnProperty(Q)) {
                      var j = B[Q];
                      for (let J in j)
                        if (j.hasOwnProperty(J)) {
                          let Y = j[J], ee = new h.Vector3(0, 0, 0);
                          for (let me = 0; me < Y.length; me++) {
                            let he = Y[me];
                            ee.x += he.x, ee.y += he.y, ee.z += he.z;
                          }
                          ee.divideScalar(Y.length), H.position = ee, H.frame = O;
                          let fe = v.addLabel(J, H, void 0, !0);
                          F.push(fe);
                        }
                    }
                };
                if (M) {
                  var E = this.getNumFrames();
                  let z = this.atoms;
                  for (let O = 0; O < E; O++)
                    this.frames[O] && (this.atoms = this.frames[O], m(this, O));
                  this.atoms = z;
                } else
                  m(this);
                return F;
              }
              //recurse over the current atoms to establish a depth first order
              setupDFS() {
                this.atomdfs = [];
                var o = this, v = new Int8Array(this.atoms.length);
                v.fill(0);
                for (var w = function(E, z, O) {
                  O.push([E, z]);
                  var R = o.atoms[E];
                  v[E] = 1;
                  for (var B = 0; B < R.bonds.length; B++) {
                    var P = R.bonds[B];
                    o.atoms[P] && !v[P] && w(P, E, O);
                  }
                }, M = 0; M < this.atoms.length; M++) {
                  var F = this.atoms[M];
                  if (F && !v[M]) {
                    var m = [];
                    w(M, -1, m), this.atomdfs.push(m);
                  }
                }
              }
              /**
              * Set coordinates from remote trajectory file.
              * @param {string} url - contains the url where mdsrv has been hosted
              * @param {string} path - contains the path of the file (<root>/filename)
              * @return {Promise}
              */
              setCoordinatesFromURL(o, v) {
                this.frames = [];
                var w = this;
                return this.box && this.setupDFS(), o.startsWith("http") || (o = "http://" + o), (0, A.get)(o + "/traj/numframes/" + v, function(M) {
                  if (!isNaN(parseInt(M)))
                    return w.frames.push(w.atoms), w.frames.numFrames = M, w.frames.url = o, w.frames.path = v, w.setFrame(0);
                });
              }
              /**
              * Set coordinates for the atoms from provided trajectory file.
              * @param {string|ArrayBuffer} str - contains the data of the file
              * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.
                @example
                   let m = viewer.addModel()  //create an empty model
                   m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms
                   viewer.setStyle({'sphere':{}})
                   m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');
                   viewer.animate({loop: "forward",reps: 1});
                   viewer.zoomTo();
                   viewer.zoom(0.5);
                   viewer.render();
              */
              setCoordinates(o, v) {
                if (v = v || "", !o)
                  return [];
                if (/\.gz$/.test(v)) {
                  v = v.replace(/\.gz$/, "");
                  try {
                    o = (0, A.inflateString)(o);
                  } catch (B) {
                    console.log(B);
                  }
                }
                var w = { mdcrd: "", inpcrd: "", pdb: "", netcdf: "", array: "" };
                if (w.hasOwnProperty(v)) {
                  this.frames = [];
                  for (var M = this.atoms.length, F = L.parseCrd(o, v), m = 0; m < F.length; ) {
                    for (var E = [], z = 0; z < M; z++) {
                      var O = {};
                      for (var R in this.atoms[z])
                        O[R] = this.atoms[z][R];
                      E[z] = O, E[z].x = F[m++], E[z].y = F[m++], E[z].z = F[m++];
                    }
                    this.frames.push(E);
                  }
                  return this.atoms = this.frames[0], this.frames;
                }
                return [];
              }
              /**
               * add atomSpecs to validAtomSelectionSpecs
               * @deprecated
               * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs
               * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.
               * These messages are no longer generated as, in theory, typescript will catch problems at compile time.
               * In practice, there may still be issues at run-time but we don't check for them...
               *
               * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime
               * type checking, but it currently doesn't work with our types...
               */
              addAtomSpecs(o) {
              }
              static parseCrd(o, v) {
                var w = [], M = 0;
                if (v == "pdb")
                  for (var F = o.indexOf(`
ATOM`); F != -1; ) {
                    for (; o.slice(F, F + 5) == `
ATOM` || o.slice(F, F + 7) == `
HETATM`; )
                      w[M++] = parseFloat(o.slice(F + 31, F + 39)), w[M++] = parseFloat(o.slice(F + 39, F + 47)), w[M++] = parseFloat(o.slice(F + 47, F + 55)), F = o.indexOf(`
`, F + 54), o.slice(F, F + 4) == `
TER` && (F = o.indexOf(`
`, F + 5));
                    F = o.indexOf(`
ATOM`, F);
                  }
                else if (v == "netcdf") {
                  var m = new $.NetCDFReader(o);
                  w = [].concat.apply([], m.getDataVariable("coordinates"));
                } else {
                  if (v == "array" || Array.isArray(o))
                    return o.flat(2);
                  {
                    let E = o.indexOf(`
`);
                    v == "inpcrd" && (E = o.indexOf(`
`, E + 1)), o = o.slice(E + 1), w = o.match(/\S+/g).map(parseFloat);
                  }
                }
                return w;
              }
              static parseMolData(o, v = "", w) {
                if (!o)
                  return [];
                if (/\.gz$/.test(v)) {
                  v = v.replace(/\.gz$/, "");
                  try {
                    v.match(/bcif/i) ? o = (0, A.inflateString)(o, !1) : o = (0, A.inflateString)(o);
                  } catch (m) {
                    console.log(m);
                  }
                }
                typeof k.Parsers[v] > "u" && (v = v.split(".").pop(), typeof k.Parsers[v] > "u" && (console.log("Unknown format: " + v), o instanceof Uint8Array ? v = "bcif" : o.match(/^@<TRIPOS>MOLECULE/gm) ? v = "mol2" : o.match(/^data_/gm) && o.match(/^loop_/gm) ? v = "cif" : o.match(/^HETATM/gm) || o.match(/^ATOM/gm) ? v = "pdb" : o.match(/ITEM: TIMESTEP/gm) ? v = "lammpstrj" : o.match(/^.*\n.*\n.\s*(\d+)\s+(\d+)/gm) ? v = "sdf" : o.match(/^%VERSION\s+VERSION_STAMP/gm) ? v = "prmtop" : v = "xyz", console.log("Best guess: " + v)));
                var M = k.Parsers[v], F = M(o, w);
                return F;
              }
            }
            L.defaultAtomStyle = {
              line: {}
            }, L.defaultlineWidth = 1, L.vdwRadii = {
              H: 1.2,
              He: 1.4,
              Li: 1.82,
              Be: 1.53,
              B: 1.92,
              C: 1.7,
              N: 1.55,
              O: 1.52,
              F: 1.47,
              Ne: 1.54,
              Na: 2.27,
              Mg: 1.73,
              Al: 1.84,
              Si: 2.1,
              P: 1.8,
              S: 1.8,
              Cl: 1.75,
              Ar: 1.88,
              K: 2.75,
              Ca: 2.31,
              Ni: 1.63,
              Cu: 1.4,
              Zn: 1.39,
              Ga: 1.87,
              Ge: 2.11,
              As: 1.85,
              Se: 1.9,
              Br: 1.85,
              Kr: 2.02,
              Rb: 3.03,
              Sr: 2.49,
              Pd: 1.63,
              Ag: 1.72,
              Cd: 1.58,
              In: 1.93,
              Sn: 2.17,
              Sb: 2.06,
              Te: 2.06,
              I: 1.98,
              Xe: 2.16,
              Cs: 3.43,
              Ba: 2.68,
              Pt: 1.75,
              Au: 1.66,
              Hg: 1.55,
              Tl: 1.96,
              Pb: 2.02,
              Bi: 2.07,
              Po: 1.97,
              At: 2.02,
              Rn: 2.2,
              Fr: 3.48,
              Ra: 2.83,
              U: 1.86
            }, L.ignoredKeys = /* @__PURE__ */ new Set(["props", "invert", "model", "frame", "byres", "expand", "within", "and", "or", "not"]);
          }
        ),
        /***/
        "./src/GLShape.ts": (
          /*!************************!*\
            !*** ./src/GLShape.ts ***!
            \************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              GLShape: () => (
                /* binding */
                $
              ),
              /* harmony export */
              splitMesh: () => (
                /* binding */
                C
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), h = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), b = r(
              /*! ./colors */
              "./src/colors.ts"
            ), g = r(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), _ = r(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), A = r(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), x = r(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), k = r(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            class $ {
              static finalizeGeo(y) {
                var o = y.updateGeoGroup(0);
                o.vertices > 0 && o.truncateArrayBuffers(!0, !0);
              }
              /*
               *
               * @param {Geometry}
               *            geo
               * @param {Color | colorlike} color
               */
              static updateColor(y, o) {
                o = o || b.CC.color(o), y.colorsNeedUpdate = !0;
                var v, w, M;
                o.constructor !== Array && (v = o.r, w = o.g, M = o.b);
                for (let F in y.geometryGroups) {
                  let m = y.geometryGroups[F], E = m.colorArray;
                  for (let z = 0, O = m.vertices; z < O; ++z) {
                    if (o.constructor === Array) {
                      let R = o[z];
                      v = R.r, w = R.g, M = R.b;
                    }
                    E[z * 3] = v, E[z * 3 + 1] = w, E[z * 3 + 2] = M;
                  }
                }
              }
              /*
               * @param {GLShape}
               *            shape
               * @param {geometryGroup}
               *            geoGroup
               * @param {ArrowSpec}
               *            spec
               */
              static drawArrow(y, o, v) {
                var w = v.start, M = v.end, F = v.radius, m = v.radiusRatio, E = v.mid, z = v.midpos;
                if (!(w && M))
                  return;
                var O = o.updateGeoGroup(51), R = new h.Vector3(M.x, M.y, M.z).sub(w);
                if (z) {
                  let Me = R.length();
                  z > 0 ? E = z / Me : E = (Me + z) / Me;
                }
                R.multiplyScalar(E);
                var B = new h.Vector3(w.x, w.y, w.z).add(R), P = R.clone().negate();
                let W = new h.Vector3(w.x, w.y, w.z);
                y.intersectionShape.cylinder.push(new s.Cylinder(W, B.clone(), F)), y.intersectionShape.sphere.push(new s.Sphere(W, F));
                var U = [];
                U[0] = R.clone(), Math.abs(U[0].x) > 1e-4 ? U[0].y += 1 : U[0].x += 1, U[0].cross(R), U[0].normalize(), U[4] = U[0].clone(), U[4].crossVectors(U[0], R), U[4].normalize(), U[8] = U[0].clone().negate(), U[12] = U[4].clone().negate(), U[2] = U[0].clone().add(U[4]).normalize(), U[6] = U[4].clone().add(U[8]).normalize(), U[10] = U[8].clone().add(U[12]).normalize(), U[14] = U[12].clone().add(U[0]).normalize(), U[1] = U[0].clone().add(U[2]).normalize(), U[3] = U[2].clone().add(U[4]).normalize(), U[5] = U[4].clone().add(U[6]).normalize(), U[7] = U[6].clone().add(U[8]).normalize(), U[9] = U[8].clone().add(U[10]).normalize(), U[11] = U[10].clone().add(U[12]).normalize(), U[13] = U[12].clone().add(U[14]).normalize(), U[15] = U[14].clone().add(U[0]).normalize();
                var V = O.vertices, K = O.vertexArray, q = O.faceArray, H = O.normalArray, j = O.lineArray, Q, J, Y;
                for (J = 0, Y = U.length; J < Y; ++J) {
                  Q = 3 * (V + 3 * J);
                  var ee = U[J].clone().multiplyScalar(F).add(w), fe = U[J].clone().multiplyScalar(F).add(B), me = U[J].clone().multiplyScalar(F * m).add(B);
                  if (K[Q] = ee.x, K[Q + 1] = ee.y, K[Q + 2] = ee.z, K[Q + 3] = fe.x, K[Q + 4] = fe.y, K[Q + 5] = fe.z, K[Q + 6] = me.x, K[Q + 7] = me.y, K[Q + 8] = me.z, J > 0) {
                    var he = K[Q - 3], we = K[Q - 2], ye = K[Q - 1], ve = new h.Vector3(he, we, ye), ce = new h.Vector3(M.x, M.y, M.z), be = B.clone(), le = new h.Vector3(me.x, me.y, me.z);
                    y.intersectionShape.triangle.push(new s.Triangle(le, ce, ve)), y.intersectionShape.triangle.push(new s.Triangle(ve.clone(), be, le.clone()));
                  }
                }
                O.vertices += 48, Q = O.vertices * 3, K[Q] = w.x, K[Q + 1] = w.y, K[Q + 2] = w.z, K[Q + 3] = B.x, K[Q + 4] = B.y, K[Q + 5] = B.z, K[Q + 6] = M.x, K[Q + 7] = M.y, K[Q + 8] = M.z, O.vertices += 3;
                var Se, ge, de, De, Be, Ve, qe, Ze, Ye, Xe, Ge, Ke, Pe, it, nt, ne, se, ue, $e, Ae = O.vertices - 3, je = O.vertices - 2, ze = O.vertices - 1, re = Ae * 3, xe = je * 3, Le = ze * 3;
                for (J = 0, Y = U.length - 1; J < Y; ++J) {
                  var He = V + 3 * J;
                  Q = He * 3, ge = O.faceidx, de = O.lineidx, De = He, Xe = De * 3, Be = He + 1, Ge = Be * 3, Ve = He + 2, Ke = Ve * 3, qe = He + 4, Pe = qe * 3, Ze = He + 5, it = Ze * 3, Ye = He + 3, nt = Ye * 3, ne = se = U[J], ue = $e = U[J + 1], H[Xe] = ne.x, H[Ge] = se.x, H[nt] = $e.x, H[Xe + 1] = ne.y, H[Ge + 1] = se.y, H[nt + 1] = $e.y, H[Xe + 2] = ne.z, H[Ge + 2] = se.z, H[nt + 2] = $e.z, H[Ge] = se.x, H[Pe] = ue.x, H[nt] = $e.x, H[Ge + 1] = se.y, H[Pe + 1] = ue.y, H[nt + 1] = $e.y, H[Ge + 2] = se.z, H[Pe + 2] = ue.z, H[nt + 2] = $e.z, H[Ke] = se.x, H[it] = ue.x, H[Ke + 1] = se.y, H[it + 1] = ue.y, H[Ke + 2] = se.z, H[it + 2] = ue.z, q[ge] = De, q[ge + 1] = Be, q[ge + 2] = Ye, q[ge + 3] = Be, q[ge + 4] = qe, q[ge + 5] = Ye, q[ge + 6] = De, q[ge + 7] = Ye, q[ge + 8] = Ae, q[ge + 9] = Ve, q[ge + 10] = je, q[ge + 11] = Ze, q[ge + 12] = Ve, q[ge + 13] = ze, q[ge + 14] = Ze, j[de] = De, j[de + 1] = Be, j[de + 2] = De, j[de + 3] = Ye, j[de + 4] = qe, j[de + 5] = Ye, j[de + 6] = De, j[de + 7] = Ye, j[de + 8] = Ve, j[de + 9] = Be, j[de + 10] = Ve, j[de + 11] = Ze, j[de + 12] = qe, j[de + 13] = Ze, j[de + 14] = Ve, j[de + 15] = ze, j[de + 16] = Ve, j[de + 17] = Ze, j[de + 18] = ze, j[de + 19] = Ze, O.faceidx += 15, O.lineidx += 20;
                }
                Se = [
                  V + 45,
                  V + 46,
                  V + 1,
                  V,
                  V + 47,
                  V + 2
                ], ge = O.faceidx, de = O.lineidx, De = Se[0], Xe = De * 3, Be = Se[1], Ge = Be * 3, Ve = Se[4], Ke = Ve * 3, qe = Se[2], Pe = qe * 3, Ze = Se[5], it = Ze * 3, Ye = Se[3], nt = Ye * 3, ne = se = U[15], ue = $e = U[0], H[Xe] = ne.x, H[Ge] = se.x, H[nt] = $e.x, H[Xe + 1] = ne.y, H[Ge + 1] = se.y, H[nt + 1] = $e.y, H[Xe + 2] = ne.z, H[Ge + 2] = se.z, H[nt + 2] = $e.z, H[Ge] = se.x, H[Pe] = ue.x, H[nt] = $e.x, H[Ge + 1] = se.y, H[Pe + 1] = ue.y, H[nt + 1] = $e.y, H[Ge + 2] = se.z, H[Pe + 2] = ue.z, H[nt + 2] = $e.z, H[Ke] = se.x, H[it] = ue.x, H[Ke + 1] = se.y, H[it + 1] = ue.y, H[Ke + 2] = se.z, H[it + 2] = ue.z, R.normalize(), P.normalize(), H[re] = P.x, H[xe] = H[Le] = R.x, H[re + 1] = P.y, H[xe + 1] = H[Le + 1] = R.y, H[re + 2] = P.z, H[xe + 2] = H[Le + 2] = R.z, q[ge] = De, q[ge + 1] = Be, q[ge + 2] = Ye, q[ge + 3] = Be, q[ge + 4] = qe, q[ge + 5] = Ye, q[ge + 6] = De, q[ge + 7] = Ye, q[ge + 8] = Ae, q[ge + 9] = Ve, q[ge + 10] = je, q[ge + 11] = Ze, q[ge + 12] = Ve, q[ge + 13] = ze, q[ge + 14] = Ze, j[de] = De, j[de + 1] = Be, j[de + 2] = De, j[de + 3] = Ye, j[de + 4] = qe, j[de + 5] = Ye, j[de + 6] = De, j[de + 7] = Ye, j[de + 8] = Ve, j[de + 9] = Be, j[de + 10] = Ve, j[de + 11] = Ze, j[de + 12] = qe, j[de + 13] = Ze, j[de + 14] = Ve, j[de + 15] = ze, j[de + 16] = Ve, j[de + 17] = Ze, j[de + 18] = ze, j[de + 19] = Ze, O.faceidx += 15, O.lineidx += 20;
              }
              // Update a bounding sphere's position and radius
              // from list of centroids and new points
              /*
               * @param {Sphere}
               *            sphere
               * @param {Object}
               *            components, centroid of all objects in shape
               * @param {Array}
               *            points, flat array of all points in shape
               * @param {int} numPoints, number of valid poitns in points
               */
              static updateBoundingFromPoints(y, o, v, w) {
                y.center.set(0, 0, 0);
                let M = 1 / 0, F = 1 / 0, m = 1 / 0, E = -1 / 0, z = -1 / 0, O = -1 / 0;
                y.box && (M = y.box.min.x, E = y.box.max.x, F = y.box.min.y, z = y.box.max.y, m = y.box.min.z, O = y.box.max.z);
                for (let W = 0, U = w; W < U; W++) {
                  var R = v[W * 3], B = v[W * 3 + 1], P = v[W * 3 + 2];
                  R < M && (M = R), B < F && (F = B), P < m && (m = P), R > E && (E = R), B > z && (z = B), P > O && (O = P);
                }
                y.center.set((E + M) / 2, (z + F) / 2, (O + m) / 2), y.radius = y.center.distanceTo({ x: E, y: z, z: O }), y.box = { min: { x: M, y: F, z: m }, max: { x: E, y: z, z: O } };
              }
              //helper function for adding an appropriately sized mesh
              static addCustomGeo(y, o, v, w, M) {
                var F = o.addGeoGroup(), m = v.vertexArr, E = v.normalArr, z = v.faceArr;
                F.vertices = m.length, F.faceidx = z.length;
                var O, R, B, P, W, U, V, K, q, H = F.vertexArray, j = F.colorArray;
                for (w.constructor !== Array && (K = w.r, q = w.g, P = w.b), U = 0, V = F.vertices; U < V; ++U)
                  O = U * 3, R = m[U], H[O] = R.x, H[O + 1] = R.y, H[O + 2] = R.z, w.constructor === Array && (W = w[U], K = W.r, q = W.g, P = W.b), j[O] = K, j[O + 1] = q, j[O + 2] = P;
                if (M)
                  for (U = 0, V = F.faceidx / 3; U < V; ++U) {
                    O = U * 3, B = z[O], P = z[O + 1], W = z[O + 2];
                    var Q = new h.Vector3(), J = new h.Vector3(), Y = new h.Vector3();
                    y.intersectionShape.triangle.push(new s.Triangle(Q.copy(m[B]), J.copy(m[P]), Y.copy(m[W])));
                  }
                if (M) {
                  var ee = new h.Vector3(0, 0, 0), fe = 0;
                  for (let we = 0; we < o.geometryGroups.length; we++)
                    ee.add(o.geometryGroups[we].getCentroid()), fe++;
                  ee.divideScalar(fe), $.updateBoundingFromPoints(y.boundingSphere, { centroid: ee }, H, F.vertices);
                }
                if (F.faceArray = new Uint16Array(z), F.truncateArrayBuffers(!0, !0), E.length < F.vertices)
                  F.setNormals();
                else {
                  var me = F.normalArray = new Float32Array(F.vertices * 3), he;
                  for (U = 0, V = F.vertices; U < V; ++U)
                    O = U * 3, he = E[U], me[O] = he.x, me[O + 1] = he.y, me[O + 2] = he.z;
                }
                F.setLineIndices(), F.lineidx = F.lineArray.length;
              }
              /*
               *
               * @param {$3Dmol.GLShape}
               *            shape
               * @param {ShapeSpec}
               *            stylespec
               * @returns {undefined}
               */
              static updateFromStyle(y, o) {
                typeof o.color < "u" ? (y.color = o.color || new b.Color(), o.color instanceof b.Color || (y.color = b.CC.color(o.color))) : y.color = b.CC.color(0), y.wireframe = !!o.wireframe, y.opacity = o.alpha ? (0, h.clamp)(o.alpha, 0, 1) : 1, typeof o.opacity < "u" && (y.opacity = (0, h.clamp)(o.opacity, 0, 1)), y.side = o.side !== void 0 ? o.side : n.DoubleSide, y.linewidth = typeof o.linewidth > "u" ? 1 : o.linewidth, y.clickable = !!o.clickable, y.callback = (0, k.makeFunction)(o.callback), y.hoverable = !!o.hoverable, y.hover_callback = (0, k.makeFunction)(o.hover_callback), y.unhover_callback = (0, k.makeFunction)(o.unhover_callback), y.contextMenuEnabled = !!o.contextMenuEnabled, y.hidden = o.hidden, y.frame = o.frame;
              }
              /**
               * Custom renderable shape
               *
               * @constructor
               *
               * @param {ShapeSpec} stylespec
               */
              constructor(y) {
                this.color = 16777215, this.hidden = !1, this.wireframe = !1, this.opacity = 1, this.linewidth = 1, this.clickable = !1, this.hoverable = !1, this.contextMenuEnabled = !1, this.side = n.DoubleSide, this.stylespec = y || {}, this.boundingSphere = new s.Sphere(), this.intersectionShape = {
                  sphere: [],
                  cylinder: [],
                  line: [],
                  triangle: []
                }, $.updateFromStyle(this, this.stylespec), this.components = [], this.shapeObj = null, this.renderedShapeObj = null, this.geo = new n.Geometry(!0), this.linegeo = new n.Geometry(!0);
              }
              /** Update shape with new style specification
               * @param {ShapeSpec} newspec
                 @example
                  let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                  sphere.updateStyle({color:'yellow',opacity:0.5});
                  viewer.render();
               */
              updateStyle(y) {
                for (var o in y)
                  this.stylespec[o] = y[o];
                if ($.updateFromStyle(this, this.stylespec), y.voldata && y.volscheme) {
                  (0, k.adjustVolumeStyle)(y);
                  const v = y.volscheme, w = y.voldata, M = b.CC, F = v.range() || [-1, 1];
                  this.geo.setColors(function(m, E, z) {
                    let O = w.getVal(m, E, z);
                    return M.color(v.valueToHex(O, F));
                  }), delete this.color;
                }
              }
              /**
               * Creates a custom shape from supplied vertex and face arrays
               * @param {CustomShapeSpec} customSpec
               */
              addCustom(y) {
                y.vertexArr = y.vertexArr || [], y.faceArr = y.faceArr || [], y.normalArr = y.normalArr || [], $.drawCustom(this, this.geo, y);
              }
              /**
               * Creates a sphere shape
               * @param {SphereSpec} sphereSpec
               @example
               viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
               
               viewer.render();
               */
              addSphere(y) {
                y.center || (y.center = new h.Vector3(0, 0, 0)), y.radius = y.radius ? (0, h.clamp)(y.radius, 0, 1 / 0) : 1.5, y.color = b.CC.color(y.color), this.intersectionShape.sphere.push(new s.Sphere(y.center, y.radius)), A.GLDraw.drawSphere(this.geo, y.center, y.radius, y.color, y.quality), this.components.push({
                  centroid: new h.Vector3(y.center.x, y.center.y, y.center.z)
                });
                var o = this.geo.updateGeoGroup(0);
                $.updateBoundingFromPoints(this.boundingSphere, this.components, o.vertexArray, o.vertices);
              }
              /**
               * Creates a box
               * @param {BoxSpec} boxSpec
               @example
               var shape = viewer.addShape({color:'red'});
               shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});
               shape.addBox({corner: {x:-5,y:-3,z:0},
                             dimensions: { w: {x:1,y:1,z:0},
                                           h: {x:-1,y:1,z:0},
                                           d: {x:0,y:0,z:1} }});
               viewer.zoomTo();
               viewer.rotate(30);
               viewer.render();
               */
              addBox(y) {
                var o = y.dimensions || { w: 1, h: 1, d: 1 }, v;
                typeof o.w == "number" ? v = { x: o.w, y: 0, z: 0 } : v = o.w;
                var w;
                typeof o.h == "number" ? w = { x: 0, y: o.h, z: 0 } : w = o.h;
                var M;
                typeof o.d == "number" ? M = { x: 0, y: 0, z: o.d } : M = o.d;
                var F = y.corner;
                F == null && (y.center !== void 0 ? F = {
                  x: y.center.x - 0.5 * (v.x + w.x + M.x),
                  y: y.center.y - 0.5 * (v.y + w.y + M.y),
                  z: y.center.z - 0.5 * (v.z + w.z + M.z)
                } : F = { x: 0, y: 0, z: 0 });
                var m = [
                  { x: F.x, y: F.y, z: F.z },
                  { x: F.x + v.x, y: F.y + v.y, z: F.z + v.z },
                  { x: F.x + w.x, y: F.y + w.y, z: F.z + w.z },
                  { x: F.x + v.x + w.x, y: F.y + v.y + w.y, z: F.z + v.z + w.z },
                  { x: F.x + M.x, y: F.y + M.y, z: F.z + M.z },
                  { x: F.x + v.x + M.x, y: F.y + v.y + M.y, z: F.z + v.z + M.z },
                  { x: F.x + w.x + M.x, y: F.y + w.y + M.y, z: F.z + w.z + M.z },
                  { x: F.x + v.x + w.x + M.x, y: F.y + v.y + w.y + M.y, z: F.z + v.z + w.z + M.z }
                ], E = [], z = [];
                E.splice(E.length, 0, m[0], m[1], m[2], m[3]), z.splice(z.length, 0, 0, 2, 1, 1, 2, 3);
                var O = 4;
                E.splice(E.length, 0, m[2], m[3], m[6], m[7]), z.splice(z.length, 0, O + 0, O + 2, O + 1, O + 1, O + 2, O + 3), O += 4, E.splice(E.length, 0, m[4], m[5], m[0], m[1]), z.splice(z.length, 0, O + 0, O + 2, O + 1, O + 1, O + 2, O + 3), O += 4, E.splice(E.length, 0, m[6], m[7], m[4], m[5]), z.splice(z.length, 0, O + 0, O + 2, O + 1, O + 1, O + 2, O + 3), O += 4, E.splice(E.length, 0, m[3], m[1], m[7], m[5]), z.splice(z.length, 0, O + 0, O + 2, O + 1, O + 1, O + 2, O + 3), O += 4, E.splice(E.length, 0, m[2], m[6], m[0], m[4]), z.splice(z.length, 0, O + 0, O + 2, O + 1, O + 1, O + 2, O + 3), O += 4;
                var R = (0, k.extend)({}, y);
                R.vertexArr = E, R.faceArr = z, R.normalArr = [], $.drawCustom(this, this.geo, R);
                var B = new h.Vector3();
                this.components.push({
                  centroid: B.addVectors(m[0], m[7]).multiplyScalar(0.5)
                });
                var P = this.geo.updateGeoGroup(0);
                $.updateBoundingFromPoints(this.boundingSphere, this.components, P.vertexArray, P.vertices);
              }
              /**
               * Creates a cylinder shape
               * @param {CylinderSpec} cylinderSpec
               @example
                    viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
                                        end:{x:10.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        fromCap:1,
                                        toCap:2,
                                        color:'red',
                                        hoverable:true,
                                        clickable:true,
                                        callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
                                        hover_callback: function(){ viewer.render( );},
                                        unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
                                       });
                    viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
                                        end:{x:0.0,y:10.0,z:0.0},
                                        radius:0.5,
                                        fromCap:false,
                                        toCap:true,
                                        color:'teal'});
                    viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
                                        end:{x:20.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        color:'black',
                                        fromCap:false,
                                        toCap:false});
                    viewer.render();
               */
              addCylinder(y) {
                var o, v;
                y.start ? o = new h.Vector3(y.start.x || 0, y.start.y || 0, y.start.z || 0) : o = new h.Vector3(0, 0, 0), y.end ? (v = new h.Vector3(y.end.x, y.end.y || 0, y.end.z || 0), typeof v.x > "u" && (v.x = 3)) : v = new h.Vector3(0, 0, 0);
                var w = y.radius || 0.1, M = b.CC.color(y.color);
                this.intersectionShape.cylinder.push(new s.Cylinder(o, v, w)), A.GLDraw.drawCylinder(this.geo, o, v, w, M, y.fromCap, y.toCap);
                var F = new h.Vector3();
                this.components.push({
                  centroid: F.addVectors(o, v).multiplyScalar(0.5)
                });
                var m = this.geo.updateGeoGroup(0);
                $.updateBoundingFromPoints(this.boundingSphere, this.components, m.vertexArray, m.vertices);
              }
              /**
               * Creates a dashed cylinder shape
               * @param {CylinderSpec} cylinderSpec
               */
              addDashedCylinder(y) {
                y.dashLength = y.dashLength || 0.25, y.gapLength = y.gapLength || 0.25;
                var o;
                y.start ? o = new h.Vector3(y.start.x || 0, y.start.y || 0, y.start.z || 0) : o = new h.Vector3(0, 0, 0);
                var v;
                y.end ? (v = new h.Vector3(y.end.x, y.end.y || 0, y.end.z || 0), typeof v.x > "u" && (v.x = 3)) : v = new h.Vector3(3, 0, 0);
                for (var w = y.radius || 0.1, M = b.CC.color(y.color), F = Math.sqrt(Math.pow(o.x - v.x, 2) + Math.pow(o.y - v.y, 2) + Math.pow(o.z - v.z, 2)), m = F / (y.gapLength + y.dashLength), E = new h.Vector3(y.start.x || 0, y.start.y || 0, y.start.z || 0), z = new h.Vector3(y.end.x, y.end.y || 0, y.end.z || 0), O = new h.Vector3((v.x - o.x) / (F / y.gapLength), (v.y - o.y) / (F / y.gapLength), (v.z - o.z) / (F / y.gapLength)), R = new h.Vector3((v.x - o.x) / (F / y.dashLength), (v.y - o.y) / (F / y.dashLength), (v.z - o.z) / (F / y.dashLength)), B = 0; B < m; B++)
                  z = new h.Vector3(E.x + R.x, E.y + R.y, E.z + R.z), this.intersectionShape.cylinder.push(new s.Cylinder(E, z, w)), A.GLDraw.drawCylinder(this.geo, E, z, w, M, y.fromCap, y.toCap), E = new h.Vector3(z.x + O.x, z.y + O.y, z.z + O.z);
                var P = new h.Vector3();
                this.components.push({
                  centroid: P.addVectors(o, v).multiplyScalar(0.5)
                });
                var W = this.geo.updateGeoGroup(0);
                $.updateBoundingFromPoints(this.boundingSphere, this.components, W.vertexArray, W.vertices);
              }
              /**
               * Creates a curved shape
               * @param {CurveSpec} curveSpec
               */
              addCurve(y) {
                y.points = y.points || [], y.smooth = y.smooth || 10, typeof y.fromCap > "u" && (y.fromCap = 2), typeof y.toCap > "u" && (y.toCap = 2);
                var o = (0, x.subdivide_spline)(y.points, y.smooth);
                if (o.length < 3) {
                  console.log("Too few points in addCurve");
                  return;
                }
                var v = y.radius || 0.1, w = b.CC.color(y.color), M = 0, F = o.length - 1, m = o[0].distanceTo(o[1]), E = Math.ceil(2 * v / m);
                if (y.toArrow) {
                  F -= E;
                  let B = {
                    start: o[F],
                    end: o[o.length - 1],
                    radius: v,
                    color: w,
                    mid: 1e-4
                  };
                  this.addArrow(B);
                }
                if (y.fromArrow) {
                  M += E;
                  let B = {
                    start: o[M],
                    end: o[0],
                    radius: v,
                    color: w,
                    mid: 1e-4
                  };
                  this.addArrow(B);
                }
                for (var z = Math.ceil(o.length / 2), O = { radius: v, color: w, fromCap: 2, toCap: 2 }, R = M; R < F; R++)
                  O.start = o[R], O.end = o[R + 1], O.fromCap = 2, O.toCap = 2, R < z ? (O.fromCap = 2, O.toCap = 0) : R > z ? (O.fromCap = 0, O.toCap = 2) : (O.fromCap = 2, O.toCap = 2), this.addCylinder(O);
              }
              /**
               * Creates a line shape
               * @param {LineSpec} lineSpec
               @example
               $3Dmol.download("pdb:2ABJ",viewer,{},function(){
                        viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
                        viewer.render(callback);
                    });
              
               */
              addLine(y) {
                var o, v;
                y.start ? o = new h.Vector3(y.start.x || 0, y.start.y || 0, y.start.z || 0) : o = new h.Vector3(0, 0, 0), y.end ? (v = new h.Vector3(y.end.x, y.end.y || 0, y.end.z || 0), typeof v.x > "u" && (v.x = 3)) : v = new h.Vector3(3, 0, 0);
                var w = this.geo.updateGeoGroup(2), M = w.vertices, F = M * 3, m = w.vertexArray;
                m[F] = o.x, m[F + 1] = o.y, m[F + 2] = o.z, m[F + 3] = v.x, m[F + 4] = v.y, m[F + 5] = v.z, w.vertices += 2;
                var E = w.lineArray, z = w.lineidx;
                E[z] = M, E[z + 1] = M + 1, w.lineidx += 2;
                var O = new h.Vector3();
                this.components.push({
                  centroid: O.addVectors(o, v).multiplyScalar(0.5)
                }), w = this.geo.updateGeoGroup(0), $.updateBoundingFromPoints(this.boundingSphere, this.components, w.vertexArray, w.vertices);
              }
              /**
               * Creates an arrow shape
               * @param {ArrowSpec} arrowSpec
               @example
                $3Dmol.download("pdb:4DM7",viewer,{},function(){
                        viewer.setBackgroundColor(0xffffffff);
                        viewer.addArrow({
                            start: {x:-10.0, y:0.0, z:0.0},
                            end: {x:0.0, y:-10.0, z:0.0},
                            radius: 1.0,
                            radiusRadio:1.0,
                            mid:1.0,
                            clickable:true,
                            callback:function(){
                                this.color.setHex(0xFF0000FF);
                                viewer.render( );
                            }
                        });
                        viewer.render();
                      });
               */
              addArrow(y) {
                if (y.start ? y.start = new h.Vector3(y.start.x || 0, y.start.y || 0, y.start.z || 0) : y.start = new h.Vector3(0, 0, 0), y.dir instanceof h.Vector3 && typeof y.length == "number") {
                  var o = y.dir.clone().multiplyScalar(y.length).add(y.start);
                  y.end = o;
                } else y.end ? (y.end = new h.Vector3(y.end.x, y.end.y || 0, y.end.z || 0), typeof y.end.x > "u" && (y.end.x = 3)) : y.end = new h.Vector3(3, 0, 0);
                y.radius = y.radius || 0.1, y.radiusRatio = y.radiusRatio || 1.618034, y.mid = 0 < y.mid && y.mid < 1 ? y.mid : 0.618034, $.drawArrow(this, this.geo, y);
                var v = new h.Vector3();
                this.components.push({
                  centroid: v.addVectors(y.start, y.end).multiplyScalar(0.5)
                });
                var w = this.geo.updateGeoGroup(0);
                $.updateBoundingFromPoints(this.boundingSphere, this.components, w.vertexArray, w.vertices);
              }
              static distance_from(y, o) {
                return Math.sqrt(Math.pow(y.x - o.x, 2) + Math.pow(y.y - o.y, 2) + Math.pow(y.z - o.z, 2));
              }
              static inSelectedRegion(y, o, v) {
                for (var w = 0; w < o.length; w++)
                  if ($.distance_from(o[w], y) <= v)
                    return !0;
                return !1;
              }
              /**
               * Create isosurface from volumetric data.
               * @param {VolumeData} data - volumetric input data
               * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification
               * @example //the user can specify a selected region for the isosurface
               $.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue",
                                                       alpha: 0.5,
                                                       smoothness: 10});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red",
                                                       smoothness: 5,
                                                       opacity:0.5,
                                                       wireframe:true,
                                                       clickable:true,
                                                       callback:
                                                       function() {
                                                           this.opacity = 0.0;
                                                           viewer.render( );
                                                       }});
                        viewer.setStyle({}, {stick:{}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(y, o, v, w) {
                var M = o.isoval !== void 0 && typeof o.isoval == "number" ? o.isoval : 0, F = !!o.voxel, m = o.smoothness === void 0 ? 1 : o.smoothness, E = y.size.x, z = y.size.y, O = y.size.z, R = new Int16Array(E * z * O), B = y.data, P, W;
                for (P = 0, W = R.length; P < W; ++P)
                  R[P] = -1;
                var U = new Uint8Array(E * z * O);
                for (P = 0, W = B.length; P < W; ++P) {
                  var V = M >= 0 ? B[P] - M : M - B[P];
                  V > 0 && (U[P] |= $.ISDONE);
                }
                var K = [], q = [];
                g.MarchingCube.march(U, K, q, {
                  fulltable: !0,
                  voxel: F,
                  unitCube: y.unit,
                  origin: y.origin,
                  matrix: y.matrix,
                  nX: E,
                  nY: z,
                  nZ: O
                }), !F && m > 0 && g.MarchingCube.laplacianSmooth(m, K, q);
                var H = [], j = [], Q = [];
                if (o.selectedRegion && o.coords === void 0 && (o.coords = o.selectedRegion), o.coords === void 0 && o.selection !== void 0 && (w ? o.coords = w.selectedAtoms(o.selection) : console.log("addIsosurface needs viewer is selection provided.")), o.coords !== void 0) {
                  var J = o.coords[0].x, Y = o.coords[0].y, ee = o.coords[0].z, fe = o.coords[0].x, me = o.coords[0].y, he = o.coords[0].z;
                  for (let de = 0; de < o.coords.length; de++)
                    o.coords[de].x > J ? J = o.coords[de].x : o.coords[de].x < fe && (fe = o.coords[de].x), o.coords[de].y > Y ? Y = o.coords[de].y : o.coords[de].y < me && (me = o.coords[de].y), o.coords[de].z > ee ? ee = o.coords[de].z : o.coords[de].z < he && (he = o.coords[de].z);
                  var we = 2;
                  o.radius !== void 0 && (we = o.radius), o.selectedOffset !== void 0 && (we = o.selectedOffset), o.seldist !== void 0 && (we = o.seldist), fe -= we, J += we, me -= we, Y += we, he -= we, ee += we;
                  for (let de = 0; de < K.length; de++)
                    K[de].x > fe && K[de].x < J && K[de].y > me && K[de].y < Y && K[de].z > he && K[de].z < ee && $.inSelectedRegion(K[de], o.coords, we) ? (H.push(j.length), j.push(K[de])) : H.push(-1);
                  for (let de = 0; de + 2 < q.length; de += 3)
                    H[q[de]] !== -1 && H[q[de + 1]] !== -1 && H[q[de + 2]] !== -1 && (Q.push(q[de] - (q[de] - H[q[de]])), Q.push(q[de + 1] - (q[de + 1] - H[q[de + 1]])), Q.push(q[de + 2] - (q[de + 2] - H[q[de + 2]])));
                  K = j, q = Q;
                }
                $.drawCustom(this, this.geo, {
                  vertexArr: K,
                  faceArr: q,
                  normalArr: [],
                  clickable: o.clickable,
                  hoverable: o.hoverable
                }), this.updateStyle(o);
                var ye = new h.Vector3(y.origin.x, y.origin.y, y.origin.z), ve = new h.Vector3(y.size.x * y.unit.x, y.size.y * y.unit.y, y.size.z * y.unit.z), ce = new h.Vector3(0, 0, 0), be = ye.clone(), le = ye.clone().add(ve);
                for (let de = 0; de < K.length; de++)
                  ce.add(K[de]), be.max(K[de]), le.min(K[de]);
                ce.divideScalar(K.length);
                var Se = ce.distanceTo(le), ge = ce.distanceTo(be);
                this.boundingSphere.center = ce, this.boundingSphere.radius = Math.max(Se, ge), typeof v == "function" && v();
              }
              /**
               * @deprecated Use addIsosurface instead
               * Creates custom shape from volumetric data
               * @param {string} data - Volumetric input data
               * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)
               * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification
               */
              addVolumetricData(y, o, v) {
                y = new _.VolumeData(y, o), this.addIsosurface(y, v);
              }
              //for internal use, truncate buffers to save memory
              finalize() {
                return $.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.geo;
              }
              /*
               * Initialize webgl objects for rendering
               * @param {$3Dmol.Object3D} group
               *
               */
              globj(y) {
                if (this.renderedShapeObj && (y.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  $.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.wireframe && this.geo.setUpWireframe(), typeof this.color < "u" && $.updateColor(this.geo, this.color), this.shapeObj = new n.Object3D();
                  var o = null;
                  this.side == n.DoubleSide ? o = new n.MeshDoubleLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: n.Coloring.VertexColors
                  }) : o = new n.MeshLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: n.Coloring.VertexColors
                  });
                  var v = new n.Mesh(this.geo, o);
                  if (this.shapeObj.add(v), this.linegeo && this.linegeo.vertices > 0) {
                    var w = new n.LineBasicMaterial({
                      linewidth: this.linewidth,
                      color: this.color
                    }), M = new n.Line(this.linegeo, w, n.LineStyle.LinePieces);
                    this.shapeObj.add(M);
                  }
                  this.renderedShapeObj = this.shapeObj.clone(), y.add(this.renderedShapeObj);
                }
              }
              removegl(y) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), y.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
            $.ISDONE = 2, $.drawCustom = function(L, y, o) {
              var v = o, w = v.vertexArr, M = v.faceArr;
              (w.length === 0 || M.length === 0) && console.warn("Error adding custom shape component: No vertices and/or face indices supplied!");
              var F = o.color;
              typeof F > "u" && (F = L.color), F = b.CC.color(F);
              for (var m = C(v), E = 0, z = m.length; E < z; E++)
                $.addCustomGeo(L, y, m[E], m[E].colorArr ? m[E].colorArr : F, o.clickable);
            };
            function C(L) {
              var y = 64e3;
              if (L.vertexArr.length < y)
                return [L];
              var o = [{ vertexArr: [], normalArr: [], faceArr: [] }];
              L.colorArr && (o.colorArr = []);
              var v = [], w = [], M = 0, F = L.faceArr;
              for (let E = 0, z = F.length; E < z; E += 3) {
                let O = o[M];
                for (let R = 0; R < 3; R++) {
                  var m = F[E + R];
                  v[m] !== M && (v[m] = M, w[m] = O.vertexArr.length, O.vertexArr.push(L.vertexArr[m]), L.normalArr && L.normalArr[m] && O.normalArr.push(L.normalArr[m]), L.colorArr && L.colorArr[m] && O.colorArr.push(L.colorArr[m])), O.faceArr.push(w[m]);
                }
                O.vertexArr.length >= y && (o.push({ vertexArr: [], normalArr: [], faceArr: [] }), L.colorArr && (o.colorArr = []), M++);
              }
              return o;
            }
          }
        ),
        /***/
        "./src/GLViewer.ts": (
          /*!*************************!*\
            !*** ./src/GLViewer.ts ***!
            \*************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CONTEXTS_PER_VIEWPORT: () => (
                /* binding */
                y
              ),
              /* harmony export */
              GLViewer: () => (
                /* binding */
                o
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* binding */
                M
              ),
              /* harmony export */
              createViewer: () => (
                /* binding */
                v
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* binding */
                w
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), h = r(
              /*! ./colors */
              "./src/colors.ts"
            ), b = r(
              /*! ./utilities */
              "./src/utilities.ts"
            ), g = r(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), _ = r(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), A = r(
              /*! ./Label */
              "./src/Label.ts"
            ), x = r(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), k = r(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), $ = r(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), C = r(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), L = r(
              /*! upng-js */
              "./node_modules/upng-js/UPNG.js"
            );
            const y = 16;
            class o {
              getWidth() {
                let m = this.container, E = m.offsetWidth;
                if (E == 0 && m.style.display === "none") {
                  let z = m.style.position, O = m.style.visibility;
                  m.style.display = "block", m.style.visibility = "hidden", m.style.position = "absolute", E = m.offsetWidth, m.style.display = "none", m.style.visibility = O, m.style.position = z;
                }
                return E;
              }
              getHeight() {
                let m = this.container, E = m.offsetHeight;
                if (E == 0 && m.style.display === "none") {
                  let z = m.style.position, O = m.style.visibility;
                  m.style.display = "block", m.style.visibility = "hidden", m.style.position = "absolute", E = m.offsetHeight, m.style.display = "none", m.style.visibility = O, m.style.position = z;
                }
                return E;
              }
              setupRenderer() {
                this.renderer = new n.Renderer({
                  antialias: this.config.antialias,
                  preserveDrawingBuffer: !0,
                  premultipliedAlpha: !1,
                  id: this.config.id,
                  row: this.config.row,
                  col: this.config.col,
                  rows: this.config.rows,
                  cols: this.config.cols,
                  canvas: this.config.canvas,
                  //cannot initialize with zero size - render will start out lost
                  containerWidth: this.WIDTH,
                  containerHeight: this.HEIGHT,
                  ambientOcclusion: this.config.ambientOcclusion,
                  outline: this.config.outline
                }), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.renderer.domElement.style.padding = "0", this.renderer.domElement.style.position = "absolute", this.renderer.domElement.style.top = "0px", this.renderer.domElement.style.left = "0px", this.renderer.domElement.style.zIndex = "0";
              }
              initializeScene() {
                this.scene = new n.Scene(), this.scene.fog = new n.Fog(this.bgColor, 100, 200), this.modelGroup = new n.Object3D(), this.rotationGroup = new n.Object3D(), this.rotationGroup.useQuaternion = !0, this.rotationGroup.quaternion = new s.Quaternion(0, 0, 0, 1), this.rotationGroup.add(this.modelGroup), this.scene.add(this.rotationGroup);
                var m = new n.Light(16777215);
                m.position = new s.Vector3(0.2, 0.2, 1).normalize(), m.intensity = 1, this.scene.add(m);
              }
              _handleLostContext(m) {
                const E = function(z) {
                  const O = z.getBoundingClientRect();
                  return !(O.right < 0 || O.bottom < 0 || O.top > (window.innerHeight || document.documentElement.clientHeight) || O.left > (window.innerWidth || document.documentElement.clientWidth));
                };
                if (E(this.container)) {
                  let z = 0;
                  for (let O of document.getElementsByTagName("canvas"))
                    if (E(O) && O._3dmol_viewer != null && (O._3dmol_viewer.resize(), z += 1, z >= y))
                      break;
                }
              }
              initContainer(m) {
                this.container = m, this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.container.append(this.renderer.domElement), this.glDOM = this.renderer.domElement, this.glDOM._3dmol_viewer = this, this.glDOM.addEventListener("webglcontextlost", this._handleLostContext.bind(this)), this.nomouse || (this.glDOM.addEventListener("mousedown", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchstart", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("wheel", this._handleMouseScroll.bind(this), { passive: !1 }), this.glDOM.addEventListener("mousemove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchmove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("contextmenu", this._handleContextMenu.bind(this), { passive: !1 }));
              }
              decAnim() {
                this.animated--, this.animated < 0 && (this.animated = 0);
              }
              incAnim() {
                this.animated++;
              }
              nextSurfID() {
                var m = 0;
                for (let z in this.surfaces)
                  if (this.surfaces.hasOwnProperty(z)) {
                    var E = parseInt(z);
                    isNaN(E) || E > m && (m = E);
                  }
                return m + 1;
              }
              setSlabAndFog() {
                let m = this.camera.position.z - this.rotationGroup.position.z;
                m < 1 && (m = 1), this.camera.near = m + this.slabNear, this.camera.near < 1 && (this.camera.near = 1), this.camera.far = m + this.slabFar, this.camera.near + 1 > this.camera.far && (this.camera.far = this.camera.near + 1), this.camera.fov = this.fov, this.camera.right = m * Math.tan(Math.PI / 180 * this.fov), this.camera.left = -this.camera.right, this.camera.top = this.camera.right / this.ASPECT, this.camera.bottom = -this.camera.top, this.camera.updateProjectionMatrix(), this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near), this.scene.fog.far = this.camera.far, this.config.disableFog && (this.scene.fog.near = this.scene.fog.far);
              }
              // display scene
              //if nolink is set/true, don't propagate changes to linked viewers
              show(m) {
                if (this.renderer.setViewport(), !!this.scene && (this.setSlabAndFog(), this.renderer.render(this.scene, this.camera), this.viewChangeCallback && this.viewChangeCallback(this._viewer.getView()), !m && this.linkedViewers.length > 0))
                  for (var E = this._viewer.getView(), z = 0; z < this.linkedViewers.length; z++) {
                    var O = this.linkedViewers[z];
                    O.setView(E, !0);
                  }
              }
              //regenerate the list of clickables
              //also updates hoverables
              updateClickables() {
                this.clickables.splice(0, this.clickables.length), this.hoverables.splice(0, this.hoverables.length), this.contextMenuEnabledObjects.splice(0, this.contextMenuEnabledObjects.length);
                for (let m = 0, E = this.models.length; m < E; m++) {
                  let z = this.models[m];
                  if (z) {
                    let O = z.selectedAtoms({
                      clickable: !0
                    }), R = z.selectedAtoms({
                      hoverable: !0
                    }), B = z.selectedAtoms({ contextMenuEnabled: !0 });
                    for (let P = 0; P < R.length; P++)
                      this.hoverables.push(R[P]);
                    for (let P = 0; P < O.length; P++)
                      this.clickables.push(O[P]);
                    for (let P = 0; P < B.length; P++)
                      this.contextMenuEnabledObjects.push(B[P]);
                  }
                }
                for (let m = 0, E = this.shapes.length; m < E; m++) {
                  let z = this.shapes[m];
                  z && z.clickable && this.clickables.push(z), z && z.hoverable && this.hoverables.push(z), z && z.contextMenuEnabled && this.contextMenuEnabledObjects.push(z);
                }
              }
              // Checks for selection intersects on mousedown
              handleClickSelection(m, E, z) {
                let O = this.targetedObjects(m, E, this.clickables);
                if (O.length) {
                  var R = O[0].clickable;
                  R.callback !== void 0 && (typeof R.callback != "function" && (R.callback = (0, b.makeFunction)(R.callback)), typeof R.callback == "function" && (this.mouseButton === 3 && this.contextMenuEnabledObjects.includes(R) && this.userContextMenuHandler || R.callback(R, this._viewer, z, this.container, O)));
                }
              }
              //return offset of container
              canvasOffset() {
                let m = this.glDOM, E = m.getBoundingClientRect(), z = m.ownerDocument, O = z.documentElement, R = z.defaultView;
                return {
                  top: E.top + R.pageYOffset - O.clientTop,
                  left: E.left + R.pageXOffset - O.clientLeft
                };
              }
              //set current_hover to sel (which can be null), calling appropraite callbacks
              setHover(m, E, z) {
                this.current_hover != m && (this.current_hover && (typeof this.current_hover.unhover_callback != "function" && (this.current_hover.unhover_callback = (0, b.makeFunction)(this.current_hover.unhover_callback)), this.current_hover.unhover_callback(this.current_hover, this._viewer, E, this.container, z)), this.current_hover = m, m && m.hover_callback !== void 0 && (typeof m.hover_callback != "function" && (m.hover_callback = (0, b.makeFunction)(m.hover_callback)), typeof m.hover_callback == "function" && m.hover_callback(m, this._viewer, E, this.container, z)));
              }
              //checks for selection intersects on hover
              handleHoverSelection(m, E, z) {
                if (this.hoverables.length == 0)
                  return;
                let O = this.targetedObjects(m, E, this.hoverables);
                if (O.length) {
                  var R = O[0].clickable;
                  this.setHover(R, z, O), this.current_hover = R;
                } else
                  this.setHover(null);
              }
              //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called
              handleHoverContinue(m, E) {
                let z = this.targetedObjects(m, E, this.hoverables);
                (z.length == 0 || z[0] === void 0) && this.setHover(null), z[0] !== void 0 && z[0].clickable !== this.current_hover && this.setHover(null);
              }
              /**
               * Determine if a positioned event is "close enough" to mouseStart to be considered a click.
               * With a mouse, the position should be exact, but allow a slight delta for a touch interface.
               * @param {Event} event
               * @param {{ allowTolerance, tolerance: number }} options
               */
              closeEnoughForClick(m, { allowTolerance: E = m.targetTouches, tolerance: z = 5 } = {}) {
                const O = this.getX(m), R = this.getY(m);
                if (E) {
                  const B = Math.abs(O - this.mouseStartX), P = Math.abs(R - this.mouseStartY);
                  return B <= z && P <= z;
                } else
                  return O === this.mouseStartX && R === this.mouseStartY;
              }
              calcTouchDistance(m) {
                var E = m.targetTouches[0].pageX - m.targetTouches[1].pageX, z = m.targetTouches[0].pageY - m.targetTouches[1].pageY;
                return Math.hypot(E, z);
              }
              //check targetTouches as well
              getX(m) {
                var E = m.pageX;
                return E == null && (E = m.pageX), m.targetTouches && m.targetTouches[0] ? E = m.targetTouches[0].pageX : m.changedTouches && m.changedTouches[0] && (E = m.changedTouches[0].pageX), E;
              }
              getY(m) {
                var E = m.pageY;
                return E == null && (E = m.pageY), m.targetTouches && m.targetTouches[0] ? E = m.targetTouches[0].pageY : m.changedTouches && m.changedTouches[0] && (E = m.changedTouches[0].pageY), E;
              }
              //for grid viewers, return true if point is in this viewer
              isInViewer(m, E) {
                if (this.viewers != null) {
                  var z = this.WIDTH / this.cols, O = this.HEIGHT / this.rows, R = this.canvasOffset(), B = m - R.left, P = E - R.top, W = this.rows - Math.floor(P / O) - 1, U = Math.floor(B / z);
                  if (W != this.row || U != this.col)
                    return !1;
                }
                return !0;
              }
              //if the user has specify zoom limits, readjust to fit within them
              //also, make sure we don't go past CAMERA_Z
              adjustZoomToLimits(m) {
                if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {
                  let E = this.CAMERA_Z - this.config.lowerZoomLimit;
                  m > E && (m = E);
                }
                if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {
                  let E = this.CAMERA_Z - this.config.upperZoomLimit;
                  m < E && (m = E);
                }
                return m > this.CAMERA_Z - 1 && (m = this.CAMERA_Z - 1), m;
              }
              //interpolate between two normalized quaternions (t between 0 and 1)
              //https://en.wikipedia.org/wiki/Slerp
              static slerp(m, E, z) {
                if (z == 1)
                  return E.clone();
                if (z == 0)
                  return m.clone();
                let O = m.x * E.x + m.y * E.y + m.z * E.z + m.w * E.w;
                if (O > 0.9995) {
                  let K = new s.Quaternion(m.x + z * (E.x - m.x), m.y + z * (E.y - m.y), m.z + z * (E.z - m.z), m.w + z * (E.w - m.w));
                  return K.normalize(), K;
                }
                O < 0 && (E = E.clone().multiplyScalar(-1), O = -O), O > 1 ? O = 1 : O < -1 && (O = -1);
                var R = Math.acos(O), B = R * z, P = E.clone();
                P.sub(m.clone().multiplyScalar(O)), P.normalize();
                var W = Math.cos(B), U = Math.sin(B), V = new s.Quaternion(m.x * W + P.x * U, m.y * W + P.y * U, m.z * W + P.z * U, m.w * W + P.w * U);
                return V.normalize(), V;
              }
              /* @param {Object} element HTML element within which to create viewer
               * @param {ViewerSpec} config Object containing optional configuration for the viewer
               */
              constructor(m, E = {}) {
                if (this.nomouse = !1, this.glDOM = null, this.models = [], this.surfaces = {}, this.shapes = [], this.labels = [], this.clickables = [], this.hoverables = [], this.contextMenuEnabledObjects = [], this.current_hover = null, this.hoverDuration = 500, this.longTouchDuration = 1e3, this.viewer_frame = 0, this.viewChangeCallback = null, this.stateChangeCallback = null, this.NEAR = 1, this.FAR = 800, this.CAMERA_Z = 150, this.fov = 20, this.linkedViewers = [], this.renderer = null, this.control_all = !1, this.scene = null, this.rotationGroup = null, this.modelGroup = null, this.fogStart = 0.4, this.slabNear = -50, this.slabFar = 50, this.cq = new s.Quaternion(0, 0, 0, 1), this.dq = new s.Quaternion(0, 0, 0, 1), this.animated = 0, this.animationTimers = /* @__PURE__ */ new Set(), this.isDragging = !1, this.mouseStartX = 0, this.mouseStartY = 0, this.touchDistanceStart = 0, this.touchHold = !1, this.currentModelPos = 0, this.cz = 0, this.cslabNear = 0, this.cslabFar = 0, this.userContextMenuHandler = null, this.config = E, this.callback = this.config.callback, this.defaultcolors = this.config.defaultcolors, this.defaultcolors || (this.defaultcolors = h.elementColors.defaultColors), this.nomouse = !!this.config.nomouse, this.bgColor = 0, this.config.backgroundColor = this.config.backgroundColor || "#ffffff", typeof this.config.backgroundColor < "u" && (this.bgColor = h.CC.color(this.config.backgroundColor).getHex()), this.config.backgroundAlpha = this.config.backgroundAlpha == null ? 1 : this.config.backgroundAlpha, this.camerax = 0, typeof this.config.camerax < "u" && (this.camerax = typeof this.config.camerax == "string" ? parseFloat(this.config.camerax) : this.config.camerax), this._viewer = this, this.container = m, this.config.hoverDuration != null && (this.hoverDuration = this.config.hoverDuration), this.config.antialias === void 0 && (this.config.antialias = !0), this.config.cartoonQuality === void 0 && (this.config.cartoonQuality = 10), this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.setupRenderer(), this.row = this.config.row == null ? 0 : this.config.row, this.col = this.config.col == null ? 0 : this.config.col, this.cols = this.config.cols, this.rows = this.config.rows, this.viewers = this.config.viewers, this.control_all = this.config.control_all, this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.camera = new n.Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic), this.camera.position = new s.Vector3(this.camerax, 0, this.CAMERA_Z), this.lookingAt = new s.Vector3(), this.camera.lookAt(this.lookingAt), this.raycaster = new n.Raycaster(new s.Vector3(0, 0, 0), new s.Vector3(0, 0, 0)), this.projector = new n.Projector(), this.initializeScene(), this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha), this.scene.fog.color = h.CC.color(this.bgColor), document.body.addEventListener("mouseup", this._handleMouseUp.bind(this)), document.body.addEventListener("touchend", this._handleMouseUp.bind(this)), this.initContainer(this.container), this.config.style && this.setViewStyle(this.config), window.addEventListener("resize", this.resize.bind(this)), typeof window.ResizeObserver < "u" && (this.divwatcher = new window.ResizeObserver(this.resize.bind(this)), this.divwatcher.observe(this.container)), typeof window.IntersectionObserver < "u") {
                  let z = (O, R) => {
                    O.forEach((B) => {
                      B.isIntersecting && this.resize();
                    });
                  };
                  this.intwatcher = new window.IntersectionObserver(z), this.intwatcher.observe(this.container);
                }
                try {
                  typeof this.callback == "function" && this.callback(this);
                } catch (z) {
                  console.log("error with glviewer callback: " + z);
                }
              }
              /**
              * Return a list of objects that intersect that at the specified viewer position.
              *
              * @param x - x position in screen coordinates
              * @param y - y position in screen coordinates
              * @param {Object[]} - list of objects or selection object specifying what object to check for targeting
              */
              targetedObjects(m, E, z) {
                var O = {
                  x: m,
                  y: E,
                  z: -1
                };
                return Array.isArray(z) || (z = this.selectedAtoms(z)), z.length == 0 ? [] : (this.raycaster.setFromCamera(O, this.camera), this.raycaster.intersectObjects(this.modelGroup, z));
              }
              /** Convert model coordinates to screen coordinates.
               * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)
               * @return {object | list} - and object or list of {x: screenX, y: screenY}
               */
              modelToScreen(m) {
                let E = !1;
                Array.isArray(m) || (m = [m], E = !0);
                let z = this.renderer.getXRatio(), O = this.renderer.getYRatio(), R = this.col, B = this.row, P = R * (this.WIDTH / z), W = (O - B - 1) * (this.HEIGHT / O), U = [], V = this.canvasOffset();
                return m.forEach((K) => {
                  let q = new s.Vector3(K.x, K.y, K.z);
                  q.applyMatrix4(this.modelGroup.matrixWorld), this.projector.projectVector(q, this.camera);
                  let H = this.WIDTH / z * (q.x + 1) / 2 + V.left + P, j = -(this.HEIGHT / O) * (q.y - 1) / 2 + V.top + W;
                  U.push({ x: H, y: j });
                }), E && (U = U[0]), U;
              }
              /**
               * For a given screen (x,y) displacement return model displacement
               * @param{x} x displacement in screen coordinates
               * @param{y} y displacement in screen corodinates
               * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis
              */
              screenOffsetToModel(m, E, z) {
                var O = m / this.WIDTH, R = E / this.HEIGHT, B = z === void 0 ? this.rotationGroup.position.z : z, P = this.rotationGroup.quaternion, W = new s.Vector3(0, 0, B);
                return this.projector.projectVector(W, this.camera), W.x += O * 2, W.y -= R * 2, this.projector.unprojectVector(W, this.camera), W.z = 0, W.applyQuaternion(P), W;
              }
              /**
               * Distance from screen coordinate to model coordinate assuming screen point
               * is projected to the same depth as model coordinate
               * @param{screen} xy screen coordinate
               * @param{model} xyz model coordinate
              */
              screenToModelDistance(m, E) {
                let z = this.canvasOffset(), O = new s.Vector3(E.x, E.y, E.z);
                O.applyMatrix4(this.modelGroup.matrixWorld);
                let R = O.clone();
                this.projector.projectVector(O, this.camera);
                let B = new s.Vector3((m.x - z.left) * 2 / this.WIDTH - 1, (m.y - z.top) * 2 / -this.HEIGHT + 1, O.z);
                return this.projector.unprojectVector(B, this.camera), B.distanceTo(R);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setViewChangeCallback(m) {
                (typeof m == "function" || m == null) && (this.viewChangeCallback = m);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setStateChangeCallback(m) {
                (typeof m == "function" || m == null) && (this.stateChangeCallback = m);
              }
              /**
               * Return configuration of viewer
               */
              getConfig() {
                return this.config;
              }
              /**
               * Set the configuration object.  Note that some settings may only
               * have an effect at viewer creation time.
               */
              setConfig(m) {
                this.config = m, m.ambientOcclusion && this.renderer.enableAmbientOcclusion(m.ambientOcclusion);
              }
              /**
               * Return object representing internal state of
               * the viewer appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                var m = { models: [], surfaces: [], shapes: [], labels: [] };
                for (let E = 0; E < this.models.length; E++)
                  this.models[E] && (m.models[E] = this.models[E].getInternalState());
                return m;
              }
              /**
               * Overwrite internal state of the viewer with passed  object
               * which should come from getInternalState.
               *
              */
              setInternalState(m) {
                this.clear();
                var E = m.models;
                for (let z = 0; z < E.length; z++)
                  E[z] && (this.models[z] = new _.GLModel(z), this.models[z].setInternalState(E[z]));
                this.render();
              }
              /**
               * Set lower and upper limit stops for zoom.
               *
               * @param {lower} - limit on zoom in (positive number).  Default 0.
               * @param {upper} - limit on zoom out (positive number).  Default infinite.
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(moldata) {
                      var m = viewer.addModel(moldata);
                      viewer.setStyle({stick:{colorscheme:"Jmol"}});
                      viewer.setZoomLimits(100,200);
                      viewer.zoomTo();
                      viewer.zoom(10); //will not zoom all the way
                      viewer.render();
                  });
              */
              setZoomLimits(m, E) {
                typeof m < "u" && (this.config.lowerZoomLimit = m), E && (this.config.upperZoomLimit = E), this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
              }
              /**
               * Set camera parameters (distance to the origin and field of view)
               *
               * @param {parameters} - new camera parameters, with possible fields
               *                       being fov for the field of view, z for the
               *                       distance to the origin, and orthographic (boolean)
               *                       for kind of projection (default false).
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(data) {
                      var m = viewer.addModel(data);
                      viewer.setStyle({stick:{}});
                      viewer.zoomTo();
                      viewer.setCameraParameters({ fov: 10 , z: 300 });
                      viewer.render();
                  });
              */
              setCameraParameters(m) {
                m.fov !== void 0 && (this.fov = m.fov, this.camera.fov = this.fov), m.z !== void 0 && (this.CAMERA_Z = m.z, this.camera.z = this.CAMERA_Z), m.orthographic !== void 0 && (this.camera.ortho = m.orthographic);
              }
              _handleMouseDown(m) {
                if (m.preventDefault(), !this.scene)
                  return;
                var E = this.getX(m), z = this.getY(m);
                if (E === void 0)
                  return;
                this.isDragging = !0, this.mouseButton = m.which, this.mouseStartX = E, this.mouseStartY = z, this.touchHold = !0, this.touchDistanceStart = 0, m.targetTouches && m.targetTouches.length == 2 && (this.touchDistanceStart = this.calcTouchDistance(m)), this.cq = this.rotationGroup.quaternion.clone(), this.cz = this.rotationGroup.position.z, this.currentModelPos = this.modelGroup.position.clone(), this.cslabNear = this.slabNear, this.cslabFar = this.slabFar;
                let O = this;
                m.targetTouches && m.targetTouches.length === 1 && (this.longTouchTimeout = setTimeout(function() {
                  if (O.touchHold == !0) {
                    O.glDOM = O.renderer.domElement;
                    const R = m.targetTouches[0], B = new PointerEvent("contextmenu", Object.assign(Object.assign({}, m), { pageX: R.pageX, pageY: R.pageY, screenX: R.screenX, screenY: R.screenY, clientX: R.clientX, clientY: R.clientY }));
                    O.glDOM.dispatchEvent(B);
                  }
                }, this.longTouchDuration));
              }
              _handleMouseUp(m) {
                if (this.touchHold = !1, this.isDragging && this.scene) {
                  var E = this.getX(m), z = this.getY(m);
                  if (this.closeEnoughForClick(m) && this.isInViewer(E, z)) {
                    let O = this.mouseXY(E, z);
                    this.handleClickSelection(O.x, O.y, m);
                  }
                }
                this.isDragging = !1;
              }
              _handleMouseScroll(m) {
                if (m.preventDefault(), !!this.scene) {
                  var E = this.getX(m), z = this.getY(m);
                  if (E !== void 0 && !(!this.control_all && !this.isInViewer(E, z))) {
                    var O = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, R = 1;
                    if (m.ctrlKey && (R = -1), m.detail)
                      this.rotationGroup.position.z += R * O * m.detail / 10;
                    else if (m.wheelDelta) {
                      let B = m.wheelDelta * 600 / (m.wheelDelta + 600);
                      this.rotationGroup.position.z -= R * O * B / 400;
                    }
                    this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
                  }
                }
              }
              /**
               * Return image URI of viewer contents (base64 encoded).     *
               */
              pngURI() {
                return this.getCanvas().toDataURL("image/png");
              }
              /**
               * Return a promise that resolves to an animated PNG image URI of
               viewer contents (base64 encoded) for nframes of viewer changes.
               * @return {Promise}
               */
              apngURI(m) {
                let E = this;
                return m = m || 1, new Promise(function(z) {
                  let O = 0, R = E.viewChangeCallback, B = [], P = [], W = Date.now();
                  E.viewChangeCallback = function() {
                    P.push(Date.now() - W), W = Date.now(), B.push(new Promise((U) => {
                      E.getCanvas().toBlob(function(V) {
                        V.arrayBuffer().then(U);
                      }, "image/png");
                    })), O += 1, O == m && (E.viewChangeCallback = R, Promise.all(B).then((U) => {
                      let V = [];
                      for (let J = 0; J < U.length; J++) {
                        let Y = (0, L.decode)(U[J]);
                        V.push((0, L.toRGBA8)(Y)[0]);
                      }
                      let K = E.getCanvas().width, q = E.getCanvas().height, H = (0, L.encode)(V, K, q, 0, P), j = new Blob([H], { type: "image/png" }), Q = new FileReader();
                      Q.onload = function(J) {
                        z(J.target.result);
                      }, Q.readAsDataURL(j);
                    }));
                  };
                });
              }
              /**
               * Return underlying canvas element.
               */
              getCanvas() {
                return this.glDOM;
              }
              /**
               * Return renderer element.
               */
              getRenderer() {
                return this.renderer;
              }
              /**
                   * Set the duration of the hover delay
                   *
                   * @param {number}
                   *            [hoverDuration] - an optional parameter that denotes
                   *            the duration of the hover delay (in milliseconds) before the hover action is called
                   *
               */
              setHoverDuration(m) {
                this.hoverDuration = m;
              }
              mouseXY(m, E) {
                let z = this.canvasOffset(), O = this.renderer.getXRatio(), R = this.renderer.getYRatio(), B = this.col, P = this.row, W = B * (this.WIDTH / O), U = (R - P - 1) * (this.HEIGHT / R), V = (m - z.left - W) / (this.WIDTH / O) * 2 - 1, K = -((E - z.top - U) / (this.HEIGHT / R)) * 2 + 1;
                return { x: V, y: K };
              }
              _handleMouseMove(m) {
                clearTimeout(this.hoverTimeout), m.preventDefault();
                let E = this.getX(m), z = this.getY(m);
                if (E === void 0)
                  return;
                let O = this.renderer.getXRatio(), R = this.renderer.getYRatio(), B = this.mouseXY(E, z), P = this;
                this.current_hover !== null && this.handleHoverContinue(B.x, B.y);
                var W = 0;
                if (!(!this.control_all && !this.isInViewer(E, z)) && this.scene && (this.hoverables.length > 0 && (this.hoverTimeout = setTimeout(function() {
                  P.handleHoverSelection(B.x, B.y, m);
                }, this.hoverDuration)), !!this.isDragging)) {
                  m.targetTouches && (m.targetTouches.length > 1 || m.targetTouches.length === 1 && !this.closeEnoughForClick(m)) && clearTimeout(this.longTouchTimeout);
                  var U = (E - this.mouseStartX) / this.WIDTH, V = (z - this.mouseStartY) / this.HEIGHT;
                  if (this.touchDistanceStart != 0 && m.targetTouches && m.targetTouches.length == 2) {
                    var K = this.calcTouchDistance(m);
                    W = 2, V = (K - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);
                  } else m.targetTouches && m.targetTouches.length == 3 && (W = 1);
                  U *= O, V *= R;
                  var q = Math.hypot(U, V), H;
                  if (W == 3 || this.mouseButton == 3 && m.ctrlKey)
                    this.slabNear = this.cslabNear + U * 100, this.slabFar = this.cslabFar - V * 100;
                  else if (W == 2 || this.mouseButton == 3 || m.shiftKey)
                    H = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, H < 80 && (H = 80), this.rotationGroup.position.z = this.cz + V * H, this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  else if (W == 1 || this.mouseButton == 2 || m.ctrlKey) {
                    var j = this.screenOffsetToModel(O * (E - this.mouseStartX), R * (z - this.mouseStartY));
                    this.modelGroup.position.addVectors(this.currentModelPos, j);
                  } else if ((W === 0 || this.mouseButton == 1) && q !== 0) {
                    var Q = Math.sin(q * Math.PI) / q;
                    this.dq.x = Math.cos(q * Math.PI), this.dq.y = 0, this.dq.z = Q * U, this.dq.w = -Q * V, this.rotationGroup.quaternion.set(1, 0, 0, 0), this.rotationGroup.quaternion.multiply(this.dq), this.rotationGroup.quaternion.multiply(this.cq);
                  }
                  this.show();
                }
              }
              _handleContextMenu(m) {
                if (m.preventDefault(), this.closeEnoughForClick(m)) {
                  var O = this.mouseStartX, R = this.mouseStartY, z = this.canvasOffset();
                  let B = this.mouseXY(O, R), P = B.x, W = B.y, U = this.targetedObjects(P, W, this.contextMenuEnabledObjects);
                  var E = null;
                  U.length && (E = U[0].clickable);
                  var z = this.canvasOffset(), O = this.mouseStartX - z.left, R = this.mouseStartY - z.top;
                  this.userContextMenuHandler && (this.userContextMenuHandler(E, O, R, U, m), this.isDragging = !1);
                }
              }
              /**
              	     * Change the viewer's container element
              	     * Also useful if the original container element was removed from the DOM.
              	     *
              	     * @param {Object | string} element
              	     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.
              
              	     */
              setContainer(m) {
                let E = (0, b.getElement)(m) || this.container;
                return this.initContainer(E), this;
              }
              /**
              	     * Set the background color (default white)
              	     *
              	     * @param {number}
              	     *            hex Hexcode specified background color, or standard color spec
              	     * @param {number}
              	     *            a Alpha level (default 1.0)
              	     *
              	     * @example
              	     *
              	     * viewer.setBackgroundColor("green",0.5);
              
              
              	     *
              	     */
              setBackgroundColor(m, E) {
                (typeof E > "u" || E < 0 || E > 1) && (E = 1);
                var z = h.CC.color(m);
                return this.scene.fog.color = z, this.bgColor = z.getHex(), this.renderer.setClearColorHex(z.getHex(), E), this.show(), this;
              }
              /**
              	     * Set view projection scheme.  Either orthographic or perspective.
              	     * Default is perspective.  Orthographic can also be enabled on viewer creation
              	     * by setting orthographic to true in the config object.
              	     *
              	     *
              	     * @example
              	     viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              	              });
              	              viewer.zoomTo();
              
              	              viewer.setProjection("orthographic");
              	              viewer.render(callback);
              	          });
              	     *
              	     */
              setProjection(m) {
                this.camera.ortho = m === "orthographic", this.setSlabAndFog();
              }
              /**
               * Set global view styles.
               *
               * @example
               *   viewer.setViewStyle({style:"outline"});
                    $3Dmol.get('data/1fas.pqr', function(data){
                        viewer.addModel(data, "pqr");
                        $3Dmol.get("data/1fas.cube",function(volumedata){
                            viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                        });
                        viewer.zoomTo();
                        viewer.render(callback);
                    });
               *
               */
              setViewStyle(m) {
                if (m = m || {}, m.style = m.style || "", m.style.includes("outline") ? this.renderer.enableOutline(m) : this.renderer.disableOutline(), m.style.includes("ambientOcclusion")) {
                  var E = {};
                  m.strength && (E.strength = m.strength), m.radius && (E.radius = m.radius), this.renderer.enableAmbientOcclusion(E);
                } else
                  this.renderer.disableAmbientOcclusion();
                return this;
              }
              updateSize() {
                this.renderer.setSize(this.WIDTH, this.HEIGHT), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.camera.aspect = this.ASPECT, this.camera.updateProjectionMatrix();
              }
              /**
               * Set viewer width independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} w Width in pixels
               */
              setWidth(m) {
                return this.WIDTH = m || this.WIDTH, this.updateSize(), this;
              }
              /**
               * Set viewer height independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} h Height in pixels
               */
              setHeight(m) {
                return this.HEIGHT = m || this.HEIGHT, this.updateSize(), this;
              }
              /**
               * Resize viewer according to containing HTML element's dimensions
               *
               */
              resize() {
                this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight();
                let m = !1;
                if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0) {
                  let E = !1, z = this.container.querySelector("canvas");
                  z && z != this.renderer.getCanvas() ? this.config.canvas = z : (z.remove(), this.config && this.config.canvas != null && (delete this.config.canvas, E = !0)), this.setupRenderer(), this.initContainer(this.container), this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha), m = !0, E && (this.config.canvas = this.renderer.getCanvas());
                }
                if (this.WIDTH == 0 || this.HEIGHT == 0 ? this.animated && this._viewer.pauseAnimate() : this.animated && this._viewer.resumeAnimate(), this.updateSize(), m) {
                  let E = this.renderer.supportedExtensions();
                  if (E.regen = !0, this.viewers)
                    for (let z = 0, O = this.viewers.length; z < O; z++)
                      for (let R = 0, B = this.viewers[z].length; R < B; R++)
                        this.viewers[z][R].render(null, E);
                  this._viewer.render(null, E);
                } else
                  this.show();
                return this;
              }
              /**
               * Return specified model
               *
               * @param {number}
               *            [id=last model id] - Retrieve model with specified id
               * @default Returns last model added to viewer or null if there are no models
               * @return {GLModel}
               *
               * @example // Retrieve reference to first GLModel added var m =
               *    $3Dmol.download("pdb:1UBQ",viewer,{},function(m1){
                        $3Dmol.download("pdb:1UBI", viewer,{}, function(m2) {
                          viewer.zoomTo();
                          m1.setStyle({cartoon: {color:'green'}});
                          //could use m2 here as well
                          viewer.getModel().setStyle({cartoon: {color:'blue'}});
                          viewer.render();
                      })
                    });
               */
              getModel(m) {
                return m === void 0 ? this.models.length == 0 ? null : this.models[this.models.length - 1] : m instanceof _.GLModel ? m : m in this.models ? this.models[m] : this.models.length == 0 ? null : this.models[this.models.length - 1];
              }
              /**
               * Continuously rotate a scene around the specified axis.
               *
               * Call `spin(false)` to stop spinning.
               *
               * @param  {string|boolean|Array} axis
               *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
               *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
               * @param  {number} speed
               *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative
               *             value reverses the direction of the spin.
               *
               */
              spin(m, E = 1) {
                if (clearInterval(this.spinInterval), typeof m > "u" && (m = "y"), typeof m == "boolean")
                  if (m)
                    m = "y";
                  else
                    return;
                Array.isArray(m) && (m = { x: m[0], y: m[1], z: m[2] });
                var z = this;
                this.spinInterval = setInterval(function() {
                  !z.getCanvas().isConnected && z.renderer.isLost() && clearInterval(z.spinInterval), z.rotate(1 * E, m);
                }, 25);
              }
              //animate motion between current position and passed position
              // can set some parameters to null
              //if fixed is true will enforce the request animation, otherwise
              //does relative updates
              //positions objects have modelggroup position, rotation group position.z,
              //and rotationgroup quaternion
              //return array includes final position, but not current
              //the returned array includes an animate method
              animateMotion(m, E, z, O, R, B) {
                var P = 20, W = Math.ceil(m / P);
                W < 1 && (W = 1), this.incAnim();
                var U = {
                  mpos: this.modelGroup.position.clone(),
                  rz: this.rotationGroup.position.z,
                  rot: this.rotationGroup.quaternion.clone(),
                  cam: this.lookingAt.clone()
                };
                if (E) {
                  let q = new Array(W);
                  for (let J = 0; J < W; J++) {
                    let Y = (J + 1) / W, ee = { mpos: U.mpos, rz: U.rz, rot: U.rot };
                    ee.mpos = z.clone().sub(U.mpos).multiplyScalar(Y).add(U.mpos), ee.rz = U.rz + Y * (O - U.rz), ee.rot = o.slerp(U.rot, R, Y), ee.cam = B.clone().sub(U.cam).multiplyScalar(Y).add(U.cam), q[J] = ee;
                  }
                  let H = 0, j = this, Q = function() {
                    var J = q[H];
                    H += 1, j.modelGroup.position = J.mpos, j.rotationGroup.position.z = J.rz, j.rotationGroup.quaternion = J.rot, j.camera.lookAt(J.cam), H < q.length ? setTimeout(Q, P) : j.decAnim(), j.show();
                  };
                  setTimeout(Q, P);
                } else {
                  var V = {};
                  let q = 1 / W;
                  if (z && (V.mpos = z.clone().sub(U.mpos).multiplyScalar(q)), typeof O < "u" && O != null && (V.rz = q * (O - U.rz)), R) {
                    var K = o.slerp(U.rot, R, q);
                    V.rot = U.rot.clone().inverse().multiply(K);
                  }
                  B && (V.cam = B.clone().sub(U.cam).multiplyScalar(q));
                  let H = 0, j = this, Q = function() {
                    H += 1, V.mpos && j.modelGroup.position.add(V.mpos), V.rz && (j.rotationGroup.position.z += V.rz), V.rot && j.rotationGroup.quaternion.multiply(V.rot), V.cam && (j.lookingAt.add(V.cam), j.camera.lookAt(j.lookingAt)), H < W ? setTimeout(Q, P) : j.decAnim(), j.show();
                  };
                  setTimeout(Q, P);
                }
              }
              /**
              	     * Rotate scene by angle degrees around axis
              	     *
              	     * @param {number}
              	     *            [angle] - Angle, in degrees, to rotate by.
              	     * @param {string}
              	     *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
              	     *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
              	     *            Axis can also be specified as a vector.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of the rotation animation. Default 0 (no animation)
              	     * @param {boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {
              	    viewer.setStyle({stick:{}});
              	    viewer.zoomTo();
              	    viewer.rotate(90,'y',1);
              	    viewer.render(callback);
              	    });
              
              	     *
              	     */
              rotate(m, E = "y", z = 0, O = !1) {
                if (E == "x" ? E = { x: 1, y: 0, z: 0 } : E == "y" ? E = { x: 0, y: 1, z: 0 } : E == "z" && (E = { x: 0, y: 0, z: 1 }), E == "vx" ? E = { vx: 1, vy: 0, vz: 0 } : E == "vy" ? E = { vx: 0, vy: 1, vz: 0 } : E == "vz" && (E = { vx: 0, vy: 0, vz: 1 }), typeof E.vx < "u") {
                  var R = new s.Vector3(E.vx, E.vy, E.vz);
                  R.applyQuaternion(this.rotationGroup.quaternion), E = { x: R.x, y: R.y, z: R.z };
                }
                var B = function(V) {
                  var K = Math.sin(V / 2), q = Math.cos(V / 2), H = 0, j = 0, Q = 0;
                  return H = E.x * K, j = E.y * K, Q = E.z * K, new s.Quaternion(H, j, Q, q).normalize();
                }, P = Math.PI * m / 180, W = B(P);
                if (z) {
                  var U = new s.Quaternion().copy(this.rotationGroup.quaternion).multiply(W);
                  this.animateMotion(z, O, this.modelGroup.position, this.rotationGroup.position.z, U, this.lookingAt);
                } else
                  this.rotationGroup.quaternion.multiply(W), this.show();
                return this;
              }
              surfacesFinished() {
                for (var m in this.surfaces)
                  if (!this.surfaces[m][0].done)
                    return !1;
                return !0;
              }
              /** Returns an array representing the current viewpoint.
               * Translation, zoom, and rotation quaternion.
               * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]
               *  */
              getView() {
                if (!this.modelGroup)
                  return [0, 0, 0, 0, 0, 0, 0, 1];
                var m = this.modelGroup.position, E = this.rotationGroup.quaternion;
                return [
                  m.x,
                  m.y,
                  m.z,
                  this.rotationGroup.position.z,
                  E.x,
                  E.y,
                  E.z,
                  E.w
                ];
              }
              /** Sets the view to the specified translation, zoom, and rotation.
               *
               * @param {Array.<number>} arg Array formatted identically to the return value of getView */
              setView(m, E) {
                return m === void 0 || !(m instanceof Array || m.length !== 8) ? this : !this.modelGroup || !this.rotationGroup ? this : (this.modelGroup.position.x = m[0], this.modelGroup.position.y = m[1], this.modelGroup.position.z = m[2], this.rotationGroup.position.z = m[3], this.rotationGroup.quaternion.x = m[4], this.rotationGroup.quaternion.y = m[5], this.rotationGroup.quaternion.z = m[6], this.rotationGroup.quaternion.w = m[7], typeof m[8] < "u" && (this.rotationGroup.position.x = m[8], this.rotationGroup.position.y = m[9]), this.show(E), this);
              }
              // apply styles, models, etc in viewer
              /**
               * Render current state of viewer, after
               * adding/removing models, applying styles, etc.
               *
               */
              render(m, E) {
                this.renderer.setViewport(), this.updateClickables();
                var z = this.getView();
                this.stateChangeCallback && this.stateChangeCallback(this.getInternalState());
                var O, R;
                for (E || (E = this.renderer.supportedExtensions()), O = 0; O < this.models.length; O++)
                  this.models[O] && this.models[O].globj(this.modelGroup, E);
                for (O = 0; O < this.shapes.length; O++)
                  this.shapes[O] && (typeof this.shapes[O].frame > "u" || this.viewer_frame < 0 || this.shapes[O].frame < 0 || this.shapes[O].frame == this.viewer_frame ? this.shapes[O].globj(this.modelGroup, E) : this.shapes[O].removegl(this.modelGroup));
                for (O = 0; O < this.labels.length; O++)
                  E.regen && (this.labels[O].dispose(), this.modelGroup.remove(this.labels[O].sprite), this.labels[O].setContext(), this.modelGroup.add(this.labels[O].sprite)), this.labels[O] && typeof this.labels[O].frame < "u" && this.labels[O].frame >= 0 && (this.modelGroup.remove(this.labels[O].sprite), (this.viewer_frame < 0 || this.labels[O].frame == this.viewer_frame) && this.modelGroup.add(this.labels[O].sprite));
                for (O in this.surfaces)
                  if (this.surfaces.hasOwnProperty(O)) {
                    var B = this.surfaces[O];
                    for (R = 0; R < B.length; R++)
                      if (B.hasOwnProperty(R)) {
                        var P = B[R].geo;
                        if (!B[R].finished || E.regen) {
                          P.verticesNeedUpdate = !0, P.elementsNeedUpdate = !0, P.normalsNeedUpdate = !0, P.colorsNeedUpdate = !0, P.buffersNeedUpdate = !0, B[R].mat.needsUpdate = !0, B[R].done && (B[R].finished = !0), B[R].lastGL && this.modelGroup.remove(B[R].lastGL);
                          var W = null;
                          if (B[R].mat instanceof n.LineBasicMaterial ? W = new n.Line(P, B[R].mat) : W = new n.Mesh(P, B[R].mat), B[R].mat.transparent && B[R].mat.opacity == 0 ? W.visible = !1 : W.visible = !0, B[R].symmetries.length > 1 || B[R].symmetries.length == 1 && !B[R].symmetries[R].isIdentity()) {
                            var U, V = new n.Object3D();
                            for (U = 0; U < B[R].symmetries.length; U++) {
                              var K = W.clone();
                              K.matrix = B[R].symmetries[U], K.matrixAutoUpdate = !1, V.add(K);
                            }
                            B[R].lastGL = V, this.modelGroup.add(V);
                          } else
                            B[R].lastGL = W, this.modelGroup.add(W);
                        }
                      }
                  }
                return this.setView(z), typeof m == "function" && m(this), this;
              }
              /* @param {AtomSelectionSpec|any} sel
               * @return list of models specified by sel
               */
              getModelList(m) {
                let E = [];
                if (typeof m > "u" || typeof m.model > "u")
                  for (let O = 0; O < this.models.length; O++)
                    this.models[O] && E.push(this.models[O]);
                else {
                  let O = m.model;
                  Array.isArray(O) || (O = [O]);
                  for (let R = 0; R < O.length; R++)
                    if (typeof O[R] == "number") {
                      var z = O[R];
                      z < 0 && (z += this.models.length), E.push(this.models[z]);
                    } else
                      E.push(O[R]);
                }
                return E;
              }
              /**
               *
               * @param {AtomSelectionSpec}
               *            sel
               * @return {AtomSpec[]}
               */
              getAtomsFromSel(m) {
                var E = [];
                typeof m > "u" && (m = {});
                var z = this.getModelList(m);
                for (let O = 0; O < z.length; O++)
                  E = E.concat(z[O].selectedAtoms(m));
                return E;
              }
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSelectionSpec}
               *            sel
               * @return {boolean}
               */
              atomIsSelected(m, E) {
                typeof E > "u" && (E = {});
                for (var z = this.getModelList(E), O = 0; O < z.length; O++)
                  if (z[O].atomIsSelected(m, E))
                    return !0;
                return !1;
              }
              /** return list of atoms selected by sel
               *
               * @param {AtomSelectionSpec} sel
               * @return {AtomSpec[]}
               */
              selectedAtoms(m) {
                return this.getAtomsFromSel(m);
              }
              /**
              * Returns valid values for the specified attribute in the given selection
              * @param {string} attribute
              * @param {AtomSelectionSpec} sel
              * @return {Array.<Object>}
              *
              */
              getUniqueValues(m, E) {
                typeof E > "u" && (E = {});
                var z = this.getAtomsFromSel(E), O = {};
                for (var R in z)
                  if (z[R].hasOwnProperty(m)) {
                    var B = z[R][m];
                    O[B] = !0;
                  }
                return Object.keys(O);
              }
              /**
               * Return pdb output of selected atoms (if atoms from pdb input)
               *
               * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer
               * @return {string} PDB string of selected atoms
               */
              pdbData(m) {
                for (var E = this.getAtomsFromSel(m), z = "", O = 0, R = E.length; O < R; ++O)
                  z += E[O].pdbline + `
`;
                return z;
              }
              /**
              	     * Zoom current view by a constant factor
              	     *
              	     * @param {number}
              	     *            [factor] - Magnification factor. Values greater than 1
              	     *            will zoom in, less than one will zoom out. Default 2.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation
              	     * @example
              	    $3Dmol.get('data/4csv.pdb', function(data) {
              	    viewer.addModel(data,'pdb');
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo()
              	    viewer.zoom(2,1000);
              	    viewer.render();
              	    });
              
              	         */
              zoom(m = 2, E = 0, z = !1) {
                var O = (this.CAMERA_Z - this.rotationGroup.position.z) / m, R = this.CAMERA_Z - O;
                return E > 0 ? this.animateMotion(E, z, this.modelGroup.position, this.adjustZoomToLimits(R), this.rotationGroup.quaternion, this.lookingAt) : (this.rotationGroup.position.z = this.adjustZoomToLimits(R), this.show()), this;
              }
              /**
               * Translate current view by x,y screen coordinates
               * This pans the camera rather than translating the model.
               *
               * @param {number} x Relative change in view coordinates of camera
               * @param {number} y Relative change in view coordinates of camera
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translate(200,50);
              viewer.rotate(90,'z');
              viewer.render(callback);
              });
               */
              translate(m, E, z = 0, O = !1) {
                var R = m / this.WIDTH, B = E / this.HEIGHT, P = new s.Vector3(0, 0, -this.CAMERA_Z);
                this.projector.projectVector(P, this.camera), P.x -= R, P.y -= B, this.projector.unprojectVector(P, this.camera), P.z = 0;
                var W = this.lookingAt.clone().add(P);
                return z > 0 ? this.animateMotion(z, O, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, W) : (this.lookingAt = W, this.camera.lookAt(this.lookingAt), this.show()), this;
              }
              /**
               * Translate current models by x,y screen coordinates
               * This translates the models relative to the current view. It does
               * not change the center of rotation.
               *
               * @param {number} x Relative change in x screen coordinate
               * @param {number} y Relative change in y screen coordinate
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translateScene(200,50);
              viewer.rotate(90,'z'); // will no longer be around model center
              viewer.render(callback);
              });
               */
              translateScene(m, E, z = 0, O = !1) {
                var R = this.screenOffsetToModel(m, E), B = this.modelGroup.position.clone().add(R);
                return z > 0 ? this.animateMotion(z, O, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = B, this.show()), this;
              }
              /**
               * Adjust slab to fully enclose selection (default everything).
               *
               * @param {AtomSelectionSpec} sel
               *            Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               */
              fitSlab(m) {
                m = m || {};
                var E = this.getAtomsFromSel(m), z = (0, b.getExtent)(E), O = z[1][0] - z[0][0], R = z[1][1] - z[0][1], B = z[1][2] - z[0][2], P = Math.hypot(O, R, B);
                return P < 5 && (P = 5), this.slabNear = -P / 1.9, this.slabFar = P / 2, this;
              }
              /**
               * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).
               *
               * @param {AtomSelectionSpec}
               *            [sel] - Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example // if the user were to pass the animationDuration value to
               *           // the function like so viewer.zoomTo({resn:'STI'},1000);
               *         //   the program would center on resn 'STI' over the course
               *         //   of 1 second(1000 milleseconds).
               *  // Reposition to centroid of all atoms of all models in this
               * //viewer glviewer.center();
              $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.center();
              viewer.render(callback);
              });
               */
              center(m = {}, E = 0, z = !1) {
                var O, R, B = this.getAtomsFromSel(m), P = (0, b.getExtent)(B);
                (0, b.isEmptyObject)(m) ? (this.shapes.forEach((Y) => {
                  if (Y && Y.boundingSphere && Y.boundingSphere.center) {
                    var ee = Y.boundingSphere.center, fe = Y.boundingSphere.radius;
                    fe > 0 ? (B.push(new s.Vector3(ee.x + fe, ee.y, ee.z)), B.push(new s.Vector3(ee.x - fe, ee.y, ee.z)), B.push(new s.Vector3(ee.x, ee.y + fe, ee.z)), B.push(new s.Vector3(ee.x, ee.y - fe, ee.z)), B.push(new s.Vector3(ee.x, ee.y, ee.z + fe)), B.push(new s.Vector3(ee.x, ee.y, ee.z - fe))) : B.push(ee);
                  }
                }), P = (0, b.getExtent)(B), O = B, R = P) : (O = this.getAtomsFromSel({}), R = (0, b.getExtent)(O));
                var W = new s.Vector3(P[2][0], P[2][1], P[2][2]), U = R[1][0] - R[0][0], V = R[1][1] - R[0][1], K = R[1][2] - R[0][2], q = Math.hypot(U, V, K);
                q < 5 && (q = 5), this.slabNear = -q / 1.9, this.slabFar = q / 2, U = P[1][0] - P[0][0], V = P[1][1] - P[0][1], K = P[1][2] - P[0][2], q = Math.hypot(U, V, K), q < 5 && (q = 5);
                for (var H = 25, j = 0; j < B.length; j++)
                  if (B[j]) {
                    var Q = W.distanceToSquared(B[j]);
                    Q > H && (H = Q);
                  }
                q = Math.sqrt(H) * 2;
                var J = W.clone().multiplyScalar(-1);
                return E > 0 ? this.animateMotion(E, z, J, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = J, this.show()), this;
              }
              /**
              	     * Zoom to center of atom selection.  The slab will be set appropriately for
              	     * the selection, unless an empty selection is provided, in which case there will be no slab.
              	     *
              	     * @param {Object}
              	     *            [sel] - Selection specification specifying model and atom
              	     *            properties to select. Default: all atoms in viewer
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	      * @example
              
              
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	          viewer.zoomTo();
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {
              	                      opacity:0.85,
              	                      voldata: new $3Dmol.VolumeData(volumedata, "cube"),
              	                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))
              	                  },{});
              
              	              viewer.render();
              	              });
              	            });
              	     */
              zoomTo(m = {}, E = 0, z = !1) {
                let O = this.getAtomsFromSel(m), R = (0, b.getExtent)(O), B = R;
                if ((0, b.isEmptyObject)(m)) {
                  let ee = O && O.length;
                  if (this.shapes.forEach((fe) => {
                    if (fe && fe.boundingSphere) {
                      if (fe.boundingSphere.box) {
                        let we = fe.boundingSphere.box;
                        O.push(new s.Vector3(we.min.x, we.min.y, we.min.z)), O.push(new s.Vector3(we.max.x, we.max.y, we.max.z));
                      } else if (fe.boundingSphere.center) {
                        var me = fe.boundingSphere.center, he = fe.boundingSphere.radius;
                        he > 0 ? (O.push(new s.Vector3(me.x + he, me.y, me.z)), O.push(new s.Vector3(me.x - he, me.y, me.z)), O.push(new s.Vector3(me.x, me.y + he, me.z)), O.push(new s.Vector3(me.x, me.y - he, me.z)), O.push(new s.Vector3(me.x, me.y, me.z + he)), O.push(new s.Vector3(me.x, me.y, me.z - he))) : O.push(me);
                      }
                    }
                  }), B = (0, b.getExtent)(O), !ee)
                    for (let fe = 0; fe < 3; fe++)
                      R[2][fe] = (B[0][fe] + B[1][fe]) / 2;
                } else {
                  let ee = this.getAtomsFromSel({});
                  B = (0, b.getExtent)(ee);
                }
                var P = new s.Vector3(R[2][0], R[2][1], R[2][2]), W = B[1][0] - B[0][0], U = B[1][1] - B[0][1], V = B[1][2] - B[0][2], K = Math.hypot(W, U, V);
                K < 5 && (K = 5), this.slabNear = -K / 1.9, this.slabFar = K / 2, Object.keys(m).length === 0 && (this.slabNear = Math.min(-K * 2, -50), this.slabFar = Math.max(K * 2, 50));
                var q = this.config.minimumZoomToDistance || 5;
                W = R[1][0] - R[0][0], U = R[1][1] - R[0][1], V = R[1][2] - R[0][2], K = Math.hypot(W, U, V), K < q && (K = q);
                for (var H = q * q, j = 0; j < O.length; j++)
                  if (O[j]) {
                    var Q = P.distanceToSquared(O[j]);
                    Q > H && (H = Q);
                  }
                K = Math.sqrt(H) * 2;
                var J = P.clone().multiplyScalar(-1), Y = -(K * 0.5 / Math.tan(Math.PI / 180 * this.camera.fov / 2) - this.CAMERA_Z);
                return Y = this.adjustZoomToLimits(Y), E > 0 ? this.animateMotion(E, z, J, Y, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = J, this.rotationGroup.position.z = Y, this.show()), this;
              }
              /**
               * Set slab of view (contents outside of slab are clipped).
               * Must call render to update.
               *
               * @param {number} near near clipping plane distance
               * @param {number} far far clipping plane distance
               */
              setSlab(m, E) {
                this.slabNear = m, this.slabFar = E;
              }
              /**
               * Get slab of view (contents outside of slab are clipped).
               *
               * @return {Object}
               *      @property {number} near - near clipping plane distance
               *      @property {number} far - far clipping plane distance
               */
              getSlab() {
                return { near: this.slabNear, far: this.slabFar };
              }
              /**
              	     * Add label to viewer
              	     *
              	     * @param {string}
              	     *            text - Label text
              	     * @param {LabelSpec}
              	     *            options - Label style specification
              	      @param {AtomSelection}
              	     *            sel - Set position of label to center of this selection
              	     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient
              	     * @return {Label}
              	     *
              	     * @example
              	     *  $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              
              	              viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.setStyle({chain:'A'},{cross:{hidden:true}});
              	              viewer.setStyle({chain:'B'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  radius:0.5}});
              	              viewer.setStyle({chain:'D'},{cross:{hidden:false,
              	                                                  linewidth:10.0}});
              	              viewer.setStyle({chain:'E'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  color:'black'}});
              
              	              viewer.render();
              
              
              	            });
              
              	     */
              addLabel(m, E = {}, z, O = !1) {
                if (z) {
                  var R = (0, b.getExtent)(this.getAtomsFromSel(z));
                  E.position = { x: R[2][0], y: R[2][1], z: R[2][2] };
                }
                var B = new A.Label(m, E);
                return B.setContext(), this.modelGroup.add(B.sprite), this.labels.push(B), O || this.show(), B;
              }
              /** Add residue labels.  This will generate one label per a
               * residue within the selected atoms.  The label will be at the
               * centroid of the atoms and styled according to the passed style.
               * The label text will be [resn][resi]
               *
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current
               *
               * @example
                   $3Dmol.download("mmtf:2ll5",viewer,{},function(){
                        viewer.setStyle({stick:{radius:0.15},cartoon:{}});
                        viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addResLabels(m, E, z = !1) {
                let O = this.labels.length;
                return this.applyToModels("addResLabels", m, this, E, z), this.show(), this.labels.slice(O);
              }
              /** Add property labels.  This will generate one label per a selected
               * atom at the atom's coordinates with the property value as the label text.
               *
               * @param {string} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               *
               * * @example
                   $3Dmol.download("cid:5291",viewer,{},function(){
                        viewer.setStyle({stick: {radius:.2}});
                        viewer.addPropertyLabels("index",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addPropertyLabels(m, E, z) {
                return this.applyToModels("addPropertyLabels", m, E, this, z), this.show(), this;
              }
              /**
              	     * Remove label from viewer
              	     *
              	     * @param {Label} label - $3Dmol label
              	     *
              	     * @example // Remove labels created in
              	     $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              	              var toremove = viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.removeLabel(toremove);
              	              viewer.render();
              
              
              	            });
              
              	     */
              removeLabel(m) {
                for (var E = 0; E < this.labels.length; E++)
                  if (this.labels[E] == m) {
                    this.labels.splice(E, 1), m.dispose(), this.modelGroup.remove(m.sprite);
                    break;
                  }
                return this.show(), this;
              }
              /**
              	     * Remove all labels from viewer
              	     *
              	     *         @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.addResLabels();
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render( ); //show labels
              
              	           viewer.removeAllLabels();
              	           viewer.render(); //hide labels
              	    });
              	     */
              removeAllLabels() {
                for (var m = 0; m < this.labels.length; m++)
                  this.labels[m] && this.labels[m].sprite && this.modelGroup.remove(this.labels[m].sprite);
                return this.labels.splice(0, this.labels.length), this.show(), this;
              }
              // Modify label style
              /**
               * Modify existing label's style
               *
               * @param {Label} label - $3Dmol label
               * @param {LabelSpec}
               *            stylespec - Label style specification
               * @return {Label}
               */
              setLabelStyle(m, E) {
                return this.modelGroup.remove(m.sprite), m.dispose(), m.stylespec = E, m.setContext(), this.modelGroup.add(m.sprite), this.show(), m;
              }
              // Change label text
              /**
               * Modify existing label's text
               *
               * @param {Label}  label - $3Dmol label
               * @param {String}
               *            text - Label text
               * @return {Label}
               */
              setLabelText(m, E) {
                return this.modelGroup.remove(m.sprite), m.dispose(), m.text = E, m.setContext(), this.modelGroup.add(m.sprite), this.show(), m;
              }
              /**
               * Add shape object to viewer
               * @see {GLShape}
               *
               * @param {ShapeSpec} shapeSpec - style specification for label
               * @return {GLShape}
               */
              addShape(m) {
                m = m || {};
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, this.shapes.push(E), E;
              }
              /**
               * Remove shape object from viewer
               *
               * @param {GLShape} shape - Reference to shape object to remove
               */
              removeShape(m) {
                if (!m)
                  return this;
                for (m.removegl(this.modelGroup), delete this.shapes[m.shapePosition]; this.shapes.length > 0 && typeof this.shapes[this.shapes.length - 1] > "u"; )
                  this.shapes.pop();
                return this;
              }
              /**
               * Remove all shape objects from viewer
               */
              removeAllShapes() {
                for (var m = 0; m < this.shapes.length; m++) {
                  var E = this.shapes[m];
                  E && E.removegl(this.modelGroup);
                }
                return this.shapes.splice(0, this.shapes.length), this;
              }
              //gets the center of the selection
              getSelectionCenter(m) {
                if (m.hasOwnProperty("x") && m.hasOwnProperty("y") && m.hasOwnProperty("z"))
                  return m;
                var E = this.getAtomsFromSel(m);
                if (E.length == 0)
                  return { x: 0, y: 0, z: 0 };
                var z = (0, b.getExtent)(E);
                return { x: z[0][0] + (z[1][0] - z[0][0]) / 2, y: z[0][1] + (z[1][1] - z[0][1]) / 2, z: z[0][2] + (z[1][2] - z[0][2]) / 2 };
              }
              /**
              	     * Create and add sphere shape. This method provides a shorthand
              	     * way to create a spherical shape object
              	     *
              	     * @param {SphereShapeSpec} spec - Sphere shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
              
              	     viewer.render();
              	     */
              addSphere(m) {
                m = m || {}, m.center = this.getSelectionCenter(m.center);
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, E.addSphere(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add box shape. This method provides a shorthand
              	     * way to create a box shape object
              	     *
              	     * @param {BoxSpec} spec - Box shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});
              	     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});
              	     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});
              
              	     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});
              	     viewer.zoomTo();
              	     viewer.rotate(45, {x:1,y:1,z:1});
              	     viewer.render();
              	     */
              addBox(m = {}) {
                m.corner != null && (m.corner = this.getSelectionCenter(m.corner)), m.center != null && (m.center = this.getSelectionCenter(m.center));
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, E.addBox(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add arrow shape
              	     *
              	     * @param {ArrowSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	    $3Dmol.download("pdb:4DM7",viewer,{},function(){
              
              	              viewer.setBackgroundColor(0xffffffff);
              	              viewer.addArrow({
              	                  start: {x:-10.0, y:0.0, z:0.0},
              	                  end: {x:0.0, y:-10.0, z:0.0},
              	                  radius: 1.0,
              	                  radiusRadio:1.0,
              	                  mid:1.0,
              	                  clickable:true,
              	                  callback:function(){
              	                      this.color.setHex(0xFF0000FF);
              	                      viewer.render( );
              	                  }
              	              });
              	              viewer.render();
              	            });
              	     */
              addArrow(m = {}) {
                m.start = this.getSelectionCenter(m.start), m.end = this.getSelectionCenter(m.end);
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, E.addArrow(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add cylinder shape
              	     *
              	     * @param {CylinderSpec} spec - Style specification
              	     * @return {GLShape}
              
              	      @example
              	     viewer.setBackgroundColor(0xffffffff);
              	          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
              	                              end:{x:10.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              fromCap:1,
              	                              toCap:2,
              	                              color:'red',
              	                              hoverable:true,
              	                              clickable:true,
              	                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
              	                              hover_callback: function(){ viewer.render( );},
              	                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
              	                             });
              	          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
              	                              end:{x:0.0,y:10.0,z:0.0},
              	                              radius:0.5,
              	                              fromCap:false,
              	                              toCap:true,
              	                              color:'teal'});
              	          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
              	                              end:{x:20.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              color:'black',
              	                              fromCap:false,
              	                              toCap:false});
              	          viewer.render();
              	     */
              addCylinder(m = {}) {
                m.start = this.getSelectionCenter(m.start), m.end = this.getSelectionCenter(m.end);
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, m.dashed ? E.addDashedCylinder(m) : E.addCylinder(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add Curve shape
              	     *
              	     * @param {CurveSpec} spec - Style specification
              	     * @return {GLShape}
              
              	     @example
              	          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],
              	                              radius:0.5,
              	                              smooth: 10,
              	                              fromArrow:false,
              	                              toArrow: true,
              	                              color:'orange',
              	                              });
              	          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],
              	                              radius:1,
              	                              fromArrow:true,
              	                              toArrow: false,
              	                              color:'purple',
              	                              });
              	          viewer.zoomTo();
              	          viewer.render();
              	     */
              addCurve(m = {}) {
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, E.addCurve(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add line shape
              	     *
              	     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength
              	     * @return {GLShape}
              	     @example
              	     $3Dmol.download("pdb:2ABJ",viewer,{},function(){
              
              	              viewer.setViewStyle({style:"outline"});
              	              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});
              	              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});
              	              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});
              	              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
              	              viewer.render();
              	          });
              
              	     */
              addLine(m = {}) {
                m.start = this.getSelectionCenter(m.start), m.end = this.getSelectionCenter(m.end), m.wireframe = !0;
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, m.dashed ? E = this.addLineDashed(m, E) : E.addLine(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Create and add unit cell visualization.
              	     *
              	     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              	     * @param {UnitCellStyleSpec} spec - visualization style
              	       @example
              
              	            $3Dmol.get('data/1jpy.cif', function(data) {
              	              let m = viewer.addModel(data);
              	              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});
              	              viewer.zoomTo();
              	              viewer.render();
              	    });
              	     */
              addUnitCell(m, E) {
                m = this.getModel(m), E = E || { alabel: "a", blabel: "b", clabel: "c" }, E.box = E.box || {}, E.astyle = E.astyle || { color: "red", radius: 0.1, midpos: -1 }, E.bstyle = E.bstyle || { color: "green", radius: 0.1, midpos: -1 }, E.cstyle = E.cstyle || { color: "blue", radius: 0.1, midpos: -1 }, E.alabelstyle = E.alabelstyle || { fontColor: "red", showBackground: !1, alignment: "center", inFront: !1 }, E.blabelstyle = E.blabelstyle || { fontColor: "green", showBackground: !1, alignment: "center", inFront: !1 }, E.clabelstyle = E.clabelstyle || { fontColor: "blue", showBackground: !1, alignment: "center", inFront: !1 }, m.unitCellObjects && this.removeUnitCell(m), m.unitCellObjects = { shapes: [], labels: [] };
                var z = m.getCrystData(), O = null;
                if (z) {
                  if (z.matrix)
                    O = z.matrix;
                  else {
                    var R = z.a, B = z.b, P = z.c, W = z.alpha, U = z.beta, V = z.gamma;
                    W = W * Math.PI / 180, U = U * Math.PI / 180, V = V * Math.PI / 180;
                    var K, q, H;
                    K = Math.cos(U), q = (Math.cos(W) - Math.cos(U) * Math.cos(V)) / Math.sin(V), H = Math.sqrt(Math.max(0, 1 - K * K - q * q)), O = new s.Matrix3(R, B * Math.cos(V), P * K, 0, B * Math.sin(V), P * q, 0, 0, P * H);
                  }
                  var j = [
                    new s.Vector3(0, 0, 0),
                    new s.Vector3(1, 0, 0),
                    new s.Vector3(0, 1, 0),
                    new s.Vector3(0, 0, 1),
                    new s.Vector3(1, 1, 0),
                    new s.Vector3(0, 1, 1),
                    new s.Vector3(1, 0, 1),
                    new s.Vector3(1, 1, 1)
                  ];
                  if (z.matrix4)
                    for (let J = 0; J < j.length; J++)
                      z.size && j[J].multiplyVectors(j[J], z.size), j[J] = j[J].applyMatrix4(z.matrix4);
                  else
                    for (let J = 0; J < j.length; J++)
                      j[J] = j[J].applyMatrix3(O);
                  if (E.box && !E.box.hidden) {
                    E.box.wireframe = !0;
                    var Q = new x.GLShape(E.box);
                    Q.shapePosition = this.shapes.length, Q.addLine({ start: j[0], end: j[1] }), Q.addLine({ start: j[0], end: j[2] }), Q.addLine({ start: j[1], end: j[4] }), Q.addLine({ start: j[2], end: j[4] }), Q.addLine({ start: j[0], end: j[3] }), Q.addLine({ start: j[3], end: j[5] }), Q.addLine({ start: j[2], end: j[5] }), Q.addLine({ start: j[1], end: j[6] }), Q.addLine({ start: j[4], end: j[7] }), Q.addLine({ start: j[6], end: j[7] }), Q.addLine({ start: j[3], end: j[6] }), Q.addLine({ start: j[5], end: j[7] }), this.shapes.push(Q), m.unitCellObjects.shapes.push(Q), Q.finalize();
                  }
                  if (!E.astyle.hidden) {
                    E.astyle.start = j[0], E.astyle.end = j[1];
                    let J = this.addArrow(E.astyle);
                    m.unitCellObjects.shapes.push(J);
                  }
                  if (!E.bstyle.hidden) {
                    E.bstyle.start = j[0], E.bstyle.end = j[2];
                    let J = this.addArrow(E.bstyle);
                    m.unitCellObjects.shapes.push(J);
                  }
                  if (!E.cstyle.hidden) {
                    E.cstyle.start = j[0], E.cstyle.end = j[3];
                    let J = this.addArrow(E.cstyle);
                    m.unitCellObjects.shapes.push(J);
                  }
                  if (E.alabel) {
                    E.alabelstyle.position = j[1];
                    let J = this.addLabel(E.alabel, E.alabelstyle);
                    m.unitCellObjects.labels.push(J);
                  }
                  if (E.blabel) {
                    E.blabelstyle.position = j[2];
                    let J = this.addLabel(E.blabel, E.blabelstyle);
                    m.unitCellObjects.labels.push(J);
                  }
                  if (E.clabel) {
                    E.clabelstyle.position = j[3];
                    let J = this.addLabel(E.clabel, E.clabelstyle);
                    m.unitCellObjects.labels.push(J);
                  }
                }
              }
              /**
              * Remove unit cell visualization from model.
              *
              * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.removeUnitCell();
                       viewer.render();
                 });
              */
              removeUnitCell(m) {
                if (m = this.getModel(m), m.unitCellObjects) {
                  let E = this;
                  m.unitCellObjects.shapes.forEach(function(z) {
                    E.removeShape(z);
                  }), m.unitCellObjects.labels.forEach(function(z) {
                    E.removeLabel(z);
                  });
                }
                delete m.unitCellObjects;
              }
              /**
              * Replicate atoms in model to form a super cell of the specified dimensions.
              * Original cell will be centered as much as possible.
              *
              * @param {integer} A - number of times to replicate cell in X dimension.
              * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.
              * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.
              * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              * @param {boolean} addBonds - Create bonds between unit cells based on distances.
              * @param {boolean} prune - Keep only atoms that are within the original unit cell (i.e., on edges).  Alternatively, call replicateUnitCell(1).
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{scale:.25}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.replicateUnitCell(3,2,1,m);
                       viewer.render();
                 });
              */
              replicateUnitCell(m = 3, E = m, z = E, O, R, B) {
                O = this.getModel(O);
                let P = O.getCrystData();
                if (P) {
                  const W = O.selectedAtoms({}), U = P.matrix;
                  let V = function(q) {
                    return q % 2 == 0 ? -q / 2 : Math.ceil(q / 2);
                  };
                  m <= 1 && E <= 1 && z <= 1 && (B = !0, m = E = z = 3);
                  let K = function(q, H, j) {
                    return !1;
                  };
                  if (B) {
                    const q = new s.Matrix3().getInverse3(U);
                    K = function(H, j, Q) {
                      let J = new s.Vector3(H, j, Q).applyMatrix3(q);
                      return !(J.x > -1e-4 && J.x < 1.0001 && J.y > -1e-4 && J.y < 1.0001 && J.z > -1e-4 && J.z < 1.0001);
                    };
                  }
                  for (let q = 0; q < m; q++)
                    for (let H = 0; H < E; H++)
                      for (let j = 0; j < z; j++) {
                        if (q == 0 && H == 0 && j == 0)
                          continue;
                        let Q = new s.Vector3(V(q), V(H), V(j));
                        Q.applyMatrix3(U);
                        let J = [];
                        for (let Y = 0; Y < W.length; Y++) {
                          let ee = W[Y].x + Q.x, fe = W[Y].y + Q.y, me = W[Y].z + Q.z;
                          if (K(ee, fe, me))
                            continue;
                          let he = {};
                          for (let we in W[Y])
                            he[we] = W[Y][we];
                          he.x = ee, he.y = fe, he.z = me, J.push(he);
                        }
                        O.addAtoms(J);
                      }
                  R && O.assignBonds();
                }
              }
              /** Add dashed line to shape */
              addLineDashed(m, E) {
                m.dashLength = m.dashLength || 0.5, m.gapLength = m.gapLength || 0.5;
                var z;
                m.start ? z = new s.Vector3(m.start.x || 0, m.start.y || 0, m.start.z || 0) : z = new s.Vector3(0, 0, 0);
                var O;
                m.end ? O = new s.Vector3(m.end.x, m.end.y || 0, m.end.z || 0) : O = new s.Vector3(0, 0, 0);
                var R = new s.Vector3(), B = new s.Vector3(), P = new s.Vector3(), W, U, V, K = z.clone(), q = 0;
                for (R.subVectors(O, z), W = R.length(), R.normalize(), B = R.clone(), P = R.clone(), B.multiplyScalar(m.dashLength), P.multiplyScalar(m.gapLength), U = B.length(), V = P.length(); q < W; ) {
                  if (q + U > W) {
                    m.start = z, m.end = O, E.addLine(m);
                    break;
                  }
                  K.addVectors(z, B), m.start = z, m.end = K, E.addLine(m), z = K.clone(), q += U, K.addVectors(z, P), z = K.clone(), q += V;
                }
                return E.finalize(), E;
              }
              /**
              	     * Add custom shape component from user supplied function
              	     *
              	     * @param {CustomSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	     function triangle(viewer) {
              	        var vertices = [];
              	        var normals = [];
              	        var colors = [];
              	        var r = 20;
              	        //triangle
              	        vertices.push(new $3Dmol.Vector3(0,0,0));
              	        vertices.push(new $3Dmol.Vector3(r,0,0));
              	        vertices.push(new $3Dmol.Vector3(0,r,0));
              
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              
              	        colors.push({r:1,g:0,b:0});
              	        colors.push({r:0,g:1,b:0});
              	        colors.push({r:0,g:0,b:1});
              
              	        var faces = [ 0,1,2 ];
              
              	        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};
              	        viewer.addCustom(spec);
              	    }
              	    triangle(viewer);
              	    viewer.render();
              	     */
              addCustom(m) {
                m = m || {};
                var E = new x.GLShape(m);
                return E.shapePosition = this.shapes.length, E.addCustom(m), this.shapes.push(E), E.finalize(), E;
              }
              /**
              	     * Construct isosurface from volumetric data in gaussian cube format
              	     * @param {String} data - Input file contents
              	     * @param {String} format - Input file format
              	     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification
              	     * @return {GLShape}
              	     *
              	     * @example
              
              
              	    $3Dmol.get('data/bohr.cube', function(data) {
              
              	    viewer.addVolumetricData(data, "cube", {isoval: -0.01, color: "red", opacity: 0.95});
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo();
              	    viewer.render();
              	    });
              
              
              	     */
              addVolumetricData(m, E, z = {}) {
                var O = new k.VolumeData(m, E);
                return z.hasOwnProperty("transferfn") ? this.addVolumetricRender(O, z) : this.addIsosurface(O, z);
              }
              /**
               * Construct isosurface from volumetric data.  This is more flexible
              * than addVolumetricData, but can not be used with py3Dmol.
               * @param {VolumeData} data - volumetric data
               * @param {IsoSurfaceSpec} spec - Shape style specification
               * @return {GLShape}
               *
               @example
               $3Dmol.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue"});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red"});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(m, E = {}, z) {
                var O = new x.GLShape(E);
                return O.shapePosition = this.shapes.length, O.addIsosurface(m, E, z, this), this.shapes.push(O), O;
              }
              /**
               * Create volumetric renderer for volumetricData
               * @param {VolumeData} data - volumetric data
               * @param {VolumetricRenderSpec} spec - specification of volumetric render
               *
               * @return {GLShape}
               *
               */
              addVolumetricRender(m, E) {
                E = E || {};
                var z = new C.GLVolumetricRender(m, E, this);
                return z.shapePosition = this.shapes.length, this.shapes.push(z), z;
              }
              /**
               * Return true if volumetric rendering is supported (WebGL 2.0 required)
               *
               * @return {boolean}
               */
              hasVolumetricRender() {
                return this.renderer.supportsVolumetric();
              }
              /**
               * Enable/disable fog for content far from the camera
               *
               * @param {boolean} fog whether to enable or disable the fog
               */
              enableFog(m) {
                m ? this.scene.fog = new n.Fog(this.bgColor, 100, 200) : (this.config.disableFog = !0, this.show());
              }
              /**
               * Sets the atomlists of all models in the viewer to specified frame.
               * Shapes and labels can also be displayed by frame.
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - fame index to use, starts at zero
               * @return {Promise}
               */
              setFrame(m) {
                this.viewer_frame = m;
                let E = this;
                return new Promise(function(z) {
                  var O = E.models.map(function(R) {
                    return R.setFrame(m, E);
                  });
                  Promise.all(O).then(function() {
                    z();
                  });
                });
              }
              /**
               * Gets the current viewer frame.
               *
               */
              getFrame() {
                return this.viewer_frame;
              }
              /**
               * Returns the number of frames that the model with the most frames in the viewer has
               *
               * @return {number}
               */
              getNumFrames() {
                var m = 0;
                for (let E = 0; E < this.models.length; E++)
                  this.models[E].getNumFrames() > m && (m = this.models[E].getNumFrames());
                for (let E = 0; E < this.shapes.length; E++)
                  this.shapes[E].frame && this.shapes[E].frame >= m && (m = this.shapes[E].frame + 1);
                for (let E = 0; E < this.labels.length; E++)
                  this.labels[E].frame && this.labels[E].frame >= m && (m = this.labels[E].frame + 1);
                return m;
              }
              /**
               * Animate all models in viewer from their respective frames
               * @param {Object} options - can specify interval (speed of animation), loop (direction
               * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)
               *
               */
              animate(m) {
                this.incAnim();
                var E = 100, z = "forward", O = 1 / 0;
                m = m || {}, m.interval && (E = m.interval), m.loop && (z = m.loop), m.reps && (O = m.reps);
                var R = this.getNumFrames(), B = this, P = 0;
                m.startFrame && (P = m.startFrame % R);
                var W = 1;
                m.step && (W = m.step, O /= W);
                var U = 0, V = R * O, K = /* @__PURE__ */ new Date(), q, H, j = function(Q) {
                  K = /* @__PURE__ */ new Date(), Q == "forward" ? B.setFrame(P).then(function() {
                    P = (P + W) % R, q();
                  }) : Q == "backward" ? B.setFrame(R - 1 - P).then(function() {
                    P = (P + W) % R, q();
                  }) : B.setFrame(P).then(function() {
                    P += W, W *= P % (R - 1) == 0 ? -1 : 1, q();
                  });
                };
                return q = function() {
                  if (B.render(), !B.getCanvas().isConnected)
                    B.stopAnimate();
                  else if (++U >= V || !B.isAnimated())
                    H.cancel(), B.animationTimers.delete(H), B.decAnim();
                  else {
                    var Q = E - ((/* @__PURE__ */ new Date()).getTime() - K.getTime());
                    Q = Q > 0 ? Q : 0, B.animationTimers.delete(H), H = new b.PausableTimer(j, Q, z), B.animationTimers.add(H);
                  }
                }, H = new b.PausableTimer(j, 0, z), this.animationTimers.add(H), this;
              }
              /**
               * Stop animation of all models in viewer
               */
              stopAnimate() {
                return this.animated = 0, this.animationTimers.forEach(function(m) {
                  m.cancel();
                }), this.animationTimers = /* @__PURE__ */ new Set(), this;
              }
              /**
               * Pause animation of all models in viewer
               */
              pauseAnimate() {
                return this.animationTimers.forEach(function(m) {
                  m.pause();
                }), this;
              }
              /**
               * Resume animation of all models in viewer
               */
              resumeAnimate() {
                return this.animationTimers.forEach(function(m) {
                  m.resume();
                }), this;
              }
              /**
               * Return true if viewer is currently being animated, false otherwise
               * @return {boolean}
               */
              isAnimated() {
                return this.animated > 0;
              }
              //setup options dict
              getModelOpt(m) {
                return m && !m.defaultcolors ? (m.defaultcolors = this.defaultcolors, m.cartoonQuality = m.cartoonQuality || this.config.cartoonQuality) : typeof m > "u" && (m = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality }), m;
              }
              /**
              	     * Create and add model to viewer, given molecular data and its format
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')
              	     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.
              	     * @example
              
              
              	          viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              
              	              viewer.render();
              	              });
              	              viewer.zoomTo();
              	          });
              	     *
              	     * @return {GLModel}
              	     */
              addModel(m, E = "", z) {
                z = this.getModelOpt(z);
                var O = new _.GLModel(this.models.length, z);
                return O.addMolData(m, E, z), this.models.push(O), O;
              }
              /**
               * Given multimodel file and its format, add atom data to the viewer as separate models
               * and return list of these models
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {Array<GLModel>}
               */
              addModels(m, E, z) {
                z = this.getModelOpt(z), z.multimodel = !0, z.frames = !0;
                for (var O = _.GLModel.parseMolData(m, E, z), R = 0; R < O.length; R++) {
                  var B = new _.GLModel(this.models.length, z);
                  B.setAtomDefaults(O[R]), B.addFrame(O[R]), B.setFrame(0), O.modelData && B.setModelData(O.modelData[R]), B.setDontDuplicateAtoms(!z.duplicateAssemblyAtoms), this.models.push(B);
                }
                return this.models;
              }
              /**
               * Create and add model to viewer. Given multimodel file and its format,
               * different atomlists are stored in model's frame
               * property and model's atoms are set to the 0th frame
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {GLModel}
               *
               * @example
                      $3Dmol.get('../test_structs/multiple2.xyz', function(data){
                        viewer.addModelsAsFrames(data, "xyz");
                        viewer.animate({loop: "forward",reps: 1});
                        viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});
                        viewer.zoomTo();
                        viewer.render();
                    });
               */
              addModelsAsFrames(m, E, z) {
                z = this.getModelOpt(z), z.multimodel = !0, z.frames = !0;
                var O = new _.GLModel(this.models.length, z);
                return O.addMolData(m, E, z), this.models.push(O), O;
              }
              /**
              	     * Create and add model to viewer. Given multimodel file and its format,
              	     * all atoms are added to one model
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format (see {@link FileFormats})
              	     * @return {GLModel}
              	     @example
              
              
              	          $3Dmol.get('../test_structs/multiple.sdf', function(data){
              	              viewer.addAsOneMolecule(data, "sdf");
              	              viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              addAsOneMolecule(m, E, z) {
                z = this.getModelOpt(z), z.multimodel = !0, z.onemol = !0;
                var O = new _.GLModel(this.models.length, z);
                return O.addMolData(m, E, z), this.models.push(O), O;
              }
              /**
               * Delete specified model from viewer
               *
               * @param {GLModel|number} model
               */
              removeModel(m) {
                if (m = this.getModel(m), !!m) {
                  for (m.removegl(this.modelGroup), delete this.models[m.getID()]; this.models.length > 0 && typeof this.models[this.models.length - 1] > "u"; )
                    this.models.pop();
                  return this;
                }
              }
              /**
               * Delete all existing models
               */
              removeAllModels() {
                for (var m = 0; m < this.models.length; m++) {
                  var E = this.models[m];
                  E && E.removegl(this.modelGroup);
                }
                return this.models.splice(0, this.models.length), this;
              }
              /**
               * Export one or all of the loaded models into ChemDoodle compatible JSON.
               * @param {boolean} includeStyles - Whether or not to include style information.
               * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.
               * @return {string}
               */
              exportJSON(m, E) {
                var z = {};
                return E === void 0 ? z.m = this.models.map(function(O) {
                  return O.toCDObject(m);
                }) : z.m = [this.models[E].toCDObject()], JSON.stringify(z);
              }
              /** return a VRML string representation of the scene.  Include VRML header information
               * @return VRML
               */
              exportVRML() {
                var m = this.modelGroup;
                this.applyToModels("removegl", this.modelGroup), this.modelGroup = new n.Object3D(), this.render(null, { supportsImposters: !1, supportsAIA: !1, regen: !0 });
                var E = `#VRML V2.0 utf8
` + this.modelGroup.vrml() + `
`;
                return this.applyToModels("removegl", this.modelGroup), this.modelGroup = m, E;
              }
              /**
               * Create a new model from atoms specified by sel.
               * If extract, removes selected atoms from existing models
               *
               * @param {AtomSelectionSpec} sel - Atom selection specification
               * @param {boolean=} extract - If true, remove selected atoms from existing models
               * @return {GLModel}
               */
              createModelFrom(m, E = !1) {
                for (var z = new _.GLModel(this.models.length, this.defaultcolors), O = 0; O < this.models.length; O++)
                  if (this.models[O]) {
                    var R = this.models[O].selectedAtoms(m);
                    z.addAtoms(R), E && this.models[O].removeAtoms(R);
                  }
                return this.models.push(z), z;
              }
              applyToModels(m, E, z, O, R, B, P) {
                for (var W = this.getModelList(E), U = 0; U < W.length; U++)
                  W[U][m](E, z, O, R, B, P);
              }
              setStyle(m, E) {
                return typeof E > "u" && (E = m, m = {}), this.applyToModels("setStyle", m, E, !1), this;
              }
              addStyle(m, E) {
                return typeof E > "u" && (E = m, m = {}), this.applyToModels("setStyle", m, E, !0), this;
              }
              /**
              	     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed
              	     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list
              	     * of all intersecting objects with their distances from the viewer.
              	     *
              	     * @example
              	        $3Dmol.download("cid:307900",viewer,{},function(){
              
              	               viewer.setStyle({},{sphere:{}});
              	               viewer.setClickable({},true,function(atom,viewer,event,container) {
              	                   viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});
              	               });
              	               viewer.render();
              	    });
              	     */
              setClickable(m, E, z) {
                return this.applyToModels("setClickable", m, E, z), this;
              }
              /** Set hoverable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              	     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.
              	     * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              	    @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.setHoverable({},true,function(atom,viewer,event,container) {
              	               if(!atom.label) {
              	                atom.label = viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});
              	               }
              	           },
              	           function(atom) {
              	               if(atom.label) {
              	                viewer.removeLabel(atom.label);
              	                delete atom.label;
              	               }
              	            }
              	           );
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render();
              	    });
              
              	     */
              setHoverable(m, E, z, O) {
                return this.applyToModels("setHoverable", m, E, z, O), this;
              }
              /** enable context menu and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
              
              	     */
              enableContextMenu(m, E) {
                return this.applyToModels("enableContextMenu", m, E), this;
              }
              /**
               * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.
               * Models can then be animated
               *
               * @param {number} numFrames - number of frames to be created, default to 10
               * @param {number} amplitude - amplitude of distortion, default to 1 (full)
               * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
               * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
               */
              vibrate(m, E, z, O) {
                return this.applyToModels("vibrate", m, E, z, this, O), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               * @param {object} range
               */
              setColorByProperty(m, E, z, O) {
                return this.applyToModels("setColorByProperty", m, E, z, O), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(m, E) {
                return this.applyToModels("setColorByElement", m, E), this;
              }
              /**
               *
               * @param {AtomSpec[]} atomlist
               * @param {Array}
               *            extent
               * @return {Array}
               */
              static getAtomsWithin(m, E) {
                var z = [];
                for (let R = 0; R < m.length; R++) {
                  var O = m[R];
                  typeof O > "u" || O.x < E[0][0] || O.x > E[1][0] || O.y < E[0][1] || O.y > E[1][1] || O.z < E[0][2] || O.z > E[1][2] || z.push(O);
                }
                return z;
              }
              // return volume of extent
              static volume(m) {
                var E = m[1][0] - m[0][0], z = m[1][1] - m[0][1], O = m[1][2] - m[0][2];
                return E * z * O;
              }
              // volume
              /*
               * Break up bounding box/atoms into smaller pieces so we can parallelize
               * with webworkers and also limit the size of the working memory Returns
               * a list of bounding boxes with the corresponding atoms. These extents
               * are expanded by 4 angstroms on each side.
               */
              /**
               *
               * @param {Array}
               *            extent
               * @param {AtomSpec[]} atomlist
               * @param {AtomSpec[]} atomstoshow
               * @return {Array}
               */
              carveUpExtent(m, E, z) {
                let O = [], R = {};
                for (let K = 0, q = E.length; K < q; K++)
                  R[E[K].index] = K;
                let B = function(K) {
                  let q = [];
                  for (let H = 0, j = K.length; H < j; H++)
                    K[H].index in R && q.push(R[K[H].index]);
                  return q;
                }, P = function(K) {
                  let q = [];
                  return q[0] = [K[0][0], K[0][1], K[0][2]], q[1] = [K[1][0], K[1][1], K[1][2]], q;
                }, W = function(K) {
                  if (o.volume(K) < o.maxVolume)
                    return [K];
                  var q = K[1][0] - K[0][0], H = K[1][1] - K[0][1], j = K[1][2] - K[0][2], Q;
                  q > H && q > j ? Q = 0 : H > q && H > j ? Q = 1 : Q = 2;
                  var J = P(K), Y = P(K), ee = (K[1][Q] - K[0][Q]) / 2 + K[0][Q];
                  J[1][Q] = ee, Y[0][Q] = ee;
                  var fe = W(J), me = W(Y);
                  return fe.concat(me);
                }, U = W(m), V = 6;
                for (let K = 0, q = U.length; K < q; K++) {
                  let H = P(U[K]);
                  H[0][0] -= V, H[0][1] -= V, H[0][2] -= V, H[1][0] += V, H[1][1] += V, H[1][2] += V;
                  let j = o.getAtomsWithin(E, H), Q = o.getAtomsWithin(z, U[K]);
                  O.push({
                    extent: U[K],
                    atoms: B(j),
                    toshow: B(Q)
                  });
                }
                return O;
              }
              // create a mesh defined from the passed vertices and faces and material
              // Just create a single geometry chunk - broken up whether sync or not
              /**
               *
               * @param {AtomSpec[]} atoms
               * @param {{vertices:number,faces:number}}
               *            VandF
               * @param {MeshLambertMaterial}
               *            mat
               * @return {Mesh}
               */
              static generateSurfaceMesh(m, E, z) {
                var O = new n.Geometry(!0), R = O.updateGeoGroup(0), B = [];
                for (let ge = 0, de = m.length; ge < de; ge++) {
                  var P = m[ge];
                  P && (typeof P.surfaceColor < "u" ? B[ge] = P.surfaceColor : P.color && (B[ge] = h.CC.color(P.color)));
                }
                var W = R.vertexArray, U = E.vertices;
                for (let ge = 0, de = U.length; ge < de; ge++) {
                  let De = R.vertices * 3;
                  W[De] = U[ge].x, W[De + 1] = U[ge].y, W[De + 2] = U[ge].z, R.vertices++;
                }
                var V = R.colorArray;
                let K = R.atomArray;
                if (z.voldata && z.volscheme) {
                  var q = z.volscheme, H = z.voldata, j = q.range() || [-1, 1];
                  for (let ge = 0, de = U.length; ge < de; ge++) {
                    let De = U[ge].atomid, Be = H.getVal(U[ge].x, U[ge].y, U[ge].z), Ve = h.CC.color(q.valueToHex(Be, j)), qe = ge * 3;
                    V[qe] = Ve.r, V[qe + 1] = Ve.g, V[qe + 2] = Ve.b, K[ge] = m[De];
                  }
                } else if (B.length > 0)
                  for (let ge = 0, de = U.length; ge < de; ge++) {
                    let De = U[ge].atomid, Be = ge * 3;
                    V[Be] = B[De].r, V[Be + 1] = B[De].g, V[Be + 2] = B[De].b, K[ge] = m[De];
                  }
                var Q = E.faces;
                R.faceidx = Q.length, O.initTypedArrays();
                var J = R.vertexArray, Y = R.normalArray, ee, fe, me, he;
                for (let ge = 0, de = Q.length; ge < de; ge += 3) {
                  var we = Q[ge], ye = Q[ge + 1], ve = Q[ge + 2], ce = we * 3, be = ye * 3, le = ve * 3;
                  ee = new s.Vector3(J[ce], J[ce + 1], J[ce + 2]), fe = new s.Vector3(J[be], J[be + 1], J[be + 2]), me = new s.Vector3(J[le], J[le + 1], J[le + 2]), me.subVectors(me, fe), ee.subVectors(ee, fe), me.cross(ee), he = me, he.normalize(), Y[ce] += he.x, Y[be] += he.x, Y[le] += he.x, Y[ce + 1] += he.y, Y[be + 1] += he.y, Y[le + 1] += he.y, Y[ce + 2] += he.z, Y[be + 2] += he.z, Y[le + 2] += he.z;
                }
                R.faceArray = new Uint16Array(Q);
                var Se = new n.Mesh(O, z);
                return Se;
              }
              // do same thing as worker in main thread
              /**
               *
               * @param {SurfaceType}
               *            type
               * @param {Array}
               *            expandedExtent
               * @param {AtomSpec[]}
               *            extendedAtoms
               * @param {AtomSpec[]}
               *            atomsToShow
               * @param {AtomSpec[]} atoms
               * @param {number}
               *            vol
               * @return {Object}
               */
              static generateMeshSyncHelper(m, E, z, O, R, B) {
                var P = new $.ProteinSurface();
                return P.initparm(E, m !== 1, B), P.fillvoxels(R, z), P.buildboundary(), (m == $.SurfaceType.SES || m == $.SurfaceType.MS) && (P.fastdistancemap(), P.boundingatom(!1), P.fillvoxelswaals(R, z)), P.marchingcube(m), P.getFacesAndVertices(O);
              }
              /*
               *
               * @param {SurfaceStyleSpec}
               *            style
               * @return {MeshLambertMaterial}
               */
              static getMatWithStyle(m) {
                let E = null;
                m.onesided ? E = new n.MeshLambertMaterial() : E = new n.MeshDoubleLambertMaterial(), E.vertexColors = n.Coloring.VertexColors;
                for (var z in m)
                  z === "color" || z === "map" || m.hasOwnProperty(z) && (E[z] = m[z]);
                return m.opacity !== void 0 && (m.opacity === 1 ? E.transparent = !1 : E.transparent = !0), E;
              }
              /**
               * Adds an explicit mesh as a surface object.
               * @param {Mesh}
               *            mesh
               * @param {Object}
               *            style
               * @returns {number} surfid
               */
              addMesh(m) {
                var E = {
                  geo: m.geometry,
                  mat: m.material,
                  done: !0,
                  finished: !1
                  //the rendered finishes surfaces when they are done
                }, z = this.nextSurfID();
                return this.surfaces[z] = [E], z;
              }
              //return a shallow copy of list l, e.g., for atoms so we can
              //ignore superficial changes (ie surfacecolor, position) that happen
              //while we're surface building
              static shallowCopy(m) {
                var E = [];
                let z = m.length;
                for (let O = 0; O < z; O++)
                  E[O] = (0, b.extend)({}, m[O]);
                return E;
              }
              /**
               * Add surface representation to atoms
               * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)
               * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)
               * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection
               * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'
               * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms
               * @param {function} surfacecallback - function to be called after setting the surface
               * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.
               */
              addSurface(m, E = {}, z = {}, O, R, B) {
                let P = this.nextSurfID(), W = null, U = this, V = $.SurfaceType.VDW;
                typeof m == "string" ? o.surfaceTypeMap[m.toUpperCase()] !== void 0 ? V = o.surfaceTypeMap[m] : console.log("Surface type : " + m + " is not recognized") : typeof m == "number" && (V = m);
                var K = null, q = null, H = o.shallowCopy(this.getAtomsFromSel(z));
                O ? K = o.shallowCopy(this.getAtomsFromSel(O)) : K = H, (0, b.adjustVolumeStyle)(E);
                var j = !1, Q;
                for (Q = 0; Q < this.models.length; Q++)
                  if (this.models[Q]) {
                    var J = this.models[Q].getSymmetries();
                    if (J.length > 1 || J.length == 1 && !J[0].isIdentity()) {
                      j = !0;
                      break;
                    }
                  }
                var Y = function(ve, ce, be) {
                  R ? q = o.shallowCopy(U.getAtomsFromSel(R)) : q = be;
                  var le, Se = (0, b.getExtent)(be, !0);
                  if (E.map && E.map.prop) {
                    var ge = E.map.prop;
                    let Pe = (0, g.getGradient)(E.map.scheme || E.map.gradient || new g.Gradient.RWB()), it = Pe.range();
                    it || (it = (0, b.getPropertyRange)(be, ge)), E.colorscheme = { prop: ge, gradient: Pe };
                  }
                  for (let Pe = 0, it = ce.length; Pe < it; Pe++)
                    le = ce[Pe], le.surfaceColor = (0, b.getColorFromStyle)(le, E);
                  var de = o.volume(Se), De = U.carveUpExtent(Se, ce, be);
                  if (q && q.length && q.length > 0) {
                    var Be = (0, b.getExtent)(q, !0), Ve = function(Pe, it) {
                      var nt = function(ue, $e) {
                        var Ae = ue.extent, je = Ae[1][0] - Ae[0][0], ze = Ae[1][1] - Ae[0][1], re = Ae[1][2] - Ae[0][2], xe = je - $e[2][0];
                        xe *= xe;
                        var Le = ze - $e[2][1];
                        Le *= Le;
                        var He = re - $e[2][2];
                        return He *= He, xe + Le + He;
                      }, ne = nt(Pe, Be), se = nt(it, Be);
                      return ne - se;
                    };
                    De.sort(Ve);
                  }
                  var qe = [];
                  for (let Pe = 0, it = ce.length; Pe < it; Pe++)
                    le = ce[Pe], qe[Pe] = {
                      x: le.x,
                      y: le.y,
                      z: le.z,
                      serial: Pe,
                      elem: le.elem
                    };
                  var Ze = !!$.syncSurface;
                  if (Ze) {
                    var Ye = function(it) {
                      return new Promise(function(nt) {
                        for (var ne = o.generateMeshSyncHelper(V, De[it].extent, De[it].atoms, De[it].toshow, qe, de), se = (0, x.splitMesh)({ vertexArr: ne.vertices, faceArr: ne.faces }), ue = 0, $e = se.length; ue < $e; ue++) {
                          ne = {
                            vertices: se[ue].vertexArr,
                            faces: se[ue].faceArr
                          };
                          var Ae = o.generateSurfaceMesh(ce, ne, W);
                          (0, b.mergeGeos)(ve.geo, Ae);
                        }
                        U.render(), nt();
                      });
                    }, Xe = [];
                    for (let Pe = 0; Pe < De.length; Pe++)
                      Xe.push(Ye(Pe));
                    return Promise.all(Xe).then(function() {
                      return ve.done = !0, Promise.resolve(P);
                    });
                  } else {
                    var Ge = [];
                    V < 0 && (V = 0);
                    for (let Pe = 0, it = o.numWorkers; Pe < it; Pe++) {
                      var Ke = new Worker($3Dmol.SurfaceWorker);
                      Ge.push(Ke), Ke.postMessage({
                        type: -1,
                        atoms: qe,
                        volume: de
                      });
                    }
                    return new Promise(function(Pe, it) {
                      var nt = 0, ne = function() {
                        !Ge || !Ge.length || Ge.forEach(function(Ae) {
                          Ae && Ae.terminate && Ae.terminate();
                        });
                      }, se = function(Ae) {
                        for (var je = (0, x.splitMesh)({
                          vertexArr: Ae.data.vertices,
                          faceArr: Ae.data.faces
                        }), ze = 0, re = je.length; ze < re; ze++) {
                          var xe = {
                            vertices: je[ze].vertexArr,
                            faces: je[ze].faceArr
                          }, Le = o.generateSurfaceMesh(ce, xe, W);
                          (0, b.mergeGeos)(ve.geo, Le);
                        }
                        U.render(), nt++, nt == De.length && (ve.done = !0, ne(), Pe(P));
                      }, ue = function(Ae) {
                        ne(), console.log(Ae.message + " (" + Ae.filename + ":" + Ae.lineno + ")"), it(Ae);
                      };
                      for (let Ae = 0; Ae < De.length; Ae++) {
                        var $e = Ge[Ae % Ge.length];
                        $e.onmessage = se, $e.onerror = ue, $e.postMessage({
                          type: V,
                          expandedExtent: De[Ae].extent,
                          extendedAtoms: De[Ae].atoms,
                          atomsToShow: De[Ae].toshow
                        });
                      }
                    });
                  }
                };
                E = E || {}, W = o.getMatWithStyle(E);
                var ee = [];
                ee.style = E, ee.atomsel = z, ee.allsel = O, ee.focus = R;
                var fe = null;
                if (j) {
                  var me = {}, he = {};
                  for (Q = 0; Q < this.models.length; Q++)
                    me[Q] = [], he[Q] = [];
                  for (Q = 0; Q < K.length; Q++)
                    me[K[Q].model].push(K[Q]);
                  for (Q = 0; Q < H.length; Q++)
                    he[H[Q].model].push(H[Q]);
                  var we = [];
                  for (Q = 0; Q < this.models.length; Q++)
                    he[Q].length > 0 && (ee.push({
                      geo: new n.Geometry(!0),
                      mat: W,
                      done: !1,
                      finished: !1,
                      symmetries: this.models[Q].getSymmetries()
                      // also webgl initialized
                    }), we.push(Y(ee[ee.length - 1], me[Q], he[Q])));
                  fe = Promise.all(we);
                } else
                  ee.push({
                    geo: new n.Geometry(!0),
                    mat: W,
                    done: !1,
                    finished: !1,
                    symmetries: [new s.Matrix4()]
                  }), fe = Y(ee[ee.length - 1], K, H);
                return this.surfaces[P] = ee, fe.surfid = P, B && typeof B == "function" ? (fe.then(function(ye) {
                  B(ye);
                }), P) : fe;
              }
              /**
               * Set the surface material to something else, must render change
               * @param {number} surf - Surface ID to apply changes to
               * @param {SurfaceStyleSpec} style - new material style specification
               @example
               $3Dmol.get("data/9002806.cif",function(data){
                  viewer.addModel(data);
                  viewer.setStyle({stick:{}});
                  let surf = viewer.addSurface("SAS");
                  surf.then(function() {
                      viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});
                      viewer.render();
                      });
                 });
               */
              setSurfaceMaterialStyle(m, E) {
                if ((0, b.adjustVolumeStyle)(E), this.surfaces[m]) {
                  var z = this.surfaces[m];
                  for (let R = 0; R < z.length; R++) {
                    var O = z[R].mat = o.getMatWithStyle(E);
                    if (z[R].mat.side = n.FrontSide, E.color) {
                      z[R].mat.color = h.CC.color(E.color), z[R].geo.colorsNeedUpdate = !0;
                      const B = h.CC.color(E.color);
                      z[R].geo.setColor(B);
                    } else if (O.voldata && O.volscheme) {
                      const B = O.volscheme, P = O.voldata, W = h.CC, U = B.range() || [-1, 1];
                      z[R].geo.setColors(function(V, K, q) {
                        let H = P.getVal(V, K, q);
                        return W.color(B.valueToHex(H, U));
                      });
                    } else {
                      z[R].geo.colorsNeedUpdate = !0;
                      for (let B of z[R].geo.geometryGroups)
                        for (let P = 0; P < B.vertices; P++) {
                          let W = (0, b.getColorFromStyle)(B.atomArray[P], E), U = 3 * P;
                          B.colorArray[U] = W.r, B.colorArray[U + 1] = W.g, B.colorArray[U + 2] = W.b;
                        }
                    }
                    z[R].finished = !1;
                  }
                }
                return this;
              }
              /**
               * Return surface object
               * @param {number} surf - surface id
               */
              getSurface(m) {
                return this.surfaces[m];
              }
              /**
               * Remove surface with given ID
               * @param {number} surf - surface id
               */
              removeSurface(m) {
                for (var E = this.surfaces[m], z = 0; z < E.length; z++)
                  E[z] && E[z].lastGL && (E[z].geo !== void 0 && E[z].geo.dispose(), E[z].mat !== void 0 && E[z].mat.dispose(), this.modelGroup.remove(E[z].lastGL));
                return delete this.surfaces[m], this.show(), this;
              }
              /** Remove all surfaces.
               **/
              removeAllSurfaces() {
                for (var m in this.surfaces)
                  if (this.surfaces.hasOwnProperty(m)) {
                    for (var E = this.surfaces[m], z = 0; z < E.length; z++)
                      E[z] && E[z].lastGL && (E[z].geo !== void 0 && E[z].geo.dispose(), E[z].mat !== void 0 && E[z].mat.dispose(), this.modelGroup.remove(E[z].lastGL));
                    delete this.surfaces[m];
                  }
                return this.show(), this;
              }
              /** return Jmol moveto command to position this scene */
              jmolMoveTo() {
                var m = this.modelGroup.position, E = "center { " + -m.x + " " + -m.y + " " + -m.z + " }; ", z = this.rotationGroup.quaternion;
                return E += "moveto .5 quaternion { " + z.x + " " + z.y + " " + z.z + " " + z.w + " };", E;
              }
              /** Clear scene of all objects
               * */
              clear() {
                return this.removeAllSurfaces(), this.removeAllModels(), this.removeAllLabels(), this.removeAllShapes(), this.show(), this;
              }
              // props is a list of objects that select certain atoms and enumerate
              // properties for those atoms
              /**
               * Add specified properties to all atoms matching input argument
               * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties
               * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here
                   @example
                   $3Dmol.get('../test_structs/b.sdf', function(data){
                            viewer.addModel(data,'sdf');
                            let props = [];
                            //make the atom index a property x
                            for(let i = 0; i < 8; i++) {
                              props.push({index:i,props:{'x':i}});
                            }
                            viewer.mapAtomProperties(props);
                            viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});
                            viewer.zoomTo();
                            viewer.render();
                          });
               */
              mapAtomProperties(m, E) {
                E = E || {};
                var z = this.getAtomsFromSel(E);
                if (typeof m == "function")
                  for (let B = 0, P = z.length; B < P; B++) {
                    let W = z[B];
                    m(W);
                  }
                else
                  for (let B = 0, P = z.length; B < P; B++) {
                    var O = z[B];
                    for (let W = 0, U = m.length; W < U; W++) {
                      let V = m[W];
                      if (V.props)
                        for (var R in V.props)
                          V.props.hasOwnProperty(R) && this.atomIsSelected(O, V) && (O.properties || (O.properties = {}), O.properties[R] = V.props[R]);
                    }
                  }
                return this;
              }
              /**
               * Synchronize this view matrix of this viewer to the passed viewer.
               * When the viewpoint of this viewer changes, the other viewer will
               * be set to this viewer's view.
               * @param {GLViewer} otherview
               */
              linkViewer(m) {
                return this.linkedViewers.push(m), this;
              }
              /**
               * Return the z distance between the model and the camera
               * @return {number} distance
               */
              getPerceivedDistance() {
                return this.CAMERA_Z - this.rotationGroup.position.z;
              }
              /**
               * Set the distance between the model and the camera
               * Essentially zooming. Useful while stereo rendering.
               */
              setPerceivedDistance(m) {
                this.rotationGroup.position.z = this.CAMERA_Z - m;
              }
              /**
               * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object
               * @return {number} camera x position
               */
              setAutoEyeSeparation(m, E) {
                var z = this.getPerceivedDistance();
                return E || (E = 5), m || this.camera.position.x > 0 ? this.camera.position.x = z * Math.tan(Math.PI / 180 * E) : this.camera.position.x = -z * Math.tan(Math.PI / 180 * E), this.camera.lookAt(new s.Vector3(0, 0, this.rotationGroup.position.z)), this.camera.position.x;
              }
              /**
               * Set the default cartoon quality for newly created models.  Default is 5.
               * Current models are not affected.
               * @number quality, higher results in higher resolution renders
               */
              setDefaultCartoonQuality(m) {
                this.config.cartoonQuality = m;
              }
            }
            o.numWorkers = 4, o.maxVolume = 64e3, o.surfaceTypeMap = {
              VDW: $.SurfaceType.VDW,
              MS: $.SurfaceType.MS,
              SAS: $.SurfaceType.SAS,
              SES: $.SurfaceType.SES
            };
            function v(F, m) {
              if (F = (0, b.getElement)(F), !!F) {
                m = m || {};
                try {
                  var E = new o(F, m);
                  return E;
                } catch (z) {
                  throw "error creating viewer: " + z;
                }
              }
            }
            function w(F, m = {}, E = {}) {
              if (F = (0, b.getElement)(F), !!F) {
                var z = [], O = document.createElement("canvas");
                E.rows = m.rows, E.cols = m.cols, E.control_all = m.control_all != null ? m.control_all : !1, F.appendChild(O);
                try {
                  for (var R = 0; R < m.rows; R++) {
                    for (var B = [], P = 0; P < m.cols; P++) {
                      E.row = R, E.col = P, E.canvas = O, E.viewers = z, E.control_all = m.control_all;
                      var W = v(F, (0, b.extend)({}, E));
                      B.push(W);
                    }
                    z.unshift(B);
                  }
                } catch (U) {
                  throw "error creating viewer grid: " + U;
                }
                return z;
              }
            }
            function M(F) {
              var m = this;
              if (F = (0, b.getElement)(F), !!F) {
                var E = w(F, { rows: 1, cols: 2, control_all: !0 });
                this.glviewer1 = E[0][0], this.glviewer2 = E[0][1], this.glviewer1.setAutoEyeSeparation(!1), this.glviewer2.setAutoEyeSeparation(!0), this.glviewer1.linkViewer(this.glviewer2), this.glviewer2.linkViewer(this.glviewer1);
                for (var z = Object.getOwnPropertyNames(this.glviewer1.__proto__).filter(function(R) {
                  return typeof m.glviewer1[R] == "function";
                }), O = 0; O < z.length; O++)
                  this[z[O]] = /* @__PURE__ */ function(R) {
                    return function() {
                      var B = this.glviewer1[R].apply(this.glviewer1, arguments), P = this.glviewer2[R].apply(this.glviewer2, arguments);
                      return [B, P];
                    };
                  }(z[O]);
                this.setCoordinates = function(R, B, P) {
                  for (var W = 0; W < R.length; W++)
                    R[W].setCoordinates(B, P);
                }, this.surfacesFinished = function() {
                  return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();
                }, this.isAnimated = function() {
                  return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();
                }, this.render = function(R) {
                  this.glviewer1.render(), this.glviewer2.render(), R && R(this);
                }, this.getCanvas = function() {
                  return this.glviewer1.getCanvas();
                };
              }
            }
          }
        ),
        /***/
        "./src/Gradient.ts": (
          /*!*************************!*\
            !*** ./src/Gradient.ts ***!
            \*************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CustomLinear: () => (
                /* binding */
                x
              ),
              /* harmony export */
              Gradient: () => (
                /* binding */
                $
              ),
              /* harmony export */
              GradientType: () => (
                /* binding */
                s
              ),
              /* harmony export */
              ROYGB: () => (
                /* binding */
                _
              ),
              /* harmony export */
              RWB: () => (
                /* binding */
                g
              ),
              /* harmony export */
              Sinebow: () => (
                /* binding */
                A
              ),
              /* harmony export */
              builtinGradients: () => (
                /* binding */
                k
              ),
              /* harmony export */
              getGradient: () => (
                /* binding */
                b
              ),
              /* harmony export */
              normalizeValue: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./colors */
              "./src/colors.ts"
            );
            class s {
            }
            function h(C, L, y) {
              return L >= C ? (y < C && (y = C), y > L && (y = L), { lo: C, hi: L, val: y }) : (y > C && (y = C), y < L && (y = L), y = C - y + L, { lo: L, hi: C, val: y });
            }
            function b(C) {
              if (C instanceof s)
                return C;
              if (C.gradient !== void 0 && k[C.gradient]) {
                let L = C.min === void 0 ? -1 : C.min, y = C.max === void 0 ? 1 : C.max;
                return C.mid === void 0 ? C.colors === void 0 ? new k[C.gradient](L, y) : new k[C.gradient](L, y, C.colors) : new k[C.gradient](L, y, C.mid);
              } else if (typeof C.gradient == "string" && C.gradient.startsWith("linear_")) {
                let L = C.gradient.split("_");
                L.shift();
                let y = C.min === void 0 ? -1 : C.min, o = C.max === void 0 ? 1 : C.max;
                return new x(y, o, L);
              }
              return C;
            }
            class g extends s {
              constructor(L, y, o) {
                super(), this.gradient = "RWB", this.mult = 1, this.mid = o, this.min = L, this.max = y, typeof y > "u" && Array.isArray(L) && L.length >= 2 ? (this.max = L[1], this.min = L[0]) : L && y && !Array.isArray(L) && (this.min = L, this.max = y);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(L, y) {
                var o, v;
                if (L = this.mult * L, y ? (o = y[0], v = y[1]) : (o = this.min, v = this.max), L === void 0)
                  return 16777215;
                var w = h(o, v, L);
                o = w.lo, v = w.hi, L = w.val;
                var M = (v + o) / 2;
                y && typeof y[2] < "u" ? M = y[2] : typeof this.mid < "u" ? M = this.mid : M = (o + v) / 2;
                var F, m;
                return L < M ? (F = Math.floor(255 * Math.sqrt((L - o) / (M - o))), m = 16711680 + 256 * F + F, m) : L > M ? (F = Math.floor(255 * Math.sqrt(1 - (L - M) / (v - M))), m = 65536 * F + 256 * F + 255, m) : 16777215;
              }
            }
            class _ extends s {
              constructor(L, y) {
                super(), this.gradient = "ROYGB", this.mult = 1, this.min = L, this.max = y, typeof y > "u" && Array.isArray(L) && L.length >= 2 ? (this.max = L[1], this.min = L[0]) : L && y && !Array.isArray(L) && (this.min = L, this.max = y);
              }
              //map value to hex color, range is provided
              valueToHex(L, y) {
                var o, v;
                if (L = this.mult * L, y ? (o = y[0], v = y[1]) : (o = this.min, v = this.max), typeof L > "u")
                  return 16777215;
                var w = h(o, v, L);
                o = w.lo, v = w.hi, L = w.val;
                var M = (o + v) / 2, F = (o + M) / 2, m = (M + v) / 2, E, z;
                return L < F ? (E = Math.floor(255 * Math.sqrt((L - o) / (F - o))), z = 16711680 + 256 * E + 0, z) : L < M ? (E = Math.floor(255 * Math.sqrt(1 - (L - F) / (M - F))), z = 65536 * E + 65280 + 0, z) : L < m ? (E = Math.floor(255 * Math.sqrt((L - M) / (m - M))), z = 65280 + 1 * E, z) : (E = Math.floor(255 * Math.sqrt(1 - (L - m) / (v - m))), z = 0 + 256 * E + 255, z);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class A extends s {
              constructor(L, y) {
                super(), this.gradient = "Sinebow", this.mult = 1, this.min = L, this.max = y, typeof y > "u" && Array.isArray(L) && L.length >= 2 && (this.max = L[1], this.min = L[0]), y < L && (this.mult = -1, this.min *= -1, this.max *= -1);
              }
              //map value to hex color, range is provided
              valueToHex(L, y) {
                var o, v;
                if (L = this.mult * L, y ? (o = y[0], v = y[1]) : (o = this.min, v = this.max), typeof L > "u")
                  return 16777215;
                var w = $.normalizeValue(o, v, L);
                o = w.lo, v = w.hi, L = w.val;
                var M = (L - o) / (v - o), F = 5 * M / 6 + 0.5, m = Math.sin(Math.PI * F);
                m *= m * 255;
                var E = Math.sin(Math.PI * (F + 1 / 3));
                E *= E * 255;
                var z = Math.sin(Math.PI * (F + 2 / 3));
                return z *= z * 255, 65536 * Math.floor(m) + 256 * Math.floor(z) + 1 * Math.floor(E);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class x extends s {
              constructor(L, y, o) {
                super(), this.gradient = "linear", this.colors = new Array();
                var v;
                if (Array.isArray(L) && L.length >= 2 ? (this.max = L[1], this.min = L[0], v = y) : (this.min = L, this.max = y, v = o), v)
                  for (let w of v)
                    this.colors.push(n.CC.color(w));
                else
                  this.colors.push(n.CC.color(0));
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(L, y) {
                var o, v;
                if (y ? (o = y[0], v = y[1]) : (o = this.min, v = this.max), L === void 0)
                  return 16777215;
                var w = h(o, v, L);
                o = w.lo, v = w.hi, L = w.val;
                let M = this.colors.length, F = (v - o) / M, m = Math.min(Math.floor((L - o) / F), M - 1), E = Math.min(m + 1, M - 1), z = (L - o - m * F) / F, O = this.colors[m], R = this.colors[E];
                return new n.Color(O.r + z * (R.r - O.r), O.g + z * (R.g - O.g), O.b + z * (R.b - O.b)).getHex();
              }
            }
            const k = {
              rwb: g,
              RWB: g,
              roygb: _,
              ROYGB: _,
              sinebow: A,
              linear: x
            };
            class $ extends s {
              valueToHex(L, y) {
                return 0;
              }
              range() {
                return null;
              }
            }
            $.RWB = g, $.ROYGB = _, $.Sinebow = A, $.CustomLinear = x, $.builtinGradients = k, $.normalizeValue = h, $.getGradient = b;
          }
        ),
        /***/
        "./src/Label.ts": (
          /*!**********************!*\
            !*** ./src/Label.ts ***!
            \**********************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Label: () => (
                /* binding */
                A
              ),
              /* harmony export */
              LabelCount: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), h = r(
              /*! ./colors */
              "./src/colors.ts"
            );
            let b = 0;
            function g(x, k, $, C, L, y, o) {
              x.beginPath(), x.moveTo(k + y, $), x.lineTo(k + C - y, $), x.quadraticCurveTo(k + C, $, k + C, $ + y), x.lineTo(k + C, $ + L - y), x.quadraticCurveTo(k + C, $ + L, k + C - y, $ + L), x.lineTo(k + y, $ + L), x.quadraticCurveTo(k, $ + L, k, $ + L - y), x.lineTo(k, $ + y), x.quadraticCurveTo(k, $, k + y, $), x.closePath(), x.fill(), o && x.stroke();
            }
            function _(x, k, $) {
              var C = $;
              return typeof x < "u" && (x instanceof h.Color ? C = x.scaled() : (C = h.CC.color(x), typeof C.scaled < "u" && (C = C.scaled()))), typeof k < "u" && (C.a = parseFloat(k)), C;
            }
            class A {
              constructor(k, $) {
                this.id = b++, this.stylespec = $ || {}, this.canvas = document.createElement("canvas"), this.canvas.width = 134, this.canvas.height = 35, this.context = this.canvas.getContext("2d"), this.sprite = new n.Sprite(), this.text = k, this.frame = this.stylespec.frame;
              }
              getStyle() {
                return this.stylespec;
              }
              /** Hide this label. */
              hide() {
                this.sprite.visible = !1;
              }
              /** Show a hidden label. */
              show() {
                this.sprite.visible = !0;
              }
              setContext() {
                var k = this.stylespec, $ = typeof k.useScreen > "u" ? !1 : k.useScreen, C = k.showBackground;
                (C === "0" || C === "false") && (C = !1), typeof C > "u" && (C = !0);
                var L = k.font ? k.font : "sans-serif", y = parseInt(k.fontSize) ? parseInt(k.fontSize) : 18, o = _(k.fontColor, k.fontOpacity, {
                  r: 255,
                  g: 255,
                  b: 255,
                  a: 1
                }), v = k.padding ? k.padding : 4, w = k.borderThickness ? k.borderThickness : 0, M = _(k.backgroundColor, k.backgroundOpacity, {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 1
                }), F = _(k.borderColor, k.borderOpacity, M), m = k.position ? k.position : {
                  x: -10,
                  y: 1,
                  z: 1
                }, E = k.inFront !== void 0 ? k.inFront : !0;
                (E === "false" || E === "0") && (E = !1);
                var z = k.alignment || n.SpriteAlignment.topLeft;
                typeof z == "string" && z in n.SpriteAlignment && (z = n.SpriteAlignment[z]);
                var O = "";
                k.bold && (O = "bold "), this.context.font = O + y + "px  " + L;
                var R = this.context.measureText(this.text), B = R.width;
                C || (w = 0);
                var P = B + 2.5 * w + 2 * v, W = y * 1.25 + 2 * w + 2 * v;
                if (k.backgroundImage) {
                  var U = k.backgroundImage, V = k.backgroundWidth ? k.backgroundWidth : U.width, K = k.backgroundHeight ? k.backgroundHeight : U.height;
                  V > P && (P = V), K > W && (W = K);
                }
                if (this.canvas.width = P, this.canvas.height = W, this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), O = "", k.bold && (O = "bold "), this.context.font = O + y + "px  " + L, this.context.fillStyle = "rgba(" + M.r + "," + M.g + "," + M.b + "," + M.a + ")", this.context.strokeStyle = "rgba(" + F.r + "," + F.g + "," + F.b + "," + F.a + ")", k.backgroundGradient) {
                  let H = this.context.createLinearGradient(0, W / 2, P, W / 2), j = s.Gradient.getGradient(k.backgroundGradient), Q = j.range(), J = -1, Y = 1;
                  Q && (J = Q[0], Y = Q[1]);
                  let ee = Y - J;
                  for (let fe = 0; fe < 1.01; fe += 0.1) {
                    let me = _(j.valueToHex(J + ee * fe)), he = "rgba(" + me.r + "," + me.g + "," + me.b + "," + me.a + ")";
                    H.addColorStop(fe, he);
                  }
                  this.context.fillStyle = H;
                }
                this.context.lineWidth = w, C && g(this.context, w, w, P - 2 * w, W - 2 * w, 6, w > 0), k.backgroundImage && this.context.drawImage(U, 0, 0, P, W), this.context.fillStyle = "rgba(" + o.r + "," + o.g + "," + o.b + "," + o.a + ")", this.context.fillText(this.text, w + v, y + w + v, B);
                var q = new n.Texture(this.canvas);
                q.needsUpdate = !0, this.sprite.material = new n.SpriteMaterial({
                  map: q,
                  useScreenCoordinates: $,
                  alignment: z,
                  depthTest: !E,
                  screenOffset: k.screenOffset || null
                }), this.sprite.scale.set(1, 1, 1), this.sprite.position.set(m.x, m.y, m.z);
              }
              // clean up material and texture
              dispose() {
                this.sprite.material.map !== void 0 && this.sprite.material.map.dispose(), this.sprite.material !== void 0 && this.sprite.material.dispose();
              }
            }
          }
        ),
        /***/
        "./src/ProteinSurface4.ts": (
          /*!********************************!*\
            !*** ./src/ProteinSurface4.ts ***!
            \********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MarchingCube: () => (
                /* binding */
                _
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* binding */
                g
              ),
              /* harmony export */
              PointGrid: () => (
                /* binding */
                A
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* binding */
                x
              ),
              /* harmony export */
              SurfaceType: () => (
                /* binding */
                s
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* binding */
                b
              ),
              /* harmony export */
              syncSurface: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), s;
            (function(k) {
              k[k.VDW = 1] = "VDW", k[k.MS = 2] = "MS", k[k.SAS = 3] = "SAS", k[k.SES = 4] = "SES";
            })(s || (s = {}));
            var h = !1;
            function b(k) {
              h = k;
            }
            (window.navigator.userAgent.indexOf("MSIE ") >= 0 || window.navigator.userAgent.indexOf("Trident/") >= 0) && (h = !0);
            class g {
              constructor() {
                this.ISDONE = 2, this.edgeTable = new Uint32Array([
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  2816,
                  0,
                  0,
                  0,
                  1792,
                  0,
                  3328,
                  3584,
                  3840,
                  0,
                  0,
                  0,
                  138,
                  0,
                  21,
                  0,
                  134,
                  0,
                  0,
                  0,
                  652,
                  0,
                  2067,
                  3865,
                  3600,
                  0,
                  0,
                  0,
                  42,
                  0,
                  0,
                  0,
                  294,
                  0,
                  0,
                  21,
                  28,
                  0,
                  3875,
                  1049,
                  3360,
                  0,
                  168,
                  162,
                  170,
                  0,
                  645,
                  2475,
                  2210,
                  0,
                  687,
                  293,
                  172,
                  4010,
                  3747,
                  3497,
                  3232,
                  0,
                  0,
                  0,
                  0,
                  0,
                  69,
                  0,
                  900,
                  0,
                  0,
                  0,
                  1792,
                  138,
                  131,
                  1608,
                  1920,
                  0,
                  81,
                  0,
                  2074,
                  84,
                  85,
                  84,
                  86,
                  0,
                  81,
                  0,
                  3676,
                  330,
                  1105,
                  1881,
                  1616,
                  0,
                  0,
                  0,
                  42,
                  0,
                  69,
                  0,
                  502,
                  0,
                  0,
                  21,
                  3580,
                  138,
                  2035,
                  1273,
                  1520,
                  2816,
                  104,
                  2337,
                  106,
                  840,
                  581,
                  367,
                  102,
                  2816,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  3910,
                  0,
                  0,
                  69,
                  588,
                  42,
                  2083,
                  41,
                  2880,
                  0,
                  0,
                  0,
                  1722,
                  0,
                  2293,
                  4095,
                  3830,
                  0,
                  255,
                  757,
                  764,
                  2538,
                  2291,
                  3065,
                  2800,
                  0,
                  0,
                  81,
                  338,
                  0,
                  3925,
                  1119,
                  3414,
                  84,
                  855,
                  85,
                  340,
                  2130,
                  2899,
                  89,
                  2384,
                  1792,
                  712,
                  194,
                  1162,
                  4036,
                  3781,
                  3535,
                  3270,
                  708,
                  719,
                  197,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  0,
                  0,
                  0,
                  0,
                  168,
                  420,
                  168,
                  1958,
                  162,
                  162,
                  676,
                  2988,
                  170,
                  163,
                  680,
                  928,
                  3328,
                  3096,
                  3328,
                  3642,
                  52,
                  53,
                  1855,
                  1590,
                  2340,
                  2111,
                  2869,
                  2620,
                  298,
                  51,
                  825,
                  560,
                  3584,
                  3584,
                  3090,
                  3482,
                  1668,
                  1941,
                  1183,
                  1430,
                  146,
                  2975,
                  2069,
                  2460,
                  154,
                  915,
                  153,
                  400,
                  3840,
                  3592,
                  3329,
                  3082,
                  1796,
                  1541,
                  1295,
                  1030,
                  2818,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ]), this.triTable = [
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [11, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [],
                  [10, 8, 11],
                  [9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [],
                  [],
                  [],
                  [1, 7, 3],
                  [],
                  [4, 2, 0],
                  [],
                  [2, 1, 7],
                  [],
                  [],
                  [],
                  [2, 7, 3, 2, 9, 7],
                  [],
                  [1, 4, 11, 1, 0, 4],
                  [3, 8, 0, 11, 9, 4, 11, 10, 9],
                  [4, 11, 9, 11, 10, 9],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [],
                  [],
                  [2, 5, 8, 2, 1, 5],
                  [],
                  [],
                  [2, 4, 0],
                  [3, 2, 4],
                  [],
                  [0, 9, 1, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4],
                  [5, 8, 10, 8, 11, 10],
                  [],
                  [3, 5, 7],
                  [7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [],
                  [9, 2, 0, 9, 7, 2],
                  [0, 3, 8, 1, 7, 11, 1, 5, 7],
                  [11, 1, 7, 1, 5, 7],
                  [],
                  [9, 1, 0, 5, 3, 2, 5, 7, 3],
                  [8, 2, 5, 8, 0, 2],
                  [2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 2, 9, 7, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [7, 1, 3],
                  [7, 1, 0],
                  [6, 9, 3, 6, 10, 9],
                  [7, 10, 8, 10, 9, 8],
                  [],
                  [6, 0, 4],
                  [],
                  [11, 1, 4, 11, 3, 1],
                  [2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [2, 4, 6],
                  [1, 4, 2, 4, 6, 2],
                  [],
                  [6, 0, 4],
                  [],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 6, 1, 8, 1, 3],
                  [10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [],
                  [],
                  [2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [9, 11, 8],
                  [3, 5, 6],
                  [0, 5, 11, 0, 11, 8],
                  [6, 3, 5, 3, 1, 5],
                  [3, 9, 6, 3, 8, 9],
                  [9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [1, 10, 2, 9, 11, 6, 9, 8, 11],
                  [],
                  [],
                  [6, 0, 2],
                  [3, 6, 9, 3, 2, 6],
                  [3, 5, 1],
                  [0, 5, 1, 0, 11, 5],
                  [0, 3, 5],
                  [6, 9, 11, 9, 8, 11],
                  [],
                  [],
                  [],
                  [4, 5, 9, 7, 1, 10, 7, 3, 1],
                  [],
                  [11, 6, 7, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [],
                  [],
                  [0, 6, 4],
                  [8, 6, 4, 8, 1, 6],
                  [],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [4, 2, 6],
                  [1, 0, 9, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [8, 2, 4, 2, 6, 4],
                  [11, 4, 1, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [10, 8, 9],
                  [6, 3, 9, 6, 7, 3],
                  [6, 7, 1],
                  [10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [],
                  [],
                  [],
                  [],
                  [5, 3, 7],
                  [8, 5, 2, 8, 7, 5],
                  [5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [1, 7, 5],
                  [1, 7, 5],
                  [9, 2, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [0, 7, 1, 7, 5, 1],
                  [9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [8, 10, 11],
                  [3, 4, 10, 3, 10, 11],
                  [8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [2, 4, 5],
                  [5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [2, 8, 5, 2, 11, 8],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [11, 9, 10],
                  [11, 9, 10],
                  [1, 11, 4, 1, 10, 11],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 7, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [1, 7, 4],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [3, 9, 11, 9, 10, 11],
                  [0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ], this.edgeTable2 = [
                  0,
                  265,
                  515,
                  778,
                  2060,
                  2309,
                  2575,
                  2822,
                  1030,
                  1295,
                  1541,
                  1804,
                  3082,
                  3331,
                  3593,
                  3840,
                  400,
                  153,
                  915,
                  666,
                  2460,
                  2197,
                  2975,
                  2710,
                  1430,
                  1183,
                  1941,
                  1692,
                  3482,
                  3219,
                  3993,
                  3728,
                  560,
                  825,
                  51,
                  314,
                  2620,
                  2869,
                  2111,
                  2358,
                  1590,
                  1855,
                  1077,
                  1340,
                  3642,
                  3891,
                  3129,
                  3376,
                  928,
                  681,
                  419,
                  170,
                  2988,
                  2725,
                  2479,
                  2214,
                  1958,
                  1711,
                  1445,
                  1196,
                  4010,
                  3747,
                  3497,
                  3232,
                  2240,
                  2505,
                  2755,
                  3018,
                  204,
                  453,
                  719,
                  966,
                  3270,
                  3535,
                  3781,
                  4044,
                  1226,
                  1475,
                  1737,
                  1984,
                  2384,
                  2137,
                  2899,
                  2650,
                  348,
                  85,
                  863,
                  598,
                  3414,
                  3167,
                  3925,
                  3676,
                  1370,
                  1107,
                  1881,
                  1616,
                  2800,
                  3065,
                  2291,
                  2554,
                  764,
                  1013,
                  255,
                  502,
                  3830,
                  4095,
                  3317,
                  3580,
                  1786,
                  2035,
                  1273,
                  1520,
                  2912,
                  2665,
                  2403,
                  2154,
                  876,
                  613,
                  367,
                  102,
                  3942,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  1120,
                  1385,
                  1635,
                  1898,
                  3180,
                  3429,
                  3695,
                  3942,
                  102,
                  367,
                  613,
                  876,
                  2154,
                  2403,
                  2665,
                  2912,
                  1520,
                  1273,
                  2035,
                  1786,
                  3580,
                  3317,
                  4095,
                  3830,
                  502,
                  255,
                  1013,
                  764,
                  2554,
                  2291,
                  3065,
                  2800,
                  1616,
                  1881,
                  1107,
                  1370,
                  3676,
                  3925,
                  3167,
                  3414,
                  598,
                  863,
                  85,
                  348,
                  2650,
                  2899,
                  2137,
                  2384,
                  1984,
                  1737,
                  1475,
                  1226,
                  4044,
                  3781,
                  3535,
                  3270,
                  966,
                  719,
                  453,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  3232,
                  3497,
                  3747,
                  4010,
                  1196,
                  1445,
                  1711,
                  1958,
                  2214,
                  2479,
                  2725,
                  2988,
                  170,
                  419,
                  681,
                  928,
                  3376,
                  3129,
                  3891,
                  3642,
                  1340,
                  1077,
                  1855,
                  1590,
                  2358,
                  2111,
                  2869,
                  2620,
                  314,
                  51,
                  825,
                  560,
                  3728,
                  3993,
                  3219,
                  3482,
                  1692,
                  1941,
                  1183,
                  1430,
                  2710,
                  2975,
                  2197,
                  2460,
                  666,
                  915,
                  153,
                  400,
                  3840,
                  3593,
                  3331,
                  3082,
                  1804,
                  1541,
                  1295,
                  1030,
                  2822,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ], this.triTable2 = [
                  [],
                  [8, 3, 0],
                  [9, 0, 1],
                  [8, 3, 1, 8, 1, 9],
                  [11, 2, 3],
                  [11, 2, 0, 11, 0, 8],
                  [11, 2, 3, 0, 1, 9],
                  [2, 1, 11, 1, 9, 11, 11, 9, 8],
                  [10, 1, 2],
                  [8, 3, 0, 1, 2, 10],
                  [9, 0, 2, 9, 2, 10],
                  [3, 2, 8, 2, 10, 8, 8, 10, 9],
                  [10, 1, 3, 10, 3, 11],
                  [1, 0, 10, 0, 8, 10, 10, 8, 11],
                  [0, 3, 9, 3, 11, 9, 9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [8, 4, 7],
                  [3, 0, 4, 3, 4, 7],
                  [1, 9, 0, 8, 4, 7],
                  [9, 4, 1, 4, 7, 1, 1, 7, 3],
                  [2, 3, 11, 7, 8, 4],
                  [7, 11, 4, 11, 2, 4, 4, 2, 0],
                  [3, 11, 2, 4, 7, 8, 9, 0, 1],
                  [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4],
                  [10, 1, 2, 8, 4, 7],
                  [2, 10, 1, 0, 4, 7, 0, 7, 3],
                  [4, 7, 8, 0, 2, 10, 0, 10, 9],
                  [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],
                  [8, 4, 7, 11, 10, 1, 11, 1, 3],
                  [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],
                  [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],
                  [7, 11, 4, 4, 11, 9, 11, 10, 9],
                  [9, 5, 4],
                  [3, 0, 8, 4, 9, 5],
                  [5, 4, 0, 5, 0, 1],
                  [4, 8, 5, 8, 3, 5, 5, 3, 1],
                  [11, 2, 3, 9, 5, 4],
                  [9, 5, 4, 8, 11, 2, 8, 2, 0],
                  [3, 11, 2, 1, 5, 4, 1, 4, 0],
                  [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5],
                  [2, 10, 1, 9, 5, 4],
                  [0, 8, 3, 5, 4, 9, 10, 1, 2],
                  [10, 5, 2, 5, 4, 2, 2, 4, 0],
                  [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],
                  [5, 4, 9, 1, 3, 11, 1, 11, 10],
                  [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],
                  [4, 8, 5, 5, 8, 10, 8, 11, 10],
                  [9, 5, 7, 9, 7, 8],
                  [0, 9, 3, 9, 5, 3, 3, 5, 7],
                  [8, 0, 7, 0, 1, 7, 7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [11, 2, 3, 8, 9, 5, 8, 5, 7],
                  [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],
                  [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],
                  [2, 1, 11, 11, 1, 7, 1, 5, 7],
                  [1, 2, 10, 5, 7, 8, 5, 8, 9],
                  [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],
                  [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],
                  [10, 5, 2, 2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [11, 7, 6],
                  [0, 8, 3, 11, 7, 6],
                  [9, 0, 1, 11, 7, 6],
                  [7, 6, 11, 3, 1, 9, 3, 9, 8],
                  [2, 3, 7, 2, 7, 6],
                  [8, 7, 0, 7, 6, 0, 0, 6, 2],
                  [1, 9, 0, 3, 7, 6, 3, 6, 2],
                  [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],
                  [1, 2, 10, 6, 11, 7],
                  [2, 10, 1, 7, 6, 11, 8, 3, 0],
                  [11, 7, 6, 10, 9, 0, 10, 0, 2],
                  [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],
                  [6, 10, 7, 10, 1, 7, 7, 1, 3],
                  [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],
                  [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],
                  [6, 10, 7, 7, 10, 8, 10, 9, 8],
                  [8, 4, 6, 8, 6, 11],
                  [11, 3, 6, 3, 0, 6, 6, 0, 4],
                  [0, 1, 9, 4, 6, 11, 4, 11, 8],
                  [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],
                  [3, 8, 2, 8, 4, 2, 2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6],
                  [9, 4, 1, 1, 4, 2, 4, 6, 2],
                  [10, 1, 2, 11, 8, 4, 11, 4, 6],
                  [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],
                  [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],
                  [1, 0, 10, 10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [9, 5, 4, 7, 6, 11],
                  [4, 9, 5, 3, 0, 8, 11, 7, 6],
                  [6, 11, 7, 4, 0, 1, 4, 1, 5],
                  [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1],
                  [4, 9, 5, 6, 2, 3, 6, 3, 7],
                  [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],
                  [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [6, 11, 7, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [5, 6, 9, 6, 11, 9, 9, 11, 8],
                  [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],
                  [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],
                  [11, 3, 6, 6, 3, 5, 3, 1, 5],
                  [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],
                  [5, 6, 9, 9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [10, 6, 5],
                  [8, 3, 0, 10, 6, 5],
                  [0, 1, 9, 5, 10, 6],
                  [10, 6, 5, 9, 8, 3, 9, 3, 1],
                  [3, 11, 2, 10, 6, 5],
                  [6, 5, 10, 2, 0, 8, 2, 8, 11],
                  [1, 9, 0, 6, 5, 10, 11, 2, 3],
                  [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11],
                  [1, 2, 6, 1, 6, 5],
                  [0, 8, 3, 2, 6, 5, 2, 5, 1],
                  [5, 9, 6, 9, 0, 6, 6, 0, 2],
                  [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6],
                  [11, 6, 3, 6, 5, 3, 3, 5, 1],
                  [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],
                  [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],
                  [5, 9, 6, 6, 9, 11, 9, 8, 11],
                  [10, 6, 5, 4, 7, 8],
                  [5, 10, 6, 7, 3, 0, 7, 0, 4],
                  [5, 10, 6, 0, 1, 9, 8, 4, 7],
                  [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],
                  [7, 8, 4, 2, 3, 11, 10, 6, 5],
                  [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [7, 8, 4, 5, 1, 2, 5, 2, 6],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [10, 6, 4, 10, 4, 9],
                  [8, 3, 0, 9, 10, 6, 9, 6, 4],
                  [1, 10, 0, 10, 6, 0, 0, 6, 4],
                  [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],
                  [2, 3, 11, 6, 4, 9, 6, 9, 10],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [9, 1, 4, 1, 2, 4, 4, 2, 6],
                  [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [3, 2, 8, 8, 2, 4, 2, 6, 4],
                  [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [11, 6, 3, 3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [6, 7, 10, 7, 8, 10, 10, 8, 9],
                  [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],
                  [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],
                  [6, 7, 10, 10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [8, 0, 7, 7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [11, 7, 5, 11, 5, 10],
                  [3, 0, 8, 7, 5, 10, 7, 10, 11],
                  [9, 0, 1, 10, 11, 7, 10, 7, 5],
                  [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],
                  [10, 2, 5, 2, 3, 5, 5, 3, 7],
                  [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],
                  [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [2, 11, 1, 11, 7, 1, 1, 7, 5],
                  [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],
                  [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [8, 7, 0, 0, 7, 1, 7, 5, 1],
                  [0, 3, 9, 9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [4, 5, 8, 5, 10, 8, 8, 10, 11],
                  [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],
                  [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],
                  [10, 2, 5, 5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [4, 5, 8, 8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [7, 4, 11, 4, 9, 11, 11, 9, 10],
                  [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],
                  [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [7, 4, 11, 11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [9, 1, 4, 4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [0, 9, 3, 3, 9, 11, 9, 10, 11],
                  [1, 10, 0, 0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [3, 8, 2, 2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [2, 11, 1, 1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ];
              }
              march($, C, L, y) {
                let o = !!y.fulltable, v = y.hasOwnProperty("origin") && y.origin.hasOwnProperty("x") ? y.origin : { x: 0, y: 0, z: 0 }, w = !!y.voxel, M = y.matrix, F = y.nX || 0, m = y.nY || 0, E = y.nZ || 0, z = y.scale || 1, O = null;
                y.unitCube ? O = y.unitCube : O = { x: z, y: z, z };
                let R = new Int32Array(F * m * E), B, P;
                for (B = 0, P = R.length; B < P; ++B)
                  R[B] = -1;
                let W = function(q, H, j, Q, J, Y) {
                  let ee = { x: 0, y: 0, z: 0 }, fe = !!(Q & 1 << J), me = !!(Q & 1 << Y), he = J;
                  if (!fe && me && (he = Y), he & 1 && j++, he & 2 && H++, he & 4 && q++, M) {
                    let ye = new n.Vector3(q, H, j);
                    ye = ye.applyMatrix4(M), ee = { x: ye.x, y: ye.y, z: ye.z };
                  } else
                    ee.x = v.x + O.x * q, ee.y = v.y + O.y * H, ee.z = v.z + O.z * j;
                  let we = (m * q + H) * E + j;
                  return w ? (C.push(ee), C.length - 1) : (R[we] < 0 && (R[we] = C.length, C.push(ee)), R[we]);
                }, U = new Int32Array(12), V = o ? this.edgeTable2 : this.edgeTable, K = o ? this.triTable2 : this.triTable;
                for (B = 0; B < F - 1; ++B)
                  for (let q = 0; q < m - 1; ++q)
                    for (let H = 0; H < E - 1; ++H) {
                      let j = 0;
                      for (let Y = 0; Y < 8; ++Y) {
                        let ee = (m * (B + ((Y & 4) >> 2)) + q + ((Y & 2) >> 1)) * E + H + (Y & 1), fe = !!($[ee] & this.ISDONE);
                        j |= fe << Y;
                      }
                      if (j === 0 || j === 255)
                        continue;
                      let Q = V[j];
                      if (Q === 0)
                        continue;
                      let J = K[j];
                      Q & 1 && (U[0] = W(B, q, H, j, 0, 1)), Q & 2 && (U[1] = W(B, q, H, j, 1, 3)), Q & 4 && (U[2] = W(B, q, H, j, 3, 2)), Q & 8 && (U[3] = W(B, q, H, j, 2, 0)), Q & 16 && (U[4] = W(B, q, H, j, 4, 5)), Q & 32 && (U[5] = W(B, q, H, j, 5, 7)), Q & 64 && (U[6] = W(B, q, H, j, 7, 6)), Q & 128 && (U[7] = W(B, q, H, j, 6, 4)), Q & 256 && (U[8] = W(B, q, H, j, 0, 4)), Q & 512 && (U[9] = W(B, q, H, j, 1, 5)), Q & 1024 && (U[10] = W(B, q, H, j, 3, 7)), Q & 2048 && (U[11] = W(B, q, H, j, 2, 6));
                      for (let Y = 0; Y < J.length; Y += 3) {
                        let ee = U[J[Y]], fe = U[J[Y + 1]], me = U[J[Y + 2]];
                        w && Y >= 3 && (C.push(C[ee]), ee = C.length - 1, C.push(C[fe]), fe = C.length - 1, C.push(C[me]), me = C.length - 1), L.push(ee), L.push(fe), L.push(me);
                      }
                    }
              }
              laplacianSmooth($, C, L) {
                let y = new Array(C.length), o, v, w, M, F;
                for (o = 0, v = C.length; o < v; o++)
                  y[o] = {
                    x: 0,
                    y: 0,
                    z: 0
                  };
                let m = new Array(20), E;
                for (o = 0; o < 20; o++)
                  m[o] = new Array(C.length);
                for (o = 0, v = C.length; o < v; o++)
                  m[0][o] = 0;
                for (o = 0, v = L.length / 3; o < v; o++) {
                  let R = o * 3, B = o * 3 + 1, P = o * 3 + 2;
                  for (E = !0, w = 0, M = m[0][L[R]]; w < M; w++)
                    if (L[B] == m[w + 1][L[R]]) {
                      E = !1;
                      break;
                    }
                  for (E && (m[0][L[R]]++, m[m[0][L[R]]][L[R]] = L[B]), E = !0, w = 0, M = m[0][L[R]]; w < M; w++)
                    if (L[P] == m[w + 1][L[R]]) {
                      E = !1;
                      break;
                    }
                  for (E && (m[0][L[R]]++, m[m[0][L[R]]][L[R]] = L[P]), E = !0, w = 0, M = m[0][L[B]]; w < M; w++)
                    if (L[R] == m[w + 1][L[B]]) {
                      E = !1;
                      break;
                    }
                  for (E && (m[0][L[B]]++, m[m[0][L[B]]][L[B]] = L[R]), E = !0, w = 0, M = m[0][L[B]]; w < M; w++)
                    if (L[P] == m[w + 1][L[B]]) {
                      E = !1;
                      break;
                    }
                  for (E && (m[0][L[B]]++, m[m[0][L[B]]][L[B]] = L[P]), E = !0, w = 0; w < m[0][L[P]]; w++)
                    if (L[R] == m[w + 1][L[P]]) {
                      E = !1;
                      break;
                    }
                  for (E && (m[0][L[P]]++, m[m[0][L[P]]][L[P]] = L[R]), E = !0, w = 0, M = m[0][L[P]]; w < M; w++)
                    if (L[B] == m[w + 1][L[P]]) {
                      E = !1;
                      break;
                    }
                  E && (m[0][L[P]]++, m[m[0][L[P]]][L[P]] = L[B]);
                }
                let z = 1, O = 0.5;
                for (F = 0; F < $; F++) {
                  for (o = 0, v = C.length; o < v; o++)
                    if (m[0][o] < 3)
                      y[o].x = C[o].x, y[o].y = C[o].y, y[o].z = C[o].z;
                    else if (m[0][o] == 3 || m[0][o] == 4) {
                      for (y[o].x = 0, y[o].y = 0, y[o].z = 0, w = 0, M = m[0][o]; w < M; w++)
                        y[o].x += C[m[w + 1][o]].x, y[o].y += C[m[w + 1][o]].y, y[o].z += C[m[w + 1][o]].z;
                      y[o].x += O * C[o].x, y[o].y += O * C[o].y, y[o].z += O * C[o].z, y[o].x /= O + m[0][o], y[o].y /= O + m[0][o], y[o].z /= O + m[0][o];
                    } else {
                      for (y[o].x = 0, y[o].y = 0, y[o].z = 0, w = 0, M = m[0][o]; w < M; w++)
                        y[o].x += C[m[w + 1][o]].x, y[o].y += C[m[w + 1][o]].y, y[o].z += C[m[w + 1][o]].z;
                      y[o].x += z * C[o].x, y[o].y += z * C[o].y, y[o].z += z * C[o].z, y[o].x /= z + m[0][o], y[o].y /= z + m[0][o], y[o].z /= z + m[0][o];
                    }
                  for (o = 0, v = C.length; o < v; o++)
                    C[o].x = y[o].x, C[o].y = y[o].y, C[o].z = y[o].z;
                }
              }
            }
            let _ = new g();
            class A {
              constructor($, C, L) {
                this.data = new Int32Array($ * C * L * 3), this.width = C, this.height = L;
              }
              // set position x,y,z to pt, which has ix,iy,and iz
              set($, C, L, y) {
                let o = (($ * this.width + C) * this.height + L) * 3;
                this.data[o] = y.ix, this.data[o + 1] = y.iy, this.data[o + 2] = y.iz;
              }
              // return point at x,y,z
              get($, C, L) {
                let y = (($ * this.width + C) * this.height + L) * 3;
                return {
                  ix: this.data[y],
                  iy: this.data[y + 1],
                  iz: this.data[y + 2]
                };
              }
            }
            class x {
              constructor() {
                this.INOUT = 1, this.ISDONE = 2, this.ISBOUND = 4, this.ptranx = 0, this.ptrany = 0, this.ptranz = 0, this.probeRadius = 1.4, this.defaultScaleFactor = 2, this.scaleFactor = this.defaultScaleFactor, this.pHeight = 0, this.pWidth = 0, this.pLength = 0, this.cutRadius = 0, this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, this.pminx = 0, this.pminy = 0, this.pminz = 0, this.pmaxx = 0, this.pmaxy = 0, this.pmaxz = 0, this.depty = {}, this.widxz = {}, this.faces = [], this.verts = [], this.vdwRadii = {
                  H: 1.2,
                  Li: 1.82,
                  Na: 2.27,
                  K: 2.75,
                  C: 1.7,
                  N: 1.55,
                  O: 1.52,
                  F: 1.47,
                  P: 1.8,
                  S: 1.8,
                  CL: 1.75,
                  BR: 1.85,
                  SE: 1.9,
                  ZN: 1.39,
                  CU: 1.4,
                  NI: 1.63,
                  X: 2
                }, this.nb = [
                  new Int32Array([1, 0, 0]),
                  new Int32Array([-1, 0, 0]),
                  new Int32Array([0, 1, 0]),
                  new Int32Array([0, -1, 0]),
                  new Int32Array([0, 0, 1]),
                  new Int32Array([0, 0, -1]),
                  new Int32Array([1, 1, 0]),
                  new Int32Array([1, -1, 0]),
                  new Int32Array([-1, 1, 0]),
                  new Int32Array([-1, -1, 0]),
                  new Int32Array([1, 0, 1]),
                  new Int32Array([1, 0, -1]),
                  new Int32Array([-1, 0, 1]),
                  new Int32Array([-1, 0, -1]),
                  new Int32Array([0, 1, 1]),
                  new Int32Array([0, 1, -1]),
                  new Int32Array([0, -1, 1]),
                  new Int32Array([0, -1, -1]),
                  new Int32Array([1, 1, 1]),
                  new Int32Array([1, 1, -1]),
                  new Int32Array([1, -1, 1]),
                  new Int32Array([-1, 1, 1]),
                  new Int32Array([1, -1, -1]),
                  new Int32Array([-1, -1, 1]),
                  new Int32Array([-1, 1, -1]),
                  new Int32Array([-1, -1, -1])
                ], x.MarchingCube || (x.MarchingCube = new g());
              }
              getVDWIndex($) {
                return !$.elem || typeof this.vdwRadii[$.elem] > "u" ? "X" : $.elem;
              }
              getFacesAndVertices($) {
                let C = {};
                for (let o = 0, v = $.length; o < v; o++)
                  C[$[o]] = !0;
                let L = this.verts;
                for (let o = 0, v = L.length; o < v; o++)
                  L[o].x = L[o].x / this.scaleFactor - this.ptranx, L[o].y = L[o].y / this.scaleFactor - this.ptrany, L[o].z = L[o].z / this.scaleFactor - this.ptranz;
                let y = [];
                for (let o = 0, v = this.faces.length; o < v; o += 3) {
                  let w = this.faces[o], M = this.faces[o + 1], F = this.faces[o + 2], m = L[w].atomid, E = L[M].atomid, z = L[F].atomid, O = m;
                  E < O && (O = E), z < O && (O = z), C[O] && w !== M && M !== F && w !== F && (y.push(w), y.push(M), y.push(F));
                }
                return this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, {
                  vertices: L,
                  faces: y
                };
              }
              initparm($, C, L) {
                L > 1e6 && (this.scaleFactor = this.defaultScaleFactor / 2);
                let y = 1 / this.scaleFactor * 5.5;
                this.pminx = $[0][0], this.pmaxx = $[1][0], this.pminy = $[0][1], this.pmaxy = $[1][1], this.pminz = $[0][2], this.pmaxz = $[1][2], C ? (this.pminx -= this.probeRadius + y, this.pminy -= this.probeRadius + y, this.pminz -= this.probeRadius + y, this.pmaxx += this.probeRadius + y, this.pmaxy += this.probeRadius + y, this.pmaxz += this.probeRadius + y) : (this.pminx -= y, this.pminy -= y, this.pminz -= y, this.pmaxx += y, this.pmaxy += y, this.pmaxz += y), this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor, this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor, this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor, this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor, this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor, this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor, this.ptranx = -this.pminx, this.ptrany = -this.pminy, this.ptranz = -this.pminz, this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1, this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1, this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1, this.boundingatom(C), this.cutRadius = this.probeRadius * this.scaleFactor, this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight), this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight), this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);
              }
              boundingatom($) {
                let C = {};
                for (const L in this.vdwRadii) {
                  let y = this.vdwRadii[L];
                  $ ? C[L] = (y + this.probeRadius) * this.scaleFactor + 0.5 : C[L] = y * this.scaleFactor + 0.5;
                  let o = C[L] * C[L];
                  this.widxz[L] = Math.floor(C[L]) + 1, this.depty[L] = new Int32Array(this.widxz[L] * this.widxz[L]);
                  let v = 0;
                  for (let w = 0; w < this.widxz[L]; w++)
                    for (let M = 0; M < this.widxz[L]; M++) {
                      let F = w * w + M * M;
                      if (F > o)
                        this.depty[L][v] = -1;
                      else {
                        let m = Math.sqrt(o - F);
                        this.depty[L][v] = Math.floor(m);
                      }
                      v++;
                    }
                }
              }
              fillvoxels($, C) {
                for (let L = 0, y = this.vpBits.length; L < y; L++)
                  this.vpBits[L] = 0, this.vpDistance[L] = -1, this.vpAtomID[L] = -1;
                for (let L in C) {
                  let y = $[C[L]];
                  y !== void 0 && this.fillAtom(y, $);
                }
                for (let L = 0, y = this.vpBits.length; L < y; L++)
                  this.vpBits[L] & this.INOUT && (this.vpBits[L] |= this.ISDONE);
              }
              fillAtom($, C) {
                let L = Math.floor(0.5 + this.scaleFactor * ($.x + this.ptranx)), y = Math.floor(0.5 + this.scaleFactor * ($.y + this.ptrany)), o = Math.floor(0.5 + this.scaleFactor * ($.z + this.ptranz)), v = this.getVDWIndex($), w = 0, M = this.pWidth * this.pHeight;
                for (let F = 0, m = this.widxz[v]; F < m; F++)
                  for (let E = 0; E < m; E++) {
                    if (this.depty[v][w] != -1) {
                      for (let z = -1; z < 2; z++)
                        for (let O = -1; O < 2; O++)
                          for (let R = -1; R < 2; R++)
                            if (z !== 0 && O !== 0 && R !== 0) {
                              let B = z * F, P = R * E;
                              for (let W = 0; W <= this.depty[v][w]; W++) {
                                let U = W * O, V = L + B, K = y + U, q = o + P;
                                if (V < 0 || K < 0 || q < 0 || V >= this.pLength || K >= this.pWidth || q >= this.pHeight)
                                  continue;
                                let H = V * M + K * this.pHeight + q;
                                if (!(this.vpBits[H] & this.INOUT))
                                  this.vpBits[H] |= this.INOUT, this.vpAtomID[H] = $.serial;
                                else {
                                  let j = C[this.vpAtomID[H]];
                                  if (j.serial != $.serial) {
                                    let Q = L + B - Math.floor(0.5 + this.scaleFactor * (j.x + this.ptranx)), J = y + U - Math.floor(0.5 + this.scaleFactor * (j.y + this.ptrany)), Y = o + P - Math.floor(0.5 + this.scaleFactor * (j.z + this.ptranz));
                                    B * B + U * U + P * P < Q * Q + J * J + Y * Y && (this.vpAtomID[H] = $.serial);
                                  }
                                }
                              }
                            }
                    }
                    w++;
                  }
              }
              fillvoxelswaals($, C) {
                for (let L = 0, y = this.vpBits.length; L < y; L++)
                  this.vpBits[L] &= ~this.ISDONE;
                for (let L in C) {
                  let y = $[C[L]];
                  y !== void 0 && this.fillAtomWaals(y, $);
                }
              }
              fillAtomWaals($, C) {
                let L = 0, y = Math.floor(0.5 + this.scaleFactor * ($.x + this.ptranx)), o = Math.floor(0.5 + this.scaleFactor * ($.y + this.ptrany)), v = Math.floor(0.5 + this.scaleFactor * ($.z + this.ptranz)), w = this.getVDWIndex($), M = this.pWidth * this.pHeight;
                for (let F = 0, m = this.widxz[w]; F < m; F++)
                  for (let E = 0; E < m; E++) {
                    if (this.depty[w][L] != -1) {
                      for (let z = -1; z < 2; z++)
                        for (let O = -1; O < 2; O++)
                          for (let R = -1; R < 2; R++)
                            if (z !== 0 && O !== 0 && R !== 0) {
                              let B = z * F, P = R * E;
                              for (let W = 0; W <= this.depty[w][L]; W++) {
                                let U = W * O, V = y + B, K = o + U, q = v + P;
                                if (V < 0 || K < 0 || q < 0 || V >= this.pLength || K >= this.pWidth || q >= this.pHeight)
                                  continue;
                                let H = V * M + K * this.pHeight + q;
                                if (!(this.vpBits[H] & this.ISDONE))
                                  this.vpBits[H] |= this.ISDONE, this.vpAtomID[H] = $.serial;
                                else {
                                  let j = C[this.vpAtomID[H]];
                                  if (j.serial != $.serial) {
                                    let Q = y + B - Math.floor(0.5 + this.scaleFactor * (j.x + this.ptranx)), J = o + U - Math.floor(0.5 + this.scaleFactor * (j.y + this.ptrany)), Y = v + P - Math.floor(0.5 + this.scaleFactor * (j.z + this.ptranz));
                                    B * B + U * U + P * P < Q * Q + J * J + Y * Y && (this.vpAtomID[H] = $.serial);
                                  }
                                }
                              }
                            }
                    }
                    L++;
                  }
              }
              buildboundary() {
                let $ = this.pWidth * this.pHeight;
                for (let C = 0; C < this.pLength; C++)
                  for (let L = 0; L < this.pHeight; L++)
                    for (let y = 0; y < this.pWidth; y++) {
                      let o = C * $ + y * this.pHeight + L;
                      if (this.vpBits[o] & this.INOUT) {
                        let v = 0;
                        for (; v < 26; ) {
                          let w = C + this.nb[v][0], M = L + this.nb[v][2], F = y + this.nb[v][1];
                          if (w > -1 && w < this.pLength && F > -1 && F < this.pWidth && M > -1 && M < this.pHeight && !(this.vpBits[w * $ + F * this.pHeight + M] & this.INOUT)) {
                            this.vpBits[o] |= this.ISBOUND;
                            break;
                          } else
                            v++;
                        }
                      }
                    }
              }
              fastdistancemap() {
                let $ = new A(this.pLength, this.pWidth, this.pHeight), C = this.pWidth * this.pHeight, L = this.cutRadius * this.cutRadius, y = [], o = [], v;
                for (let F = 0; F < this.pLength; F++)
                  for (let m = 0; m < this.pWidth; m++)
                    for (let E = 0; E < this.pHeight; E++)
                      if (v = F * C + m * this.pHeight + E, this.vpBits[v] &= ~this.ISDONE, this.vpBits[v] & this.INOUT && this.vpBits[v] & this.ISBOUND) {
                        let z = {
                          ix: F,
                          iy: m,
                          iz: E
                        };
                        $.set(F, m, E, z), y.push(z), this.vpDistance[v] = 0, this.vpBits[v] |= this.ISDONE, this.vpBits[v] &= ~this.ISBOUND;
                      }
                do {
                  o = this.fastoneshell(y, $), y = [];
                  for (let F = 0, m = o.length; F < m; F++)
                    v = C * o[F].ix + this.pHeight * o[F].iy + o[F].iz, this.vpBits[v] &= ~this.ISBOUND, this.vpDistance[v] <= 1.0404 * L && y.push({
                      ix: o[F].ix,
                      iy: o[F].iy,
                      iz: o[F].iz
                    });
                } while (y.length !== 0);
                y = [], o = [], $ = null;
                let w = this.scaleFactor - 0.5;
                w < 0 && (w = 0);
                let M = L - 0.5 / (0.1 + w);
                for (let F = 0; F < this.pLength; F++)
                  for (let m = 0; m < this.pWidth; m++)
                    for (let E = 0; E < this.pHeight; E++)
                      v = F * C + m * this.pHeight + E, this.vpBits[v] &= ~this.ISBOUND, this.vpBits[v] & this.INOUT && (!(this.vpBits[v] & this.ISDONE) || this.vpBits[v] & this.ISDONE && this.vpDistance[v] >= M) && (this.vpBits[v] |= this.ISBOUND);
              }
              fastoneshell($, C) {
                let L, y, o, v, w, M, F, m, E, z = [];
                if ($.length === 0)
                  return z;
                let O = {
                  ix: -1,
                  iy: -1,
                  iz: -1
                }, R = this.pWidth * this.pHeight;
                for (let B = 0, P = $.length; B < P; B++) {
                  L = $[B].ix, y = $[B].iy, o = $[B].iz, m = C.get(L, y, o);
                  for (let W = 0; W < 6; W++)
                    O.ix = L + this.nb[W][0], O.iy = y + this.nb[W][1], O.iz = o + this.nb[W][2], O.ix < this.pLength && O.ix > -1 && O.iy < this.pWidth && O.iy > -1 && O.iz < this.pHeight && O.iz > -1 && (E = O.ix * R + this.pHeight * O.iy + O.iz, this.vpBits[E] & this.INOUT && !(this.vpBits[E] & this.ISDONE) ? (C.set(O.ix, O.iy, o + this.nb[W][2], m), v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, this.vpDistance[E] = F, this.vpBits[E] |= this.ISDONE, this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })) : this.vpBits[E] & this.INOUT && this.vpBits[E] & this.ISDONE && (v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, F < this.vpDistance[E] && (C.set(O.ix, O.iy, O.iz, m), this.vpDistance[E] = F, this.vpBits[E] & this.ISBOUND || (this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })))));
                }
                for (let B = 0, P = $.length; B < P; B++) {
                  L = $[B].ix, y = $[B].iy, o = $[B].iz, m = C.get(L, y, o);
                  for (let W = 6; W < 18; W++)
                    O.ix = L + this.nb[W][0], O.iy = y + this.nb[W][1], O.iz = o + this.nb[W][2], O.ix < this.pLength && O.ix > -1 && O.iy < this.pWidth && O.iy > -1 && O.iz < this.pHeight && O.iz > -1 && (E = O.ix * R + this.pHeight * O.iy + O.iz, this.vpBits[E] & this.INOUT && !(this.vpBits[E] & this.ISDONE) ? (C.set(O.ix, O.iy, o + this.nb[W][2], m), v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, this.vpDistance[E] = F, this.vpBits[E] |= this.ISDONE, this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })) : this.vpBits[E] & this.INOUT && this.vpBits[E] & this.ISDONE && (v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, F < this.vpDistance[E] && (C.set(O.ix, O.iy, O.iz, m), this.vpDistance[E] = F, this.vpBits[E] & this.ISBOUND || (this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })))));
                }
                for (let B = 0, P = $.length; B < P; B++) {
                  L = $[B].ix, y = $[B].iy, o = $[B].iz, m = C.get(L, y, o);
                  for (let W = 18; W < 26; W++)
                    O.ix = L + this.nb[W][0], O.iy = y + this.nb[W][1], O.iz = o + this.nb[W][2], O.ix < this.pLength && O.ix > -1 && O.iy < this.pWidth && O.iy > -1 && O.iz < this.pHeight && O.iz > -1 && (E = O.ix * R + this.pHeight * O.iy + O.iz, this.vpBits[E] & this.INOUT && !(this.vpBits[E] & this.ISDONE) ? (C.set(O.ix, O.iy, o + this.nb[W][2], m), v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, this.vpDistance[E] = F, this.vpBits[E] |= this.ISDONE, this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })) : this.vpBits[E] & this.INOUT && this.vpBits[E] & this.ISDONE && (v = O.ix - m.ix, w = O.iy - m.iy, M = O.iz - m.iz, F = v * v + w * w + M * M, F < this.vpDistance[E] && (C.set(O.ix, O.iy, O.iz, m), this.vpDistance[E] = F, this.vpBits[E] & this.ISBOUND || (this.vpBits[E] |= this.ISBOUND, z.push({
                      ix: O.ix,
                      iy: O.iy,
                      iz: O.iz
                    })))));
                }
                return z;
              }
              marchingcubeinit($) {
                for (let C = 0, L = this.vpBits.length; C < L; C++)
                  $ == 1 ? this.vpBits[C] &= ~this.ISBOUND : $ == 4 ? (this.vpBits[C] &= ~this.ISDONE, this.vpBits[C] & this.ISBOUND && (this.vpBits[C] |= this.ISDONE), this.vpBits[C] &= ~this.ISBOUND) : $ == 2 ? this.vpBits[C] & this.ISBOUND && this.vpBits[C] & this.ISDONE ? this.vpBits[C] &= ~this.ISBOUND : this.vpBits[C] & this.ISBOUND && !(this.vpBits[C] & this.ISDONE) && (this.vpBits[C] |= this.ISDONE) : $ == 3 && (this.vpBits[C] &= ~this.ISBOUND);
              }
              marchingcube($) {
                this.marchingcubeinit($), this.verts = [], this.faces = [], x.MarchingCube.march(this.vpBits, this.verts, this.faces, {
                  smooth: 1,
                  nX: this.pLength,
                  nY: this.pWidth,
                  nZ: this.pHeight
                });
                let C = this.pWidth * this.pHeight;
                for (let L = 0, y = this.verts.length; L < y; L++)
                  this.verts[L].atomid = this.vpAtomID[this.verts[L].x * C + this.pHeight * this.verts[L].y + this.verts[L].z];
                x.MarchingCube.laplacianSmooth(1, this.verts, this.faces);
              }
            }
            x.MarchingCube = new g();
          }
        ),
        /***/
        "./src/VolumeData.ts": (
          /*!***************************!*\
            !*** ./src/VolumeData.ts ***!
            \***************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              VolumeData: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utilities */
              "./src/utilities.ts"
            ), s = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), h = r(
              /*! ./parsers/VASP */
              "./src/parsers/VASP.ts"
            ), b = r(
              /*! ./parsers/CUBE */
              "./src/parsers/CUBE.ts"
            ), g = r(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            );
            class _ {
              constructor(x, k, $) {
                if (this.unit = {
                  x: 1,
                  y: 1,
                  z: 1
                }, this.origin = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.size = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.data = new Float32Array([]), this.matrix = null, this.inversematrix = null, this.isbinary = /* @__PURE__ */ new Set(["ccp4", "CCP4"]), this.getCoordinates = function(v) {
                  var w = v / (this.size.y * this.size.z), M = v % (this.size.y * this.size.z), F = v % this.size.z;
                  return w *= this.unit.x, M *= this.unit.y, F *= this.unit.z, w += this.origin.x, M += this.origin.y, F += this.origin.z, { x: w, y: M, z: F };
                }, this.vasp = function(v) {
                  var w = v.replace(/^\s+/, "").split(/[\n\r]/), M = (0, h.VASP)(v)[0], F = M.length;
                  if (F == 0) {
                    console.warn("No good formating of CHG or CHGCAR file, not atomic information provided in the file."), this.data = [];
                    return;
                  }
                  var m = 1.889725992, E = 0.036749309, z = parseFloat(w[1]), O;
                  O = w[2].replace(/^\s+/, "").split(/\s+/);
                  var R = new s.Vector3(parseFloat(O[0]), parseFloat(O[1]), parseFloat(O[2])).multiplyScalar(z * m);
                  O = w[3].replace(/^\s+/, "").split(/\s+/);
                  var B = new s.Vector3(parseFloat(O[0]), parseFloat(O[1]), parseFloat(O[2])).multiplyScalar(z * m);
                  O = w[4].replace(/^\s+/, "").split(/\s+/);
                  var P = new s.Vector3(parseFloat(O[0]), parseFloat(O[1]), parseFloat(O[2])).multiplyScalar(z * m), W = R.x * (B.y * P.z - P.y * B.z) - B.x * (R.y * P.z - P.y * R.z) + P.x * (R.y * B.z - B.y * R.z);
                  W = Math.abs(W) / Math.pow(m, 3);
                  var U = 1 / W;
                  w.splice(0, 8 + F + 1);
                  var V = w[0].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), K = Math.abs(parseFloat(V[0])), q = Math.abs(parseFloat(V[1])), H = Math.abs(parseFloat(V[2])), j = this.origin = new s.Vector3(0, 0, 0);
                  this.size = { x: K, y: q, z: H }, this.unit = new s.Vector3(R.x, B.y, P.z), R = R.multiplyScalar(1 / (m * K)), B = B.multiplyScalar(1 / (m * q)), P = P.multiplyScalar(1 / (m * H)), (R.y != 0 || R.z != 0 || B.x != 0 || B.z != 0 || P.x != 0 || P.y != 0) && (this.matrix = new s.Matrix4(R.x, B.x, P.x, 0, R.y, B.y, P.y, 0, R.z, B.z, P.z, 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new s.Matrix4().makeTranslation(j.x, j.y, j.z)), this.origin = new s.Vector3(0, 0, 0), this.unit = new s.Vector3(1, 1, 1)), w.splice(0, 1);
                  var Q = w.join(" ");
                  Q = Q.replace(/^\s+/, "");
                  var J = Q.split(/[\s\r]+/);
                  J.splice(K * q * H + 1);
                  for (var Y = Float32Array.from(J, parseFloat), ee = 0; ee < Y.length; ee++)
                    Y[ee] = Y[ee] * U * E;
                  this.data = Y;
                }, this.dx = function(v) {
                  var w = v.split(/[\n\r]+/), M, F = /gridpositions\s+counts\s+(\d+)\s+(\d+)\s+(\d+)/, m = /^origin\s+(\S+)\s+(\S+)\s+(\S+)/, E = /^delta\s+(\S+)\s+(\S+)\s+(\S+)/, z = /data follows/, O = 0;
                  for (O = 0; O < w.length; O++) {
                    var R = w[O];
                    if (M = F.exec(R)) {
                      var B = parseInt(M[1]), P = parseInt(M[2]), W = parseInt(M[3]);
                      this.size = { x: B, y: P, z: W };
                    } else if (M = E.exec(R)) {
                      var U = parseFloat(M[1]);
                      if ((parseFloat(M[2]) != 0 || parseFloat(M[3]) != 0) && console.warn("Non-orthogonal delta matrix not currently supported in dx format"), O += 1, R = w[O], M = E.exec(R), M == null) {
                        console.error("Parse error in dx delta matrix");
                        return;
                      }
                      var V = parseFloat(M[2]);
                      if ((parseFloat(M[1]) != 0 || parseFloat(M[3]) != 0) && console.warn("Non-orthogonal delta matrix not currently supported in dx format"), O += 1, R = w[O], M = E.exec(R), M == null) {
                        console.error("Parse error in dx delta matrix");
                        return;
                      }
                      var K = parseFloat(M[3]);
                      (parseFloat(M[1]) != 0 || parseFloat(M[2]) != 0) && console.warn("Non-orthogonal delta matrix not currently supported in dx format"), this.unit = new s.Vector3(U, V, K);
                    } else if (M = m.exec(R)) {
                      var q = parseFloat(M[1]), H = parseFloat(M[2]), j = parseFloat(M[3]);
                      this.origin = new s.Vector3(q, H, j);
                    } else if (M = z.exec(R))
                      break;
                  }
                  if (O += 1, !this.size || !this.origin || !this.unit || !this.size) {
                    console.error("Error parsing dx format");
                    return;
                  }
                  var Q = w.splice(O).join(" "), J = Q.split(/[\s\r]+/);
                  this.data = Float32Array.from(J, parseFloat);
                }, k = k.toLowerCase(), /\.gz$/.test(k)) {
                  k = k.replace(/\.gz$/, "");
                  try {
                    this[k] && this.isbinary.has(k) ? (typeof x == "string" && (x = (0, n.base64ToArray)(x)), x = (0, g.inflate)(x)) : x = new TextDecoder("utf-8").decode((0, g.inflate)(x));
                  } catch (v) {
                    console.error(v);
                  }
                }
                if (this[k] && (this.isbinary.has(k) && typeof x == "string" && (x = (0, n.base64ToArray)(x)), this[k](x)), $) {
                  if ($.negate)
                    for (let v = 0, w = this.data.length; v < w; v++)
                      this.data[v] = -this.data[v];
                  if ($.normalize) {
                    var C = 0;
                    for (let v = 0, w = this.data.length; v < w; v++)
                      C += this.data[v];
                    var L = C / this.data.length;
                    C = 0;
                    for (let v = 0, w = this.data.length; v < w; v++) {
                      var y = this.data[v] - L;
                      C += y * y;
                    }
                    var o = C / this.data.length;
                    for (let v = 0, w = this.data.length; v < w; v++)
                      this.data[v] = (this.data[v] - L) / o;
                  }
                }
              }
              /**
               * @function $3Dmol.VolumeData.getIndex
               * @param {number} x,y,z - the coordinates
               * @returns - index into flat array closest to provided coordinate; -1 if invalid
               */
              getIndex(x, k, $) {
                if (this.matrix) {
                  this.inversematrix == null && (this.inversematrix = new s.Matrix4().getInverse(this.matrix));
                  var C = new s.Vector3(x, k, $);
                  C = C.applyMatrix4(this.inversematrix), x = C.x, k = C.y, $ = C.z;
                } else
                  x -= this.origin.x, k -= this.origin.y, $ -= this.origin.z, x /= this.unit.x, k /= this.unit.y, $ /= this.unit.z;
                return x = Math.round(x), k = Math.round(k), $ = Math.round($), x < 0 || x >= this.size.x || k < 0 || k >= this.size.y || $ < 0 || $ >= this.size.z ? -1 : x * this.size.y * this.size.z + k * this.size.z + $;
              }
              /**
               * @function $3Dmol.VolumeData.getVal
               * @param {number} x,y,z - the coordinates
               * @returns - value closest to provided coordinate; zero if coordinate invalid
               */
              getVal(x, k, $) {
                let C = this.getIndex(x, k, $);
                return C < 0 ? 0 : this.data[C];
              }
              // parse cube data
              cube(x) {
                var k = x.split(/\r?\n/);
                if (!(k.length < 6)) {
                  var $ = (0, b.CUBE)(x, {}).modelData[0].cryst, C = k[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), L = parseFloat(C[0]), y = Math.abs(L);
                  this.origin = $.origin, this.size = $.size, this.unit = $.unit, this.matrix = $.matrix4;
                  var o = 6;
                  L < 0 && o++;
                  var v = k.splice(y + o).join(" ");
                  v = v.replace(/^\s+/, "");
                  var w = v.split(/[\s\r]+/);
                  this.data = Float32Array.from(w, parseFloat);
                }
              }
              //parse cp4 files
              ccp4(x) {
                var k = {};
                x = new Int8Array(x);
                var $ = new Int32Array(x.buffer, 0, 56), C = new Float32Array(x.buffer, 0, 56), L = new DataView(x.buffer);
                if (k.MAP = String.fromCharCode(L.getUint8(208), L.getUint8(209), L.getUint8(210), L.getUint8(211)), k.MACHST = [L.getUint8(212), L.getUint8(213)], k.MACHST[0] === 17 && k.MACHST[1] === 17)
                  for (var y = x.byteLength, o = 0; o < y; o += 4)
                    L.setFloat32(o, L.getFloat32(o), !0);
                k.NX = $[0], k.NY = $[1], k.NZ = $[2], k.MODE = $[3], k.NXSTART = $[4], k.NYSTART = $[5], k.NZSTART = $[6], k.MX = $[7], k.MY = $[8], k.MZ = $[9], k.xlen = C[10], k.ylen = C[11], k.zlen = C[12], k.alpha = C[13], k.beta = C[14], k.gamma = C[15], k.MAPC = $[16], k.MAPR = $[17], k.MAPS = $[18], k.DMIN = C[19], k.DMAX = C[20], k.DMEAN = C[21], k.ISPG = $[22], k.NSYMBT = $[23], k.LSKFLG = $[24], k.originX = C[49], k.originY = C[50], k.originZ = C[51], k.ARMS = C[54];
                var v = k, w = [
                  v.xlen,
                  0,
                  0
                ], M = [
                  v.ylen * Math.cos(Math.PI / 180 * v.gamma),
                  v.ylen * Math.sin(Math.PI / 180 * v.gamma),
                  0
                ], F = [
                  v.zlen * Math.cos(Math.PI / 180 * v.beta),
                  v.zlen * (Math.cos(Math.PI / 180 * v.alpha) - Math.cos(Math.PI / 180 * v.gamma) * Math.cos(Math.PI / 180 * v.beta)) / Math.sin(Math.PI / 180 * v.gamma),
                  0
                ];
                F[2] = Math.sqrt(v.zlen * v.zlen * Math.sin(Math.PI / 180 * v.beta) * Math.sin(Math.PI / 180 * v.beta) - F[1] * F[1]);
                var m = [0, w, M, F], E = [0, v.MX, v.MY, v.MZ], z = [0, v.MAPC, v.MAPR, v.MAPS];
                this.matrix = new s.Matrix4(), this.matrix.set(m[z[1]][0] / E[z[1]], m[z[2]][0] / E[z[2]], m[z[3]][0] / E[z[3]], 0, m[z[1]][1] / E[z[1]], m[z[2]][1] / E[z[2]], m[z[3]][1] / E[z[3]], 0, m[z[1]][2] / E[z[1]], m[z[2]][2] / E[z[2]], m[z[3]][2] / E[z[3]], 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new s.Matrix4().makeTranslation(v.NXSTART + v.originX, v.NYSTART + v.originY, v.NZSTART + v.originZ)), this.origin = new s.Vector3(0, 0, 0), this.unit = new s.Vector3(1, 1, 1), this.size = { x: k.NX, y: k.NY, z: k.NZ }, this.dimensionorder = [k.MAPC, k.MAPR, k.MAPS];
                var O = new Float32Array(x.buffer, 1024 + k.NSYMBT), R = k.NX, B = k.NY, P = k.NZ;
                this.data = new Float32Array(R * B * P);
                for (let W = 0; W < R; W++)
                  for (let U = 0; U < B; U++)
                    for (let V = 0; V < P; V++)
                      this.data[(W * B + U) * P + V] = O[(V * B + U) * R + W];
              }
            }
          }
        ),
        /***/
        "./src/VolumetricRender.ts": (
          /*!*********************************!*\
            !*** ./src/VolumetricRender.ts ***!
            \*********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              GLVolumetricRender: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), s = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), h = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), b = r(
              /*! ./colors */
              "./src/colors.ts"
            ), g = r(
              /*! ./GLShape */
              "./src/GLShape.ts"
            );
            class _ {
              static interpolateArray(x, k) {
                function $(F, m, E) {
                  return F + (m - F) * E;
                }
                var C = [], L = (x.length - 1) / (k - 1);
                C[0] = x[0];
                for (var y = 1; y < k - 1; y++) {
                  var o = y * L, v = Math.floor(o), w = Math.ceil(o), M = o - v;
                  C[y] = $(x[v], x[w], M);
                }
                return C[k - 1] = x[x.length - 1], C;
              }
              constructor(x, k, $) {
                this.hidden = !1, this.boundingSphere = new n.Sphere(), this.renderedShapeObj = null, this.shapeObj = null, this.subsamples = 5, this.data = null, this.transferfunctionbuffer = [], this.min = 0, this.max = 0, k = k || {};
                var C = Object.assign([], k.transferfn);
                this.subsamples = k.subsamples || 5;
                let L = 256;
                C.forEach(function(B) {
                  B.value = parseFloat(B.value);
                }), C.sort(function(B, P) {
                  return B.value - P.value;
                }), this.min = C[0].value, C.length == 0 && C.push(C[0]), this.max = C[C.length - 1].value;
                var y, o, v, w, M, F, m, E, z, O;
                for (let B = 0; B < C.length - 1; B++)
                  if (v = b.CC.color(C[B].color), w = b.CC.color(C[B + 1].color), z = C[B].opacity, O = C[B + 1].opacity, y = Math.floor((C[B].value - this.min) * L / (this.max - this.min)), o = Math.floor((C[B + 1].value - this.min) * L / (this.max - this.min)), y != o) {
                    M = _.interpolateArray([v.r * 255, w.r * 255], o - y), F = _.interpolateArray([v.g * 255, w.g * 255], o - y), m = _.interpolateArray([v.b * 255, w.b * 255], o - y), E = _.interpolateArray([z * 255, O * 255], o - y);
                    for (let P = 0; P < M.length; P++)
                      this.transferfunctionbuffer.push(M[P]), this.transferfunctionbuffer.push(F[P]), this.transferfunctionbuffer.push(m[P]), this.transferfunctionbuffer.push(E[P]);
                  }
                if (this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer), x.matrix) {
                  let B = new s.Vector3(0, 0, 0), P = new s.Vector3(x.size.x, x.size.y, x.size.z), W = new s.Vector3(1, 1, 1);
                  B.applyMatrix4(x.matrix), P.applyMatrix4(x.matrix), W.applyMatrix4(x.matrix).sub(B), this.extent = [[B.x, B.y, B.z], [P.x, P.y, P.z]];
                  for (let q = 1; q < 7; q++)
                    P.x = q & 1 ? x.size.x : 0, P.y = q & 2 ? x.size.y : 0, P.z = q & 4 ? x.size.z : 0, P.applyMatrix4(x.matrix), this.extent[0][0] = Math.min(this.extent[0][0], P.x), this.extent[0][1] = Math.min(this.extent[0][1], P.y), this.extent[0][2] = Math.min(this.extent[0][2], P.z), this.extent[1][0] = Math.max(this.extent[1][0], P.x), this.extent[1][1] = Math.max(this.extent[1][1], P.y), this.extent[1][2] = Math.max(this.extent[1][2], P.z);
                  let U = P.x - B.x, V = P.y - B.y, K = P.z - B.z;
                  this.maxdepth = Math.sqrt(U * U + V * V + K * K), this.minunit = Math.min(Math.min(W.x, W.y), W.z), this.texmatrix = new s.Matrix4().identity().scale({ x: x.size.x, y: x.size.y, z: x.size.z }), this.texmatrix = this.texmatrix.multiplyMatrices(x.matrix, this.texmatrix), this.texmatrix = this.texmatrix.getInverse(this.texmatrix);
                } else {
                  this.texmatrix = new s.Matrix4().identity();
                  let B = x.unit.x * x.size.x, P = x.unit.y * x.size.y, W = x.unit.z * x.size.z;
                  this.texmatrix.makeTranslation(-x.origin.x / B, -x.origin.y / P, -x.origin.z / W), this.texmatrix.scale({ x: 1 / B, y: 1 / P, z: 1 / W }), this.minunit = Math.min(Math.min(x.unit.x, x.unit.y), x.unit.z), this.extent = [
                    [x.origin.x, x.origin.y, x.origin.z],
                    [x.origin.x + B, x.origin.y + P, x.origin.z + W]
                  ], this.maxdepth = Math.sqrt(B * B + P * P + W * W);
                }
                var R = new g.GLShape({});
                if (R.addBox({
                  corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },
                  dimensions: {
                    w: this.extent[1][0] - this.extent[0][0],
                    h: this.extent[1][1] - this.extent[0][1],
                    d: this.extent[1][2] - this.extent[0][2]
                  }
                }), this.geo = R.finalize(), this.boundingSphere.center = new s.Vector3((this.extent[0][0] + this.extent[1][0]) / 2, (this.extent[0][1] + this.extent[1][1]) / 2, (this.extent[0][2] + this.extent[1][2]) / 2), this.boundingSphere.radius = this.maxdepth / 2, k.coords === void 0 && k.selection !== void 0 && ($ ? k.coords = $.selectedAtoms(k.selection) : console.log("Need to provide viewer to volumetric renderer if selection specified.")), k.coords !== void 0 && k.seldist !== void 0) {
                  let B = new Uint8Array(x.data.length), P = k.seldist, W = P * P;
                  for (let U = 0, V = k.coords.length; U < V; U++) {
                    let K = k.coords[U], q = K.x - P, H = K.y - P, j = K.z - P, Q = K.x + P, J = K.y + P, Y = K.z + P;
                    if (x.getIndex(q, H, j) >= 0 || x.getIndex(Q, J, Y) >= 0)
                      for (let ee = q; ee < Q; ee += this.minunit)
                        for (let fe = H; fe < J; fe += this.minunit)
                          for (let me = j; me < Y; me += this.minunit) {
                            let he = x.getIndex(ee, fe, me);
                            he >= 0 && !B[he] && (ee - K.x) * (ee - K.x) + (fe - K.y) * (fe - K.y) + (me - K.z) * (me - K.z) < W && (B[he] = 1);
                          }
                  }
                  for (let U = 0, V = x.data.length; U < V; U++)
                    B[U] == 0 && (x.data[U] = 1 / 0);
                }
                this.data = x;
              }
              /**
               * Initialize webgl objects for rendering
               * @param {Object3D} group
               *
               */
              globj(x) {
                if (this.renderedShapeObj && (x.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  this.shapeObj = new h.Object3D();
                  var k = null, $ = new h.Texture(this.data, !0), C = new h.Texture(this.transferfunctionbuffer, !1);
                  $.needsUpdate = !0, C.needsUpdate = !0, C.flipY = !1, k = new h.VolumetricMaterial({
                    transferfn: C,
                    transfermin: this.min,
                    transfermax: this.max,
                    map: $,
                    extent: this.extent,
                    maxdepth: this.maxdepth,
                    texmatrix: this.texmatrix,
                    unit: this.minunit,
                    subsamples: this.subsamples
                  });
                  var L = new h.Mesh(this.geo, k);
                  this.shapeObj.add(L), this.renderedShapeObj = this.shapeObj.clone(), x.add(this.renderedShapeObj);
                }
              }
              removegl(x) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), x.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Camera.ts": (
          /*!*****************************!*\
            !*** ./src/WebGL/Camera.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Camera: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), s = r(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            );
            class h extends n.Object3D {
              constructor(g = 50, _ = 1, A = 0.1, x = 2e3, k = !1) {
                super(), this.projectionMatrix = new s.Matrix4(), this.projectionMatrixInverse = new s.Matrix4(), this.matrixWorldInverse = new s.Matrix4(), this.fov = g, this.aspect = _, this.near = A, this.far = x;
                var $ = this.position.z;
                this.right = $ * Math.tan(Math.PI / 180 * g), this.left = -this.right, this.top = this.right / this.aspect, this.bottom = -this.top, this.ortho = !!k, this.updateProjectionMatrix();
              }
              lookAt(g) {
                this.matrix.lookAt(this.position, g, this.up), this.rotationAutoUpdate && (this.useQuaternion === !1 && this.rotation instanceof s.Vector3 ? this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : console.error("Unimplemented math operation."));
              }
              updateProjectionMatrix() {
                this.ortho ? this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far) : this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Fog.ts": (
          /*!**************************!*\
            !*** ./src/WebGL/Fog.ts ***!
            \**************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Fog: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../colors */
              "./src/colors.ts"
            );
            class s {
              constructor(b, g = 1, _ = 1e3) {
                this.name = "", this.color = new n.Color(b), this.near = g, this.far = _;
              }
              clone() {
                return new s(this.color.getHex(), this.near, this.far);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Renderer.ts": (
          /*!*******************************!*\
            !*** ./src/WebGL/Renderer.ts ***!
            \*******************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Renderer: () => (
                /* binding */
                y
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), s = r(
              /*! ./constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), h = r(
              /*! ./constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), b = r(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), g = r(
              /*! ../colors */
              "./src/colors.ts"
            ), _ = r(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), A = r(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), x = r(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), k = r(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), $ = r(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            ), C = null, L = null;
            class y {
              constructor(v) {
                this.context = null, this.devicePixelRatio = 1, this.sortObjects = !0, this.autoUpdateObjects = !0, this.autoUpdateScene = !0, this.info = {
                  memory: {
                    programs: 0,
                    geometries: 0,
                    textures: 0
                  },
                  render: {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                  }
                }, this._offscreen = null, this._bitmap = null, this._programs = [], this._programs_counter = 0, this._webglversion = 1, this._currentProgram = null, this._currentMaterialId = -1, this._currentGeometryGroupHash = null, this._currentCamera = null, this._geometryGroupCounter = 0, this._oldDoubleSided = -1, this._oldFlipSided = -1, this._oldDepthTest = -1, this._oldDepthWrite = -1, this._oldPolygonOffset = null, this._oldLineWidth = null, this._viewportWidth = 0, this._viewportHeight = 0, this._currentWidth = 0, this._currentHeight = 0, this._enabledAttributes = {}, this._vector3 = new A.Vector3(), this._worldInverse = new A.Matrix4(), this._projInverse = new A.Matrix4(), this._textureMatrix = new A.Matrix4(), this._fullProjModelMatrix = new A.Matrix4(), this._fullProjModelMatrixInv = new A.Matrix4(), this._direction = new A.Vector3(), this._lightsNeedUpdate = !0, this._lights = {
                  ambient: [0, 0, 0],
                  directional: {
                    length: 0,
                    colors: [],
                    positions: []
                  },
                  point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: []
                  },
                  spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: []
                  },
                  hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                  }
                }, this.sprites = new $.SpritePlugin(), this._screenshader = null, this._AOshader = null, this._blurshader = null, this._vertexattribpos = null, this._aovertexattribpos = null, this._blurvertexattribpos = null, this._screenQuadVBO = null, this._fb = null, this._targetTexture = null, this._depthTexture = null, this._shadingTexture = null, this._scratchTexture = null, this._AOstrength = 1, this._AOradius = 5, this.SHADE_TEXTURE = 3, v = v || {}, this.row = v.row, this.col = v.col, this.rows = v.rows, this.cols = v.cols, this._canvas = v.canvas !== void 0 ? v.canvas : document.createElement("canvas"), this._precision = v.precision !== void 0 ? v.precision : "highp", this._alpha = v.alpha !== void 0 ? v.alpha : !0, this._premultipliedAlpha = v.premultipliedAlpha !== void 0 ? v.premultipliedAlpha : !0, this._antialias = v.antialias !== void 0 ? v.antialias : !1, this._preserveDrawingBuffer = v.preserveDrawingBuffer !== void 0 ? v.preserveDrawingBuffer : !1, this._clearColor = v.clearColor !== void 0 ? new g.Color(v.clearColor) : new g.Color(0), this._clearAlpha = v.clearAlpha !== void 0 ? v.clearAlpha : 0, this._outlineMaterial = new _.MeshOutlineMaterial(v.outline), this._outlineSphereImposterMaterial = new _.SphereImposterOutlineMaterial(v.outline), this._outlineStickImposterMaterial = new _.StickImposterOutlineMaterial(v.outline), this._outlineEnabled = !!v.outline, this._AOEnabled = !!v.ambientOcclusion, v.ambientOcclusion && typeof v.ambientOcclusion.strength < "u" && (this._AOstrength = parseFloat(v.ambientOcclusion.strength)), this._AOstrength == 0 && (this._AOEnabled = !1), v.ambientOcclusion && typeof v.ambientOcclusion.radius < "u" && (this._AOradius = parseFloat(v.ambientOcclusion.radius)), this.domElement = this._canvas, this._canvas.id = v.id, !(v.containerWidth == 0 || v.containerHeight == 0) && (this.initGL(), this.setDefaultGLState(), this.context = this._gl, this.isWebGL1() ? this._extInstanced = this._gl.getExtension("ANGLE_instanced_arrays") : this._extInstanced = {
                  vertexAttribDivisorANGLE: this._gl.vertexAttribDivisor.bind(this._gl),
                  drawElementsInstancedANGLE: this._gl.drawElementsInstanced.bind(this._gl)
                }, this._extFragDepth = this._gl.getExtension("EXT_frag_depth"), this._extFloatLinear = this._gl.getExtension("OES_texture_float_linear"), this._extColorBufferFloat = this._gl.getExtension("EXT_color_buffer_float"), this.sprites.init(this));
              }
              // API
              supportedExtensions() {
                return {
                  supportsAIA: !!this._extInstanced,
                  supportsImposters: !!this._extFragDepth || !this.isWebGL1(),
                  regen: !1
                };
              }
              getContext() {
                return this._gl;
              }
              getCanvas() {
                return this._canvas;
              }
              isLost() {
                return this._gl == null || this._gl.isContextLost();
              }
              getPrecision() {
                return this._precision;
              }
              setClearColorHex(v, w) {
                this._clearColor.setHex(v), this._clearAlpha = w, this.isLost() || this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              enableOutline(v) {
                this._outlineMaterial = new _.MeshOutlineMaterial(v), this._outlineSphereImposterMaterial = new _.SphereImposterOutlineMaterial(v), this._outlineStickImposterMaterial = new _.StickImposterOutlineMaterial(v), this._outlineEnabled = !0;
              }
              disableOutline() {
                this._outlineEnabled = !1;
              }
              enableAmbientOcclusion(v) {
                v && (v.strength && (this._AOstrength = v.strength), v.scale && (this._AOradius = v.scale)), this._AOEnabled = this._AOstrength > 0;
              }
              disableAmbientOcclusion() {
                this._AOEnabled = !1;
              }
              setViewport() {
                if (this._offscreen && (this._offscreen.width = this._canvas.width, this._offscreen.height = this._canvas.height), this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var v = this._canvas.width / this.cols, w = this._canvas.height / this.rows;
                  this._viewportWidth = v, this._viewportHeight = w, this.isLost() || (this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(v * this.col, w * this.row, v, w), this._gl.viewport(v * this.col, w * this.row, v, w));
                }
              }
              setSize(v, w) {
                if (this.devicePixelRatio = window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1, this._antialias && this.devicePixelRatio < 2 && (this.devicePixelRatio *= 2), this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var M = v / this.cols, F = w / this.rows;
                  this._canvas.width = v * this.devicePixelRatio, this._canvas.height = w * this.devicePixelRatio, this._viewportWidth = M * this.devicePixelRatio, this._viewportHeight = F * this.devicePixelRatio, this._canvas.style.width = v + "px", this._canvas.style.height = w + "px", this.setViewport();
                } else
                  this._viewportWidth = this._canvas.width = v * this.devicePixelRatio, this._viewportHeight = this._canvas.height = w * this.devicePixelRatio, this._canvas.style.width = v + "px", this._canvas.style.height = w + "px", this.isLost() || this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
                this.initFrameBuffer();
              }
              clear(v, w, M) {
                var F = 0;
                (v === void 0 || v) && (F |= this._gl.COLOR_BUFFER_BIT), (w === void 0 || w) && (F |= this._gl.DEPTH_BUFFER_BIT), (M === void 0 || M) && (F |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(F);
              }
              setMaterialFaces(v, w) {
                var M = v.side === s.DoubleSide, F = v.side === s.BackSide;
                v.imposter || (F = w ? !F : F), this._oldDoubleSided !== M && (M ? this._gl.disable(this._gl.CULL_FACE) : this._gl.enable(this._gl.CULL_FACE), this._oldDoubleSided = M), this._oldFlipSided !== F && (F ? this._gl.frontFace(this._gl.CW) : this._gl.frontFace(this._gl.CCW), this._oldFlipSided = F), this._gl.cullFace(this._gl.BACK);
              }
              setDepthTest(v) {
                this._oldDepthTest !== v && (v ? this._gl.enable(this._gl.DEPTH_TEST) : this._gl.disable(this._gl.DEPTH_TEST), this._oldDepthTest = v);
              }
              setDepthWrite(v) {
                this._oldDepthWrite !== v && (this._gl.depthMask(v), this._oldDepthWrite = v);
              }
              setBlending(v) {
                v ? (this._gl.enable(this._gl.BLEND), this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD), this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)) : this._gl.disable(this._gl.BLEND);
              }
              // TODO: need to set up shader attributes and uniforms as attributes on
              // material object after attaching prgm
              // We need to attach appropriate uniform variables to material after shaders
              // have been chosen
              initMaterial(v, w, M, F) {
                v.addEventListener("dispose", this.onMaterialDispose.bind(this));
                var m, E;
                if (E = v.shaderID, E) {
                  var z = k.ShaderLib[E];
                  v.vertexShader = z.vertexShader, v.fragmentShader = z.fragmentShader, v.uniforms = k.ShaderUtils.clone(z.uniforms), v.shaded && v.makeShaded(this.SHADE_TEXTURE);
                }
                m = {
                  wireframe: v.wireframe,
                  fragdepth: v.imposter,
                  volumetric: v.volumetric,
                  shaded: v.shaded
                }, v.program = this.buildProgram(v.fragmentShader, v.vertexShader, v.uniforms, m);
              }
              renderBuffer(v, w, M, F, m, E) {
                if (F.visible) {
                  var z, O;
                  if (z = this.setProgram(v, w, M, F, E, this), !!z) {
                    O = z.attributes;
                    var R = !1, B = F.wireframe ? 1 : 0, P = m.id * 16777215 + z.id * 2 + B;
                    P !== this._currentGeometryGroupHash && (this._currentGeometryGroupHash = P, R = !0), R && (this.disableAttributes(), O.position >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglVertexBuffer), this.enableAttribute(O.position), this._gl.vertexAttribPointer(O.position, 3, this._gl.FLOAT, !1, 0, 0)), O.color >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglColorBuffer), this.enableAttribute(O.color), this._gl.vertexAttribPointer(O.color, 3, this._gl.FLOAT, !1, 0, 0)), O.normal >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglNormalBuffer), this.enableAttribute(O.normal), this._gl.vertexAttribPointer(O.normal, 3, this._gl.FLOAT, !1, 0, 0)), O.offset >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglOffsetBuffer), this.enableAttribute(O.offset), this._gl.vertexAttribPointer(O.offset, 3, this._gl.FLOAT, !1, 0, 0)), O.radius >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglRadiusBuffer), this.enableAttribute(O.radius), this._gl.vertexAttribPointer(O.radius, 1, this._gl.FLOAT, !1, 0, 0)));
                    var W, U;
                    if (E instanceof x.Mesh) {
                      if (F.shaderID === "instanced") {
                        var V = F.sphere.geometryGroups[0];
                        R && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, V.vertexArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, m.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, V.normalArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, m.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, V.faceArray, this._gl.STATIC_DRAW)), W = V.faceidx, this._extInstanced.vertexAttribDivisorANGLE(O.offset, 1), this._extInstanced.vertexAttribDivisorANGLE(O.radius, 1), this._extInstanced.vertexAttribDivisorANGLE(O.color, 1), this._extInstanced.drawElementsInstancedANGLE(this._gl.TRIANGLES, W, this._gl.UNSIGNED_SHORT, 0, m.radiusArray.length), this._extInstanced.vertexAttribDivisorANGLE(O.offset, 0), this._extInstanced.vertexAttribDivisorANGLE(O.radius, 0), this._extInstanced.vertexAttribDivisorANGLE(O.color, 0);
                      } else F.wireframe ? (U = m.lineidx, this.setLineWidth(F.wireframeLinewidth), R && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, m.__webglLineBuffer), this._gl.drawElements(this._gl.LINES, U, this._gl.UNSIGNED_SHORT, 0)) : (W = m.faceidx, R && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, m.__webglFaceBuffer), this._gl.drawElements(this._gl.TRIANGLES, W, this._gl.UNSIGNED_SHORT, 0));
                      this.info.render.calls++, this.info.render.vertices += W, this.info.render.faces += W / 3;
                    } else E instanceof x.Line && (U = m.vertices, this.setLineWidth(F.linewidth), this._gl.drawArrays(this._gl.LINES, 0, U), this.info.render.calls++);
                  }
                }
              }
              /* clear out the shading textures */
              clearShading() {
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0), this.clear(!1, !0, !1), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
              }
              /* Setup the shading buffer to reflect desired shading (ambient occlusion) values.
                Only the matching object with materialType are considered. */
              setShading(v, w, M) {
                let F = v.__lights, m = v.fog, E = [];
                for (let R = 0, B = v.__webglObjects.length; R < B; R++) {
                  let P = v.__webglObjects[R];
                  P.render && P[M] && E.push(P);
                }
                if (E.length == 0)
                  return;
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0), this._gl.framebufferTexture2D(
                  this._gl.FRAMEBUFFER,
                  this._gl.COLOR_ATTACHMENT0,
                  this._gl.TEXTURE_2D,
                  null,
                  //don't write colors (can we do this?)
                  0
                ), this.renderObjects(v.__webglObjects, !0, M + "Depth", w, F, m, !1), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._scratchTexture, 0), this.clear(!1, !0, !1), this._gl.useProgram(this._AOshader), this._currentProgram = this._AOshader, this.setDepthTest(-1), this.setDepthWrite(-1);
                let z = this._AOshader.uniforms;
                this._gl.uniform1f(z.total_strength, this._AOstrength), this._gl.uniform1f(z.radius, this._AOradius), this._fullProjModelMatrix = new A.Matrix4(), this._fullProjModelMatrixInv = new A.Matrix4();
                let O = E[0].object;
                this._fullProjModelMatrix.multiplyMatrices(w.projectionMatrix, O._modelViewMatrix), this._fullProjModelMatrixInv.getInverse(this._fullProjModelMatrix), this._gl.uniformMatrix4fv(z.projectionMatrix, !1, this._fullProjModelMatrix.elements), this._gl.uniformMatrix4fv(z.projinv, !1, this._fullProjModelMatrixInv.elements), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.enableVertexAttribArray(this._aovertexattribpos), this._gl.vertexAttribPointer(this._aovertexattribpos, 2, this._gl.FLOAT, !1, 0, 0), this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture), this._gl.drawArrays(this._gl.TRIANGLES, 0, 6), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0), this.clear(!1, !0, !1), this._gl.useProgram(this._blurshader), this._currentProgram = this._blurshader, this.setDepthTest(-1), this.setDepthWrite(-1), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.enableVertexAttribArray(this._blurvertexattribpos), this._gl.vertexAttribPointer(this._blurvertexattribpos, 2, this._gl.FLOAT, !1, 0, 0), this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture), this._gl.drawArrays(this._gl.TRIANGLES, 0, 6), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
              }
              render(v, w) {
                if (!(w instanceof n.Camera)) {
                  console.error("Renderer.render: camera is not an instance of Camera.");
                  return;
                }
                var M, F, m, E, z, O = v.__lights, R = v.fog;
                if (this._currentMaterialId = -1, this._lightsNeedUpdate = !0, this.autoUpdateScene && v.updateMatrixWorld(), w.parent === void 0 && w.updateMatrixWorld(), w.matrixWorldInverse.getInverse(w.matrixWorld), this.isLost())
                  return;
                this.autoUpdateObjects && this.initWebGLObjects(v), this.info.render.calls = 0, this.info.render.vertices = 0, this.info.render.faces = 0, this.info.render.points = 0, this._currentWidth = this._viewportWidth, this._currentHeight = this._viewportHeight, this.setViewport(), this.setFrameBuffer(), this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha), this.clear(!0, !0, !0), z = v.__webglObjects;
                let B = !1, P = this._AOEnabled;
                for (M = 0, F = z.length; M < F; M++)
                  m = z[M], E = m.object, m.render = !1, E.visible && (this.setupMatrices(E, w), this.unrollBufferMaterial(m), m.render = !0, m.volumetric && (B = !0), m.hasAO && (P = !0));
                if (this.setBlending(!1), P && this.setShading(v, w, "opaque"), this.renderObjects(v.__webglObjects, !0, "opaque", w, O, R, !1), P && this.clearShading(), this.renderSprites(v, w, !1), this.renderObjects(v.__webglObjects, !0, "transparentDepth", w, O, R, !0), this.renderObjects(v.__webglObjects, !1, "transparent", w, O, R, !0), B && this._fb && (this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, null, 0), this.renderObjects(v.__webglObjects, !1, "volumetric", w, O, R, !0)), this.renderFrameBuffertoScreen(), this.setDepthTest(!0), this.setDepthWrite(!0), this.renderSprites(v, w, !0), this._bitmap) {
                  const W = this._offscreen.transferToImageBitmap();
                  this._bitmap.transferFromImageBitmap(W);
                }
              }
              //setup framebuffer for drawing into, assumes buffers already allocated
              setFrameBuffer() {
                if (this.isWebGL1() || !this._fb)
                  return;
                let v = this._viewportWidth, w = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, v, w), this._gl.viewport(0, 0, v, w), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, v, w, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, v, w, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._shadingTexture && (this._gl.deleteTexture(this._shadingTexture), this._shadingTexture = this._gl.createTexture(), this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, v, w, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.deleteTexture(this._scratchTexture), this._scratchTexture = this._gl.createTexture(), this._gl.bindTexture(this._gl.TEXTURE_2D, this._scratchTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, v, w, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE)), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._shadingTexture, 0), this._gl.clearDepth(1), this._gl.clear(this._gl.DEPTH_BUFFER_BIT), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
              }
              //allocate buffers for framebuffer, needs to be called with every resize
              initFrameBuffer() {
                if (this.isWebGL1())
                  return;
                let v = this._viewportWidth, w = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, v, w), this._gl.viewport(0, 0, v, w), this._targetTexture = this._gl.createTexture(), this._depthTexture = this._gl.createTexture(), this._shadingTexture = this._gl.createTexture(), this._scratchTexture = this._gl.createTexture(), this._fb = this._gl.createFramebuffer();
                var M = this._antialias ? k.ShaderLib.screenaa : k.ShaderLib.screen;
                this._screenshader = this.buildProgram(M.fragmentShader, M.vertexShader, M.uniforms, {}), this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, "vertexPosition");
                var F = [
                  // First triangle:
                  1,
                  1,
                  -1,
                  1,
                  -1,
                  -1,
                  // Second triangle:
                  -1,
                  -1,
                  1,
                  -1,
                  1,
                  1
                ];
                this._screenQuadVBO = this._gl.createBuffer(), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(F), this._gl.STATIC_DRAW);
                let m = k.ShaderLib.ssao;
                this._AOshader = this.buildProgram(m.fragmentShader, m.vertexShader, m.uniforms, {}), this._aovertexattribpos = this._gl.getAttribLocation(this._AOshader, "vertexPosition");
                let E = k.ShaderLib.blur;
                this._blurshader = this.buildProgram(E.fragmentShader, E.vertexShader, E.uniforms, {}), this._blurvertexattribpos = this._gl.getAttribLocation(this._blurshader, "vertexPosition");
              }
              renderFrameBuffertoScreen() {
                this.isWebGL1() || this._fb === null || (this.setViewport(), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null), this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.useProgram(this._screenshader), this._currentProgram = this._screenshader, this.setDepthTest(-1), this.setDepthWrite(-1), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.enableVertexAttribArray(this._vertexattribpos), this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, !1, 0, 0), this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.drawArrays(this._gl.TRIANGLES, 0, 6));
              }
              initWebGLObjects(v) {
                if (v.__webglObjects || (v.__webglObjects = [], v.__webglObjectsImmediate = [], v.__webglSprites = [], v.__webglFlares = []), v.__objectsAdded.length) {
                  for (; v.__objectsAdded.length; )
                    this.addObject(v.__objectsAdded[0], v), v.__objectsAdded.splice(0, 1);
                  this._currentGeometryGroupHash = -1;
                }
                for (; v.__objectsRemoved.length; )
                  this.removeObject(v.__objectsRemoved[0], v), v.__objectsRemoved.splice(0, 1);
                for (var w = 0, M = v.__webglObjects.length; w < M; w++)
                  this.updateObject(v.__webglObjects[w].object);
              }
              getYRatio() {
                return this.rows !== void 0 && this.row !== void 0 ? this.rows : 1;
              }
              getXRatio() {
                return this.cols !== void 0 && this.col !== void 0 ? this.cols : 1;
              }
              getAspect(v, w) {
                (v == null || w == null) && (v = this._canvas.width, w = this._canvas.height);
                var M = v / w;
                if (this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var F = v / this.cols, m = w / this.rows;
                  M = F / m;
                }
                return M;
              }
              setTexture(v, w, M) {
                if (v.needsUpdate) {
                  v.__webglInit || (v.__webglInit = !0, v.addEventListener("dispose", this.onTextureDispose.bind(this)), v.__webglTexture = this._gl.createTexture(), this.info.memory.textures++), this._gl.activeTexture(this._gl.TEXTURE0 + w);
                  var F = M ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D;
                  this._gl.bindTexture(F, v.__webglTexture), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, v.flipY), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha), this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, v.unpackAlignment), this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, v.unpackAlignment);
                  var m = this.paramToGL(v.format), E = this.paramToGL(v.type);
                  if (M)
                    this.setTextureParameters(this._gl.TEXTURE_3D, v), this._gl.texImage3D(this._gl.TEXTURE_3D, 0, this._gl.R32F, v.image.size.z, v.image.size.y, v.image.size.x, 0, this._gl.RED, this._gl.FLOAT, v.image.data);
                  else {
                    var z = v.image, O = z.width, R = z.height;
                    typeof O > "u" && (O = z.length, m == this._gl.RGBA && (O /= 4), R = 1), this.setTextureParameters(this._gl.TEXTURE_2D, v), this.isWebGL1() ? this._gl.texImage2D(this._gl.TEXTURE_2D, 0, m, m, E, v.image) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, m, O, R, 0, m, E, v.image);
                  }
                  v.needsUpdate = !1, v.onUpdate && v.onUpdate();
                } else
                  this._gl.activeTexture(this._gl.TEXTURE0 + w), M ? this._gl.bindTexture(this._gl.TEXTURE_3D, v.__webglTexture) : this._gl.bindTexture(this._gl.TEXTURE_2D, v.__webglTexture);
              }
              supportsVolumetric() {
                return !this.isWebGL1();
              }
              enableAttribute(v) {
                this._enabledAttributes[v] || (this._gl.enableVertexAttribArray(v), this._enabledAttributes[v] = !0);
              }
              disableAttributes() {
                for (let v in this._enabledAttributes)
                  this._enabledAttributes[v] && (this._gl.disableVertexAttribArray(v), this._enabledAttributes[v] = !1);
              }
              setPolygonOffset(v, w, M) {
                this._oldPolygonOffset !== v && (v ? this._gl.enable(this._gl.POLYGON_OFFSET_FILL) : this._gl.disable(this._gl.POLYGON_OFFSET_FILL));
              }
              setLineWidth(v) {
                v !== this._oldLineWidth && (this._gl.lineWidth(v), this._oldLineWidth = v);
              }
              deallocateGeometry(v) {
                if (v.__webglInit = void 0, v.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(v.__webglVertexBuffer), v.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(v.__webglColorBuffer), v.geometryGroups !== void 0)
                  for (var w = 0, M = v.groups; w < M; w++) {
                    var F = v.geometryGroups[w];
                    F.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(F.__webglVertexBuffer), F.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(F.__webglColorBuffer), F.__webglNormalBuffer !== void 0 && this._gl.deleteBuffer(F.__webglNormalBuffer), F.__webglFaceBuffer !== void 0 && this._gl.deleteBuffer(F.__webglFaceBuffer), F.__webglLineBuffer !== void 0 && this._gl.deleteBuffer(F.__webglLineBuffer);
                  }
              }
              deallocateMaterial(v) {
                var w = v.program;
                if (w !== void 0) {
                  v.program = void 0;
                  var M, F, m, E = !1;
                  for (M = 0, F = this._programs.length; M < F; M++)
                    if (m = this._programs[M], m.program === w) {
                      m.usedTimes--, m.usedTimes === 0 && (E = !0);
                      break;
                    }
                  if (E === !0) {
                    var z = [];
                    for (M = 0, F = this._programs.length; M < F; M++)
                      m = this._programs[M], m.program !== w && z.push(m);
                    this._programs = z, this._gl.deleteProgram(w), this.info.memory.programs--;
                  }
                }
              }
              deallocateTexture(v) {
                if (v.image && v.image.__webglTextureCube)
                  this._gl.deleteTexture(v.image.__webglTextureCube);
                else {
                  if (!v.__webglInit)
                    return;
                  v.__webglInit = !1, this._gl.deleteTexture(v.__webglTexture);
                }
              }
              onGeometryDispose(v) {
                var w = v.target;
                w.removeEventListener("dispose", this.onGeometryDispose), this.deallocateGeometry(w), this.info.memory.geometries--;
              }
              onTextureDispose(v) {
                var w = v.target;
                w.removeEventListener("dispose", this.onTextureDispose), this.deallocateTexture(w), this.info.memory.textures--;
              }
              onMaterialDispose(v) {
                var w = v.target;
                w.removeEventListener("dispose", this.onMaterialDispose), this.deallocateMaterial(w);
              }
              // Compile and return shader
              getShader(v, w) {
                var M;
                return !this.isWebGL1() && !w.startsWith("#version") && (w = w.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), v == "fragment" ? w = w.replace(/varying/g, "in") : w = w.replace(/varying/g, "out"), w = w.replace(/attribute/g, "in"), w = w.replace(/texture2D/g, "texture"), w = w.replace(/\/\/DEFINEFRAGCOLOR/g, "out vec4 glFragColor;"), w = w.replace(/gl_FragColor/g, "glFragColor"), w = `#version 300 es
` + w), v === "fragment" ? M = this._gl.createShader(this._gl.FRAGMENT_SHADER) : v === "vertex" && (M = this._gl.createShader(this._gl.VERTEX_SHADER)), M == null ? null : (this._gl.shaderSource(M, w), this._gl.compileShader(M), this._gl.getShaderParameter(M, this._gl.COMPILE_STATUS) ? M : (console.error(this._gl.getShaderInfoLog(M)), console.error("could not initialize shader"), null));
              }
              // Compile appropriate shaders (if necessary) from source code and attach to
              // gl program.
              buildProgram(v, w, M, F) {
                var m, E, z, O, R = [];
                R.push(v), R.push(w);
                for (m in F)
                  R.push(m), R.push(F[m]);
                for (O = R.join(), m = 0, E = this._programs.length; m < E; m++) {
                  var B = this._programs[m];
                  if (B.code === O)
                    return B.usedTimes++, B.program;
                }
                if (this.isWebGL1() && F.volumetric)
                  throw new Error("Volumetric rendering requires webgl2 which is not supported by your hardware.");
                if (z = this._gl.createProgram(), z == null)
                  return null;
                var P = this._precision, W = "precision " + P + " float;", U = [
                  F.volumetric ? "#version 300 es" : "",
                  W
                ].join(`
`), V = [
                  F.volumetric ? "#version 300 es" : "",
                  F.fragdepth && this.isWebGL1() ? "#extension GL_EXT_frag_depth: enable" : "",
                  F.shaded ? "#define SHADED 1" : "",
                  F.wireframe ? "#define WIREFRAME 1" : "",
                  W
                ].join(`
`), K = this.getShader("fragment", V + v), q = this.getShader("vertex", U + w);
                q != null && this._gl.attachShader(z, q), K != null && this._gl.attachShader(z, K), this._gl.linkProgram(z), this._gl.getProgramParameter(z, this._gl.LINK_STATUS) || console.error("Could not initialize shader"), z.uniforms = {}, z.attributes = {};
                var H, j, Q;
                H = [
                  "viewMatrix",
                  "modelViewMatrix",
                  "projectionMatrix",
                  "normalMatrix",
                  "vWidth",
                  "vHeight"
                ];
                for (j in M)
                  H.push(j);
                for (Q = 0; Q < H.length; Q++) {
                  var J = H[Q];
                  z.uniforms[J] = this._gl.getUniformLocation(z, J);
                }
                for (H = [
                  "position",
                  "normal",
                  "color",
                  "lineDistance",
                  "offset",
                  "radius"
                ], Q = 0; Q < H.length; Q++) {
                  var Y = H[Q];
                  z.attributes[Y] = this._gl.getAttribLocation(z, Y);
                }
                return z.id = this._programs_counter++, this._programs.push({
                  program: z,
                  code: O,
                  usedTimes: 1
                }), this.info.memory.programs = this._programs.length, z;
              }
              setProgram(v, w, M, F, m, E) {
                if (F.needsUpdate && (F.program && this.deallocateMaterial(F), this.initMaterial(F, w, M, m), F.needsUpdate = !1), F.program == null)
                  return null;
                var z = !1, O = F.program, R = O.uniforms, B = F.uniforms;
                if (O != this._currentProgram && (this._gl.useProgram(O), this._currentProgram = O, z = !0), F.id != this._currentMaterialId && (this._currentMaterialId = F.id, z = !0), v != this._currentCamera && (this._currentCamera = v, z = !0), R.projectionMatrix && this._gl.uniformMatrix4fv(R.projectionMatrix, !1, v.projectionMatrix.elements), R.modelViewMatrix && this._gl.uniformMatrix4fv(R.modelViewMatrix, !1, m._modelViewMatrix.elements), R.normalMatrix && this._gl.uniformMatrix3fv(R.normalMatrix, !1, m._normalMatrix.elements), R.projinv && (this._projInverse.getInverse(v.projectionMatrix), this._gl.uniformMatrix4fv(R.projinv, !1, this._projInverse.elements)), R.viewMatrix && this._gl.uniformMatrix4fv(R.viewMatrix, !1, v.matrixWorldInverse.elements), R.vWidth && this._gl.uniform1f(R.vWidth, this._viewportWidth), R.vHeight && this._gl.uniform1f(R.vHeight, this._viewportHeight), z) {
                  if (B.fogColor.value = M.color, B.fogNear.value = M.near, B.fogFar.value = M.far, F.shaderID.startsWith("lambert") || F.shaderID === "instanced" || F.shaderID.endsWith("imposter"))
                    this._lightsNeedUpdate && (this.setupLights(O, w), this._lightsNeedUpdate = !1), B.directionalLightColor.value = this._lights.directional.colors, B.directionalLightDirection.value = this._lights.directional.positions;
                  else if (F.shaderID.endsWith("outline"))
                    B.outlineColor.value = F.outlineColor, B.outlineWidth.value = F.outlineWidth, B.outlinePushback.value = F.outlinePushback, B.outlineMaxPixels.value = F.outlineMaxPixels * this.devicePixelRatio;
                  else if (F.shaderID === "volumetric") {
                    m._modelViewMatrix.getScale(this._direction), this._worldInverse.getInverse(m._modelViewMatrix), this._projInverse.getInverse(v.projectionMatrix), this._textureMatrix.multiplyMatrices(m.material.texmatrix, this._worldInverse), this._gl.uniformMatrix4fv(R.textmat, !1, this._textureMatrix.elements), this._gl.uniformMatrix4fv(R.projinv, !1, this._projInverse.elements);
                    let P = Math.min(Math.min(this._direction.x, this._direction.y), this._direction.z);
                    B.step.value = m.material.unit * P, B.maxdepth.value = m.material.maxdepth * P, B.transfermax.value = m.material.transfermax, B.transfermin.value = m.material.transfermin, B.subsamples.value = m.material.subsamples, E.setTexture(m.material.transferfn, 4, !1), E.setTexture(m.material.map, 3, !0), this._gl.activeTexture(this._gl.TEXTURE5), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);
                  }
                  B.opacity.value = F.opacity, this.loadMaterialUniforms(R, B);
                }
                return B.shading && (B.shading.value == 3 ? (this._gl.activeTexture(this._gl.TEXTURE0 + this.SHADE_TEXTURE), this._gl.bindTexture(this._gl.TEXTURE_2D, this._shadingTexture)) : console.error("Invalid shading textures.")), O;
              }
              loadMaterialUniforms(v, w) {
                var M, F, m, E;
                for (M in w)
                  v[M] && (F = w[M].type, m = w[M].value, E = v[M], F === "f" ? this._gl.uniform1f(E, m) : F === "i" ? this._gl.uniform1i(E, m) : F === "fv" ? this._gl.uniform3fv(E, m) : F === "c" ? this._gl.uniform3f(E, m.r, m.g, m.b) : F === "f4" && this._gl.uniform4f(E, m[0], m[1], m[2], m[3]));
              }
              // Objects adding
              addObject(v, w) {
                var M, F, m, E;
                if (!v.__webglInit && (v.__webglInit = !0, v._modelViewMatrix = new A.Matrix4(), v._normalMatrix = new A.Matrix3(), v.geometry !== void 0 && v.geometry.__webglInit === void 0 && (v.geometry.__webglInit = !0, v.geometry.addEventListener("dispose", this.onGeometryDispose.bind(this))), v instanceof x.Mesh || v instanceof x.Line))
                  for (m = v.geometry, M = 0, F = m.geometryGroups.length; M < F; M++)
                    E = m.geometryGroups[M], E.id = this._geometryGroupCounter++, E.__webglVertexBuffer || (v instanceof x.Mesh ? (this.createMeshBuffers(E), m.elementsNeedUpdate = !0, m.normalsNeedUpdate = !0) : v instanceof x.Line && this.createLineBuffers(E), m.verticesNeedUpdate = !0, m.colorsNeedUpdate = !0);
                if (!v.__webglActive) {
                  if (v instanceof x.Mesh || v instanceof x.Line)
                    for (m = v.geometry, M = 0, F = m.geometryGroups.length; M < F; M++)
                      E = m.geometryGroups[M], this.addBuffer(w.__webglObjects, E, v);
                  else v instanceof x.Sprite && w.__webglSprites.push(v);
                  v.__webglActive = !0;
                }
              }
              updateObject(v) {
                var w = v.geometry, M;
                if (v instanceof x.Mesh || v instanceof x.Line) {
                  for (var F = 0, m = w.geometryGroups.length; F < m; F++)
                    M = w.geometryGroups[F], (w.verticesNeedUpdate || w.elementsNeedUpdate || w.colorsNeedUpdate || w.normalsNeedUpdate) && this.setBuffers(M, this._gl.STATIC_DRAW);
                  w.verticesNeedUpdate = !1, w.elementsNeedUpdate = !1, w.normalsNeedUpdate = !1, w.colorsNeedUpdate = !1, w.buffersNeedUpdate = !1;
                }
              }
              removeObject(v, w) {
                v instanceof x.Mesh || v instanceof x.Line ? this.removeInstances(w.__webglObjects, v) : v instanceof x.Sprite && this.removeInstancesDirect(w.__webglSprites, v), v.__webglActive = !1;
              }
              removeInstances(v, w) {
                for (var M = v.length - 1; M >= 0; --M)
                  v[M].object === w && v.splice(M, 1);
              }
              removeInstancesDirect(v, w) {
                for (var M = v.length - 1; M >= 0; --M)
                  v[M] === w && v.splice(M, 1);
              }
              unrollBufferMaterial(v) {
                var w = v.object, M = w.material;
                if (M.volumetric)
                  v.opaque = null, v.transparent = null, v.volumetric = M;
                else if (M.transparent) {
                  if (v.opaque = null, v.volumetric = null, v.transparent = M, !M.wireframe) {
                    let F = M.clone();
                    F.opacity = 0, v.transparentDepth = F;
                  }
                } else {
                  if (v.opaque = M, v.transparent = null, v.volumetric = null, !M.wireframe) {
                    let F = M.clone();
                    F.opacity = 0, v.opaqueDepth = F;
                  }
                  M.hasAO && (v.hasAO = !0), (this._AOEnabled || v.hasAO) && (v.opaqueShaded = M.clone(), v.opaqueShaded.shaded = !0);
                }
              }
              setBuffers(v, w) {
                var M = v.vertexArray, F = v.colorArray;
                if (v.__webglOffsetBuffer !== void 0 ? (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, v.__webglOffsetBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, M, w)) : (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, v.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, M, w)), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, v.__webglColorBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, F, w), v.normalArray && v.__webglNormalBuffer !== void 0) {
                  var m = v.normalArray;
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, v.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, m, w);
                }
                if (v.radiusArray && v.__webglRadiusBuffer !== void 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, v.__webglRadiusBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, v.radiusArray, w)), v.faceArray && v.__webglFaceBuffer !== void 0) {
                  var E = v.faceArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, v.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, E, w);
                }
                if (v.lineArray && v.__webglLineBuffer !== void 0) {
                  var z = v.lineArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, v.__webglLineBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, z, w);
                }
              }
              // Creates appropriate gl buffers for geometry chunk
              // TODO: do we need line buffer for mesh objects?
              // Also, can we integrate this with createLineBuffers?
              createMeshBuffers(v) {
                v.radiusArray && (v.__webglRadiusBuffer = this._gl.createBuffer()), v.useOffset && (v.__webglOffsetBuffer = this._gl.createBuffer()), v.__webglVertexBuffer = this._gl.createBuffer(), v.__webglNormalBuffer = this._gl.createBuffer(), v.__webglColorBuffer = this._gl.createBuffer(), v.__webglFaceBuffer = this._gl.createBuffer(), v.__webglLineBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              createLineBuffers(v) {
                v.__webglVertexBuffer = this._gl.createBuffer(), v.__webglColorBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              addBuffer(v, w, M) {
                v.push({
                  buffer: w,
                  object: M,
                  opaque: null,
                  transparent: null
                });
              }
              setupMatrices(v, w) {
                v._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, v.matrixWorld), v._normalMatrix.getInverse(v._modelViewMatrix), v._normalMatrix.transpose();
              }
              // Fallback filters for non-power-of-2 textures
              filterFallback(v) {
                return this._gl.LINEAR;
              }
              setTextureParameters(v, w) {
                v == this._gl.TEXTURE_2D ? (this._gl.texParameteri(v, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(v, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(v, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(w.magFilter)), this._gl.texParameteri(v, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(w.minFilter))) : (this._gl.texParameteri(v, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(v, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(v, this._gl.TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE), this._extColorBufferFloat && this._extFloatLinear ? (this._gl.texParameteri(v, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(v, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR)) : (this._gl.texParameteri(v, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(v, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST)));
              }
              // Map constants to WebGL constants
              paramToGL(v) {
                return v === h.UnsignedByteType ? this._gl.UNSIGNED_BYTE : v === h.RGBAFormat ? this._gl.RGBA : v === h.NearestFilter ? this._gl.NEAREST : 0;
              }
              setupLights(v, w) {
                var M, F, m, E = 0, z = 0, O = 0, R, B, P = this._lights, W = P.directional.colors, U = P.directional.positions, V = 0, K = 0;
                for (M = 0, F = w.length; M < F; M++)
                  if (m = w[M], R = m.color, B = m.intensity, m instanceof b.Light) {
                    if (this._direction.getPositionFromMatrix(m.matrixWorld), this._vector3.getPositionFromMatrix(m.target.matrixWorld), this._direction.sub(this._vector3), this._direction.normalize(), this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)
                      continue;
                    U[K] = this._direction.x, U[K + 1] = this._direction.y, U[K + 2] = this._direction.z, W[K] = R.r * B, W[K + 1] = R.g * B, W[K + 2] = R.b * B, K += 3, V++;
                  }
                P.ambient[0] = E, P.ambient[1] = z, P.ambient[2] = O, P.directional.length = V;
              }
              initGL() {
                try {
                  if (OffscreenCanvas && !(this.rows != null && this.cols != null && this.row != null && this.col != null))
                    (L == null || L.isContextLost()) && (C = new OffscreenCanvas(this._canvas.width, this._canvas.height), L = C.getContext("webgl2", {
                      alpha: !0,
                      premultipliedAlpha: this._premultipliedAlpha,
                      antialias: this._antialias,
                      preserveDrawingBuffer: this._preserveDrawingBuffer
                    })), this._offscreen = C, this._gl = L, this._bitmap = this._canvas.getContext("bitmaprenderer", {
                      alpha: !0
                    });
                  else if (!(this._gl = this._canvas.getContext("webgl2", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("experimental-webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })))
                    throw "Error creating WebGL context.";
                  var v = this._gl.getParameter(this._gl.VERSION);
                  this._webglversion = parseInt(v[6]);
                } catch (w) {
                  console.error(w);
                }
              }
              isWebGL1() {
                return this._webglversion == 1;
              }
              setDefaultGLState() {
                this._gl.clearDepth(1), this._gl.clearStencil(0), this._gl.enable(this._gl.DEPTH_TEST), this._gl.depthFunc(this._gl.LEQUAL), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.enable(this._gl.CULL_FACE), this._gl.enable(this._gl.BLEND), this._gl.blendEquation(this._gl.FUNC_ADD), this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              // rendering
              renderObjects(v, w, M, F, m, E, z) {
                var O, R, B, P, W, U, V;
                w ? (W = v.length - 1, U = -1, V = -1) : (W = 0, U = v.length, V = 1);
                for (var K = W; K !== U; K += V)
                  if (O = v[K], O.render) {
                    if (R = O.object, B = O.buffer, P = O[M], (O.hasAO || this._AOEnabled) && O[M + "Shaded"] && (P = O[M + "Shaded"]), !P)
                      continue;
                    z && this.setBlending(!0), this.setDepthTest(P.depthTest), this.setDepthWrite(P.depthWrite), this.setPolygonOffset(P.polygonOffset, P.polygonOffsetFactor, P.polygonOffsetUnits);
                    var q = R._modelViewMatrix.isReflected();
                    if (this.setMaterialFaces(P, q), this.renderBuffer(F, m, E, P, B, R), (this._outlineEnabled || P.outline) && !P.wireframe && P.shaderID !== "basic" && P.opacity !== 0) {
                      let H = this._outlineMaterial;
                      P.shaderID == "sphereimposter" ? H = this._outlineSphereImposterMaterial : P.shaderID == "stickimposter" && (H = this._outlineStickImposterMaterial), this.renderBuffer(F, m, E, H, B, R);
                    }
                  }
              }
              renderSprites(v, w, M) {
                this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1, this._lightsNeedUpdate = !0, this.sprites.render(v, w, this._currentWidth, this._currentHeight, M), this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/SpritePlugin.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/SpritePlugin.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SpritePlugin: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./shaders/index */
              "./src/WebGL/shaders/index.ts"
            );
            class s {
              constructor() {
                this.sprite = {
                  vertices: null,
                  faces: null,
                  vertexBuffer: null,
                  elementBuffer: null,
                  program: null,
                  attributes: {},
                  uniforms: null
                };
              }
              init(g) {
                this.gl = g.context, this.renderer = g, this.precision = g.getPrecision(), this.sprite.vertices = new Float32Array(16), this.sprite.faces = new Uint16Array(6);
                var _ = 0;
                this.sprite.vertices[_++] = -1, this.sprite.vertices[_++] = -1, this.sprite.vertices[_++] = 0, this.sprite.vertices[_++] = 0, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = -1, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = 0, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = -1, this.sprite.vertices[_++] = 1, this.sprite.vertices[_++] = 0, this.sprite.vertices[_++] = 1, _ = 0, this.sprite.faces[_++] = 0, this.sprite.faces[_++] = 1, this.sprite.faces[_++] = 2, this.sprite.faces[_++] = 0, this.sprite.faces[_++] = 2, this.sprite.faces[_++] = 3, this.sprite.vertexBuffer = this.gl.createBuffer(), this.sprite.elementBuffer = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.sprite.vertices, this.gl.STATIC_DRAW), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.faces, this.gl.STATIC_DRAW), this.sprite.program = this.createProgram(
                  n.ShaderLib.sprite,
                  this.precision || 1
                  /** added default to single precision */
                ), this.sprite.attributes = {};
                const A = {};
                this.sprite.attributes.position = this.gl.getAttribLocation(this.sprite.program, "position"), this.sprite.attributes.uv = this.gl.getAttribLocation(this.sprite.program, "uv"), A.uvOffset = this.gl.getUniformLocation(this.sprite.program, "uvOffset"), A.uvScale = this.gl.getUniformLocation(this.sprite.program, "uvScale"), A.rotation = this.gl.getUniformLocation(this.sprite.program, "rotation"), A.scale = this.gl.getUniformLocation(this.sprite.program, "scale"), A.alignment = this.gl.getUniformLocation(this.sprite.program, "alignment"), A.color = this.gl.getUniformLocation(this.sprite.program, "color"), A.map = this.gl.getUniformLocation(this.sprite.program, "map"), A.opacity = this.gl.getUniformLocation(this.sprite.program, "opacity"), A.useScreenCoordinates = this.gl.getUniformLocation(this.sprite.program, "useScreenCoordinates"), A.screenPosition = this.gl.getUniformLocation(this.sprite.program, "screenPosition"), A.modelViewMatrix = this.gl.getUniformLocation(this.sprite.program, "modelViewMatrix"), A.projectionMatrix = this.gl.getUniformLocation(this.sprite.program, "projectionMatrix"), A.fogType = this.gl.getUniformLocation(this.sprite.program, "fogType"), A.fogDensity = this.gl.getUniformLocation(this.sprite.program, "fogDensity"), A.fogNear = this.gl.getUniformLocation(this.sprite.program, "fogNear"), A.fogFar = this.gl.getUniformLocation(this.sprite.program, "fogFar"), A.fogColor = this.gl.getUniformLocation(this.sprite.program, "fogColor"), A.alphaTest = this.gl.getUniformLocation(this.sprite.program, "alphaTest"), this.sprite.uniforms = A;
              }
              render(g, _, A, x, k) {
                var $, C, L, y, o, v, w, M, F, m;
                if (!this.gl)
                  throw new Error("WebGLRenderer not initialized");
                let E = [];
                ($ = g?.__webglSprites) === null || $ === void 0 || $.forEach((fe) => {
                  (k && fe.material.depthTest == !1 || !k && fe.material.depthTest) && E.push(fe);
                });
                let z = E.length;
                if (!z)
                  return;
                const O = this.sprite.attributes, R = this.sprite.uniforms;
                if (!R)
                  throw new Error("Uniforms not defined");
                var B = A * 0.5, P = x * 0.5;
                this.gl.useProgram(this.sprite.program), this.gl.enableVertexAttribArray(O.position), this.gl.enableVertexAttribArray(O.uv), this.gl.disable(this.gl.CULL_FACE), this.gl.enable(this.gl.BLEND), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.vertexAttribPointer(O.position, 2, this.gl.FLOAT, !1, 16, 0), this.gl.vertexAttribPointer(O.uv, 2, this.gl.FLOAT, !1, 16, 8), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.uniformMatrix4fv(R.projectionMatrix, !1, _.projectionMatrix.elements), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.uniform1i(R.map, 0);
                var W = 0, U = 0, V = g.fog;
                V ? (this.gl.uniform3f(R.fogColor, V.color.r, V.color.g, V.color.b), this.gl.uniform1f(R.fogNear, V.near), this.gl.uniform1f(R.fogFar, V.far), this.gl.uniform1i(R.fogType, 1), W = 1, U = 1) : (this.gl.uniform1i(R.fogType, 0), W = 0, U = 0);
                var K;
                let q, H, j, Q, J = [];
                for (K = 0; K < z; K++)
                  q = E[K], H = q.material, H && (H.depthTest == !1 && !k || !q.visible || H.opacity === 0 || (H.useScreenCoordinates ? q.z = -q.position.z : (q._modelViewMatrix.multiplyMatrices(_.matrixWorldInverse, q.matrixWorld), q.z = -q._modelViewMatrix.elements[14])));
                for (E.sort(h), K = 0; K < z; K++)
                  if (q = E[K], H = q.material, !!H && !(!q.visible || H.opacity === 0) && H.map && H.map.image && H.map.image.width) {
                    this.gl.uniform1f(R?.alphaTest || null, H.alphaTest);
                    var Y = H.map.image.width, ee = H.map.image.height;
                    J[0] = Y * this.renderer.devicePixelRatio / A, J[1] = ee * this.renderer.devicePixelRatio / x, H.useScreenCoordinates === !0 ? (this.gl.uniform1i(R.useScreenCoordinates, 1), this.gl.uniform3f(R.screenPosition, (q.position.x * this.renderer.devicePixelRatio - B) / B, (P - q.position.y * this.renderer.devicePixelRatio) / P, Math.max(0, Math.min(1, q.position.z)))) : (this.gl.uniform1i(R.useScreenCoordinates, 0), this.gl.uniformMatrix4fv(R.modelViewMatrix, !1, q._modelViewMatrix.elements)), g.fog && H.fog ? Q = U : Q = 0, W !== Q && (this.gl.uniform1i(R.fogType, Q), W = Q), j = 1 / (H.scaleByViewport ? x : 1), J[0] *= j * q.scale.x, J[1] *= j * q.scale.y;
                    let fe = (C = H?.alignment) === null || C === void 0 ? void 0 : C.x, me = (L = H?.alignment) === null || L === void 0 ? void 0 : L.y;
                    H.screenOffset && (fe = (fe || 0) + 2 * H.screenOffset.x / Y, me = (me || 0) + 2 * H.screenOffset.y / ee), this.gl.uniform2f(R.uvScale, ((y = H?.uvScale) === null || y === void 0 ? void 0 : y.x) || 1, ((o = H?.uvScale) === null || o === void 0 ? void 0 : o.y) || 1), this.gl.uniform2f(R.uvOffset, ((v = H?.uvOffset) === null || v === void 0 ? void 0 : v.x) || 0, ((w = H?.uvOffset) === null || w === void 0 ? void 0 : w.y) || 0), this.gl.uniform2f(R.alignment, fe || 0, me || 0), this.gl.uniform1f(R.opacity, H.opacity), this.gl.uniform3f(R.color, ((M = H?.color) === null || M === void 0 ? void 0 : M.r) || 0, ((F = H?.color) === null || F === void 0 ? void 0 : F.g) || 0, ((m = H?.color) === null || m === void 0 ? void 0 : m.b) || 0), this.gl.uniform1f(R.rotation, q.rotation), this.gl.uniform2fv(R.scale, J), this.renderer.setDepthTest(H.depthTest), this.renderer.setDepthWrite(H.depthWrite), this.renderer.setTexture(H.map, 0), this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
                  }
                this.gl.enable(this.gl.CULL_FACE);
              }
              createProgram(g, _) {
                if (!this.gl)
                  throw new Error("WebGL Rendering context not found");
                var A = this.gl.createProgram();
                if (!A)
                  throw new Error("Error creating webgl program");
                var x = this.gl.createShader(this.gl.FRAGMENT_SHADER), k = this.gl.createShader(this.gl.VERTEX_SHADER);
                if (!x)
                  throw new Error("Unable to create fragment shader SpritePlugin.createProgram");
                if (!k)
                  throw new Error("Unable to create vertex shader SpritePlugin.createProgram");
                var $ = "precision " + _ + ` float;
`;
                if (this.gl.shaderSource(x, $ + g.fragmentShader), this.gl.shaderSource(k, $ + g.vertexShader), this.gl.compileShader(x), this.gl.compileShader(k), !this.gl.getShaderParameter(x, this.gl.COMPILE_STATUS) || !this.gl.getShaderParameter(k, this.gl.COMPILE_STATUS))
                  throw new Error(`Error compiling shader: 
      ${this.gl.getShaderInfoLog(x)} 
      ${this.gl.getShaderInfoLog(k)}`);
                return this.gl.attachShader(A, x), this.gl.attachShader(A, k), this.gl.linkProgram(A), this.gl.getProgramParameter(A, this.gl.LINK_STATUS) || console.error("Could not initialize shader"), A;
              }
            }
            function h(b, g) {
              return b.z !== g.z ? g.z - b.z : g.id - b.id;
            }
          }
        ),
        /***/
        "./src/WebGL/constants/Coloring.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/constants/Coloring.ts ***!
            \*****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Coloring: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            var n;
            (function(s) {
              s[s.NoColors = 0] = "NoColors", s[s.FaceColors = 1] = "FaceColors", s[s.VertexColors = 2] = "VertexColors";
            })(n || (n = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Shading.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/constants/Shading.ts ***!
            \****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Shading: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            var n;
            (function(s) {
              s[s.NoShading = 0] = "NoShading", s[s.FlatShading = 1] = "FlatShading", s[s.SmoothShading = 2] = "SmoothShading";
            })(n || (n = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Sides.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/Sides.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              BackSide: () => (
                /* binding */
                s
              ),
              /* harmony export */
              DoubleSide: () => (
                /* binding */
                h
              ),
              /* harmony export */
              FrontSide: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = 0, s = 1, h = 2;
          }
        ),
        /***/
        "./src/WebGL/constants/SpriteAlignment.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/constants/SpriteAlignment.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SpriteAlignment: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const s = {
              topLeft: new n.Vector2(1, -1),
              topCenter: new n.Vector2(0, -1),
              topRight: new n.Vector2(-1, -1),
              centerLeft: new n.Vector2(1, 0),
              center: new n.Vector2(0, 0),
              centerRight: new n.Vector2(-1, 0),
              bottomLeft: new n.Vector2(1, 1),
              bottomCenter: new n.Vector2(0, 1),
              bottomRight: new n.Vector2(-1, 1)
            };
          }
        ),
        /***/
        "./src/WebGL/constants/TextureConstants.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/constants/TextureConstants.ts ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* binding */
                n
              ),
              /* harmony export */
              FloatType: () => (
                /* binding */
                _
              ),
              /* harmony export */
              LinearFilter: () => (
                /* binding */
                s
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* binding */
                b
              ),
              /* harmony export */
              NearestFilter: () => (
                /* binding */
                h
              ),
              /* harmony export */
              R32Format: () => (
                /* binding */
                k
              ),
              /* harmony export */
              RFormat: () => (
                /* binding */
                x
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* binding */
                A
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            const n = 1001, s = 1006, h = 1007, b = 1008, g = 1009, _ = 1010, A = 1021, x = 1022, k = 1023;
          }
        ),
        /***/
        "./src/WebGL/constants/TextureOperations.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/constants/TextureOperations.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              TextureOperations: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            var n;
            (function(s) {
              s[s.MultiplyOperation = 0] = "MultiplyOperation", s[s.MixOperation = 1] = "MixOperation", s[s.AddOperation = 2] = "AddOperation";
            })(n || (n = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/index.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                s.BackSide
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                g.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                n.Coloring
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                s.DoubleSide
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                g.FloatType
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                s.FrontSide
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                g.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                g.LinearMipMapLinearFilter
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                g.NearestFilter
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                g.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                g.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                g.RGBAFormat
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                h.Shading
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                b.SpriteAlignment
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                _.TextureOperations
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                g.UnsignedByteType
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), s = r(
              /*! ./Sides */
              "./src/WebGL/constants/Sides.ts"
            ), h = r(
              /*! ./Shading */
              "./src/WebGL/constants/Shading.ts"
            ), b = r(
              /*! ./SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), g = r(
              /*! ./TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), _ = r(
              /*! ./TextureOperations */
              "./src/WebGL/constants/TextureOperations.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/core/EventDispatcher.ts": (
          /*!*******************************************!*\
            !*** ./src/WebGL/core/EventDispatcher.ts ***!
            \*******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              EventDispatcher: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            class n {
              constructor() {
                this.listeners = {};
              }
              dispatchEvent(h) {
                var b = this.listeners[h.type];
                if (b !== void 0) {
                  h.target = this;
                  for (var g = 0, _ = b.length; g < _; g++)
                    b[g].call(this, h);
                }
              }
              removeEventListener(h, b) {
                if (!b)
                  this.listeners[h] = [];
                else {
                  var g = this.listeners[h].indexOf(b);
                  g !== -1 && this.listeners[h].splice(g, 1);
                }
              }
              addEventListener(h, b) {
                this.listeners[h] === void 0 && (this.listeners[h] = []), this.listeners[h].indexOf(b) === -1 && this.listeners[h].push(b);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Geometry.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Geometry.ts ***!
            \************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Geometry: () => (
                /* binding */
                A
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* binding */
                _
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* binding */
                x
              )
              /* harmony export */
            });
            var n = r(
              /*! ../materials/LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), s = r(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), h = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), b = r(
              /*! ../../colors */
              "./src/colors.ts"
            );
            const g = 65535;
            class _ {
              constructor($ = 0) {
                this.vertexArray = null, this.colorArray = null, this.normalArray = null, this.radiusArray = null, this.faceArray = null, this.lineArray = null, this.atomArray = Array(), this.vertices = 0, this.faceidx = 0, this.lineidx = 0, this.__inittedArrays = !1, this.id = $;
              }
              setColor($) {
                var C = this.vertexArray, L = this.colorArray;
                if (!C)
                  throw new Error("vertex array not initialized");
                if (!L)
                  throw new Error("color array not initialized");
                let y = b.CC.color($);
                for (var o = 0; o < C.length; o += 3)
                  L[o] = y.r, L[o + 1] = y.g, L[o + 2] = y.b;
              }
              setColors($) {
                var C = this.vertexArray, L = this.colorArray;
                if (!C)
                  throw new Error("vertex array not initialized");
                if (!L)
                  throw new Error("color array not initialized");
                if (C.length != L.length) {
                  console.log("Cannot re-color geometry group due to mismatched lengths.");
                  return;
                }
                for (var y = 0; y < C.length; y += 3) {
                  var o = $(C[y], C[y + 1], C[y + 2]);
                  o instanceof b.Color || (o = b.CC.color(o)), L[y] = o.r, L[y + 1] = o.g, L[y + 2] = o.b;
                }
              }
              getNumVertices() {
                return this.vertices;
              }
              getVertices() {
                return this.vertexArray;
              }
              getCentroid() {
                if (!this.vertexArray)
                  throw new Error("vertex array not initialized");
                for (var $ = new h.Vector3(), C, L, y, o, v = 0; v < this.vertices; ++v)
                  C = v * 3, L = this.vertexArray[C], y = this.vertexArray[C + 1], o = this.vertexArray[C + 2], $.x += L, $.y += y, $.z += o;
                return $.divideScalar(this.vertices), $;
              }
              //setup normals - vertex and face array must exist
              setNormals() {
                var $ = this.faceArray, C = this.vertexArray, L = this.normalArray;
                if (!(!this.vertices || !this.faceidx)) {
                  if (!$)
                    throw new Error("face array not initialized");
                  if (!C)
                    throw new Error("vertex array not initialized");
                  if (!L)
                    throw new Error("normal array not initialized");
                  for (var y, o, v, w, M, F, m, E = 0; E < $.length / 3; ++E)
                    y = $[E * 3] * 3, o = $[E * 3 + 1] * 3, v = $[E * 3 + 2] * 3, w = new h.Vector3(C[y], C[y + 1], C[y + 2]), M = new h.Vector3(C[o], C[o + 1], C[o + 2]), F = new h.Vector3(C[v], C[v + 1], C[v + 2]), w.subVectors(w, M), F.subVectors(F, M), F.cross(w), m = F, m.normalize(), L[y] += m.x, L[o] += m.x, L[v] += m.x, L[y + 1] += m.y, L[o + 1] += m.y, L[v + 1] += m.y, L[y + 2] += m.z, L[o + 2] += m.z, L[v + 2] += m.z;
                }
              }
              /* sets line index array from face arr
              Note - assumes all faces are triangles (i.e. there will
              be an extra diagonal for four-sided faces - user should
              specify linearr for custom shape generation to show wireframe squares
              as rectangles rather than two triangles) */
              setLineIndices() {
                if (this.faceidx && !(this.lineArray && this.lineArray.length == this.faceidx * 2 && this.lineidx == this.faceidx * 2)) {
                  var $ = this.faceArray, C = this.lineArray = new Uint16Array(this.faceidx * 2);
                  if (this.lineidx = this.faceidx * 2, !$)
                    throw new Error("face array not initialized");
                  for (var L = 0; L < this.faceidx / 3; ++L) {
                    var y = L * 3, o = y * 2, v = $[y], w = $[y + 1], M = $[y + 2];
                    C[o] = v, C[o + 1] = w, C[o + 2] = v, C[o + 3] = M, C[o + 4] = w, C[o + 5] = M;
                  }
                }
              }
              vrml($, C) {
                var L, y, o, v, w, M, F, m, E, z, O, R, B, P, W, U, V, K, q = "";
                if (q += $ + `Shape {
` + $ + ` appearance Appearance {
` + $ + `  material Material {
` + $ + "   diffuseColor " + ((L = C?.color) === null || L === void 0 ? void 0 : L.r) + " " + ((y = C?.color) === null || y === void 0 ? void 0 : y.g) + " " + ((o = C?.color) === null || o === void 0 ? void 0 : o.b) + `
`, C.wireframe && this.colorArray) {
                  let j = this.colorArray;
                  q += $ + "    emissiveColor " + j[0] + " " + j[1] + " " + j[2] + `
`;
                }
                C?.transparent && (q += $ + "   transparency " + (1 - C.opacity) + `
`), q += $ + `  }
`, q += $ + ` }
`;
                var H = $;
                if ($ += " ", C instanceof n.LineBasicMaterial || C.wireframe) {
                  q += $ + `geometry IndexedLineSet {
` + $ + ` colorPerVertex TRUE
` + $ + ` coord Coordinate {
` + $ + `  point [
`;
                  let j, Q, J;
                  for (let Y = 0; Y < this.vertices; ++Y) {
                    let ee = Y * 3;
                    j = (v = this.vertexArray) === null || v === void 0 ? void 0 : v[ee], Q = (w = this.vertexArray) === null || w === void 0 ? void 0 : w[ee + 1], J = (M = this.vertexArray) === null || M === void 0 ? void 0 : M[ee + 2], q += $ + "   " + j + " " + Q + " " + J + `,
`;
                  }
                  if (q += $ + `  ]
`, q += $ + ` }
`, this.colorArray && !C.wireframe) {
                    q += $ + ` color Color {
` + $ + `  color [
`;
                    for (let Y = 0; Y < this.vertices; ++Y) {
                      let ee = Y * 3;
                      j = this.colorArray[ee], Q = this.colorArray[ee + 1], J = this.colorArray[ee + 2], q += $ + "   " + j + " " + Q + " " + J + `,
`;
                    }
                    q += $ + `  ]
`, q += $ + ` }
`;
                  }
                  if (q += $ + ` coordIndex [
`, C.wireframe && this.faceArray)
                    for (let Y = 0; Y < this.faceidx; Y += 3)
                      j = (F = this.faceArray) === null || F === void 0 ? void 0 : F[Y], Q = (m = this.faceArray) === null || m === void 0 ? void 0 : m[Y + 1], J = (E = this.faceArray) === null || E === void 0 ? void 0 : E[Y + 2], q += $ + "  " + j + ", " + Q + ", " + J + `, -1,
`;
                  else
                    for (let Y = 0; Y < this.vertices - 1; Y += 2)
                      q += $ + "  " + Y + ", " + (Y + 1) + `, -1,
`;
                  q += $ + ` ]
`, q += $ + `}
`;
                } else {
                  q += $ + `geometry IndexedFaceSet {
` + $ + ` colorPerVertex TRUE
` + $ + ` normalPerVertex TRUE
` + $ + ` solid FALSE
`, q += $ + ` coord Coordinate {
` + $ + `  point [
`;
                  let j, Q, J;
                  for (let Y = 0; Y < this.vertices; ++Y) {
                    let ee = Y * 3;
                    j = (z = this.vertexArray) === null || z === void 0 ? void 0 : z[ee], Q = (O = this.vertexArray) === null || O === void 0 ? void 0 : O[ee + 1], J = (R = this.vertexArray) === null || R === void 0 ? void 0 : R[ee + 2], q += $ + "   " + j + " " + Q + " " + J + `,
`;
                  }
                  q += $ + `  ]
`, q += $ + ` }
`, q += $ + ` normal Normal {
` + $ + `  vector [
`;
                  for (let Y = 0; Y < this.vertices; ++Y) {
                    let ee = Y * 3;
                    j = (B = this.normalArray) === null || B === void 0 ? void 0 : B[ee], Q = (P = this.normalArray) === null || P === void 0 ? void 0 : P[ee + 1], J = (W = this.normalArray) === null || W === void 0 ? void 0 : W[ee + 2], q += $ + "   " + j + " " + Q + " " + J + `,
`;
                  }
                  if (q += $ + `  ]
`, q += $ + ` }
`, this.colorArray) {
                    q += $ + ` color Color {
` + $ + `  color [
`;
                    for (let Y = 0; Y < this.vertices; ++Y) {
                      let ee = Y * 3;
                      j = this.colorArray[ee], Q = this.colorArray[ee + 1], J = this.colorArray[ee + 2], q += $ + "   " + j + " " + Q + " " + J + `,
`;
                    }
                    q += $ + `  ]
`, q += $ + ` }
`;
                  }
                  q += $ + ` coordIndex [
`;
                  for (let Y = 0; Y < this.faceidx; Y += 3)
                    j = (U = this.faceArray) === null || U === void 0 ? void 0 : U[Y], Q = (V = this.faceArray) === null || V === void 0 ? void 0 : V[Y + 1], J = (K = this.faceArray) === null || K === void 0 ? void 0 : K[Y + 2], q += $ + "  " + j + ", " + Q + ", " + J + `, -1,
`;
                  q += $ + ` ]
`, q += $ + `}
`;
                }
                return q += H + "}", q;
              }
              truncateArrayBuffers($ = !0, C = !1) {
                var L = this.vertexArray, y = this.colorArray, o = this.normalArray, v = this.faceArray, w = this.lineArray, M = this.radiusArray;
                this.vertexArray = L?.subarray(0, this.vertices * 3) || null, this.colorArray = y?.subarray(0, this.vertices * 3) || null, $ ? (this.normalArray = o?.subarray(0, this.vertices * 3) || null, this.faceArray = v?.subarray(0, this.faceidx) || null, this.lineidx > 0 ? this.lineArray = w?.subarray(0, this.lineidx) || null : this.lineArray = new Uint16Array(0)) : (this.normalArray = new Float32Array(0), this.faceArray = new Uint16Array(0), this.lineArray = new Uint16Array(0)), M && (this.radiusArray = M.subarray(0, this.vertices)), C && (this.normalArray && (this.normalArray = new Float32Array(this.normalArray)), this.faceArray && (this.faceArray = new Uint16Array(this.faceArray)), this.lineArray && (this.lineArray = new Uint16Array(this.lineArray)), this.vertexArray && (this.vertexArray = new Float32Array(this.vertexArray)), this.colorArray && (this.colorArray = new Float32Array(this.colorArray)), this.radiusArray && (this.radiusArray = new Float32Array(this.radiusArray))), this.__inittedArrays = !0;
              }
            }
            class A extends s.EventDispatcher {
              constructor($ = !1, C = !1, L = !1) {
                super(), this.name = "", this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.buffersNeedUpdate = !1, this.imposter = !1, this.instanced = !1, this.geometryGroups = [], this.groups = 0, this.id = x++, this.mesh = $, this.radii = C, this.offset = L;
              }
              //Get geometry group to accomodate addVertices new vertices - create
              // new group if necessary
              updateGeoGroup($ = 0) {
                var C, L = this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;
                return (!L || L.vertices + $ > (((C = L?.vertexArray) === null || C === void 0 ? void 0 : C.length) || 0) / 3) && (L = this.addGeoGroup()), L;
              }
              //return comma separated list of IndexedFace (or Line) sets from geometry groups
              vrml($, C) {
                for (var L = "", y = this.geometryGroups.length, o = 0; o < y; o++) {
                  var v = this.geometryGroups[o];
                  L += v.vrml($, C) + `,
`;
                }
                return L;
              }
              addGeoGroup() {
                var $ = new _(this.geometryGroups.length);
                return this.geometryGroups.push($), this.groups = this.geometryGroups.length, $.vertexArray = new Float32Array(g * 3), $.colorArray = new Float32Array(g * 3), this.mesh && ($.normalArray = new Float32Array(g * 3), $.faceArray = new Uint16Array(g * 6), $.lineArray = new Uint16Array(g * 6)), this.radii && ($.radiusArray = new Float32Array(g)), $.useOffset = this.offset, $;
              }
              setUpNormals(...$) {
                for (var C = 0; C < this.groups; C++) {
                  var L = this.geometryGroups[C];
                  L.setNormals(...$);
                }
              }
              setColors(...$) {
                for (var C = this.geometryGroups.length, L = 0; L < C; L++) {
                  var y = this.geometryGroups[L];
                  y.setColors(...$);
                }
              }
              setColor(...$) {
                for (var C = this.geometryGroups.length, L = 0; L < C; L++) {
                  var y = this.geometryGroups[L];
                  y.setColor(...$);
                }
              }
              setUpWireframe(...$) {
                for (var C = 0; C < this.groups; C++) {
                  var L = this.geometryGroups[C];
                  L.setLineIndices(...$);
                }
              }
              //After vertices, colors, etc are collected in regular or typed arrays,
              //  create typed arrays from regular arrays if they don't already exist,
              initTypedArrays() {
                for (var $ = 0; $ < this.groups; $++) {
                  var C = this.geometryGroups[$];
                  C.__inittedArrays !== !0 && C.truncateArrayBuffers(this.mesh, !1);
                }
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
              get vertices() {
                for (var $ = 0, C = 0; C < this.groups; C++)
                  $ += this.geometryGroups[C].vertices;
                return $;
              }
            }
            let x = 0;
          }
        ),
        /***/
        "./src/WebGL/core/Object3D.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Object3D.ts ***!
            \************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Light: () => (
                /* binding */
                _
              ),
              /* harmony export */
              Object3D: () => (
                /* binding */
                b
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* binding */
                h
              ),
              /* harmony export */
              Scene: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), s = r(
              /*! ../../colors */
              "./src/colors.ts"
            );
            let h = 0;
            class b {
              constructor() {
                this.id = h++, this.name = "", this.children = [], this.position = new n.Vector3(), this.rotation = new n.Vector3(), this.matrix = new n.Matrix4(), this.matrixWorld = new n.Matrix4(), this.quaternion = new n.Quaternion(), this.eulerOrder = "XYZ", this.up = new n.Vector3(0, 1, 0), this.scale = new n.Vector3(1, 1, 1), this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !0, this.rotationAutoUpdate = !0, this.useQuaternion = !1, this.visible = !0;
              }
              lookAt(x) {
                this.matrix.lookAt(x, this.position, this.up), this.rotationAutoUpdate && (this.useQuaternion === !0 ? console.error("Unimplemented math operation.") : this.rotation instanceof n.Vector3 && this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder));
              }
              //add child object
              add(x) {
                if (x === this) {
                  console.error("Can't add $3Dmol.Object3D to itself");
                  return;
                }
                x.parent = this, this.children.push(x);
                for (var k = this; k.parent !== void 0; )
                  k = k.parent;
                k !== void 0 && k instanceof g && k.__addObject(x);
              }
              remove(x) {
                var k = this.children.indexOf(x);
                if (k !== -1) {
                  x.parent = void 0, this.children.splice(k, 1);
                  for (var $ = this; $.parent !== void 0; )
                    $ = $.parent;
                  $ !== void 0 && $ instanceof g && $.__removeObject(x);
                }
              }
              //convert to vrml
              vrml(x) {
                x || (x = " ");
                var k = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w), $ = 0, C = 0, L = 0;
                if (k != 0) {
                  let v = Math.sin(k / 2);
                  $ = this.quaternion.x / v, C = this.quaternion.y / v, L = this.quaternion.z / v;
                }
                var y = x + `Transform {
` + x + " center " + this.position.x + " " + this.position.y + " " + this.position.z + `
` + x + " rotation " + $ + " " + C + " " + L + " " + k + `
` + x + ` children [
`;
                this.geometry && (y += this.geometry.vrml(x, this.material));
                for (var o = 0; o < this.children.length; o++)
                  y += this.children[o].vrml(x + " ") + `,
`;
                return y += ` ]
`, y += "}", y;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.useQuaternion === !1 && this.rotation instanceof n.Vector3 ? this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder) : this.matrix.setRotationFromQuaternion(this.quaternion), (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              updateMatrixWorld(x) {
                this.matrixAutoUpdate === !0 && this.updateMatrix(), (this.matrixWorldNeedsUpdate === !0 || x === !0) && (this.parent === void 0 ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1;
                for (var k = 0; k < this.children.length; k++)
                  this.children[k].updateMatrixWorld(!0);
              }
              clone(x) {
                x === void 0 && (x = new b()), x.name = this.name, x.up.copy(this.up), x.position.copy(this.position), x.rotation instanceof n.Vector3 && this.rotation instanceof n.Vector3 ? x.rotation.copy(this.rotation) : x.rotation = this.rotation, x.eulerOrder = this.eulerOrder, x.scale.copy(this.scale), x.rotationAutoUpdate = this.rotationAutoUpdate, x.matrix.copy(this.matrix), x.matrixWorld.copy(this.matrixWorld), x.quaternion.copy(this.quaternion), x.matrixAutoUpdate = this.matrixAutoUpdate, x.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, x.useQuaternion = this.useQuaternion, x.visible = this.visible;
                for (var k = 0; k < this.children.length; k++) {
                  var $ = this.children[k];
                  x.add($.clone());
                }
                return x;
              }
              setVisible(x) {
                this.visible = x;
                for (var k = 0; k < this.children.length; k++) {
                  var $ = this.children[k];
                  $.setVisible(x);
                }
              }
            }
            class g extends b {
              constructor() {
                super(...arguments), this.fog = null, this.overrideMaterial = null, this.matrixAutoUpdate = !1, this.__objects = [], this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = [];
              }
              __addObject(x) {
                if (x instanceof _)
                  this.__lights.indexOf(x) === -1 && this.__lights.push(x), x.target && x.target.parent === void 0 && this.add(x.target);
                else if (this.__objects.indexOf(x) === -1) {
                  this.__objects.push(x), this.__objectsAdded.push(x);
                  var k = this.__objectsRemoved.indexOf(x);
                  k !== -1 && this.__objectsRemoved.splice(k, 1);
                }
                for (var $ = 0; $ < x.children.length; $++)
                  this.__addObject(x.children[$]);
              }
              __removeObject(x) {
                var k;
                if (x instanceof _)
                  k = this.__lights.indexOf(x), k !== -1 && this.__lights.splice(k, 1);
                else if (k = this.__objects.indexOf(x), k !== -1) {
                  this.__objects.splice(k, 1), this.__objectsRemoved.push(x);
                  var $ = this.__objectsAdded.indexOf(x);
                  $ !== -1 && this.__objectsAdded.splice(k, 1);
                }
                for (var C = 0; C < x.children.length; C++)
                  this.__removeObject(x.children[C]);
              }
            }
            class _ extends b {
              constructor(x, k = 1) {
                super(), this.position = new n.Vector3(0, 1, 0), this.target = new b(), this.castShadow = !1, this.onlyShadow = !1, this.color = new s.Color(x), this.intensity = k;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Projector.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Projector.ts ***!
            \*************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Projector: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const s = new n.Matrix4();
            class h {
              static unprojectVector(g, _) {
                return _.projectionMatrixInverse.getInverse(_.projectionMatrix), s.multiplyMatrices(_.matrixWorld, _.projectionMatrixInverse), g.applyProjection(s);
              }
              static projectVector(g, _) {
                return _.matrixWorldInverse.getInverse(_.matrixWorld), s.multiplyMatrices(_.projectionMatrix, _.matrixWorldInverse), g.applyProjection(s);
              }
              projectVector(g, _) {
                return h.projectVector(g, _);
              }
              unprojectVector(g, _) {
                return h.unprojectVector(g, _);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Raycaster.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Raycaster.ts ***!
            \*************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Raycaster: () => (
                /* binding */
                g
              ),
              /* harmony export */
              intersectObject: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), s = r(
              /*! ../shapes */
              "./src/WebGL/shapes/index.ts"
            );
            const h = (w, M) => w.distance - M.distance, b = new n.Matrix4();
            class g {
              constructor(M, F, m, E) {
                this.precision = 1e-4, this.linePrecision = 0.2, this.ray = new n.Ray(M, F), this.ray.direction.lengthSq() > 0 && this.ray.direction.normalize(), this.near = E || 0, this.far = m || 1 / 0;
              }
              set(M, F) {
                this.ray.set(M, F);
              }
              setFromCamera(M, F) {
                F.ortho ? (this.ray.origin.set(M.x, M.y, (F.near + F.far) / (F.near - F.far)).unproject(F), this.ray.direction.set(0, 0, -1).transformDirection(F.matrixWorld)) : (this.ray.origin.setFromMatrixPosition(F.matrixWorld), this.ray.direction.set(M.x, M.y, M.z), F.projectionMatrixInverse.getInverse(F.projectionMatrix), b.multiplyMatrices(F.matrixWorld, F.projectionMatrixInverse), this.ray.direction.applyProjection(b), this.ray.direction.sub(this.ray.origin).normalize());
              }
              intersectObjects(M, F) {
                for (var m = [], E = 0, z = F.length; E < z; E++)
                  v(M, F[E], this, m);
                return m.sort(h), m;
              }
            }
            const _ = (w) => Math.min(Math.max(w, -1), 1);
            var A = new s.Sphere(), x = new s.Cylinder(), k = new s.Triangle(), $ = new n.Vector3(), C = new n.Vector3(), L = new n.Vector3(), y = new n.Vector3(), o = new n.Vector3();
            function v(w, M, F, m) {
              if (o.getPositionFromMatrix(w.matrixWorld), M.intersectionShape === void 0)
                return m;
              var E = M.intersectionShape, z = F.linePrecision;
              z *= w.matrixWorld.getMaxScaleOnAxis();
              var O = z * z;
              if (M.boundingSphere !== void 0 && M.boundingSphere instanceof s.Sphere && (A.copy(M.boundingSphere), A.applyMatrix4(w.matrixWorld), !F.ray.isIntersectionSphere(A)))
                return m;
              var R, B, P, W, U, V, K, q, H, j, Q, J, Y, ee;
              for (R = 0, B = E.triangle.length; R < B; R++)
                if (E.triangle[R] instanceof s.Triangle) {
                  if (k.copy(E.triangle[R]), k.applyMatrix4(w.matrixWorld), P = k.getNormal(), W = F.ray.direction.dot(P), W >= 0 || ($.subVectors(k.a, F.ray.origin), K = P.dot($) / W, K < 0))
                    continue;
                  C.copy(F.ray.direction).multiplyScalar(K).add(F.ray.origin), C.sub(k.a), L.copy(k.b).sub(k.a), y.copy(k.c).sub(k.a);
                  var fe = L.dot(y), me = L.lengthSq(), he = y.lengthSq();
                  if (J = (me * C.dot(y) - fe * C.dot(L)) / (me * he - fe * fe), J < 0 || J > 1 || (Q = (C.dot(L) - J * fe) / me, Q < 0 || Q > 1 || Q + J > 1))
                    continue;
                  m.push({ clickable: M, distance: K });
                }
              for (R = 0, B = E.cylinder.length; R < B; R++)
                if (E.cylinder[R] instanceof s.Cylinder) {
                  if (x.copy(E.cylinder[R]), x.applyMatrix4(w.matrixWorld), $.subVectors(x.c1, F.ray.origin), U = $.dot(x.direction), V = $.dot(F.ray.direction), W = _(F.ray.direction.dot(x.direction)), H = 1 - W * W, H === 0)
                    continue;
                  Y = (W * V - U) / H, ee = (V - W * U) / H, C.copy(x.direction).multiplyScalar(Y).add(x.c1), L.copy(F.ray.direction).multiplyScalar(ee).add(F.ray.origin), q = y.subVectors(C, L).lengthSq();
                  var we = x.radius * x.radius;
                  if (q <= we) {
                    if (j = (W * U - V) * (W * U - V) - H * ($.lengthSq() - U * U - we), j <= 0 ? J = K = Math.sqrt(q) : J = K = (V - W * U - Math.sqrt(j)) / H, Q = W * J - U, Q < 0 || Q * Q > x.lengthSq() || J < 0)
                      continue;
                    m.push({ clickable: M, distance: K });
                  }
                }
              for (R = 0, B = E.line.length; R < B; R += 2) {
                C.copy(E.line[R]), C.applyMatrix4(w.matrixWorld), L.copy(E.line[R + 1]), L.applyMatrix4(w.matrixWorld), y.subVectors(L, C);
                var ye = y.lengthSq();
                y.normalize(), $.subVectors(C, F.ray.origin);
                var ve = $.dot(y);
                V = $.dot(F.ray.direction), W = _(F.ray.direction.dot(y)), H = 1 - W * W, H !== 0 && (Y = (W * V - ve) / H, ee = (V - W * ve) / H, C.add(y.multiplyScalar(Y)), L.copy(F.ray.direction).multiplyScalar(ee).add(F.ray.origin), q = y.subVectors(L, C).lengthSq(), q < O && Y * Y < ye && m.push({ clickable: M, distance: ee }));
              }
              for (R = 0, B = E.sphere.length; R < B; R++)
                if (E.sphere[R] instanceof s.Sphere && (A.copy(E.sphere[R]), A.applyMatrix4(w.matrixWorld), F.ray.isIntersectionSphere(A))) {
                  C.subVectors(A.center, F.ray.origin);
                  var ce = C.dot(F.ray.direction);
                  if (j = ce * ce - (C.lengthSq() - A.radius * A.radius), ce < 0)
                    return m;
                  j <= 0 ? K = ce : K = ce - Math.sqrt(j), m.push({ clickable: M, distance: K });
                }
              return m;
            }
          }
        ),
        /***/
        "./src/WebGL/core/Texture.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/core/Texture.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Texture: () => (
                /* binding */
                g
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ../constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), s = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = r(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), b = r(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
            class g extends h.EventDispatcher {
              constructor(x, k) {
                super(), this.id = _++, this.name = "", this.image = x, this.mapping = new b.UVMapping(), this.wrapS = n.ClampToEdgeWrapping, this.wrapT = n.ClampToEdgeWrapping, this.anisotropy = 1, k ? (this.format = n.RFormat, this.type = n.FloatType, this.premultiplyAlpha = !1, this.flipY = !1, this.unpackAlignment = 1, this.magFilter = n.NearestFilter, this.minFilter = n.NearestFilter) : (this.format = n.RGBAFormat, this.type = n.UnsignedByteType, this.offset = new s.Vector2(0, 0), this.repeat = new s.Vector2(1, 1), this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.magFilter = n.LinearFilter, this.minFilter = n.LinearMipMapLinearFilter), this.needsUpdate = !1, this.onUpdate = null;
              }
              clone(x = new g()) {
                return x.image = this.image, x.mapping = this.mapping, x.wrapS = this.wrapS, x.wrapT = this.wrapT, x.magFilter = this.magFilter, x.minFilter = this.minFilter, x.anisotropy = this.anisotropy, x.format = this.format, x.type = this.type, x.offset.copy(this.offset), x.repeat.copy(this.repeat), x.premultiplyAlpha = this.premultiplyAlpha, x.flipY = this.flipY, x.unpackAlignment = this.unpackAlignment, x;
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let _ = 0;
          }
        ),
        /***/
        "./src/WebGL/core/UVMapping.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/UVMapping.ts ***!
            \*************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              UVMapping: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            class n {
            }
          }
        ),
        /***/
        "./src/WebGL/core/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/core/index.ts ***!
            \*********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                n.EventDispatcher
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                s.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                s.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                s.GeometryIDCount
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                h.Light
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                h.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                h.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                b.Projector
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                g.Raycaster
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                h.Scene
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                _.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                _.TextureIdCount
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                A.UVMapping
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                g.intersectObject
              )
              /* harmony export */
            });
            var n = r(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), s = r(
              /*! ./Geometry */
              "./src/WebGL/core/Geometry.ts"
            ), h = r(
              /*! ./Object3D */
              "./src/WebGL/core/Object3D.ts"
            ), b = r(
              /*! ./Projector */
              "./src/WebGL/core/Projector.ts"
            ), g = r(
              /*! ./Raycaster */
              "./src/WebGL/core/Raycaster.ts"
            ), _ = r(
              /*! ./Texture */
              "./src/WebGL/core/Texture.ts"
            ), A = r(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/index.ts": (
          /*!****************************!*\
            !*** ./src/WebGL/index.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                n.BackSide
              ),
              /* harmony export */
              Camera: () => (
                /* reexport safe */
                x.Camera
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                n.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                n.Coloring
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                A.Cylinder
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                n.DoubleSide
              ),
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                s.EventDispatcher
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                n.FloatType
              ),
              /* harmony export */
              Fog: () => (
                /* reexport safe */
                k.Fog
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                n.FrontSide
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                s.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                s.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                s.GeometryIDCount
              ),
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                h.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                h.InstancedMaterial
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                s.Light
              ),
              /* harmony export */
              Line: () => (
                /* reexport safe */
                g.Line
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                h.LineBasicMaterial
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                g.LineStyle
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                n.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                n.LinearMipMapLinearFilter
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                h.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                h.MaterialIdCount
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                b.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                b.Matrix4
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                g.Mesh
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                h.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                h.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                h.MeshOutlineMaterial
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                n.NearestFilter
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                s.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                s.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                s.Projector
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                b.Quaternion
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                n.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                n.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                n.RGBAFormat
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                b.Ray
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                s.Raycaster
              ),
              /* harmony export */
              Renderer: () => (
                /* reexport safe */
                $.Renderer
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                s.Scene
              ),
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                _.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                _.ShaderUtils
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                n.Shading
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                A.Sphere
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                h.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                h.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                g.Sprite
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                n.SpriteAlignment
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                h.SpriteMaterial
              ),
              /* harmony export */
              SpritePlugin: () => (
                /* reexport safe */
                C.SpritePlugin
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                h.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                h.StickImposterOutlineMaterial
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                s.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                s.TextureIdCount
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                n.TextureOperations
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                A.Triangle
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                s.UVMapping
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                n.UnsignedByteType
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                b.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                b.Vector3
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                h.VolumetricMaterial
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                _.basic
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                b.clamp
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                _.clone
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                b.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                b.degToRad
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                _.instanced
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                s.intersectObject
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                _.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                _.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                _.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                _.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                _.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                _.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                _.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                _.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                _.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                _.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                _.volumetric
              )
              /* harmony export */
            });
            var n = r(
              /*! ./constants */
              "./src/WebGL/constants/index.ts"
            ), s = r(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), h = r(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), b = r(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), g = r(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), _ = r(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), A = r(
              /*! ./shapes */
              "./src/WebGL/shapes/index.ts"
            ), x = r(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), k = r(
              /*! ./Fog */
              "./src/WebGL/Fog.ts"
            ), $ = r(
              /*! ./Renderer */
              "./src/WebGL/Renderer.ts"
            ), C = r(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/materials/ImposterMaterial.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/materials/ImposterMaterial.ts ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ImposterMaterial: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), s = r(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), h = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), b = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), g = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class _ extends g.Material {
              constructor(x) {
                super(), this.color = new h.Color(16777215), this.ambient = new h.Color(1048575), this.emissive = new h.Color(0), this.imposter = !0, this.wrapAround = !1, this.wrapRGB = new b.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = s.Shading.SmoothShading, this.shaderID = null, this.vertexColors = n.Coloring.NoColors, this.skinning = !1, this.setValues(x);
              }
              clone(x = new _()) {
                return super.clone.call(this, x), x.color.copy(this.color), x.ambient.copy(this.ambient), x.emissive.copy(this.emissive), x.wrapAround = this.wrapAround, x.wrapRGB.copy(this.wrapRGB), x.map = this.map, x.lightMap = this.lightMap, x.specularMap = this.specularMap, x.envMap = this.envMap, x.combine = this.combine, x.reflectivity = this.reflectivity, x.refractionRatio = this.refractionRatio, x.fog = this.fog, x.shading = this.shading, x.shaderID = this.shaderID, x.vertexColors = this.vertexColors, x.skinning = this.skinning, x.morphTargets = this.morphTargets, x.morphNormals = this.morphNormals, x;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/InstancedMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/InstancedMaterial.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              InstancedMaterial: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), s = r(
              /*! ../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), h = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), b = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), g = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class _ extends g.Material {
              constructor(x) {
                super(), this.color = new h.Color(16777215), this.ambient = new h.Color(1048575), this.emissive = new h.Color(0), this.wrapAround = !1, this.wrapRGB = new b.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = s.Shading.SmoothShading, this.shaderID = "instanced", this.vertexColors = n.Coloring.NoColors, this.skinning = !1, this.sphere = null, this.setValues(x);
              }
              clone(x = new _()) {
                return super.clone.call(this, x), x.color.copy(this.color), x.ambient.copy(this.ambient), x.emissive.copy(this.emissive), x.wrapAround = this.wrapAround, x.wrapRGB.copy(this.wrapRGB), x.map = this.map, x.lightMap = this.lightMap, x.specularMap = this.specularMap, x.envMap = this.envMap, x.combine = this.combine, x.reflectivity = this.reflectivity, x.refractionRatio = this.refractionRatio, x.fog = this.fog, x.shading = this.shading, x.shaderID = this.shaderID, x.vertexColors = this.vertexColors, x.skinning = this.skinning, x.morphTargets = this.morphTargets, x.morphNormals = this.morphNormals, x.sphere = this.sphere, x;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/LineBasicMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/LineBasicMaterial.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              LineBasicMaterial: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), s = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class h extends s.Material {
              constructor(g) {
                super(), this.color = new n.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = !1, this.fog = !0, this.shaderID = "basic", this.setValues(g);
              }
              clone(g = new h()) {
                return super.clone.call(this, g), g.color.copy(this.color), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/Material.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/materials/Material.ts ***!
            \*****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Material: () => (
                /* binding */
                g
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), s = r(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), h = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), b = r(
              /*! ../../colors */
              "./src/colors.ts"
            );
            class g extends s.EventDispatcher {
              constructor() {
                super(...arguments), this.id = _++, this.name = "", this.side = n.FrontSide, this.opacity = 1, this.transparent = !1, this.depthTest = !0, this.depthWrite = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.visible = !0, this.needsUpdate = !0, this.outline = !1, this.wireframe = !1, this.shaded = !1;
              }
              setValues(x = {}) {
                if (x !== void 0)
                  for (var k in x) {
                    var $ = x[k];
                    if ($ === void 0) {
                      console.warn("$3Dmol.Material: '" + k + "' parameter is undefined.");
                      continue;
                    }
                    if (k in this) {
                      var C = this[k];
                      C instanceof b.Color && $ instanceof b.Color ? C.copy($) : C instanceof b.Color ? C.set($) : C instanceof h.Vector3 && $ instanceof h.Vector3 ? C.copy($) : this[k] = $;
                    }
                  }
              }
              //TODO: might want to look into blending equations
              clone(x = new g()) {
                return x.name = this.name, x.side = this.side, x.opacity = this.opacity, x.transparent = this.transparent, x.depthTest = this.depthTest, x.depthWrite = this.depthWrite, x.polygonOffset = this.polygonOffset, x.polygonOffsetFactor = this.polygonOffsetFactor, x.polygonOffsetUnits = this.polygonOffsetUnits, x.alphaTest = this.alphaTest, x.overdraw = this.overdraw, x.visible = this.visible, x;
              }
              makeShaded(x) {
                this.shaded = !0, this.uniforms && (this.uniforms.shading = { type: "i", value: x }, this.uniforms.vWidth = { type: "f", value: 1 }, this.uniforms.vHeight = { type: "f", value: 1 });
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let _ = 0;
          }
        ),
        /***/
        "./src/WebGL/materials/MeshDoubleLambertMaterial.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/materials/MeshDoubleLambertMaterial.ts ***!
            \**********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), s = r(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            );
            class h extends s.MeshLambertMaterial {
              constructor(g) {
                super(g), this.shaderID = "lambertdouble", this.side = n.DoubleSide, this.outline = !1;
              }
              clone(g = new h()) {
                return super.clone.call(this, g), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshLambertMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshLambertMaterial.ts ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MeshLambertMaterial: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), s = r(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), h = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), b = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), g = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class _ extends h.Material {
              constructor(x) {
                super(), this.color = new b.Color(16777215), this.ambient = new b.Color(1048575), this.emissive = new b.Color(0), this.wrapAround = !1, this.wrapRGB = new g.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = s.Shading.SmoothShading, this.shaderID = "lambert", this.vertexColors = n.Coloring.NoColors, this.skinning = !1, this.setValues(x);
              }
              clone(x = new _()) {
                return super.clone.call(this, x), x.color.copy(this.color), x.ambient.copy(this.ambient), x.emissive.copy(this.emissive), x.wrapAround = this.wrapAround, x.wrapRGB.copy(this.wrapRGB), x.map = this.map, x.lightMap = this.lightMap, x.specularMap = this.specularMap, x.envMap = this.envMap, x.combine = this.combine, x.reflectivity = this.reflectivity, x.refractionRatio = this.refractionRatio, x.fog = this.fog, x.shading = this.shading, x.shaderID = this.shaderID, x.vertexColors = this.vertexColors, x.skinning = this.skinning, x.morphTargets = this.morphTargets, x.morphNormals = this.morphNormals, x;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshOutlineMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshOutlineMaterial.ts ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), s = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class h extends s.Material {
              constructor(g) {
                super(), g = g || {}, this.fog = !0, this.shaderID = "outline", this.wireframe = !1, this.outlineColor = n.CC.color(g.color || new n.Color(0, 0, 0)), this.outlineWidth = g.width || 0.1, this.outlinePushback = g.pushback || 1, this.outlineMaxPixels = g.maxpixels || 0;
              }
              clone(g = new h()) {
                return super.clone.call(this, g), g.fog = this.fog, g.shaderID = this.shaderID, g.wireframe = this.wireframe, g.outlineColor = this.outlineColor, g.outlineWidth = this.outlineWidth, g.outlinePushback = this.outlinePushback, g.outlineMaxPixels = this.outlineMaxPixels, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterMaterial.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterMaterial.ts ***!
            \*******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SphereImposterMaterial: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class s extends n.ImposterMaterial {
              constructor(b) {
                super(b), this.shaderID = "sphereimposter", this.setValues(b);
              }
              clone(b = new s()) {
                return super.clone.call(this, b), b;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterOutlineMaterial.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterOutlineMaterial.ts ***!
            \**************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), s = r(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class h extends s.ImposterMaterial {
              constructor(g) {
                super(g), g = g || {}, this.shaderID = "sphereimposteroutline", this.outlineColor = n.CC.color(g.color || new n.Color(0, 0, 0)), this.outlineWidth = g.width || 0.1, this.outlinePushback = g.pushback || 1, this.outlineMaxPixels = g.maxpixels || 0, this.setValues(g);
              }
              clone(g = new h()) {
                return super.clone.call(this, g), g.outlineColor = this.outlineColor, g.outlineWidth = this.outlineWidth, g.outlinePushback = this.outlinePushback, g.outlineMaxPixels = this.outlineMaxPixels, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SpriteMaterial.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/materials/SpriteMaterial.ts ***!
            \***********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SpriteMaterial: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ../constants/SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), s = r(
              /*! ../core/Texture */
              "./src/WebGL/core/Texture.ts"
            ), h = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), b = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), g = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class _ extends g.Material {
              constructor(x) {
                super(), this.color = new h.Color(16777215), this.map = new s.Texture(), this.useScreenCoordinates = !0, this.fog = !1, this.uvOffset = new b.Vector2(0, 0), this.uvScale = new b.Vector2(1, 1), this.depthTest = !this.useScreenCoordinates, this.sizeAttenuation = !this.useScreenCoordinates, this.screenOffset = this.screenOffset, this.scaleByViewPort = !this.sizeAttenuation, this.alignment = n.SpriteAlignment.center.clone(), this.setValues(x), x = x || {}, x.depthTest === void 0 && (this.depthTest = !this.useScreenCoordinates), x.sizeAttenuation === void 0 && (this.sizeAttenuation = !this.useScreenCoordinates), x.scaleByViewPort === void 0 && (this.scaleByViewPort = !this.sizeAttenuation);
              }
              clone(x = new _()) {
                return super.clone.call(this, x), x.color.copy(this.color), x.map = this.map, x.useScreenCoordinates = this.useScreenCoordinates, x.screenOffset = this.screenOffset, x.sizeAttenuation = this.sizeAttenuation, x.scaleByViewport = this.scaleByViewPort, x.alignment.copy(this.alignment), x.uvOffset.copy(this.uvOffset), x;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterMaterial.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/materials/StickImposterMaterial.ts ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              StickImposterMaterial: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class s extends n.ImposterMaterial {
              constructor(b) {
                super(b), this.shaderID = "stickimposter", this.setValues(b);
              }
              clone(b = new s()) {
                return super.clone.call(this, b), b;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterOutlineMaterial.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/materials/StickImposterOutlineMaterial.ts ***!
            \*************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), s = r(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class h extends s.ImposterMaterial {
              constructor(g = {}) {
                super(g), this.shaderID = "stickimposteroutline", this.outlineColor = new n.Color(0, 0, 0), this.outlineWidth = 0.1, this.outlinePushback = 1, this.outlineMaxPixels = 0, g.color && (this.outlineColor = n.CC.color(g.color)), g.width && (this.outlineWidth = g.width), g.pushback && (this.outlinePushback = g.pushback), g.maxpixels && (this.outlineMaxPixels = g.maxpixels), this.setValues(g);
              }
              clone(g = new h()) {
                return super.clone.call(this, g), g.outlineColor = this.outlineColor, g.outlineWidth = this.outlineWidth, g.outlinePushback = this.outlinePushback, g.outlineMaxPixels = this.outlineMaxPixels, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/VolumetricMaterial.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/materials/VolumetricMaterial.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              VolumetricMaterial: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), s = r(
              /*! ../../colors */
              "./src/colors.ts"
            ), h = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class b extends h.Material {
              constructor(_) {
                super(), this.transparent = !1, this.volumetric = !0, this.color = new s.Color(16777215), this.transferfn = null, this.map = void 0, this.extent = [], this.maxdepth = 100, this.unit = 0, this.texmatrix = null, this.transfermin = -1, this.transfermax = 1, this.subsamples = 5, this.shaderID = "volumetric", this.side = n.FrontSide, this.setValues(_);
              }
              clone(_ = new b()) {
                return super.clone.call(this, _), _.transparent = this.transparent, _.volumetric = this.volumetric, _.color = this.color, _.transferfn = this.transferfn, _.map = this.map, _.extent = this.extent, _.maxdepth = this.maxdepth, _.unit = this.unit, _.texmatrix = this.texmatrix, _.transfermin = this.transfermin, _.transfermax = this.transfermax, _.subsamples = this.subsamples, _.shaderID = this.shaderID, _.side = this.side, _;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/materials/index.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                n.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                s.InstancedMaterial
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                h.LineBasicMaterial
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                b.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                b.MaterialIdCount
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                g.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                _.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                A.MeshOutlineMaterial
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                x.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                k.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                $.SpriteMaterial
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                C.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                L.StickImposterOutlineMaterial
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                y.VolumetricMaterial
              )
              /* harmony export */
            });
            var n = r(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            ), s = r(
              /*! ./InstancedMaterial */
              "./src/WebGL/materials/InstancedMaterial.ts"
            ), h = r(
              /*! ./LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), b = r(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), g = r(
              /*! ./MeshDoubleLambertMaterial */
              "./src/WebGL/materials/MeshDoubleLambertMaterial.ts"
            ), _ = r(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            ), A = r(
              /*! ./MeshOutlineMaterial */
              "./src/WebGL/materials/MeshOutlineMaterial.ts"
            ), x = r(
              /*! ./SphereImposterMaterial */
              "./src/WebGL/materials/SphereImposterMaterial.ts"
            ), k = r(
              /*! ./SphereImposterOutlineMaterial */
              "./src/WebGL/materials/SphereImposterOutlineMaterial.ts"
            ), $ = r(
              /*! ./SpriteMaterial */
              "./src/WebGL/materials/SpriteMaterial.ts"
            ), C = r(
              /*! ./StickImposterMaterial */
              "./src/WebGL/materials/StickImposterMaterial.ts"
            ), L = r(
              /*! ./StickImposterOutlineMaterial */
              "./src/WebGL/materials/StickImposterOutlineMaterial.ts"
            ), y = r(
              /*! ./VolumetricMaterial */
              "./src/WebGL/materials/VolumetricMaterial.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/Quaternion.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/math/Quaternion.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Quaternion: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            class n {
              constructor(h, b, g, _) {
                this.x = h || 0, this.y = b || 0, this.z = g || 0, this.w = _ !== void 0 ? _ : 1;
              }
              set(h, b, g, _) {
                return this.x = h, this.y = b, this.z = g, this.w = _, this;
              }
              copy(h) {
                return this.x = h.x, this.y = h.y, this.z = h.z, this.w = h.w, this;
              }
              conjugate() {
                return this.x *= -1, this.y *= -1, this.z *= -1, this;
              }
              inverse() {
                return this.conjugate().normalize();
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
              }
              lengthxyz() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              normalize() {
                let h = this.length();
                return h === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (h = 1 / h, this.x *= h, this.y *= h, this.z *= h, this.w *= h), this;
              }
              multiply(h) {
                return this.multiplyQuaternions(this, h);
              }
              multiplyScalar(h) {
                return this.x *= h, this.y *= h, this.z *= h, this.w *= h, this;
              }
              multiplyQuaternions(h, b) {
                const g = h.x, _ = h.y, A = h.z, x = h.w, k = b.x, $ = b.y, C = b.z, L = b.w;
                return this.x = g * L + x * k + _ * C - A * $, this.y = _ * L + x * $ + A * k - g * C, this.z = A * L + x * C + g * $ - _ * k, this.w = x * L - g * k - _ * $ - A * C, this;
              }
              sub(h) {
                return this.x -= h.x, this.y -= h.y, this.z -= h.z, this.w -= h.w, this;
              }
              clone() {
                return new n(this.x, this.y, this.z, this.w);
              }
              setFromEuler(h) {
                const b = Math.cos(h.x / 2), g = Math.cos(h.y / 2), _ = Math.cos(h.z / 2), A = Math.sin(h.x / 2), x = Math.sin(h.y / 2), k = Math.sin(h.z / 2);
                return this.x = A * g * _ + b * x * k, this.y = b * x * _ - A * g * k, this.z = b * g * k + A * x * _, this.w = b * g * _ - A * x * k, this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/Vector2.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/math/Vector2.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Vector2: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            class n {
              constructor(h, b) {
                this.x = h || 0, this.y = b || 0;
              }
              set(h, b) {
                return this.x = h, this.y = b, this;
              }
              subVectors(h, b) {
                return this.x = h.x - b.x, this.y = h.y - b.y, this;
              }
              copy(h) {
                return this.x = h.x, this.y = h.y, this;
              }
              clone() {
                return new n(this.x, this.y);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/math/index.ts ***!
            \*********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                _.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                _.Matrix4
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                n.Quaternion
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                _.Ray
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                s.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                _.Vector3
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                h.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                b.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                g.degToRad
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Quaternion */
              "./src/WebGL/math/Quaternion.ts"
            ), s = r(
              /*! ./Vector2 */
              "./src/WebGL/math/Vector2.ts"
            ), h = r(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), b = r(
              /*! ./utils/conversionMatrix3 */
              "./src/WebGL/math/utils/conversionMatrix3.ts"
            ), g = r(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), _ = r(
              /*! ./math */
              "./src/WebGL/math/math.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/math.ts": (
          /*!********************************!*\
            !*** ./src/WebGL/math/math.ts ***!
            \********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Matrix3: () => (
                /* binding */
                $
              ),
              /* harmony export */
              Matrix4: () => (
                /* binding */
                x
              ),
              /* harmony export */
              Ray: () => (
                /* binding */
                C
              ),
              /* harmony export */
              Vector3: () => (
                /* binding */
                k
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), s = r(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), h, b, g, _, A;
            class x {
              constructor(y = 1, o = 0, v = 0, w = 0, M = 0, F = 1, m = 0, E = 0, z = 0, O = 0, R = 1, B = 0, P = 0, W = 0, U = 0, V = 1) {
                typeof y < "u" && typeof y != "number" ? this.elements = new Float32Array(y) : (this.elements = new Float32Array(16), this.elements[0] = y, this.elements[4] = o, this.elements[8] = v, this.elements[12] = w, this.elements[1] = M, this.elements[5] = F, this.elements[9] = m, this.elements[13] = E, this.elements[2] = z, this.elements[6] = O, this.elements[10] = R, this.elements[14] = B, this.elements[3] = P, this.elements[7] = W, this.elements[11] = U, this.elements[15] = V);
              }
              // eslint-disable-next-line no-unused-vars, class-methods-use-this
              makeScale(y, o, v) {
                throw new Error("Method not implemented.");
              }
              set(y, o, v, w, M, F, m, E, z, O, R, B, P, W, U, V) {
                const K = this.elements;
                return K[0] = y, K[4] = o, K[8] = v, K[12] = w, K[1] = M, K[5] = F, K[9] = m, K[13] = E, K[2] = z, K[6] = O, K[10] = R, K[14] = B, K[3] = P, K[7] = W, K[11] = U, K[15] = V, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
              }
              copy(y) {
                const o = y.elements;
                return this.set(o[0], o[4], o[8], o[12], o[1], o[5], o[9], o[13], o[2], o[6], o[10], o[14], o[3], o[7], o[11], o[15]), this;
              }
              matrix3FromTopLeft() {
                const y = this.elements;
                return new $(y[0], y[4], y[8], y[1], y[5], y[9], y[2], y[6], y[10]);
              }
              setRotationFromEuler(y, o) {
                const v = this.elements, { x: w, y: M, z: F } = y, m = Math.cos(w), E = Math.sin(w), z = Math.cos(M), O = Math.sin(M), R = Math.cos(F), B = Math.sin(F);
                if (o === void 0 || o === "XYZ") {
                  const P = m * R, W = m * B, U = E * R, V = E * B;
                  v[0] = z * R, v[4] = -z * B, v[8] = O, v[1] = W + U * O, v[5] = P - V * O, v[9] = -E * z, v[2] = V - P * O, v[6] = U + W * O, v[10] = m * z;
                } else
                  console.error(`Error with matrix4 setRotationFromEuler. Order: ${o}`);
                return this;
              }
              setRotationFromQuaternion(y) {
                const o = this.elements, { x: v, y: w, z: M, w: F } = y, m = v + v, E = w + w, z = M + M, O = v * m, R = v * E, B = v * z, P = w * E, W = w * z, U = M * z, V = F * m, K = F * E, q = F * z;
                return o[0] = 1 - (P + U), o[4] = R - q, o[8] = B + K, o[1] = R + q, o[5] = 1 - (O + U), o[9] = W - V, o[2] = B - K, o[6] = W + V, o[10] = 1 - (O + P), this;
              }
              multiplyMatrices(y, o) {
                const v = y.elements, w = o.elements, M = this.elements, F = v[0], m = v[4], E = v[8], z = v[12], O = v[1], R = v[5], B = v[9], P = v[13], W = v[2], U = v[6], V = v[10], K = v[14], q = v[3], H = v[7], j = v[11], Q = v[15], J = w[0], Y = w[4], ee = w[8], fe = w[12], me = w[1], he = w[5], we = w[9], ye = w[13], ve = w[2], ce = w[6], be = w[10], le = w[14], Se = w[3], ge = w[7], de = w[11], De = w[15];
                return M[0] = F * J + m * me + E * ve + z * Se, M[4] = F * Y + m * he + E * ce + z * ge, M[8] = F * ee + m * we + E * be + z * de, M[12] = F * fe + m * ye + E * le + z * De, M[1] = O * J + R * me + B * ve + P * Se, M[5] = O * Y + R * he + B * ce + P * ge, M[9] = O * ee + R * we + B * be + P * de, M[13] = O * fe + R * ye + B * le + P * De, M[2] = W * J + U * me + V * ve + K * Se, M[6] = W * Y + U * he + V * ce + K * ge, M[10] = W * ee + U * we + V * be + K * de, M[14] = W * fe + U * ye + V * le + K * De, M[3] = q * J + H * me + j * ve + Q * Se, M[7] = q * Y + H * he + j * ce + Q * ge, M[11] = q * ee + H * we + j * be + Q * de, M[15] = q * fe + H * ye + j * le + Q * De, this;
              }
              multiplyScalar(y) {
                const o = this.elements;
                return o[0] *= y, o[4] *= y, o[8] *= y, o[12] *= y, o[1] *= y, o[5] *= y, o[9] *= y, o[13] *= y, o[2] *= y, o[6] *= y, o[10] *= y, o[14] *= y, o[3] *= y, o[7] *= y, o[11] *= y, o[15] *= y, this;
              }
              makeTranslation(y, o, v) {
                return this.set(1, 0, 0, y, 0, 1, 0, o, 0, 0, 1, v, 0, 0, 0, 1), this;
              }
              // snap values close to integers to their integer value
              // useful and identifying identity matrices
              snap(y) {
                const o = Math.pow(10, 4), v = this.elements;
                for (let w = 0; w < 16; w++) {
                  const M = Math.round(v[w]);
                  M === Math.round(v[w] * o) / o && (v[w] = M);
                }
                return this;
              }
              transpose() {
                const y = this.elements;
                let o;
                return o = y[1], y[1] = y[4], y[4] = o, o = y[2], y[2] = y[8], y[8] = o, o = y[6], y[6] = y[9], y[9] = o, o = y[3], y[3] = y[12], y[12] = o, o = y[7], y[7] = y[13], y[13] = o, o = y[11], y[11] = y[14], y[14] = o, this;
              }
              setPosition(y) {
                const o = this.elements;
                return o[12] = y.x, o[13] = y.y, o[14] = y.z, this;
              }
              translate(y) {
                const o = this.elements;
                return o[12] += y.x, o[13] += y.y, o[14] += y.z, this;
              }
              getInverse(y, o) {
                const v = this.elements, w = y.elements, M = w[0], F = w[4], m = w[8], E = w[12], z = w[1], O = w[5], R = w[9], B = w[13], P = w[2], W = w[6], U = w[10], V = w[14], K = w[3], q = w[7], H = w[11], j = w[15];
                v[0] = R * V * q - B * U * q + B * W * H - O * V * H - R * W * j + O * U * j, v[4] = E * U * q - m * V * q - E * W * H + F * V * H + m * W * j - F * U * j, v[8] = m * B * q - E * R * q + E * O * H - F * B * H - m * O * j + F * R * j, v[12] = E * R * W - m * B * W - E * O * U + F * B * U + m * O * V - F * R * V, v[1] = B * U * K - R * V * K - B * P * H + z * V * H + R * P * j - z * U * j, v[5] = m * V * K - E * U * K + E * P * H - M * V * H - m * P * j + M * U * j, v[9] = E * R * K - m * B * K - E * z * H + M * B * H + m * z * j - M * R * j, v[13] = m * B * P - E * R * P + E * z * U - M * B * U - m * z * V + M * R * V, v[2] = O * V * K - B * W * K + B * P * q - z * V * q - O * P * j + z * W * j, v[6] = E * W * K - F * V * K - E * P * q + M * V * q + F * P * j - M * W * j, v[10] = F * B * K - E * O * K + E * z * q - M * B * q - F * z * j + M * O * j, v[14] = E * O * P - F * B * P - E * z * W + M * B * W + F * z * V - M * O * V, v[3] = R * W * K - O * U * K - R * P * q + z * U * q + O * P * H - z * W * H, v[7] = F * U * K - m * W * K + m * P * q - M * U * q - F * P * H + M * W * H, v[11] = m * O * K - F * R * K - m * z * q + M * R * q + F * z * H - M * O * H, v[15] = F * R * P - m * O * P + m * z * W - M * R * W - F * z * U + M * O * U;
                const Q = M * v[0] + z * v[4] + P * v[8] + K * v[12];
                if (Q === 0) {
                  const J = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                  if (o)
                    throw new Error(J);
                  return console.warn(J), this.identity(), this;
                }
                return this.multiplyScalar(1 / Q), this;
              }
              isReflected() {
                const y = this.elements, o = y[0], v = y[4], w = y[8], M = y[1], F = y[5], m = y[9], E = y[2], z = y[6], O = y[10];
                return o * F * O + // +aei
                M * z * w + // +bfg
                E * v * m - // +cdh
                E * F * w - // -ceg
                M * v * O - // -bdi
                o * z * m < 0;
              }
              scale(y) {
                const o = this.elements, { x: v } = y, { y: w } = y, { z: M } = y;
                return o[0] *= v, o[4] *= w, o[8] *= M, o[1] *= v, o[5] *= w, o[9] *= M, o[2] *= v, o[6] *= w, o[10] *= M, o[3] *= v, o[7] *= w, o[11] *= M, this;
              }
              getMaxScaleOnAxis() {
                const y = this.elements, o = y[0] * y[0] + y[1] * y[1] + y[2] * y[2], v = y[4] * y[4] + y[5] * y[5] + y[6] * y[6], w = y[8] * y[8] + y[9] * y[9] + y[10] * y[10];
                return Math.sqrt(Math.max(o, Math.max(v, w)));
              }
              makeFrustum(y, o, v, w, M, F) {
                const m = this.elements, E = 2 * M / (o - y), z = 2 * M / (w - v), O = (o + y) / (o - y), R = (w + v) / (w - v), B = -(F + M) / (F - M), P = -2 * F * M / (F - M);
                return m[0] = E, m[4] = 0, m[8] = O, m[12] = 0, m[1] = 0, m[5] = z, m[9] = R, m[13] = 0, m[2] = 0, m[6] = 0, m[10] = B, m[14] = P, m[3] = 0, m[7] = 0, m[11] = -1, m[15] = 0, this;
              }
              makePerspective(y, o, v, w) {
                const M = v * Math.tan((0, n.degToRad)(y * 0.5)), F = -M, m = F * o, E = M * o;
                return this.makeFrustum(m, E, F, M, v, w);
              }
              makeOrthographic(y, o, v, w, M, F) {
                const m = this.elements, E = 1 / (o - y), z = 1 / (v - w), O = 1 / (F - M), R = (o + y) * E, B = (v + w) * z, P = (F + M) * O;
                return m[0] = 2 * E, m[4] = 0, m[8] = 0, m[12] = -R, m[1] = 0, m[5] = 2 * z, m[9] = 0, m[13] = -B, m[2] = 0, m[6] = 0, m[10] = -2 * O, m[14] = -P, m[3] = 0, m[7] = 0, m[11] = 0, m[15] = 1, this;
              }
              isEqual(y) {
                const o = y.elements, v = this.elements;
                return v[0] === o[0] && v[4] === o[4] && v[8] === o[8] && v[12] === o[12] && v[1] === o[1] && v[5] === o[5] && v[9] === o[9] && v[13] === o[13] && v[2] === o[2] && v[6] === o[6] && v[10] === o[10] && v[14] === o[14] && v[3] === o[3] && v[7] === o[7] && v[11] === o[11] && v[15] === o[15];
              }
              clone() {
                const y = this.elements;
                return new x(y[0], y[4], y[8], y[12], y[1], y[5], y[9], y[13], y[2], y[6], y[10], y[14], y[3], y[7], y[11], y[15]);
              }
              isIdentity() {
                const y = this.elements;
                return y[0] === 1 && y[4] === 0 && y[8] === 0 && y[12] === 0 && y[1] === 0 && y[5] === 1 && y[9] === 0 && y[13] === 0 && y[2] === 0 && y[6] === 0 && y[10] === 1 && y[14] === 0 && y[3] === 0 && y[7] === 0 && y[11] === 0 && y[15] === 1;
              }
              // return true if elements are with digits of identity
              isNearlyIdentity(y) {
                return this.clone().snap(y).isIdentity();
              }
              getScale(y) {
                const o = this.elements;
                return y = y || new k(), g.set(o[0], o[1], o[2]), _.set(o[4], o[5], o[6]), A.set(o[8], o[9], o[10]), y.x = g.length(), y.y = _.length(), y.z = A.length(), y;
              }
              lookAt(y, o, v) {
                const w = this.elements;
                return A.subVectors(y, o).normalize(), A.length() === 0 && (A.z = 1), g.crossVectors(v, A).normalize(), g.length() === 0 && (A.x += 1e-4, g.crossVectors(v, A).normalize()), _.crossVectors(A, g), w[0] = g.x, w[4] = _.x, w[8] = A.x, w[1] = g.y, w[5] = _.y, w[9] = A.y, w[2] = g.z, w[6] = _.z, w[10] = A.z, this;
              }
              compose(y, o, v) {
                const w = this.elements;
                return h.identity(), h.setRotationFromQuaternion(o), b.makeScale(v.x, v.y, v.z), this.multiplyMatrices(h, b), w[12] = y.x, w[13] = y.y, w[14] = y.z, this;
              }
            }
            h = new x(), b = new x();
            class k {
              constructor(y, o, v) {
                this.x = y || 0, this.y = o || 0, this.z = v || 0, this.atomid = void 0;
              }
              set(y, o, v) {
                return this.x = y, this.y = o, this.z = v, this;
              }
              copy(y) {
                return this.x = y.x, this.y = y.y, this.z = y.z, this;
              }
              add(y) {
                return this.x += y.x, this.y += y.y, this.z += y.z, this;
              }
              addVectors(y, o) {
                return this.x = y.x + o.x, this.y = y.y + o.y, this.z = y.z + o.z, this;
              }
              multiplyVectors(y, o) {
                return this.x = y.x * o.x, this.y = y.y * o.y, this.z = y.z * o.z, this;
              }
              sub(y) {
                return this.x -= y.x, this.y -= y.y, this.z -= y.z, this;
              }
              subVectors(y, o) {
                return this.x = y.x - o.x, this.y = y.y - o.y, this.z = y.z - o.z, this;
              }
              multiplyScalar(y) {
                return this.x *= y, this.y *= y, this.z *= y, this;
              }
              divideScalar(y) {
                return y !== 0 ? (this.x /= y, this.y /= y, this.z /= y) : (this.x = 0, this.y = 0, this.z = 0), this;
              }
              // accumulate maximum
              max(y) {
                return this.x = Math.max(this.x, y.x), this.y = Math.max(this.y, y.y), this.z = Math.max(this.z, y.z), this;
              }
              // accumulate min
              min(y) {
                return this.x = Math.min(this.x, y.x), this.y = Math.min(this.y, y.y), this.z = Math.min(this.z, y.z), this;
              }
              distanceTo(y) {
                return Math.sqrt(this.distanceToSquared(y));
              }
              distanceToSquared(y) {
                const o = this.x - y.x, v = this.y - y.y, w = this.z - y.z;
                return o * o + v * v + w * w;
              }
              applyMatrix3(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this, M = y.elements;
                return this.x = M[0] * o + M[3] * v + M[6] * w, this.y = M[1] * o + M[4] * v + M[7] * w, this.z = M[2] * o + M[5] * v + M[8] * w, this;
              }
              applyMatrix4(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this, M = y.elements;
                return this.x = M[0] * o + M[4] * v + M[8] * w + M[12], this.y = M[1] * o + M[5] * v + M[9] * w + M[13], this.z = M[2] * o + M[6] * v + M[10] * w + M[14], this;
              }
              applyProjection(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this, M = y.elements, F = M[3] * o + M[7] * v + M[11] * w + M[15];
                return this.x = (M[0] * o + M[4] * v + M[8] * w + M[12]) / F, this.y = (M[1] * o + M[5] * v + M[9] * w + M[13]) / F, this.z = (M[2] * o + M[6] * v + M[10] * w + M[14]) / F, this;
              }
              applyQuaternion(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this, M = y.x, F = y.y, m = y.z, E = y.w, z = {};
                z.x = 2 * (v * m - w * F), z.y = 2 * (w * M - o * m), z.z = 2 * (o * F - v * M);
                const O = {};
                return O.x = z.y * m - z.z * F, O.y = z.z * M - z.x * m, O.z = z.x * F - z.y * M, this.x = o + E * z.x + O.x, this.y = v + E * z.y + O.y, this.z = w + E * z.z + O.z, this;
              }
              negate() {
                return this.multiplyScalar(-1);
              }
              dot(y) {
                return this.x * y.x + this.y * y.y + this.z * y.z;
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
              }
              normalize() {
                return this.divideScalar(this.length());
              }
              cross(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this;
                return this.x = v * y.z - w * y.y, this.y = w * y.x - o * y.z, this.z = o * y.y - v * y.x, this;
              }
              crossVectors(y, o) {
                return this.x = y.y * o.z - y.z * o.y, this.y = y.z * o.x - y.x * o.z, this.z = y.x * o.y - y.y * o.x, this;
              }
              equals(y) {
                return this.x == y.x && this.y == y.y && this.z == y.z;
              }
              getPositionFromMatrix(y) {
                return this.x = y.elements[12], this.y = y.elements[13], this.z = y.elements[14], this;
              }
              setEulerFromRotationMatrix(y, o) {
                const v = y.elements, w = v[0], M = v[4], F = v[8], m = v[5], E = v[9], z = v[6], O = v[10];
                return o === void 0 || o === "XYZ" ? (this.y = Math.asin((0, s.clamp)(F, -1, 1)), Math.abs(F) < 0.99999 ? (this.x = Math.atan2(-E, O), this.z = Math.atan2(-M, w)) : (this.x = Math.atan2(z, m), this.z = 0)) : console.error(`Error with vector's setEulerFromRotationMatrix: Unknown order: ${o}`), this;
              }
              rotateAboutVector(y, o) {
                y.normalize();
                const v = Math.cos(o), w = Math.sin(o), M = this.clone().multiplyScalar(v), F = y.clone().cross(this).multiplyScalar(w), m = y.clone().multiplyScalar(y.clone().dot(this)).multiplyScalar(1 - v), E = M.add(F).add(m);
                return this.x = E.x, this.y = E.y, this.z = E.z, this;
              }
              setFromMatrixPosition(y) {
                const o = y.elements;
                return this.x = o[12], this.y = o[13], this.z = o[14], this;
              }
              // unproject is defined after Matrix4
              transformDirection(y) {
                const { x: o } = this, { y: v } = this, { z: w } = this, M = y.elements;
                return this.x = M[0] * o + M[4] * v + M[8] * w, this.y = M[1] * o + M[5] * v + M[9] * w, this.z = M[2] * o + M[6] * v + M[10] * w, this.normalize();
              }
              clone() {
                return new k(this.x, this.y, this.z);
              }
              unproject(y) {
                const o = h;
                return o.multiplyMatrices(y.matrixWorld, o.getInverse(y.projectionMatrix)), this.applyMatrix4(o);
              }
            }
            g = new k(), _ = new k(), A = new k();
            class $ {
              constructor(y = 1, o = 0, v = 0, w = 0, M = 1, F = 0, m = 0, E = 0, z = 1) {
                this.elements = new Float32Array(9), this.set(y, o, v, w, M, F, m, E, z);
              }
              set(y, o, v, w, M, F, m, E, z) {
                const O = this.elements;
                return O[0] = y, O[3] = o, O[6] = v, O[1] = w, O[4] = M, O[7] = F, O[2] = m, O[5] = E, O[8] = z, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
              }
              copy(y) {
                const o = y.elements;
                this.set(o[0], o[3], o[6], o[1], o[4], o[7], o[2], o[5], o[8]);
              }
              multiplyScalar(y) {
                const o = this.elements;
                return o[0] *= y, o[3] *= y, o[6] *= y, o[1] *= y, o[4] *= y, o[7] *= y, o[2] *= y, o[5] *= y, o[8] *= y, this;
              }
              getInverse3(y) {
                const o = y.elements, v = this.elements;
                v[0] = o[4] * o[8] - o[5] * o[7], v[3] = o[6] * o[5] - o[3] * o[8], v[6] = o[3] * o[7] - o[6] * o[4], v[1] = o[7] * o[2] - o[1] * o[8], v[4] = o[0] * o[8] - o[6] * o[2], v[7] = o[1] * o[6] - o[0] * o[7], v[2] = o[1] * o[5] - o[2] * o[4], v[5] = o[2] * o[3] - o[0] * o[5], v[8] = o[0] * o[4] - o[1] * o[3];
                const w = o[0] * v[0] + o[3] * v[1] + o[6] * v[2];
                return this.multiplyScalar(1 / w), this;
              }
              getInverse(y, o) {
                const v = y.elements, w = this.elements;
                w[0] = v[10] * v[5] - v[6] * v[9], w[1] = -v[10] * v[1] + v[2] * v[9], w[2] = v[6] * v[1] - v[2] * v[5], w[3] = -v[10] * v[4] + v[6] * v[8], w[4] = v[10] * v[0] - v[2] * v[8], w[5] = -v[6] * v[0] + v[2] * v[4], w[6] = v[9] * v[4] - v[5] * v[8], w[7] = -v[9] * v[0] + v[1] * v[8], w[8] = v[5] * v[0] - v[1] * v[4];
                const M = v[0] * w[0] + v[1] * w[3] + v[2] * w[6];
                if (M === 0) {
                  const F = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                  if (o)
                    throw new Error(F);
                  return console.warn(F), this.identity(), this;
                }
                return this.multiplyScalar(1 / M), this;
              }
              // https://en.wikipedia.org/wiki/Determinant
              getDeterminant() {
                const y = this.elements;
                return y[0] * y[4] * y[8] + // +aei
                y[1] * y[5] * y[6] + // +bfg
                y[2] * y[3] * y[7] - // +cdh
                y[2] * y[4] * y[6] - // -ceg
                y[1] * y[3] * y[8] - // -bdi
                y[0] * y[5] * y[7];
              }
              transpose() {
                let y;
                const o = this.elements;
                return y = o[1], o[1] = o[3], o[3] = y, y = o[2], o[2] = o[6], o[6] = y, y = o[5], o[5] = o[7], o[7] = y, this;
              }
              clone() {
                const y = this.elements;
                return new $(y[0], y[3], y[6], y[1], y[4], y[7], y[2], y[5], y[8]);
              }
              getMatrix4() {
                const y = this.elements;
                return new x(y[0], y[3], y[6], 0, y[1], y[4], y[7], 0, y[2], y[5], y[8], 0);
              }
            }
            class C {
              constructor(y, o) {
                this.origin = y !== void 0 ? y : new k(), this.direction = o !== void 0 ? o : new k();
              }
              set(y, o) {
                return this.origin.copy(y), this.direction.copy(o), this;
              }
              copy(y) {
                return this.origin.copy(y.origin), this.direction.copy(y.direction), this;
              }
              at(y, o) {
                return (o || new k()).copy(this.direction).multiplyScalar(y).add(this.origin);
              }
              recast(y) {
                const o = g;
                return this.origin.copy(this.at(y, o)), this;
              }
              closestPointToPoint(y, o) {
                const v = o || new k();
                v.subVectors(y, this.origin);
                const w = v.dot(this.direction);
                return v.copy(this.direction).multiplyScalar(w).add(this.origin);
              }
              distanceToPoint(y) {
                const o = g, v = o.subVectors(y, this.origin).dot(this.direction);
                return o.copy(this.direction).multiplyScalar(v).add(this.origin), o.distanceTo(y);
              }
              // eslint-disable-next-line class-methods-use-this
              isIntersectionCylinder() {
              }
              isIntersectionSphere(y) {
                return this.distanceToPoint(y.center) <= y.radius;
              }
              isIntersectionPlane(y) {
                return y.normal.dot(this.direction) !== 0 || y.distanceToPoint(this.origin) === 0;
              }
              distanceToPlane(y) {
                const o = y.normal.dot(this.direction);
                return o === 0 ? y.distanceToPoint(this.origin) === 0 ? 0 : void 0 : -(this.origin.dot(y.normal) + y.constant) / o;
              }
              intersectPlane(y, o) {
                const v = this.distanceToPlane(y);
                if (v !== void 0)
                  return this.at(v, o);
              }
              applyMatrix4(y) {
                return this.direction.add(this.origin).applyMatrix4(y), this.origin.applyMatrix4(y), this.direction.sub(this.origin), this;
              }
              clone() {
                return new C().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/clamp.ts": (
          /*!***************************************!*\
            !*** ./src/WebGL/math/utils/clamp.ts ***!
            \***************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              clamp: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s, h, b) {
              return Math.min(Math.max(s, h), b);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/conversionMatrix3.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/math/utils/conversionMatrix3.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              conversionMatrix3: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/math.ts"
            );
            function s(h, b, g, _, A, x) {
              _ = _ * Math.PI / 180, A = A * Math.PI / 180, x = x * Math.PI / 180;
              const k = (v) => v * v, $ = Math.cos(_), C = Math.cos(A), L = Math.cos(x), y = Math.sin(x);
              return new n.Matrix3(h, b * L, g * C, 0, b * y, g * ($ - C * L) / y, 0, 0, g * Math.sqrt(1 - k($) - k(C) - k(L) + 2 * $ * C * L) / y);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/degToRad.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/math/utils/degToRad.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              degToRad: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            const n = Math.PI / 180;
            function s(h) {
              return h * n;
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Line.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Line.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Line: () => (
                /* binding */
                b
              ),
              /* harmony export */
              LineStyle: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), s = r(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), h;
            (function(g) {
              g[g.LineStrip = 0] = "LineStrip", g[g.LinePieces = 1] = "LinePieces";
            })(h || (h = {}));
            class b extends s.Object3D {
              constructor(_, A = new n.LineBasicMaterial({
                color: Math.random() * 16777215
              }), x = h.LineStrip) {
                super(), this.geometry = _, this.material = A, this.type = x;
              }
              clone(_ = new b(this.geometry, this.material, this.type)) {
                return super.clone.call(this, _), _;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Mesh.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Mesh.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Mesh: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class s extends n.Object3D {
              constructor(b, g) {
                super(), this.geometry = b, this.material = g;
              }
              clone(b) {
                return b === void 0 && (b = new s(this.geometry, this.material)), super.clone.call(this, b), b;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Sprite.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/objects/Sprite.ts ***!
            \*************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Sprite: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), s = r(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class h extends s.Object3D {
              constructor(g = new n.SpriteMaterial()) {
                super(), this.material = g, this.rotation3d = this.rotation, this.rotation = 0;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.rotation3d.set(0, 0, this.rotation), this.matrix.setRotationFromEuler(this.rotation3d), (this.scale.x !== 1 || this.scale.y !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              clone(g = new h(this.material)) {
                return s.Object3D.prototype.clone.call(this, g), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/objects/index.ts ***!
            \************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Line: () => (
                /* reexport safe */
                n.Line
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                n.LineStyle
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                s.Mesh
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                h.Sprite
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Line */
              "./src/WebGL/objects/Line.ts"
            ), s = r(
              /*! ./Mesh */
              "./src/WebGL/objects/Mesh.ts"
            ), h = r(
              /*! ./Sprite */
              "./src/WebGL/objects/Sprite.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/ShaderType.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/shaders/ShaderType.ts ***!
            \*****************************************/
          /***/
          (a, e, r) => {
            r.r(e);
          }
        ),
        /***/
        "./src/WebGL/shaders/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shaders/index.ts ***!
            \************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                n.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                s.ShaderUtils
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                n.basic
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                s.clone
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                n.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                n.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                n.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                n.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                n.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                n.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                n.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                n.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                n.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                n.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                n.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                n.volumetric
              )
              /* harmony export */
            });
            var n = r(
              /*! ./lib */
              "./src/WebGL/shaders/lib/index.ts"
            ), s = r(
              /*! ./utils */
              "./src/WebGL/shaders/utils/index.ts"
            );
            r(
              /*! ./ShaderType */
              "./src/WebGL/shaders/ShaderType.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/index.ts": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/index.ts ***!
            \**********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              basic: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/basic/uniforms.ts"
            ), s = r(
              /*! ./basic.frag */
              "./src/WebGL/shaders/lib/basic/basic.frag"
            ), h = r(
              /*! ./basic.vert */
              "./src/WebGL/shaders/lib/basic/basic.vert"
            );
            const b = {
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/uniforms.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/uniforms.ts ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/blur/index.ts": (
          /*!*********************************************!*\
            !*** ./src/WebGL/shaders/lib/blur/index.ts ***!
            \*********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              blur: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/blur/uniforms.ts"
            ), s = r(
              /*! ./blur.frag */
              "./src/WebGL/shaders/lib/blur/blur.frag"
            ), h = r(
              /*! ./blur.vert */
              "./src/WebGL/shaders/lib/blur/blur.vert"
            );
            const b = {
              fragmentShader: s.default,
              vertexShader: h.default,
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/blur/uniforms.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/blur/uniforms.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/index.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/shaders/lib/index.ts ***!
            \****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ShaderLib: () => (
                /* binding */
                w
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                n.basic
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                s.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                h.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                b.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                g.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                _.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                A.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                x.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                k.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                $.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                C.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                L.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                y.volumetric
              )
              /* harmony export */
            });
            var n = r(
              /*! ./basic */
              "./src/WebGL/shaders/lib/basic/index.ts"
            ), s = r(
              /*! ./instanced */
              "./src/WebGL/shaders/lib/instanced/index.ts"
            ), h = r(
              /*! ./lambert */
              "./src/WebGL/shaders/lib/lambert/index.ts"
            ), b = r(
              /*! ./lambertdouble */
              "./src/WebGL/shaders/lib/lambertdouble/index.ts"
            ), g = r(
              /*! ./outline */
              "./src/WebGL/shaders/lib/outline/index.ts"
            ), _ = r(
              /*! ./screen */
              "./src/WebGL/shaders/lib/screen/index.ts"
            ), A = r(
              /*! ./screenaa */
              "./src/WebGL/shaders/lib/screenaa/index.ts"
            ), x = r(
              /*! ./sphereimposter */
              "./src/WebGL/shaders/lib/sphereimposter/index.ts"
            ), k = r(
              /*! ./sphereimposteroutline */
              "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts"
            ), $ = r(
              /*! ./sprite */
              "./src/WebGL/shaders/lib/sprite/index.ts"
            ), C = r(
              /*! ./stickimposter */
              "./src/WebGL/shaders/lib/stickimposter/index.ts"
            ), L = r(
              /*! ./stickimposteroutline */
              "./src/WebGL/shaders/lib/stickimposteroutline/index.ts"
            ), y = r(
              /*! ./volumetric */
              "./src/WebGL/shaders/lib/volumetric/index.ts"
            ), o = r(
              /*! ./ssao */
              "./src/WebGL/shaders/lib/ssao/index.ts"
            ), v = r(
              /*! ./blur */
              "./src/WebGL/shaders/lib/blur/index.ts"
            );
            const w = {
              basic: n.basic,
              blur: v.blur,
              instanced: s.instanced,
              lambert: h.lambert,
              lambertdouble: b.lambertdouble,
              outline: g.outline,
              screen: _.screen,
              screenaa: A.screenaa,
              ssao: o.ssao,
              sphereimposter: x.sphereimposter,
              sphereimposteroutline: k.sphereimposteroutline,
              sprite: $.sprite,
              stickimposter: C.stickimposter,
              stickimposteroutline: L.stickimposteroutline,
              volumetric: y.volumetric
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/index.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/index.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              instanced: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/instanced/uniforms.ts"
            ), s = r(
              /*! ./instanced.frag */
              "./src/WebGL/shaders/lib/instanced/instanced.frag"
            ), h = r(
              /*! ./instanced.vert */
              "./src/WebGL/shaders/lib/instanced/instanced.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/uniforms.ts": (
          /*!*****************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/uniforms.ts ***!
            \*****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/index.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              lambert: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambert/uniforms.ts"
            ), s = r(
              /*! ./lambert.frag */
              "./src/WebGL/shaders/lib/lambert/lambert.frag"
            ), h = r(
              /*! ./lambert.vert */
              "./src/WebGL/shaders/lib/lambert/lambert.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/uniforms.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/index.ts ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              lambertdouble: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts"
            ), s = r(
              /*! ./lambertdouble.frag */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag"
            ), h = r(
              /*! ./lambertdouble.vert */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/uniforms.ts ***!
            \*********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/index.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              outline: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/outline/uniforms.ts"
            ), s = r(
              /*! ./outline.frag */
              "./src/WebGL/shaders/lib/outline/outline.frag"
            ), h = r(
              /*! ./outline.vert */
              "./src/WebGL/shaders/lib/outline/outline.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/uniforms.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new n.Color(0, 0, 0) },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 },
              outlineMaxPixels: { type: "f", value: 0 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/index.ts ***!
            \***********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              screen: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screen/uniforms.ts"
            ), s = r(
              /*! ./screen.frag */
              "./src/WebGL/shaders/lib/screen/screen.frag"
            ), h = r(
              /*! ./screen.vert */
              "./src/WebGL/shaders/lib/screen/screen.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/uniforms.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/index.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/index.ts ***!
            \*************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              screenaa: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screenaa/uniforms.ts"
            ), s = r(
              /*! ./screenaa.frag */
              "./src/WebGL/shaders/lib/screenaa/screenaa.frag"
            ), h = r(
              /*! ./screenaa.vert */
              "./src/WebGL/shaders/lib/screenaa/screenaa.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/uniforms.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/uniforms.ts ***!
            \****************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/index.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/index.ts ***!
            \*******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              sphereimposter: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts"
            ), s = r(
              /*! ./sphereimposter.frag */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag"
            ), h = r(
              /*! ./sphereimposter.vert */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert"
            );
            const b = {
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/uniforms.ts ***!
            \**********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/index.ts ***!
            \**************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              sphereimposteroutline: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts"
            ), s = r(
              /*! ./sphereimposteroutline.frag */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag"
            ), h = r(
              /*! ./sphereimposteroutline.vert */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts": (
          /*!*****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts ***!
            \*****************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new n.Color(0, 0, 0) },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 },
              outlineMaxPixels: { type: "f", value: 0 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/index.ts ***!
            \***********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              sprite: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sprite/uniforms.ts"
            ), s = r(
              /*! ./sprite.frag */
              "./src/WebGL/shaders/lib/sprite/sprite.frag"
            ), h = r(
              /*! ./sprite.vert */
              "./src/WebGL/shaders/lib/sprite/sprite.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/uniforms.ts ***!
            \**************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/ssao/index.ts": (
          /*!*********************************************!*\
            !*** ./src/WebGL/shaders/lib/ssao/index.ts ***!
            \*********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ssao: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/ssao/uniforms.ts"
            ), s = r(
              /*! ./ssao.frag */
              "./src/WebGL/shaders/lib/ssao/ssao.frag"
            ), h = r(
              /*! ./ssao.vert */
              "./src/WebGL/shaders/lib/ssao/ssao.vert"
            );
            const b = {
              fragmentShader: s.default,
              vertexShader: h.default,
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/ssao/uniforms.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/ssao/uniforms.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {
              total_strength: { type: "f", value: 1 },
              radius: { type: "f", value: 5 },
              projinv: { type: "mat4", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/index.ts ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              stickimposter: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposter/uniforms.ts"
            ), s = r(
              /*! ./stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag"
            ), h = r(
              /*! ./stickimposter.partial.frag */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag"
            ), b = r(
              /*! ./stickimposter.vert */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert"
            );
            const _ = {
              fragmentShader: [s.default, h.default].join(`
`),
              vertexShader: b.default,
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/uniforms.ts ***!
            \*********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/index.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/index.ts ***!
            \*************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              stickimposteroutline: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts"
            ), s = r(
              /*! ../stickimposter/stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/lib/stickimposter/stickimposterFragmentShader.partial.frag"
            ), h = r(
              /*! ./stickimposteroutline.vert */
              "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert"
            );
            const g = {
              fragmentShader: s.default + "gl_FragColor = vec4(color,1.0);}",
              vertexShader: h.default,
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts ***!
            \****************************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineColor: { type: "c", value: new n.Color(0, 0, 0) },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 },
              outlineMaxPixels: { type: "f", value: 0 },
              projinv: { type: "mat4", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/index.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/index.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              volumetric: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/volumetric/uniforms.ts"
            ), s = r(
              /*! ./volumetric.frag */
              "./src/WebGL/shaders/lib/volumetric/volumetric.frag"
            ), h = r(
              /*! ./volumetric.vert */
              "./src/WebGL/shaders/lib/volumetric/volumetric.vert"
            );
            const b = {
              fragmentShader: s.default.replace("#define GLSLIFY 1", ""),
              vertexShader: h.default.replace("#define GLSLIFY 1", ""),
              uniforms: n.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/uniforms.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/uniforms.ts ***!
            \******************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const s = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new n.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              data: { type: "i", value: 3 },
              colormap: { type: "i", value: 4 },
              depthmap: { type: "i", value: 5 },
              step: { type: "f", value: 1 },
              maxdepth: { type: "f", value: 100 },
              subsamples: { type: "f", value: 5 },
              textmat: { type: "mat4", value: [] },
              projinv: { type: "mat4", value: [] },
              transfermin: { type: "f", value: -0.2 },
              transfermax: { type: "f", value: 0.2 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/clone.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/clone.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              clone: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../../colors */
              "./src/colors.ts"
            );
            function s(h) {
              let b = {};
              for (const _ in h) {
                b[_] = {}, b[_].type = h[_].type;
                var g = h[_].value;
                g instanceof n.Color ? b[_].value = g.clone() : typeof g == "number" ? b[_].value = g : g instanceof Array ? b[_].value = [] : console.error("Error copying shader uniforms from ShaderLib: unknown type for uniform");
              }
              return b;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/index.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/index.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              ShaderUtils: () => (
                /* binding */
                s
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                n.clone
              )
              /* harmony export */
            });
            var n = r(
              /*! ./clone */
              "./src/WebGL/shaders/utils/clone.ts"
            );
            const s = {
              clone: n.clone
            };
          }
        ),
        /***/
        "./src/WebGL/shapes/Cylinder.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Cylinder.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Cylinder: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            let s = new n.Vector3();
            class h {
              constructor(g = new n.Vector3(), _ = new n.Vector3(), A = 0) {
                this.c1 = g, this.c2 = _, this.radius = A, this.direction = new n.Vector3().subVectors(this.c2, this.c1).normalize();
              }
              copy(g) {
                return this.c1.copy(g.c1), this.c2.copy(g.c2), this.direction.copy(g.direction), this.radius = g.radius, this;
              }
              lengthSq() {
                return s.subVectors(this.c2, this.c1).lengthSq();
              }
              applyMatrix4(g) {
                return this.direction.add(this.c1).applyMatrix4(g), this.c1.applyMatrix4(g), this.c2.applyMatrix4(g), this.direction.sub(this.c1).normalize(), this.radius = this.radius * g.getMaxScaleOnAxis(), this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Sphere.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shapes/Sphere.ts ***!
            \************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Sphere: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class s {
              constructor(b = { x: 0, y: 0, z: 0 }, g = 0) {
                this.center = new n.Vector3(b.x, b.y, b.z), this.radius = g;
              }
              set(b, g) {
                return this.center.copy(b), this.radius = g, this;
              }
              copy(b) {
                return this.center.copy(b.center), this.radius = b.radius, this;
              }
              applyMatrix4(b) {
                return this.center.applyMatrix4(b), this.radius = this.radius * b.getMaxScaleOnAxis(), this;
              }
              translate(b) {
                return this.center.add(b), this;
              }
              equals(b) {
                return b.center.equals(this.center) && b.radius === this.radius;
              }
              clone() {
                return new s().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Triangle.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Triangle.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Triangle: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const s = new n.Vector3();
            class h {
              constructor(g = new n.Vector3(), _ = new n.Vector3(), A = new n.Vector3()) {
                this.a = g, this.b = _, this.c = A;
              }
              copy(g) {
                return this.a.copy(g.a), this.b.copy(g.b), this.c.copy(g.c), this;
              }
              applyMatrix4(g) {
                return this.a.applyMatrix4(g), this.b.applyMatrix4(g), this.c.applyMatrix4(g), this;
              }
              getNormal() {
                var g = this.a.clone();
                return g.sub(this.b), s.subVectors(this.c, this.b), g.cross(s), g.normalize(), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/index.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/shapes/index.ts ***!
            \***********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                s.Cylinder
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                n.Sphere
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                h.Triangle
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Sphere */
              "./src/WebGL/shapes/Sphere.ts"
            ), s = r(
              /*! ./Cylinder */
              "./src/WebGL/shapes/Cylinder.ts"
            ), h = r(
              /*! ./Triangle */
              "./src/WebGL/shapes/Triangle.ts"
            );
          }
        ),
        /***/
        "./src/autoload.ts": (
          /*!*************************!*\
            !*** ./src/autoload.ts ***!
            \*************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              autoinit: () => (
                /* binding */
                g
              ),
              /* harmony export */
              autoload: () => (
                /* binding */
                x
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* binding */
                _
              ),
              /* harmony export */
              viewers: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var n = r(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), s = r(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), h = r(
              /*! ./utilities */
              "./src/utilities.ts"
            ), b = r(
              /*! ./colors */
              "./src/colors.ts"
            ), g = !1, _ = !1, A = {};
            function x(k, $) {
              var C, L, y;
              if (document.querySelector(".viewer_3Dmoljs") != null && (g = !0), g) {
                _ = !0, k = k ?? null;
                var o = 0;
                document.querySelectorAll(".viewer_3Dmoljs").forEach((v) => {
                  var w = [], M = [], F = "";
                  v.style.position == "static" && (v.style.position = "relative");
                  var m = null;
                  if (y = null, v.dataset.pdb)
                    w.push("https://files.rcsb.org/view/" + v.dataset.pdb + ".pdb"), M.push("pdb");
                  else if (v.dataset.cid)
                    M.push("sdf"), w.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + v.dataset.cid + "/SDF?record_type=3d");
                  else if (v.dataset.href || v.dataset.url) {
                    if (v.dataset.href ? F = v.dataset.href : F = v.dataset.url, w.push(F), y = F.substring(F.lastIndexOf(".") + 1), y == "gz") {
                      let ge = F.substring(0, F.lastIndexOf(".")).lastIndexOf(".");
                      y = F.substring(ge + 1);
                    }
                    M.push(y);
                    var E = F.substring(F.lastIndexOf("/") + 1, F.lastIndexOf("."));
                    E == "/" && (E = F.substring(F.lastIndexOf("/") + 1)), v.dataset[M[M.length - 1]] = E;
                  }
                  let z = v.dataset;
                  for (C in z)
                    C.substring(0, 3) === "pdb" && C !== "pdb" ? (w.push("https://files.rcsb.org/view/" + z[C] + ".pdb"), M.push("pdb")) : C.substring(0, 4) === "href" && C !== "href" ? (F = z[C], w.push(F), M.push(F.substring(F.lastIndexOf(".") + 1))) : C.substring(0, 3) === "cid" && C !== "cid" && (w.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + z[C] + "/SDF?record_type=3d"), M.push("sdf"));
                  var O = {};
                  v.dataset.options && (O = (0, h.specStringToObject)(v.dataset.options));
                  var R = b.CC.color(v.dataset.backgroundcolor), B = v.dataset.backgroundalpha;
                  B = B == null ? 1 : parseFloat(B);
                  var P = { line: {} };
                  v.dataset.style && (P = (0, h.specStringToObject)(v.dataset.style));
                  var W = {};
                  v.dataset.select && (W = (0, h.specStringToObject)(v.dataset.select));
                  var U = [], V = [], K = [], q = {}, H = null, j = v.dataset, Q = /style(.+)/, J = /surface(.*)/, Y = /labelres(.*)/, ee = [];
                  for (L in j)
                    Object.prototype.hasOwnProperty.call(j, L) && ee.push(L);
                  for (ee.sort(), C = 0; C < ee.length; C++) {
                    L = ee[C];
                    var fe = Q.exec(L), me, he, we;
                    fe && (me = "select" + fe[1], he = (0, h.specStringToObject)(j[me]), we = (0, h.specStringToObject)(j[L]), U.push([he, we])), fe = J.exec(L), fe && (me = "select" + fe[1], he = (0, h.specStringToObject)(j[me]), we = (0, h.specStringToObject)(j[L]), V.push([he, we])), fe = Y.exec(L), fe && (me = "select" + fe[1], he = (0, h.specStringToObject)(j[me]), we = (0, h.specStringToObject)(j[L]), K.push([he, we])), L == "zoomto" && (q = (0, h.specStringToObject)(j[L])), L == "spin" && (H = (0, h.specStringToObject)(j[L]));
                  }
                  var ye = function(ge) {
                    for (ge.setStyle(W, P), m && m.createSelectionAndStyle(W, P), C = 0; C < U.length; C++) {
                      let de = U[C][0] || {}, De = U[C][1] || { line: {} };
                      ge.setStyle(de, De), m && m.createSelectionAndStyle(W, P);
                    }
                    for (C = 0; C < V.length; C++) {
                      let de = V[C][0] || {}, De = V[C][1] || {};
                      m ? ge.addSurface(s.SurfaceType.VDW, De, de, de).then((Ve) => {
                        m.loadSurface("VDW", de, De, Ve);
                      }) : ge.addSurface(s.SurfaceType.VDW, De, de, de);
                    }
                    for (C = 0; C < K.length; C++) {
                      let de = K[C][0] || {}, De = K[C][1] || {};
                      ge.addResLabels(de, De);
                    }
                    ge.render(), ge.zoomTo(q), H && ge.spin(H.axis, H.speed);
                  };
                  let ve = k;
                  try {
                    var ce = (0, h.specStringToObject)(v.dataset.config) || {};
                    ce.backgroundColor === void 0 && (ce.backgroundColor = R), ce.backgroundAlpha === void 0 && (ce.backgroundAlpha = B), ve == null ? ve = A[v.id || o++] = (0, n.createViewer)(v, ce) : (ve.setBackgroundColor(R, B), ve.setConfig(ce), m && m.initiateUI()), v.dataset.ui && $3Dmol.StateManager && (m = new $3Dmol.StateManager(ve));
                  } catch (ge) {
                    console.log(ge), v.textContent = "WebGL appears to be disabled.";
                  }
                  if (w.length != 0) {
                    let ge = 0, de = /* @__PURE__ */ ((De, Be) => function(Ve) {
                      F = w[ge];
                      var qe = De.dataset.type || De.dataset.datatype || M[ge];
                      if (Be.addModel(Ve, qe, O), m) {
                        var Ze = De.dataset[M[ge]];
                        m.setModelTitle(Ze);
                      }
                      ge += 1, ge < w.length ? (0, h.get)(w[ge]).then(de) : (ye(Be), De.dataset.callback && (0, h.makeFunction)(De.dataset.callback)(Be), _ = !1, $ && $(Be));
                    })(v, ve);
                    y && y.endsWith("gz") ? (0, h.getbin)(w[0]).then(de) : (0, h.get)(w[0]).then(de);
                  } else {
                    if (v.dataset.element) {
                      var be = "#" + v.dataset.element, le = document.querySelector(be), Se = le ? le.textContent : "";
                      y = v.dataset.type || v.dataset.datatype, ve.addModel(Se, y, O);
                    }
                    ye(ve), v.dataset.callback && (0, h.makeFunction)(v.dataset.callback)(ve), _ = !1, $ && $(ve);
                  }
                });
              }
            }
            document.onreadystatechange = () => {
              document.readyState === "complete" && x();
            };
          }
        ),
        /***/
        "./src/colors.ts": (
          /*!***********************!*\
            !*** ./src/colors.ts ***!
            \***********************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CC: () => (
                /* binding */
                s
              ),
              /* harmony export */
              Color: () => (
                /* binding */
                n
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* binding */
                k
              ),
              /* harmony export */
              chains: () => (
                /* binding */
                x
              ),
              /* harmony export */
              elementColors: () => (
                /* binding */
                _
              ),
              /* harmony export */
              htmlColors: () => (
                /* binding */
                h
              ),
              /* harmony export */
              residues: () => (
                /* binding */
                A
              ),
              /* harmony export */
              ssColors: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            class n {
              constructor(C, L, y) {
                return this.r = 0, this.g = 0, this.b = 0, arguments.length > 1 && typeof C == "number" ? (this.r = C || 0, this.g = L || 0, this.b = y || 0, this) : this.set(C || 0);
              }
              set(C) {
                return C instanceof n ? C.clone() : (typeof C == "number" ? this.setHex(C) : typeof C == "object" && (this.r = C?.r || 0, this.g = C?.g || 0, this.b = C?.b || 0), this);
              }
              setHex(C) {
                return C = Math.floor(C), this.r = (C >> 16 & 255) / 255, this.g = (C >> 8 & 255) / 255, this.b = (C & 255) / 255, this;
              }
              getHex() {
                var C = Math.round(this.r * 255), L = Math.round(this.g * 255), y = Math.round(this.b * 255);
                return C << 16 | L << 8 | y;
              }
              clone() {
                return new n(this.r, this.g, this.b);
              }
              copy(C) {
                return this.r = C.r, this.g = C.g, this.b = C.b, this;
              }
              //return object that represents color components from 0 to 255
              scaled() {
                var C = {};
                return C.r = Math.round(this.r * 255), C.g = Math.round(this.g * 255), C.b = Math.round(this.b * 255), C.a = 1, C;
              }
            }
            class s {
              static color(C) {
                if (!C)
                  return s.cache[0];
                if (C instanceof n)
                  return C;
                if (typeof C == "number" && typeof s.cache[C] < "u")
                  return s.cache[C];
                if (C && Array.isArray(C))
                  return C.map(s.color);
                let L = s.getHex(C), y = new n(L);
                return s.cache[L] = y, y;
              }
              static getHex(C) {
                var L;
                if (Array.isArray(C))
                  return C.map(s.getHex);
                if (typeof C == "string") {
                  let y = C;
                  if (!isNaN(parseInt(y)))
                    return parseInt(y);
                  if (y = y.trim(), y.length == 4 && y[0] == "#" && (y = "#" + y[1] + y[1] + y[2] + y[2] + y[3] + y[3]), y.length == 7 && y[0] == "#")
                    return parseInt(y.substring(1), 16);
                  let o = s.rgbRegEx.exec(y);
                  if (o) {
                    o[1] != "" && console.log("WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.");
                    let v = 0;
                    for (let w = 2; w < 5; w++) {
                      v *= 256;
                      let M = o[w].endsWith("%") ? 255 * parseFloat(o[w]) / 100 : parseFloat(o[w]);
                      v += Math.round(M);
                    }
                    return v;
                  }
                  return ((L = window?.$3Dmol) === null || L === void 0 ? void 0 : L.htmlColors[C.toLowerCase()]) || 0;
                }
                return C;
              }
            }
            s.rgbRegEx = /rgb(a?)\(\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)/i, s.cache = { 0: new n(0) };
            const h = {
              aliceblue: 15792383,
              antiquewhite: 16444375,
              aqua: 65535,
              aquamarine: 8388564,
              azure: 15794175,
              beige: 16119260,
              bisque: 16770244,
              black: 0,
              blanchedalmond: 16772045,
              blue: 255,
              blueviolet: 9055202,
              brown: 10824234,
              burlywood: 14596231,
              cadetblue: 6266528,
              chartreuse: 8388352,
              chocolate: 13789470,
              coral: 16744272,
              cornflowerblue: 6591981,
              cornsilk: 16775388,
              crimson: 14423100,
              cyan: 65535,
              darkblue: 139,
              darkcyan: 35723,
              darkgoldenrod: 12092939,
              darkgray: 11119017,
              darkgrey: 11119017,
              darkgreen: 25600,
              darkkhaki: 12433259,
              darkmagenta: 9109643,
              darkolivegreen: 5597999,
              darkorange: 16747520,
              darkorchid: 10040012,
              darkred: 9109504,
              darksalmon: 15308410,
              darkseagreen: 9419919,
              darkslateblue: 4734347,
              darkslategray: 3100495,
              darkslategrey: 3100495,
              darkturquoise: 52945,
              darkviolet: 9699539,
              deeppink: 16716947,
              deepskyblue: 49151,
              dimgray: 6908265,
              dimgrey: 6908265,
              dodgerblue: 2003199,
              firebrick: 11674146,
              floralwhite: 16775920,
              forestgreen: 2263842,
              fuchsia: 16711935,
              gainsboro: 14474460,
              ghostwhite: 16316671,
              gold: 16766720,
              goldenrod: 14329120,
              gray: 8421504,
              grey: 8421504,
              green: 32768,
              greenyellow: 11403055,
              honeydew: 15794160,
              hotpink: 16738740,
              indianred: 13458524,
              indigo: 4915330,
              ivory: 16777200,
              khaki: 15787660,
              lavender: 15132410,
              lavenderblush: 16773365,
              lawngreen: 8190976,
              lemonchiffon: 16775885,
              lightblue: 11393254,
              lightcoral: 15761536,
              lightcyan: 14745599,
              lightgoldenrodyellow: 16448210,
              lightgray: 13882323,
              lightgrey: 13882323,
              lightgreen: 9498256,
              lightpink: 16758465,
              lightsalmon: 16752762,
              lightseagreen: 2142890,
              lightskyblue: 8900346,
              lightslategray: 7833753,
              lightslategrey: 7833753,
              lightsteelblue: 11584734,
              lightyellow: 16777184,
              lime: 65280,
              limegreen: 3329330,
              linen: 16445670,
              magenta: 16711935,
              maroon: 8388608,
              mediumaquamarine: 6737322,
              mediumblue: 205,
              mediumorchid: 12211667,
              mediumpurple: 9662683,
              mediumseagreen: 3978097,
              mediumslateblue: 8087790,
              mediumspringgreen: 64154,
              mediumturquoise: 4772300,
              mediumvioletred: 13047173,
              midnightblue: 1644912,
              mintcream: 16121850,
              mistyrose: 16770273,
              moccasin: 16770229,
              navajowhite: 16768685,
              navy: 128,
              oldlace: 16643558,
              olive: 8421376,
              olivedrab: 7048739,
              orange: 16753920,
              orangered: 16729344,
              orchid: 14315734,
              palegoldenrod: 15657130,
              palegreen: 10025880,
              paleturquoise: 11529966,
              palevioletred: 14381203,
              papayawhip: 16773077,
              peachpuff: 16767673,
              peru: 13468991,
              pink: 16761035,
              plum: 14524637,
              powderblue: 11591910,
              purple: 8388736,
              rebeccapurple: 6697881,
              red: 16711680,
              rosybrown: 12357519,
              royalblue: 4286945,
              saddlebrown: 9127187,
              salmon: 16416882,
              sandybrown: 16032864,
              seagreen: 3050327,
              seashell: 16774638,
              sienna: 10506797,
              silver: 12632256,
              skyblue: 8900331,
              slateblue: 6970061,
              slategray: 7372944,
              slategrey: 7372944,
              snow: 16775930,
              springgreen: 65407,
              steelblue: 4620980,
              tan: 13808780,
              teal: 32896,
              thistle: 14204888,
              tomato: 16737095,
              turquoise: 4251856,
              violet: 15631086,
              wheat: 16113331,
              white: 16777215,
              whitesmoke: 16119285,
              yellow: 16776960,
              yellowgreen: 10145074
            }, b = {
              //names are in helix-sheet-coil order
              pyMol: { h: 16711680, s: 16776960, c: 65280 },
              Jmol: { h: 16711808, s: 16762880, c: 16777215 }
            }, g = {
              H: 16777215,
              He: 16761035,
              HE: 16761035,
              Li: 11674146,
              LI: 11674146,
              B: 65280,
              C: 13158600,
              N: 9408511,
              O: 15728640,
              F: 14329120,
              Na: 255,
              NA: 255,
              Mg: 2263842,
              MG: 2263842,
              Al: 8421520,
              AL: 8421520,
              Si: 14329120,
              SI: 14329120,
              P: 16753920,
              S: 16762930,
              Cl: 65280,
              CL: 65280,
              Ca: 8421520,
              CA: 8421520,
              Ti: 8421520,
              TI: 8421520,
              Cr: 8421520,
              CR: 8421520,
              Mn: 8421520,
              MN: 8421520,
              Fe: 16753920,
              FE: 16753920,
              Ni: 10824234,
              NI: 10824234,
              Cu: 10824234,
              CU: 10824234,
              Zn: 10824234,
              ZN: 10824234,
              Br: 10824234,
              BR: 10824234,
              Ag: 8421520,
              AG: 8421520,
              I: 10494192,
              Ba: 16753920,
              BA: 16753920,
              Au: 14329120,
              AU: 14329120
            }, _ = {
              defaultColor: 16716947,
              /** Jmol-like element colors*/
              Jmol: {
                H: 16777215,
                He: 14286847,
                HE: 14286847,
                Li: 13402367,
                LI: 13402367,
                Be: 12779264,
                BE: 12779264,
                B: 16758197,
                C: 9474192,
                N: 3166456,
                O: 16715021,
                F: 9494608,
                Ne: 11789301,
                NE: 11789301,
                Na: 11230450,
                NA: 11230450,
                Mg: 9109248,
                MG: 9109248,
                Al: 12560038,
                AL: 12560038,
                Si: 1578e4,
                SI: 1578e4,
                P: 16744448,
                S: 16777008,
                Cl: 2093087,
                CL: 2093087,
                Ar: 8442339,
                AR: 8442339,
                K: 9388244,
                Ca: 4062976,
                CA: 4062976,
                Sc: 15132390,
                SC: 15132390,
                Ti: 12567239,
                TI: 12567239,
                V: 10921643,
                Cr: 9083335,
                CR: 9083335,
                Mn: 10255047,
                MN: 10255047,
                Fe: 14706227,
                FE: 14706227,
                Co: 15765664,
                CO: 15765664,
                Ni: 5296208,
                NI: 5296208,
                Cu: 13140019,
                CU: 13140019,
                Zn: 8224944,
                ZN: 8224944,
                Ga: 12750735,
                GA: 12750735,
                Ge: 6721423,
                GE: 6721423,
                As: 12419299,
                AS: 12419299,
                Se: 16752896,
                SE: 16752896,
                Br: 10889513,
                BR: 10889513,
                Kr: 6076625,
                KR: 6076625,
                Rb: 7351984,
                RB: 7351984,
                Sr: 65280,
                SR: 65280,
                Y: 9764863,
                Zr: 9756896,
                ZR: 9756896,
                Nb: 7586505,
                NB: 7586505,
                Mo: 5551541,
                MO: 5551541,
                Tc: 3907230,
                TC: 3907230,
                Ru: 2396047,
                RU: 2396047,
                Rh: 687500,
                RH: 687500,
                Pd: 27013,
                PD: 27013,
                Ag: 12632256,
                AG: 12632256,
                Cd: 16767375,
                CD: 16767375,
                In: 10909043,
                IN: 10909043,
                Sn: 6717568,
                SN: 6717568,
                Sb: 10380213,
                SB: 10380213,
                Te: 13924864,
                TE: 13924864,
                I: 9699476,
                Xe: 4366e3,
                XE: 4366e3,
                Cs: 5707663,
                CS: 5707663,
                Ba: 51456,
                BA: 51456,
                La: 7394559,
                LA: 7394559,
                Ce: 16777159,
                CE: 16777159,
                Pr: 14286791,
                PR: 14286791,
                Nd: 13107143,
                ND: 13107143,
                Pm: 10747847,
                PM: 10747847,
                Sm: 9437127,
                SM: 9437127,
                Eu: 6422471,
                EU: 6422471,
                Gd: 4587463,
                GD: 4587463,
                Tb: 3211207,
                TB: 3211207,
                Dy: 2097095,
                DY: 2097095,
                Ho: 65436,
                HO: 65436,
                Er: 58997,
                ER: 58997,
                Tm: 54354,
                TM: 54354,
                Yb: 48952,
                YB: 48952,
                Lu: 43812,
                LU: 43812,
                Hf: 5096191,
                HF: 5096191,
                Ta: 5089023,
                TA: 5089023,
                W: 2200790,
                Re: 2522539,
                RE: 2522539,
                Os: 2516630,
                OS: 2516630,
                Ir: 1528967,
                IR: 1528967,
                Pt: 13684960,
                PT: 13684960,
                Au: 16765219,
                AU: 16765219,
                Hg: 12105936,
                HG: 12105936,
                Tl: 10900557,
                TL: 10900557,
                Pb: 5724513,
                PB: 5724513,
                Bi: 10375093,
                BI: 10375093,
                Po: 11230208,
                PO: 11230208,
                At: 7688005,
                AT: 7688005,
                Rn: 4358806,
                RN: 4358806,
                Fr: 4325478,
                FR: 4325478,
                Ra: 32e3,
                RA: 32e3,
                Ac: 7384058,
                AC: 7384058,
                Th: 47871,
                TH: 47871,
                Pa: 41471,
                PA: 41471,
                U: 36863,
                Np: 33023,
                NP: 33023,
                Pu: 27647,
                PU: 27647,
                Am: 5528818,
                AM: 5528818,
                Cm: 7888099,
                CM: 7888099,
                Bk: 9064419,
                BK: 9064419,
                Cf: 10565332,
                CF: 10565332,
                Es: 11739092,
                ES: 11739092,
                Fm: 11739066,
                FM: 11739066,
                Md: 11734438,
                MD: 11734438,
                No: 12389767,
                NO: 12389767,
                Lr: 13041766,
                LR: 13041766,
                Rf: 13369433,
                RF: 13369433,
                Db: 13697103,
                DB: 13697103,
                Sg: 14221381,
                SG: 14221381,
                Bh: 14680120,
                BH: 14680120,
                Hs: 15073326,
                HS: 15073326,
                Mt: 15400998,
                MT: 15400998
              },
              /** rasmol-like element colors */
              rasmol: g,
              defaultColors: Object.assign({}, g),
              greenCarbon: Object.assign(Object.assign({}, g), { C: 65280 }),
              cyanCarbon: Object.assign(Object.assign({}, g), { C: 65535 }),
              magentaCarbon: Object.assign(Object.assign({}, g), { C: 16711935 }),
              yellowCarbon: Object.assign(Object.assign({}, g), { C: 16776960 }),
              whiteCarbon: Object.assign(Object.assign({}, g), { C: 16777215 }),
              orangeCarbon: Object.assign(Object.assign({}, g), { C: 16753920 }),
              purpleCarbon: Object.assign(Object.assign({}, g), { C: 8388736 }),
              blueCarbon: Object.assign(Object.assign({}, g), { C: 255 })
            }, A = {
              /** @property standard amino acid color scheme*/
              amino: {
                ALA: 13158600,
                ARG: 1334015,
                ASN: 56540,
                ASP: 15075850,
                CYS: 15132160,
                GLN: 56540,
                GLU: 15075850,
                GLY: 15461355,
                HIS: 8553170,
                ILE: 1016335,
                LEU: 1016335,
                LYS: 1334015,
                MET: 15132160,
                PHE: 3289770,
                PRO: 14456450,
                SER: 16422400,
                THR: 16422400,
                TRP: 11819700,
                TYR: 3289770,
                VAL: 1016335,
                ASX: 16738740,
                GLX: 16738740
              },
              /** @property shapely amino acid color scheme*/
              shapely: {
                ALA: 9240460,
                ARG: 124,
                ASN: 16743536,
                ASP: 10485826,
                CYS: 16777072,
                GLN: 16731212,
                GLU: 6684672,
                GLY: 16777215,
                HIS: 7368959,
                ILE: 19456,
                LEU: 4546117,
                LYS: 4671416,
                MET: 12099650,
                PHE: 5459026,
                PRO: 5395026,
                SER: 16740418,
                THR: 12078080,
                TRP: 5195264,
                TYR: 9203788,
                VAL: 16747775,
                ASX: 16711935,
                GLX: 16711935
              },
              /** @property nucleic acid color scheme*/
              nucleic: {
                A: 10526975,
                G: 16740464,
                I: 8454143,
                C: 16747595,
                T: 10551200,
                U: 16744576
              }
            }, x = {
              /** @property chain based standard color scheme */
              atom: {
                A: 12636415,
                B: 11599792,
                C: 16761032,
                D: 16777088,
                E: 16761087,
                F: 11596016,
                G: 16765040,
                H: 15761536,
                I: 16113331,
                J: 49151,
                K: 13458524,
                L: 6737322,
                M: 10145074,
                N: 15631086,
                O: 52945,
                P: 65407,
                Q: 3978097,
                R: 139,
                S: 12433259,
                T: 25600,
                U: 8388608,
                V: 8421376,
                W: 8388736,
                X: 32896,
                Y: 12092939,
                Z: 11674146
              },
              /** @property hetatm color scheme */
              hetatm: {
                A: 9478351,
                B: 8441752,
                C: 13602992,
                D: 13619056,
                E: 13603023,
                F: 8437952,
                G: 13607008,
                H: 12603504,
                I: 12955267,
                J: 42959,
                K: 11881548,
                L: 5682578,
                M: 9090346,
                N: 12481214,
                O: 46753,
                P: 53103,
                Q: 3447649,
                R: 187,
                S: 10854235,
                T: 37888,
                U: 11534336,
                V: 11579392,
                W: 11534512,
                X: 45232,
                Y: 15250963,
                Z: 12726834
              }
            }, k = {
              /** secondary structure pymol */
              ssPyMol: { prop: "ss", map: b.pyMol },
              ssJmol: { prop: "ss", map: b.Jmol },
              Jmol: { prop: "elem", map: _.Jmol },
              amino: { prop: "resn", map: A.amino },
              shapely: { prop: "resn", map: A.shapely },
              nucleic: { prop: "resn", map: A.nucleic },
              chain: { prop: "chain", map: x.atom },
              rasmol: { prop: "elem", map: _.rasmol },
              default: { prop: "elem", map: _.defaultColors },
              greenCarbon: { prop: "elem", map: _.greenCarbon },
              chainHetatm: { prop: "chain", map: x.hetatm },
              cyanCarbon: { prop: "elem", map: _.cyanCarbon },
              magentaCarbon: { prop: "elem", map: _.magentaCarbon },
              purpleCarbon: { prop: "elem", map: _.purpleCarbon },
              whiteCarbon: { prop: "elem", map: _.whiteCarbon },
              orangeCarbon: { prop: "elem", map: _.orangeCarbon },
              yellowCarbon: { prop: "elem", map: _.yellowCarbon },
              blueCarbon: { prop: "elem", map: _.blueCarbon }
            };
          }
        ),
        /***/
        "./src/glcartoon.ts": (
          /*!**************************!*\
            !*** ./src/glcartoon.ts ***!
            \**************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              drawCartoon: () => (
                /* binding */
                W
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* binding */
                x
              )
              /* harmony export */
            });
            var n = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), s = r(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), h = r(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), b = r(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), g = r(
              /*! ./colors */
              "./src/colors.ts"
            ), _ = r(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), A = r(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            function x(U, V) {
              var K = [], q = U;
              q = [], q.push(U[0]);
              var H, j, Q, J, Y, ee, fe, me, he;
              for (H = 1, j = U.length - 1; H < j; H++)
                if (Y = U[H], ee = U[H + 1], Y.smoothen) {
                  var we = new n.Vector3((Y.x + ee.x) / 2, (Y.y + ee.y) / 2, (Y.z + ee.z) / 2);
                  we.atom = Y.atom, q.push(we);
                } else
                  q.push(Y);
              for (q.push(U[U.length - 1]), H = -1, Q = q.length; H <= Q - 3; H++)
                if (J = q[H === -1 ? 0 : H], Y = q[H + 1], ee = q[H + 2], fe = q[H === Q - 3 ? Q - 1 : H + 3], me = new n.Vector3().subVectors(ee, J).multiplyScalar(0.5), he = new n.Vector3().subVectors(fe, Y).multiplyScalar(0.5), !ee.skip)
                  for (var ye = 0; ye < V; ye++) {
                    var ve = 1 / V * ye, ce = Y.x + ve * me.x + ve * ve * (-3 * Y.x + 3 * ee.x - 2 * me.x - he.x) + ve * ve * ve * (2 * Y.x - 2 * ee.x + me.x + he.x), be = Y.y + ve * me.y + ve * ve * (-3 * Y.y + 3 * ee.y - 2 * me.y - he.y) + ve * ve * ve * (2 * Y.y - 2 * ee.y + me.y + he.y), le = Y.z + ve * me.z + ve * ve * (-3 * Y.z + 3 * ee.z - 2 * me.z - he.z) + ve * ve * ve * (2 * Y.z - 2 * ee.z + me.z + he.z), Se = new n.Vector3(ce, be, le);
                    ye < V / 2 ? Se.atom = Y.atom : Se.atom = ee.atom, K.push(Se);
                  }
              return K.push(q[q.length - 1]), K;
            }
            const k = 0.5, $ = 1.3, C = 0.8, L = 0.4, y = 0.4;
            function o(U, V, K, q) {
              for (var H, j, Q, J, Y = 0, ee = V.length; Y < ee; Y++) {
                J = Math.round(Y * (q.length - 1) / ee), Q = g.CC.color(q[J]);
                var fe = U.updateGeoGroup(2), me = fe.vertexArray, he = fe.colorArray, we = fe.faceArray;
                H = fe.vertices, j = H * 3, me[j] = V[Y].x, me[j + 1] = V[Y].y, me[j + 2] = V[Y].z, me[j + 3] = K[Y].x, me[j + 4] = K[Y].y, me[j + 5] = K[Y].z;
                for (var ye = 0; ye < 6; ++ye)
                  he[j + 3 * ye] = Q.r, he[j + 1 + 3 * ye] = Q.g, he[j + 2 + 3 * ye] = Q.b;
                if (Y > 0) {
                  var ve = [H, H + 1, H - 1, H - 2], ce = fe.faceidx;
                  we[ce] = ve[0], we[ce + 1] = ve[1], we[ce + 2] = ve[3], we[ce + 3] = ve[1], we[ce + 4] = ve[2], we[ce + 5] = ve[3], fe.faceidx += 6;
                }
                fe.vertices += 2;
              }
            }
            function v(U, V, K, q, H, j, Q) {
              var J, Y, ee, fe;
              if (ee = V.length, ee < 2 || V[0].length < 2)
                return;
              for (J = 0; J < ee; J++)
                V[J] = x(V[J], q);
              if (fe = V[0].length, !H)
                return o(U, V[0], V[ee - 1], K);
              var me, he, we, ye, ve, ce, be = [], le = [], Se = [];
              for (Y = 0; Y < ee; Y++)
                be.push(0.25 + 1.5 * Math.sqrt((ee - 1) * Y - Math.pow(Y, 2)) / (ee - 1)), le.push(0.5), Se.push(2 * (Math.pow(Y / ee, 2) - Y / ee) + 0.6);
              var ge = [];
              for (Y = 0; Y < ee * 2 - 1; Y++)
                ge[Y] = [Y, Y + 1, Y + 1 - 2 * ee, Y - 2 * ee];
              ge[ee * 2 - 1] = [
                Y,
                Y + 1 - 2 * ee,
                Y + 1 - 4 * ee,
                Y - 2 * ee
              ];
              var de, De, Be, Ve, qe, Ze, Ye, Xe, Ge, Ke;
              let Pe = U.updateGeoGroup();
              for (J = 0; J < fe; J++) {
                let se = U.groups, ue = !1;
                Pe = U.updateGeoGroup(2 * ee), se != U.groups && J > 0 && (J = J - 1, ue = !0), Ze = Math.round(J * (K.length - 1) / fe), qe = g.CC.color(K[Ze]), ve = we, ce = ye, we = [], ye = [], me = [], V[0][J].atom !== void 0 && (Ve = V[0][J].atom, Q === "oval" ? he = be : Q === "rectangle" ? he = le : Q === "parabola" && (he = Se)), he || (he = le);
                var it, nt;
                for (Y = 0; Y < ee; Y++)
                  J < fe - 1 ? it = V[Y][J + 1].clone().sub(V[Y][J]) : it = V[Y][J - 1].clone().sub(V[Y][J]).negate(), Y < ee - 1 ? nt = V[Y + 1][J].clone().sub(V[Y][J]) : nt = V[Y - 1][J].clone().sub(V[Y][J]).negate(), me[Y] = nt.cross(it).normalize().multiplyScalar(H * he[Y]);
                for (Y = 0; Y < ee; Y++)
                  we[Y] = V[Y][J].clone().add(me[Y].clone().negate());
                for (Y = 0; Y < ee; Y++)
                  ye[Y] = V[Y][J].clone().add(me[Y]);
                for (Ye = Pe.vertexArray, Xe = Pe.colorArray, Ge = Pe.faceArray, de = Pe.vertices, De = de * 3, Y = 0; Y < ee; Y++)
                  Ye[De + 3 * Y + 0] = we[Y].x, Ye[De + 3 * Y + 1] = we[Y].y, Ye[De + 3 * Y + 2] = we[Y].z;
                for (Y = 0; Y < ee; Y++)
                  Ye[De + 3 * Y + 0 + 3 * ee] = ye[ee - 1 - Y].x, Ye[De + 3 * Y + 1 + 3 * ee] = ye[ee - 1 - Y].y, Ye[De + 3 * Y + 2 + 3 * ee] = ye[ee - 1 - Y].z;
                for (Y = 0; Y < 2 * ee; ++Y)
                  Xe[De + 3 * Y + 0] = qe.r, Xe[De + 3 * Y + 1] = qe.g, Xe[De + 3 * Y + 2] = qe.b;
                if (J > 0 && !ue) {
                  for (Y = 0; Y < ee * 2; Y++)
                    Ke = [
                      de + ge[Y][0],
                      de + ge[Y][1],
                      de + ge[Y][2],
                      de + ge[Y][3]
                    ], Be = Pe.faceidx, Ge[Be] = Ke[0], Ge[Be + 1] = Ke[1], Ge[Be + 2] = Ke[3], Ge[Be + 3] = Ke[1], Ge[Be + 4] = Ke[2], Ge[Be + 5] = Ke[3], Pe.faceidx += 6;
                  if (Ve.clickable || Ve.hoverable) {
                    var ne = [];
                    ne.push(new s.Triangle(ve[0], we[0], we[ee - 1])), ne.push(new s.Triangle(ve[0], we[ee - 1], ve[ee - 1])), ne.push(new s.Triangle(ve[ee - 1], we[ee - 1], ye[ee - 1])), ne.push(new s.Triangle(ve[ee - 1], ye[ee - 1], ce[ee - 1])), ne.push(new s.Triangle(ye[0], ce[0], ce[ee - 1])), ne.push(new s.Triangle(ye[ee - 1], ye[0], ce[ee - 1])), ne.push(new s.Triangle(we[0], ve[0], ce[0])), ne.push(new s.Triangle(ye[0], we[0], ce[0]));
                    for (Y in ne)
                      Ve.intersectionShape.triangle.push(ne[Y]);
                  }
                }
                Pe.vertices += 2 * ee;
              }
              for (Ye = Pe.vertexArray, Xe = Pe.colorArray, Ge = Pe.faceArray, de = Pe.vertices, De = de * 3, Be = Pe.faceidx, J = 0; J < ee - 1; J++)
                Ke = [J, J + 1, 2 * ee - 2 - J, 2 * ee - 1 - J], Be = Pe.faceidx, Ge[Be] = Ke[0], Ge[Be + 1] = Ke[1], Ge[Be + 2] = Ke[3], Ge[Be + 3] = Ke[1], Ge[Be + 4] = Ke[2], Ge[Be + 5] = Ke[3], Pe.faceidx += 6;
              for (J = 0; J < ee - 1; J++)
                Ke = [
                  de - 1 - J,
                  de - 2 - J,
                  de - 2 * ee + J + 1,
                  de - 2 * ee + J
                ], Be = Pe.faceidx, Ge[Be] = Ke[0], Ge[Be + 1] = Ke[1], Ge[Be + 2] = Ke[3], Ge[Be + 3] = Ke[1], Ge[Be + 4] = Ke[2], Ge[Be + 5] = Ke[3], Pe.faceidx += 6;
            }
            function w(U, V, K, q, H, j) {
              if (!(V.length < 2)) {
                var Q, J;
                if (Q = V[0], J = V[V.length - 1], Q = x(Q, q), J = x(J, q), !H)
                  return o(U, Q, J, K);
                var Y = [], ee, fe, me, he, we, ye = [
                  [0, 2, -6, -8],
                  [-4, -2, 6, 4],
                  [7, -1, -5, 3],
                  [-3, 5, 1, -7]
                ], ve, ce, be, le, Se, ge, de, De, Be, Ve, qe, Ze, Ye, Xe, Ge, Ke, Pe;
                for (De = 0, Be = Q.length; De < Be; De++) {
                  if (Se = Math.round(De * (K.length - 1) / Be), le = g.CC.color(K[Se]), Y.push(fe = Q[De]), Y.push(fe), Y.push(me = J[De]), Y.push(me), De < Be - 1) {
                    var it = Q[De + 1].clone().sub(Q[De]), nt = J[De].clone().sub(Q[De]);
                    ee = nt.cross(it).normalize().multiplyScalar(H);
                  }
                  for (Y.push(he = Q[De].clone().add(ee)), Y.push(he), Y.push(we = J[De].clone().add(ee)), Y.push(we), fe.atom !== void 0 && (ge = fe.atom), Xe = U.updateGeoGroup(8), Ge = Xe.vertexArray, Ke = Xe.colorArray, Pe = Xe.faceArray, ve = Xe.vertices, ce = ve * 3, Ge[ce] = fe.x, Ge[ce + 1] = fe.y, Ge[ce + 2] = fe.z, Ge[ce + 3] = fe.x, Ge[ce + 4] = fe.y, Ge[ce + 5] = fe.z, Ge[ce + 6] = me.x, Ge[ce + 7] = me.y, Ge[ce + 8] = me.z, Ge[ce + 9] = me.x, Ge[ce + 10] = me.y, Ge[ce + 11] = me.z, Ge[ce + 12] = he.x, Ge[ce + 13] = he.y, Ge[ce + 14] = he.z, Ge[ce + 15] = he.x, Ge[ce + 16] = he.y, Ge[ce + 17] = he.z, Ge[ce + 18] = we.x, Ge[ce + 19] = we.y, Ge[ce + 20] = we.z, Ge[ce + 21] = we.x, Ge[ce + 22] = we.y, Ge[ce + 23] = we.z, Ve = 0; Ve < 8; ++Ve)
                    Ke[ce + 3 * Ve] = le.r, Ke[ce + 1 + 3 * Ve] = le.g, Ke[ce + 2 + 3 * Ve] = le.b;
                  if (De > 0) {
                    var ne = de !== void 0 && ge !== void 0 && de.serial !== ge.serial;
                    for (Ve = 0; Ve < 4; Ve++) {
                      var se = [
                        ve + ye[Ve][0],
                        ve + ye[Ve][1],
                        ve + ye[Ve][2],
                        ve + ye[Ve][3]
                      ];
                      if (be = Xe.faceidx, Pe[be] = se[0], Pe[be + 1] = se[1], Pe[be + 2] = se[3], Pe[be + 3] = se[1], Pe[be + 4] = se[2], Pe[be + 5] = se[3], Xe.faceidx += 6, ge.clickable || de.clickable || ge.hoverable || de.hoverable) {
                        var ue = Y[se[3]].clone(), $e = Y[se[0]].clone(), Ae = Y[se[2]].clone(), je = Y[se[1]].clone();
                        if (ue.atom = Y[se[3]].atom || null, Ae.atom = Y[se[2]].atom || null, $e.atom = Y[se[0]].atom || null, je.atom = Y[se[1]].atom || null, ne) {
                          var ze = ue.clone().add($e).multiplyScalar(0.5), re = Ae.clone().add(je).multiplyScalar(0.5), xe = ue.clone().add(je).multiplyScalar(0.5);
                          Ve % 2 === 0 ? ((de.clickable || de.hoverable) && (qe = new s.Triangle(ze, xe, ue), Ze = new s.Triangle(re, Ae, xe), Ye = new s.Triangle(xe, Ae, ue), de.intersectionShape.triangle.push(qe), de.intersectionShape.triangle.push(Ze), de.intersectionShape.triangle.push(Ye)), (ge.clickable || ge.hoverable) && (qe = new s.Triangle($e, je, xe), Ze = new s.Triangle(je, re, xe), Ye = new s.Triangle($e, xe, ze), ge.intersectionShape.triangle.push(qe), ge.intersectionShape.triangle.push(Ze), ge.intersectionShape.triangle.push(Ye))) : ((ge.clickable || ge.hoverable) && (qe = new s.Triangle(ze, xe, ue), Ze = new s.Triangle(re, Ae, xe), Ye = new s.Triangle(xe, Ae, ue), ge.intersectionShape.triangle.push(qe), ge.intersectionShape.triangle.push(Ze), ge.intersectionShape.triangle.push(Ye)), (de.clickable || de.hoverable) && (qe = new s.Triangle($e, je, xe), Ze = new s.Triangle(je, re, xe), Ye = new s.Triangle($e, xe, ze), de.intersectionShape.triangle.push(qe), de.intersectionShape.triangle.push(Ze), de.intersectionShape.triangle.push(Ye)));
                        } else (ge.clickable || ge.hoverable) && (qe = new s.Triangle($e, je, ue), Ze = new s.Triangle(je, Ae, ue), ge.intersectionShape.triangle.push(qe), ge.intersectionShape.triangle.push(Ze));
                      }
                    }
                  }
                  Xe.vertices += 8, de = ge;
                }
                var Le = Y.length - 8;
                for (Xe = U.updateGeoGroup(8), Ge = Xe.vertexArray, Ke = Xe.colorArray, Pe = Xe.faceArray, ve = Xe.vertices, ce = ve * 3, be = Xe.faceidx, De = 0; De < 4; De++) {
                  Y.push(Y[De * 2]), Y.push(Y[Le + De * 2]);
                  var He = Y[De * 2], Me = Y[Le + De * 2];
                  Ge[ce + 6 * De] = He.x, Ge[ce + 1 + 6 * De] = He.y, Ge[ce + 2 + 6 * De] = He.z, Ge[ce + 3 + 6 * De] = Me.x, Ge[ce + 4 + 6 * De] = Me.y, Ge[ce + 5 + 6 * De] = Me.z, Ke[ce + 6 * De] = le.r, Ke[ce + 1 + 6 * De] = le.g, Ke[ce + 2 + 6 * De] = le.b, Ke[ce + 3 + 6 * De] = le.r, Ke[ce + 4 + 6 * De] = le.g, Ke[ce + 5 + 6 * De] = le.b;
                }
                Le += 8, qe = [ve, ve + 2, ve + 6, ve + 4], Ze = [ve + 1, ve + 5, ve + 7, ve + 3], Pe[be] = qe[0], Pe[be + 1] = qe[1], Pe[be + 2] = qe[3], Pe[be + 3] = qe[1], Pe[be + 4] = qe[2], Pe[be + 5] = qe[3], Pe[be + 6] = Ze[0], Pe[be + 7] = Ze[1], Pe[be + 8] = Ze[3], Pe[be + 9] = Ze[1], Pe[be + 10] = Ze[2], Pe[be + 11] = Ze[3], Xe.faceidx += 12, Xe.vertices += 8;
              }
            }
            function M(U, V, K, q, H, j, Q) {
              (!Q || Q === "default") && (Q = "rectangle"), Q === "edged" ? w(U, V, K, q, H) : (Q === "rectangle" || Q === "oval" || Q === "parabola") && v(U, V, K, q, H, j, Q);
            }
            function F(U) {
              return U && U.elem === "C" && U.atom === "CA";
            }
            function m(U, V) {
              if (U && V && U.chain === V.chain) {
                if (!U.hetflag && !V.hetflag && U.reschain === V.reschain && (U.resi === V.resi || U.resi === V.resi - 1))
                  return !0;
                if (U.resi < V.resi) {
                  var K = U.x - V.x, q = U.y - V.y, H = U.z - V.z, j = K * K + q * q + H * H;
                  if (U.atom == "CA" && V.atom == "CA" && j < 16)
                    return !0;
                  if ((U.atom == "P" || V.atom == "P") && j < 64)
                    return !0;
                }
              }
              return !1;
            }
            function E(U, V, K, q, H) {
              if (!(V == null || V.vertices == 0)) {
                H && (V.initTypedArrays(), V.setUpNormals());
                var j = new h.MeshDoubleLambertMaterial();
                j.vertexColors = h.Coloring.FaceColors, typeof K == "number" && K >= 0 && K < 1 && (j.transparent = !0, j.opacity = K), j.outline = q;
                var Q = new h.Mesh(V, j);
                U.add(Q);
              }
            }
            function z(U, V, K, q, H, j, Q, J, Y) {
              var ee, fe, me, he, we, ye;
              if (!(!q || !H || !Q)) {
                var ve = H.sub(q);
                ve.normalize();
                var ce = J[Y];
                for (fe = Y + 1; fe < J.length && (ce = J[fe], ce.atom != Q.atom); fe++)
                  ;
                if (ce = ce ? new n.Vector3(ce.x, ce.y, ce.z) : new n.Vector3(0, 0, 0), ce.sub(q), Q.ss === "arrow start") {
                  var be = ce.clone().multiplyScalar(0.3).cross(H);
                  q.add(be);
                  var le = ce.clone().cross(ve).normalize();
                  ve.rotateAboutVector(le, 0.43);
                }
                for (Q.style.cartoon.ribbon ? ee = Q.style.cartoon.thickness || L : Q.style.cartoon.width ? ee = Q.style.cartoon.width : Q.ss === "c" ? Q.atom === "P" ? ee = C : ee = k : Q.ss === "arrow start" ? (ee = $, we = !0) : Q.ss === "arrow end" || Q.ss === "h" && Q.style.cartoon.tubes || Q.ss === "tube start" ? ee = k : ee = $, j != null && ve.dot(j) < 0 && ve.negate(), ve.multiplyScalar(ee), fe = 0; fe < V; fe++)
                  me = -1 + fe * 2 / (V - 1), he = new n.Vector3(q.x + me * ve.x, q.y + me * ve.y, q.z + me * ve.z), he.atom = Q, Q.ss === "s" && (he.smoothen = !0), U[fe].push(he);
                if (we)
                  for (ve.multiplyScalar(2), fe = 0; fe < V; fe++)
                    me = -1 + fe * 2 / (V - 1), he = new n.Vector3(q.x + me * ve.x, q.y + me * ve.y, q.z + me * ve.z), he.atom = Q, he.smoothen = !1, he.skip = !0, U[fe].push(he);
                return ye = Q.style.cartoon.style || "default", U.style ? U.style != ye && (console.log("Warning: a cartoon chain's strand-style is ambiguous"), U.style = "default") : U.style = ye, (Q.ss === "arrow start" || Q.ss === "arrow end") && (Q.ss = "s"), we;
              }
            }
            const O = {
              C: !0,
              CA: !0,
              O: !0,
              P: !0,
              OP2: !0,
              O2P: !0,
              "O5'": !0,
              "O3'": !0,
              "C5'": !0,
              "C2'": !0,
              "O5*": !0,
              "O3*": !0,
              "C5*": !0,
              "C2*": !0,
              N1: !0,
              N3: !0
            }, R = { DA: !0, DG: !0, A: !0, G: !0 }, B = { DT: !0, DC: !0, U: !0, C: !0, T: !0 }, P = { DA: !0, DG: !0, A: !0, G: !0, DT: !0, DC: !0, U: !0, C: !0, T: !0 };
            function W(U, V, K, q = 10) {
              let H = q, j = q;
              var Q, J, Y, ee, fe, me, he, we, ye, ve, ce, be, le, Se, ge, de, De, Be, Ve = new h.Geometry(!0), qe = new h.Geometry(!0), Ze = [], Ye = [], Xe = 1, Ge = !1, Ke = {};
              for (var Pe in b.Gradient.builtinGradients)
                b.Gradient.builtinGradients.hasOwnProperty(Pe) && (Ke[Pe] = new b.Gradient.builtinGradients[Pe](K[1], K[0]));
              var it = function(ie, We) {
                return K && We.color === "spectrum" ? We.colorscheme in Ke ? Ke[We.colorscheme].valueToHex(ie.resi) : Ke.sinebow.valueToHex(ie.resi) : (0, A.getColorFromStyle)(ie, We).getHex();
              };
              for (we = 0; we < H; we++)
                Ye[we] = [];
              var nt = !1, ne = !1, se = [];
              for (we in V) {
                if (ee = V[we], ee.elem === "C" && ee.atom === "CA") {
                  var ue = m(Y, ee);
                  ue && ee.ss === "s" ? nt = !0 : nt && (Y && J && Y.style.cartoon.arrows && J.style.cartoon.arrows && (Y.ss = "arrow end", J.ss = "arrow start"), nt = !1), ue && (Y.ss === "h" || Y.ss == "tube start") && Y.style.cartoon.tubes ? !ne && Y.ss != "tube start" && ee.style.cartoon.tubes && (ee.ss = "tube start", ne = !0) : ne && (Y.ss === "tube start" ? Y.ss = "tube end" : J && J.style.cartoon.tubes && (J.ss = "tube end"), ne = !1), J = Y, Y = ee;
                }
                ee && ee.atom in O && se.push(ee);
              }
              ne && Y.style.cartoon.tubes && (Y.ss = "tube end", ne = !1);
              var $e = function(ie) {
                Ye[0].length > 0 && M(qe, Ye, Ze, j, he, Xe, Ye.style);
                var We = [], Qe = null;
                if (ie) {
                  for (we = 0; we < H; we++)
                    We[we] = Ye[we][Ye[we].length - 1];
                  Qe = Ze[Ze.length - 1];
                }
                for (Ye = [], we = 0; we < H; we++)
                  Ye[we] = [];
                if (Ze = [], ie) {
                  for (we = 0; we < H; we++)
                    Ye[we].push(We[we]);
                  Ze.push(Qe);
                }
                E(U, qe, Xe, Ge, !0), E(U, Ve, Xe, Ge, !1), qe = new h.Geometry(!0), Ve = new h.Geometry(!0);
              };
              Y = void 0;
              for (var Ae = 0; Ae < se.length; Ae++) {
                ee = se[Ae];
                var je = ee.resn.trim(), ze = je in P;
                if (Xe = 1, Q = ee.style.cartoon, Y && Y.style.cartoon && (Xe = Y.style.cartoon.opacity), Y && Y.style.cartoon && Y.style.cartoon.outline && (Ge = Y.style.cartoon.outline), Y && Y.style.cartoon && (!ee.style.cartoon || Y.style.cartoon.opacity != ee.style.cartoon.opacity) && $e(Y.chain == ee.chain), Q.style === "trace") {
                  if (!ee.hetflag) {
                    if (ee.elem === "C" && ee.atom === "CA" || ze && ee.atom === "P" || ee.atom === "BB") {
                      if (me = it(ee, Q), (0, A.isNumeric)(Q.thickness) ? he = Q.thickness : he = L, m(Y, ee))
                        if (me == fe) {
                          var re = g.CC.color(me);
                          _.GLDraw.drawCylinder(Ve, Y, ee, he, re, 2, 2);
                        } else {
                          var xe = new n.Vector3().addVectors(Y, ee).multiplyScalar(0.5), Le = g.CC.color(fe), He = g.CC.color(me);
                          _.GLDraw.drawCylinder(Ve, Y, xe, he, Le, 2, 0), _.GLDraw.drawCylinder(Ve, xe, ee, he, He, 0, 2);
                        }
                      if ((ee.clickable === !0 || ee.hoverable) && ee.intersectionShape !== void 0) {
                        var Me = new n.Vector3(ee.x, ee.y, ee.z);
                        ee.intersectionShape.sphere.push(new s.Sphere(Me, he));
                      }
                      Y = ee, fe = me;
                    }
                  }
                } else {
                  if (F(ee) || ze && (ee.atom === "P" || ee.atom.indexOf("O5") == 0)) {
                    if (Be)
                      if (ee.ss === "tube end")
                        Be = !1, De = new n.Vector3(ee.x, ee.y, ee.z), _.GLDraw.drawCylinder(Ve, de, De, 2, g.CC.color(fe), 1, 1), ee.ss = "h";
                      else if (Y.chain != ee.chain || Y.ss === "tube end")
                        Be = !1, Y.ss = "h", De = new n.Vector3(Y.x, Y.y, Y.z), _.GLDraw.drawCylinder(Ve, de, De, 2, g.CC.color(fe), 1, 1);
                      else
                        continue;
                    if (Y && (!m(Y, ee) || Y.ss === "tube start")) {
                      for (Y.ss === "tube start" && (Be = !0, de = new n.Vector3(Y.x, Y.y, Y.z), Y.ss = "h"), ge && (be ? Se = new n.Vector3().addVectors(Y, be).multiplyScalar(0.5) : Se = new n.Vector3(Y.x, Y.y, Y.z), _.GLDraw.drawCylinder(Ve, Se, ge, y, g.CC.color(ge.color), 0, 2), z(Ye, H, !0, be, le, ce, Y, se, Ae), Ze.push(me), Se = null, ge = null), Ye[0].length > 0 && M(qe, Ye, Ze, j, he, Xe, Ye.style), Ye = [], we = 0; we < H; we++)
                        Ye[we] = [];
                      Ze = [];
                    }
                    if (Y === void 0 || Y.rescode != ee.rescode || Y.resi != ee.resi) {
                      if (ge && Y != null) {
                        Se = new n.Vector3().addVectors(Y, ee).multiplyScalar(0.5);
                        var Re = Se.clone().sub(ge).multiplyScalar(0.02);
                        Se.add(Re), _.GLDraw.drawCylinder(Ve, Se, ge, y, g.CC.color(ge.color), 0, 2), Se = null, ge = null;
                      }
                      me = it(ee, Q), Ze.push(me), (0, A.isNumeric)(Q.thickness) ? he = Q.thickness : he = L, Y = ee, ye = new n.Vector3(Y.x, Y.y, Y.z), ye.resi = Y.resi, fe = me;
                    }
                    (ee.clickable === !0 || ee.hoverable === !0) && (ee.intersectionShape === void 0 || ee.intersectionShape.triangle === void 0) && (ee.intersectionShape = {
                      sphere: null,
                      cylinder: [],
                      line: [],
                      triangle: []
                    });
                  } else Y != null && (F(Y) && ee.atom === "O" || ze && Y.atom === "P" && (ee.atom === "OP2" || ee.atom === "O2P") || ze && Y.atom.indexOf("O5") == 0 && ee.atom.indexOf("C5") == 0) ? (ve = new n.Vector3(ee.x, ee.y, ee.z), ve.resi = ee.resi, (ee.atom === "OP2" || ee.atom === "O2P") && (le = new n.Vector3(ee.x, ee.y, ee.z))) : ze && ee.atom.indexOf("O3") == 0 ? be = new n.Vector3(ee.x, ee.y, ee.z) : (ee.atom === "N1" && je in R || ee.atom === "N3" && je in B) && (ge = new n.Vector3(ee.x, ee.y, ee.z), ge.color = (0, A.getColorFromStyle)(ee, Q).getHex());
                  ve && ye && ve.resi === ye.resi && (z(Ye, H, !0, ye, ve, ce, Y, se, Ae), ce = ve, ye = null, ve = null, Ze.push(me));
                }
              }
              ge && (be ? Se = new n.Vector3().addVectors(Y, be).multiplyScalar(0.5) : Se = new n.Vector3(Y.x, Y.y, Y.z), _.GLDraw.drawCylinder(Ve, Se, ge, y, g.CC.color(ge.color), 0, 2), z(Ye, H, !0, be, le, ce, Y, se, Ae), Ze.push(me)), $e(!1);
            }
          }
        ),
        /***/
        "./src/index.ts": (
          /*!**********************!*\
            !*** ./src/index.ts ***!
            \**********************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CAP: () => (
                /* reexport safe */
                y.CAP
              ),
              /* harmony export */
              CC: () => (
                /* reexport safe */
                s.CC
              ),
              /* harmony export */
              CONTEXTS_PER_VIEWPORT: () => (
                /* reexport safe */
                w.CONTEXTS_PER_VIEWPORT
              ),
              /* harmony export */
              Color: () => (
                /* reexport safe */
                s.Color
              ),
              /* harmony export */
              CustomLinear: () => (
                /* reexport safe */
                n.CustomLinear
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                A.Cylinder
              ),
              /* harmony export */
              GLDraw: () => (
                /* reexport safe */
                y.GLDraw
              ),
              /* harmony export */
              GLModel: () => (
                /* reexport safe */
                v.GLModel
              ),
              /* harmony export */
              GLShape: () => (
                /* reexport safe */
                L.GLShape
              ),
              /* harmony export */
              GLViewer: () => (
                /* reexport safe */
                w.GLViewer
              ),
              /* harmony export */
              GLVolumetricRender: () => (
                /* reexport safe */
                C.GLVolumetricRender
              ),
              /* harmony export */
              Gradient: () => (
                /* reexport safe */
                n.Gradient
              ),
              /* harmony export */
              GradientType: () => (
                /* reexport safe */
                n.GradientType
              ),
              /* harmony export */
              Label: () => (
                /* reexport safe */
                h.Label
              ),
              /* harmony export */
              LabelCount: () => (
                /* reexport safe */
                h.LabelCount
              ),
              /* harmony export */
              MarchingCube: () => (
                /* reexport safe */
                k.MarchingCube
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* reexport safe */
                k.MarchingCubeInitializer
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                _.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                _.Matrix4
              ),
              /* harmony export */
              Parsers: () => (
                /* reexport safe */
                g.Parsers
              ),
              /* harmony export */
              PausableTimer: () => (
                /* reexport safe */
                x.PausableTimer
              ),
              /* harmony export */
              PointGrid: () => (
                /* reexport safe */
                k.PointGrid
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* reexport safe */
                k.ProteinSurface
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                _.Quaternion
              ),
              /* harmony export */
              ROYGB: () => (
                /* reexport safe */
                n.ROYGB
              ),
              /* harmony export */
              RWB: () => (
                /* reexport safe */
                n.RWB
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                _.Ray
              ),
              /* harmony export */
              Sinebow: () => (
                /* reexport safe */
                n.Sinebow
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                A.Sphere
              ),
              /* harmony export */
              SurfaceType: () => (
                /* reexport safe */
                k.SurfaceType
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                A.Triangle
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                _.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                _.Vector3
              ),
              /* harmony export */
              VolumeData: () => (
                /* reexport safe */
                $.VolumeData
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* reexport safe */
                x.adjustVolumeStyle
              ),
              /* harmony export */
              applyPartialCharges: () => (
                /* reexport safe */
                b.applyPartialCharges
              ),
              /* harmony export */
              autoinit: () => (
                /* reexport safe */
                M.autoinit
              ),
              /* harmony export */
              autoload: () => (
                /* reexport safe */
                M.autoload
              ),
              /* harmony export */
              base64ToArray: () => (
                /* reexport safe */
                x.base64ToArray
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                g.bondLength
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* reexport safe */
                s.builtinColorSchemes
              ),
              /* harmony export */
              builtinGradients: () => (
                /* reexport safe */
                n.builtinGradients
              ),
              /* harmony export */
              chains: () => (
                /* reexport safe */
                s.chains
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                _.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                _.conversionMatrix3
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* reexport safe */
                w.createStereoViewer
              ),
              /* harmony export */
              createViewer: () => (
                /* reexport safe */
                w.createViewer
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* reexport safe */
                w.createViewerGrid
              ),
              /* harmony export */
              deepCopy: () => (
                /* reexport safe */
                x.deepCopy
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                _.degToRad
              ),
              /* harmony export */
              download: () => (
                /* reexport safe */
                x.download
              ),
              /* harmony export */
              drawCartoon: () => (
                /* reexport safe */
                o.drawCartoon
              ),
              /* harmony export */
              elementColors: () => (
                /* reexport safe */
                s.elementColors
              ),
              /* harmony export */
              extend: () => (
                /* reexport safe */
                x.extend
              ),
              /* harmony export */
              get: () => (
                /* reexport safe */
                x.get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* reexport safe */
                x.getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* reexport safe */
                x.getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* reexport safe */
                x.getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* reexport safe */
                x.getExtent
              ),
              /* harmony export */
              getGradient: () => (
                /* reexport safe */
                n.getGradient
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* reexport safe */
                x.getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* reexport safe */
                x.getbin
              ),
              /* harmony export */
              htmlColors: () => (
                /* reexport safe */
                s.htmlColors
              ),
              /* harmony export */
              inflateString: () => (
                /* reexport safe */
                x.inflateString
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* reexport safe */
                x.isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* reexport safe */
                x.isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* reexport safe */
                x.makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* reexport safe */
                x.mergeGeos
              ),
              /* harmony export */
              normalizeValue: () => (
                /* reexport safe */
                n.normalizeValue
              ),
              /* harmony export */
              partialCharges: () => (
                /* reexport safe */
                b.partialCharges
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* reexport safe */
                M.processing_autoinit
              ),
              /* harmony export */
              residues: () => (
                /* reexport safe */
                s.residues
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                g.setBondLength
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* reexport safe */
                k.setSyncSurface
              ),
              /* harmony export */
              specStringToObject: () => (
                /* reexport safe */
                x.specStringToObject
              ),
              /* harmony export */
              splitMesh: () => (
                /* reexport safe */
                L.splitMesh
              ),
              /* harmony export */
              ssColors: () => (
                /* reexport safe */
                s.ssColors
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* reexport safe */
                o.subdivide_spline
              ),
              /* harmony export */
              syncSurface: () => (
                /* reexport safe */
                k.syncSurface
              ),
              /* harmony export */
              viewers: () => (
                /* reexport safe */
                M.viewers
              )
              /* harmony export */
            });
            var n = r(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), s = r(
              /*! ./colors */
              "./src/colors.ts"
            ), h = r(
              /*! ./Label */
              "./src/Label.ts"
            ), b = r(
              /*! ./partialCharges */
              "./src/partialCharges.ts"
            ), g = r(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), _ = r(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), A = r(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), x = r(
              /*! ./utilities */
              "./src/utilities.ts"
            ), k = r(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), $ = r(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), C = r(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), L = r(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), y = r(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), o = r(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), v = r(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), w = r(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), M = r(
              /*! ./autoload */
              "./src/autoload.ts"
            );
            r(
              /*! ./specs */
              "./src/specs.ts"
            ), window && (window.$3Dmol = e);
          }
        ),
        /***/
        "./src/parsers/BCIF.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/BCIF.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              BCIF: () => (
                /* binding */
                L
              )
              /* harmony export */
            });
            var n = r(
              /*! ../utilities */
              "./src/utilities.ts"
            ), s = r(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), h = r(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), b = r(
              /*! ./cifutils/category */
              "./src/parsers/cifutils/category.ts"
            ), g = r(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), _ = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), A = r(
              /*! ./utils/isEmpty */
              "./src/parsers/utils/isEmpty.ts"
            ), x = r(
              /*! ./src/vendor/mmtf.js */
              "./src/vendor/mmtf.js"
            );
            class k {
              constructor(o) {
                if (this.C = {}, o) {
                  let v = o.getField("comp_id"), w = o.getField("atom_id_1"), M = o.getField("atom_id_2"), F = o.getField("value_order");
                  for (let m = 0; m < v.length; m++) {
                    let E = v[m], z = w[m], O = M[m], R = F[m], B = 1;
                    R == "doub" ? B = 2 : R == "trip" && (B = 3), this.C[E] == null && (this.C[E] = {}), this.C[E][z] == null && (this.C[E][z] = {}), this.C[E][O] == null && (this.C[E][O] = {}), this.C[E][z][O] = B, this.C[E][O][z] = B;
                  }
                }
              }
              //returns bond order, zero if not connected
              order(o, v, w) {
                return this.C[o] !== void 0 && this.C[o][v] !== void 0 && this.C[o][v][w] !== void 0 ? this.C[o][v][w] : 0;
              }
            }
            class $ {
              constructor(o) {
                if (this.C = [], o) {
                  let v = o.getField("conn_type_id"), w = o.getField("ptnr1_label_asym_id"), M = o.getField("ptnr1_label_seq_id"), F = o.getField("ptnr1_label_comp_id"), m = o.getField("ptnr1_label_atom_id"), E = o.getField("ptnr2_label_asym_id"), z = o.getField("ptnr2_label_seq_id"), O = o.getField("ptnr2_label_comp_id"), R = o.getField("ptnr2_label_atom_id"), B = o.getField("pdbx_value_order");
                  for (let P = 0; P < v.length; P++)
                    if (v[P] == "disulf" || v[P] == "covale") {
                      let W = B ? B[P] == "" ? 1 : parseInt(B[P]) : 1;
                      this.C.push([[w[P], M[P], F[P], m[P]], [E[P], z[P], O[P], R[P]], W]);
                    }
                }
              }
            }
            class C {
              constructor() {
                this.R = {};
              }
              add(o) {
                this.R[o.lchain] == null && (this.R[o.lchain] = {}), this.R[o.lchain][o.lresi] == null && (this.R[o.lchain][o.lresi] = {}), this.R[o.lchain][o.lresi][o.lresn] == null && (this.R[o.lchain][o.lresi][o.lresn] = []), this.R[o.lchain][o.lresi][o.lresn].push(o), this.R[o.lchain][o.lresi][o.lresn][o.atom] = o;
              }
              geta([o, v, w, M]) {
                if (this.R[o] !== void 0 && this.R[o][v] !== void 0 && this.R[o][v][w] !== void 0)
                  return this.R[o][v][w][M];
              }
              setBonds(o, v) {
                for (let w in this.R)
                  for (let M in this.R[w])
                    for (let F in this.R[w][M]) {
                      let m = this.R[w][M][F];
                      for (let E = 0; E < m.length; E++)
                        for (let z = E + 1; z < m.length; z++) {
                          let O = m[E], R = m[z], B = o.order(F, O.atom, R.atom);
                          B > 0 && (O.bonds.push(R.index), R.bonds.push(O.index), O.bondOrder.push(B), R.bondOrder.push(B));
                        }
                    }
                for (let w of v.C) {
                  let M = w[0], F = w[1], m = w[2], E = this.geta(M), z = this.geta(F);
                  E != null && z != null && (E.bonds.push(z.index), z.bonds.push(E.index), E.bondOrder.push(m), z.bondOrder.push(m));
                }
              }
            }
            function L(y, o) {
              var v = !o.keepH, w = o.altLoc ? o.altLoc : "A", M = !o.noComputeSecondaryStructure;
              const F = !o.doAssembly, m = o.assignBonds === void 0 ? !0 : o.assignBonds;
              if (typeof y == "string")
                try {
                  y = (0, n.base64ToArray)(y);
                } catch {
                  y = new TextEncoder().encode(y);
                }
              else
                y = new Uint8Array(y);
              var E = x.decodeMsgpack(y);
              E == 31 && (y = (0, n.inflateString)(y, !1), E = x.decodeMsgpack(y));
              var z = [], O = z.modelData = [], R = E.dataBlocks.length;
              if (R == 0)
                return z;
              o.multimodel || (R = 1);
              for (let B = 0; B < R; B++) {
                let P = z.length;
                const W = [];
                O.push({ symmetries: [] }), z.push([]);
                const U = E.dataBlocks[B], V = /* @__PURE__ */ Object.create(null);
                for (const Ke of U.categories)
                  V[Ke.name.substr(1)] = (0, b.Category)(Ke);
                let K = {}, q = V.struct_conf;
                if (q) {
                  let Ke = q.getField("conf_type_id"), Pe = q.getField("beg_label_asym_id"), it = q.getField("beg_label_seq_id"), nt = q.getField("end_label_seq_id");
                  for (let ne = 0; ne < Ke.length; ne++)
                    if (Ke[ne].startsWith("H")) {
                      let se = Pe[ne], ue = it[ne], $e = nt[ne];
                      se in K || (K[se] = {}), K[se][ue] = "h1";
                      for (let Ae = ue + 1; Ae < $e; Ae++)
                        K[se][Ae] = "h";
                      K[se][$e] = "h2";
                    }
                }
                let H = V.struct_sheet_range;
                if (H) {
                  let Ke = H.getField("id"), Pe = H.getField("beg_label_asym_id"), it = H.getField("beg_label_seq_id"), nt = H.getField("end_label_seq_id");
                  for (let ne = 0; ne < Ke.length; ne++) {
                    let se = Pe[ne], ue = it[ne], $e = nt[ne];
                    se in K || (K[se] = {}), K[se][ue] = "s1";
                    for (let Ae = ue + 1; Ae < $e; Ae++)
                      K[se][Ae] = "s";
                    K[se][$e] = "s2";
                  }
                }
                let j = V.pdbx_struct_oper_list, Q = j.getField("id");
                if (Q && !F) {
                  let Ke = j.getField("matrix[1][1]"), Pe = j.getField("matrix[1][2]"), it = j.getField("matrix[1][3]"), nt = j.getField("matrix[2][1]"), ne = j.getField("matrix[2][2]"), se = j.getField("matrix[2][3]"), ue = j.getField("matrix[3][1]"), $e = j.getField("matrix[3][2]"), Ae = j.getField("matrix[3][3]"), je = j.getField("vector[1]"), ze = j.getField("vector[2]"), re = j.getField("vector[3]");
                  for (let xe = 0; xe < Q.length; xe++) {
                    const Le = new _.Matrix4(Ke[xe], Pe[xe], it[xe], je[xe], nt[xe], ne[xe], se[xe], ze[xe], ue[xe], $e[xe], Ae[xe], re[xe]);
                    O[O.length - 1].symmetries.push(Le);
                  }
                }
                let J = new k(V.chem_comp_bond), Y = new C(), ee = new $(V.struct_conn), fe = V.atom_site, me = fe.rowCount, he = fe.getField("group_PDB"), we = fe.getField("Cartn_x"), ye = fe.getField("Cartn_y"), ve = fe.getField("Cartn_z"), ce = fe.getField("auth_asym_id"), be = fe.getField("label_asym_id"), le = fe.getField("auth_seq_id"), Se = fe.getField("label_seq_id"), ge = fe.getField("auth_comp_id"), de = fe.getField("label_comp_id"), De = fe.getField("auth_atom_id"), Be = fe.getField("label_atom_id"), Ve = fe.getField("type_symbol"), qe = fe.getField("B_iso_or_equiv"), Ze = fe.getField("id"), Ye = fe.getField("label_alt_id"), Xe = fe.getField("pdbx_PDB_model_num"), Ge = Xe ? Xe[0] : 0;
                for (let Ke = 0; Ke < me; Ke++) {
                  if (he !== void 0 && he[Ke] === "TER")
                    continue;
                  if (Xe && Xe[Ke] != Ge)
                    if (Ge = Xe[Ke], o.multimodel)
                      o.onemol || (z.push([]), O.push(O[O.length - 1]), Ge = Xe[Ke], Y.setBonds(J, ee), Y = new C());
                    else
                      break;
                  const Pe = {};
                  Pe.x = we[Ke], Pe.y = ye[Ke], Pe.z = ve[Ke], Pe.chain = ce ? ce[Ke] : be ? be[Ke] : void 0, Pe.lchain = be ? be[Ke] : void 0, Pe.resi = le ? le[Ke] : Se ? Se[Ke] : void 0, Pe.lresi = Se ? Se[Ke] : void 0, Pe.resn = ge ? ge[Ke].trim() : de ? de[Ke].trim() : void 0, Pe.lresn = de ? de[Ke].trim() : void 0, Pe.atom = De ? De[Ke].replace(/"/gm, "") : Be ? Be[Ke].replace(/"/gm, "") : void 0, Pe.icode = Ye ? Ye[Ke] : void 0, Pe.altLoc = Pe.icode, Pe.hetflag = !he || he[Ke] === "HETA" || he[Ke] === "HETATM";
                  let it = "X";
                  Ve && (it = Ve[Ke].replace(/\(?\+?\d+.*/, "")), Pe.elem = it[0].toUpperCase() + it.substring(1, 2).toLowerCase(), qe && (Pe.b = qe[Ke]), !(v && Pe.elem == "H") && (Pe.altLoc != "" && Pe.altLoc != w && w != "*" || (Pe.bonds = [], Pe.ss = "c", Pe.serial = Ze[Ke], Pe.model = Ge, Pe.bondOrder = [], Pe.properties = {}, Pe.index = z[z.length - 1].length, W[Pe.serial] = [z.length, Pe.index], z[z.length - 1].push(Pe), Y.add(Pe)));
                }
                if (Y.setBonds(J, ee), !(0, A.isEmpty)(K))
                  for (let Ke = P; Ke < z.length; Ke++) {
                    let Pe = z[Ke];
                    for (let it = 0; it < Pe.length; it++) {
                      const nt = Pe[it];
                      if (nt !== void 0 && nt.lchain in K && nt.lresi in K[nt.lchain]) {
                        const ne = K[nt.lchain][nt.lresi];
                        nt.ss = ne[0], ne.length > 1 && (ne[1] == "1" ? nt.ssbegin = !0 : ne[1] == "2" && (nt.ssend = !0));
                      }
                    }
                  }
                o.multimodel && B < R - 1 && (o.onemol || (z.push([]), O.push({ symmetries: [] })));
              }
              for (let B = 0; B < z.length; B++)
                m && !(o.duplicateAssemblyAtoms && !o.dontConnectDuplicatedAtoms) && (0, g.assignPDBBonds)(z[B], o), M && (0, s.computeSecondaryStructure)(z[B], o.hbondCutoff), (0, h.processSymmetries)(O[B].symmetries, z[B], o, O[B].cryst), o.duplicateAssemblyAtoms && !o.dontConnectDuplicatedAtoms && m && (0, g.assignPDBBonds)(z[B], o);
              return z;
            }
          }
        ),
        /***/
        "./src/parsers/CDJSON.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/CDJSON.ts ***!
            \*******************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CDJSON: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s, h) {
              var b = [[]];
              typeof s == "string" && (s = JSON.parse(s));
              for (var g = s.m, _ = g[0].a, A = g[0].b, x = g[0].s, k = h !== void 0 && h.parseStyle !== void 0 ? h.parseStyle : x !== void 0, $ = b[b.length - 1].length, C = 0; C < _.length; C++) {
                var L = _[C], y = {};
                y.id = L.i, y.x = L.x, y.y = L.y, y.z = L.z || 0, y.bonds = [], y.bondOrder = [];
                var o = L.l || "C";
                y.elem = o[0].toUpperCase() + o.substring(1).toLowerCase(), y.serial = b[b.length - 1].length, k && (y.style = x[L.s || 0]), b[b.length - 1].push(y);
              }
              for (let v = 0; v < A.length; v++) {
                let w = A[v], M = w.b + $, F = w.e + $, m = w.o || 1, E = b[b.length - 1][M], z = b[b.length - 1][F];
                E.bonds.push(F), E.bondOrder.push(m), z.bonds.push(M), z.bondOrder.push(m);
              }
              return b;
            }
          }
        ),
        /***/
        "./src/parsers/CIF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/CIF.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CIF: () => (
                /* binding */
                _
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), s = r(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), h = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), b = r(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            );
            const g = function(A, x, k, $) {
              return new h.Vector3(x, k, $).applyMatrix3(A);
            };
            function _(A, x = {}) {
              const k = [], $ = !x.doAssembly, C = k.modelData = [], L = x.assignBonds === void 0 ? !0 : x.assignBonds;
              function y(m, E) {
                const z = [];
                let O = 0, R = 0;
                for (; R < m.length; ) {
                  for (; m.substring(R, R + E.length) !== E && R < m.length; )
                    if (m[R] === "'") {
                      for (R++; R < m.length && m[R] !== "'"; )
                        R++;
                      for (; m.substring(R, R + E.length) !== E && R < m.length; )
                        R++;
                    } else if (m[R] === '"') {
                      for (R++; R < m.length && m[R] !== '"'; )
                        R++;
                      R++;
                    } else
                      R++;
                  z.push(m.substring(O, R)), O = R = R + E.length;
                }
                return z;
              }
              const o = A.split(/\r?\n|\r/), v = [];
              let w = !1;
              for (let m = 0; m < o.length; m++) {
                var M = o[m].split("#")[0];
                if (w ? M[0] === ";" && (w = !1) : M[0] === ";" && (w = !0), w || M !== "") {
                  if (!w && (M = M.trim(), M[0] === "_")) {
                    const E = M.split(/\s/)[0].indexOf(".");
                    if (E > -1) {
                      let z = M.split("");
                      z[E] = "_", M = z.join(""), M = M.substring(0, E) + "_" + M.substring(E + 1);
                    }
                  }
                  v.push(M);
                }
              }
              let F = 0;
              for (; F < v.length; ) {
                for (; !v[F].startsWith("data_") || v[F] === "data_global"; )
                  F++;
                F++;
                const m = {};
                for (; F < v.length && !v[F].startsWith("data_"); )
                  if (v[F][0] === void 0)
                    F++;
                  else if (v[F][0] === "_") {
                    const R = v[F].split(/\s/)[0].toLowerCase(), B = m[R] = m[R] || [], P = v[F].substring(v[F].indexOf(R) + R.length);
                    if (P === "")
                      if (F++, v[F][0] === ";") {
                        let W = v[F].substring(1);
                        for (F++; v[F] !== ";"; )
                          W = W + `
` + v[F], F++;
                        B.push(W);
                      } else
                        B.push(v[F]);
                    else
                      B.push(P.trim());
                    F++;
                  } else if (v[F].substring(0, 5) === "loop_") {
                    F++;
                    const R = [];
                    for (; v[F] === "" || v[F][0] === "_"; ) {
                      if (v[F] !== "") {
                        let P = v[F].split(/\s/)[0].toLowerCase(), W = m[P] = m[P] || [];
                        R.push(W);
                      }
                      F++;
                    }
                    let B = 0;
                    for (; F < v.length && v[F][0] !== "_" && !v[F].startsWith("loop_") && !v[F].startsWith("data_"); ) {
                      let P = y(v[F], " ");
                      for (let W = 0; W < P.length; W++)
                        P[W] !== "" && (R[B].push(P[W]), B = (B + 1) % R.length);
                      F++;
                    }
                  } else
                    F++;
                C.push({ symmetries: [] }), k.push([]);
                const E = m._atom_site_id !== void 0 ? m._atom_site_id.length : m._atom_site_label.length;
                let z;
                if (m._cell_length_a !== void 0) {
                  const R = parseFloat(m._cell_length_a), B = parseFloat(m._cell_length_b), P = parseFloat(m._cell_length_c), W = parseFloat(m._cell_angle_alpha) || 90, U = parseFloat(m._cell_angle_beta) || 90, V = parseFloat(m._cell_angle_gamma) || 90;
                  z = (0, h.conversionMatrix3)(R, B, P, W, U, V), C[C.length - 1].cryst = {
                    a: R,
                    b: B,
                    c: P,
                    alpha: W,
                    beta: U,
                    gamma: V
                  };
                }
                for (let R = 0; R < E; R++) {
                  if (m._atom_site_group_pdb !== void 0 && m._atom_site_group_pdb[R] === "TER")
                    continue;
                  const B = {};
                  if (m._atom_site_cartn_x !== void 0)
                    B.x = parseFloat(m._atom_site_cartn_x[R]), B.y = parseFloat(m._atom_site_cartn_y[R]), B.z = parseFloat(m._atom_site_cartn_z[R]);
                  else {
                    const W = g(z, parseFloat(m._atom_site_fract_x[R]), parseFloat(m._atom_site_fract_y[R]), parseFloat(m._atom_site_fract_z[R]));
                    B.x = W.x, B.y = W.y, B.z = W.z;
                  }
                  B.chain = m._atom_site_auth_asym_id ? m._atom_site_auth_asym_id[R] : m._atom_site_label_asym_id ? m._atom_site_label_asym_id[R] : void 0, B.resi = m._atom_site_auth_seq_id ? parseInt(m._atom_site_auth_seq_id[R]) : m._atom_site_label_seq_id ? m._atom_site_label_seq_id[R] : void 0, B.resn = m._atom_site_auth_comp_id ? m._atom_site_auth_comp_id[R].trim() : m._atom_site_label_comp_id ? m._atom_site_label_comp_id[R].trim() : void 0, B.atom = m._atom_site_auth_atom_id ? m._atom_site_auth_atom_id[R].replace(/"/gm, "") : m._atom_site_label_atom_id ? m._atom_site_label_atom_id[R].replace(/"/gm, "") : void 0, B.hetflag = !m._atom_site_group_pdb || m._atom_site_group_pdb[R] === "HETA" || m._atom_site_group_pdb[R] === "HETATM", m._atom_site_b_iso_or_equiv && (B.b = parseFloat(m._atom_site_b_iso_or_equiv[R]));
                  let P = "X";
                  m._atom_site_type_symbol ? P = m._atom_site_type_symbol[R].replace(/\(?\+?\d+.*/, "") : m._atom_site_label && (P = m._atom_site_label[R].split("_")[0].replace(/\(?\d+.*/, "")), B.elem = P[0].toUpperCase() + P.substring(1, 2).toLowerCase(), B.bonds = [], B.ss = "c", B.serial = R, B.bondOrder = [], B.properties = {}, k[k.length - 1].push(B);
                }
                if (m._pdbx_struct_oper_list_id !== void 0 && !$)
                  for (let R = 0; R < m._pdbx_struct_oper_list_id.length; R++) {
                    const B = parseFloat(m["_pdbx_struct_oper_list_matrix[1][1]"][R]), P = parseFloat(m["_pdbx_struct_oper_list_matrix[1][2]"][R]), W = parseFloat(m["_pdbx_struct_oper_list_matrix[1][3]"][R]), U = parseFloat(m["_pdbx_struct_oper_list_vector[1]"][R]), V = parseFloat(m["_pdbx_struct_oper_list_matrix[2][1]"][R]), K = parseFloat(m["_pdbx_struct_oper_list_matrix[2][2]"][R]), q = parseFloat(m["_pdbx_struct_oper_list_matrix[2][3]"][R]), H = parseFloat(m["_pdbx_struct_oper_list_vector[2]"][R]), j = parseFloat(m["_pdbx_struct_oper_list_matrix[3][1]"][R]), Q = parseFloat(m["_pdbx_struct_oper_list_matrix[3][2]"][R]), J = parseFloat(m["_pdbx_struct_oper_list_matrix[3][3]"][R]), Y = parseFloat(m["_pdbx_struct_oper_list_vector[3]"][R]), ee = new h.Matrix4(B, P, W, U, V, K, q, H, j, Q, J, Y);
                    C[C.length - 1].symmetries.push(ee);
                  }
                const O = function(R) {
                  const B = R.match("-");
                  R = R.replace(/[-xyz]/g, "");
                  const P = R.split("/");
                  let W, U;
                  return P[1] === void 0 ? U = 1 : U = parseInt(P[1]), P[0] === "" ? W = 1 : W = parseInt(P[0]), W / U * (B ? -1 : 1);
                };
                if (m._symmetry_equiv_pos_as_xyz !== void 0 && !$)
                  for (let R = 0; R < m._symmetry_equiv_pos_as_xyz.length; R++) {
                    const P = m._symmetry_equiv_pos_as_xyz[R].replace(/["' ]/g, "").split(",").map(function(K) {
                      return K.replace(/-/g, "+-");
                    });
                    let W = new h.Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
                    for (let K = 0; K < 3; K++) {
                      const q = P[K].split("+");
                      for (let H = 0; H < q.length; H++) {
                        const j = q[H];
                        if (j === "")
                          continue;
                        const Q = O(j);
                        j.match("x") ? W.elements[K + 0] = Q : j.match("y") ? W.elements[K + 4] = Q : j.match("z") ? W.elements[K + 8] = Q : W.elements[K + 12] = Q;
                      }
                    }
                    const U = z.getMatrix4(), V = new h.Matrix4().getInverse(U, !0);
                    W = new h.Matrix4().multiplyMatrices(W, V), W = new h.Matrix4().multiplyMatrices(U, W), C[C.length - 1].symmetries.push(W);
                  }
              }
              for (let m = 0; m < k.length; m++)
                L && !(x.duplicateAssemblyAtoms && !x.dontConnectDuplicatedAtoms) && (0, b.assignPDBBonds)(k[m], x), (0, n.computeSecondaryStructure)(k[m], x.hbondCutoff), (0, s.processSymmetries)(C[m].symmetries, k[m], x, C[m].cryst), x.duplicateAssemblyAtoms && !x.dontConnectDuplicatedAtoms && L && (0, b.assignPDBBonds)(k[m], x);
              return k;
            }
          }
        ),
        /***/
        "./src/parsers/CUBE.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/CUBE.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              CUBE: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), h = r(
              /*! ./utils/anumToSymbol */
              "./src/parsers/utils/anumToSymbol.ts"
            );
            function b(g, _) {
              _ = _ || {};
              const A = [[]];
              let x = g.split(/\r?\n/);
              const k = _.assignBonds === void 0 ? !0 : _.assignBonds;
              if (x.length < 6)
                return A;
              let $ = x[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              const C = Math.abs(parseFloat($[0]));
              let L = {
                origin: void 0,
                size: void 0,
                unit: void 0,
                matrix4: void 0,
                matrix: void 0
              };
              const y = L.origin = new n.Vector3(parseFloat($[1]), parseFloat($[2]), parseFloat($[3]));
              $ = x[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), $ = x[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              const o = $[0] > 0 ? 0.529177 : 1;
              y.multiplyScalar(o);
              const v = Math.abs($[0]), w = new n.Vector3(parseFloat($[1]), parseFloat($[2]), parseFloat($[3])).multiplyScalar(o);
              $ = x[4].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              const M = Math.abs($[0]), F = new n.Vector3(parseFloat($[1]), parseFloat($[2]), parseFloat($[3])).multiplyScalar(o);
              $ = x[5].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              const m = Math.abs($[0]), E = new n.Vector3(parseFloat($[1]), parseFloat($[2]), parseFloat($[3])).multiplyScalar(o);
              if (L.size = { x: v, y: M, z: m }, L.unit = new n.Vector3(w.x, F.y, E.z), w.y != 0 || w.z != 0 || F.x != 0 || F.z != 0 || E.x != 0 || E.y != 0) {
                L.matrix4 = new n.Matrix4(w.x, F.x, E.x, 0, w.y, F.y, E.y, 0, w.z, F.z, E.z, 0, 0, 0, 0, 1);
                let U = new n.Matrix4().makeTranslation(y.x, y.y, y.z);
                L.matrix4 = L.matrix4.multiplyMatrices(U, L.matrix4), L.matrix = L.matrix4.matrix3FromTopLeft(), L.origin = new n.Vector3(0, 0, 0), L.unit = new n.Vector3(1, 1, 1);
              }
              A.modelData = [{ cryst: L }], x = x.splice(6, C);
              for (var z = A[A.length - 1].length, O = z + x.length, R = z; R < O; ++R) {
                var B = {};
                B.serial = R;
                var P = x[R - z], W = P.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                B.elem = h.anumToSymbol[W[0]], B.x = parseFloat(W[2]) * o, B.y = parseFloat(W[3]) * o, B.z = parseFloat(W[4]) * o, B.hetflag = !0, B.bonds = [], B.bondOrder = [], B.properties = {}, A[A.length - 1].push(B);
              }
              if (k)
                for (let U = 0; U < A.length; U++)
                  (0, s.assignBonds)(A[U], _);
              return A;
            }
          }
        ),
        /***/
        "./src/parsers/GRO.ts": (
          /*!****************************!*\
            !*** ./src/parsers/GRO.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              GRO: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), s = r(
              /*! ./utils/atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            );
            function h(b, g) {
              const _ = [], A = b.split(/\r?\n|\r/);
              for (; A.length > 0; ) {
                const x = parseInt(A[1]);
                if (A.length < 3 || isNaN(x) || x <= 0 || A.length < x + 3)
                  break;
                const $ = [];
                _.push($);
                let C = 2;
                const L = $.length, y = L + x;
                for (let o = L; o < y; o++) {
                  const v = A[C++], w = {};
                  w.serial = o, w.atom = v.slice(10, 15).trim(), w.elem = (0, s.atomNameToElem)(w.atom, !0), w.x = 10 * parseFloat(v.slice(20, 28)), w.y = 10 * parseFloat(v.slice(28, 36)), w.z = 10 * parseFloat(v.slice(36, 44)), w.resi = parseInt(v.slice(0, 5)), w.resn = v.slice(5, 10).trim(), w.bonds = [], w.bondOrder = [], w.properties = {}, v.length > 44 && (w.dx = 10 * parseFloat(v.slice(44, 52)), w.dy = 10 * parseFloat(v.slice(52, 60)), w.dz = 10 * parseFloat(v.slice(60, 68))), $[o] = w;
                }
                if (A.length <= C + 3) {
                  const v = A[C++].trim().split(/\s+/);
                  if (v.length === 3) {
                    for (let w = 0; w < 3; w++)
                      v[w] = (parseFloat(v[w]) * 10).toString();
                    _.box = v;
                  }
                }
                A.splice(0, ++C);
              }
              for (let x = 0; x < _.length; x++)
                (0, n.assignPDBBonds)(_[x], g);
              return _;
            }
          }
        ),
        /***/
        "./src/parsers/LAMMPSTRJ.ts": (
          /*!**********************************!*\
            !*** ./src/parsers/LAMMPSTRJ.ts ***!
            \**********************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              LAMMPSTRJ: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            const s = {
              id: "serial",
              type: "atom",
              element: "elem",
              q: "charge",
              radius: "radius",
              x: "x",
              xu: "x",
              xs: "x",
              xsu: "x",
              y: "y",
              yu: "y",
              ys: "y",
              ysu: "y",
              z: "z",
              zu: "z",
              zs: "z",
              zsu: "z"
            };
            function h(b, g) {
              const _ = [], A = b.split(/\r?\n|\r/);
              let x = 0, k = 0, $ = 0;
              for (; $ < A.length - 9; ) {
                for (var C = $; C < A.length; C++)
                  if (A[C].match(/ITEM: NUMBER OF ATOMS/) && (k = parseInt(A[C + 1])), A[C].match(/ITEM: ATOMS/)) {
                    x = C + 1;
                    break;
                  }
                const L = A[x - 1].replace("ITEM: ATOMS ", "").split(" ");
                _.push([]);
                for (let y = x; y < x + k; y++) {
                  const o = {}, v = {}, w = A[y].split(" ");
                  for (let M = 0; M < w.length; M++) {
                    const F = s[L[M]];
                    F !== void 0 && (F === "serial" ? o[F] = parseInt(w[M]) : F === "x" || F === "y" || F === "z" ? o[F] = parseFloat(w[M]) : F === "charge" || F === "radius" ? v[F] = parseFloat(w[M]) : o[F] = w[M]), o.properties = v, o.bonds = [], o.bondOrder = [];
                  }
                  _[_.length - 1][y - x] = o;
                }
                $ = x + k - 1;
              }
              if (g.assignBonds)
                for (let L = 0; L < _.length; L++)
                  (0, n.assignBonds)(_[L], g);
              return _;
            }
          }
        ),
        /***/
        "./src/parsers/MMTF.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MMTF.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MMTFparser: () => (
                /* binding */
                k
              )
              /* harmony export */
            });
            var n = r(
              /*! ../utilities */
              "./src/utilities.ts"
            ), s = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), h = r(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), b = r(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), g = r(
              /*! ./src/vendor/mmtf.js */
              "./src/vendor/mmtf.js"
            ), _ = function($) {
              return String.fromCharCode.apply(null, $).replace(/\0/g, "");
            }, A = function($) {
              return $ == 0 || $ == 2 || $ == 4 ? "h" : $ == 3 ? "s" : "c";
            };
            let x = /* @__PURE__ */ new Set([
              "D-SACCHARIDE",
              "D-SACCHARIDE 1,4 AND 1,4 LINKING",
              "D-SACCHARIDE 1,4 AND 1,6 LINKING",
              "L-SACCHARIDE",
              "L-SACCHARIDE 1,4 AND 1,4 LINKING",
              "L-SACCHARIDE 1,4 AND 1,6 LINKING",
              "NON-POLYMER",
              "OTHER",
              "PEPTIDE-LIKE",
              "SACCHARIDE"
            ]);
            function k($, C) {
              var L = !C.keepH, y = C.altLoc ? C.altLoc : "A", o = !!C.noSecondaryStructure, v = !C.noComputeSecondaryStructure, w = !C.doAssembly, M = C.assemblyIndex ? C.assemblyIndex : 0;
              typeof $ == "string" ? $ = (0, n.base64ToArray)($) : $ = new Uint8Array($);
              var F = g.decode($), m = [[]], E = m.modelData = [], z = 0, O = 0, R = 0, B = F.secStructList, P = F.bFactorList, W = F.altLocList, U = F.occupancyList, V = F.bondAtomList, K = F.bondOrderList, q = F.numModels;
              if (q == 0)
                return m;
              C.multimodel || (q = 1);
              var H, j, Q, J, Y, ee, fe = [];
              if (!w && F.bioAssemblyList && F.bioAssemblyList.length > 0) {
                var me = F.bioAssemblyList[M].transformList;
                for (H = 0, ee = me.length; H < ee; H++) {
                  var he = new s.Matrix4(me[H].matrix);
                  he.transpose(), fe.push(he);
                }
              }
              var we = null;
              if (F.unitCell) {
                var ye = F.unitCell;
                we = { a: ye[0], b: ye[1], c: ye[2], alpha: ye[3], beta: ye[4], gamma: ye[5] };
              }
              let ve = [];
              F.entityList.forEach((Te) => {
                Te.chainIndexList.forEach((ae) => {
                  ve[ae] = Te.type == "polymer";
                });
              });
              var ce = 0;
              for (Y = 0; Y < q; Y++) {
                var be = F.chainsPerModel[Y], le = m[m.length - 1], Se = [];
                for (E.push({ symmetries: fe, cryst: we }), H = 0; H < be; ++H) {
                  var ge = F.groupsPerChain[z], de = _(F.chainIdList.subarray(z * 4, z * 4 + 4));
                  F.chainNameList && (de = _(F.chainNameList.subarray(z * 4, z * 4 + 4)));
                  var De = O, Be = "";
                  for (j = 0; j < ge; ++j) {
                    var Ve = F.groupList[F.groupTypeList[O]], qe = Ve.atomNameList.length, Ze = 0, Ye = !1, Xe = !1;
                    if (B) {
                      Ze = B[O];
                      var Ge = A(Ze);
                      (O == 0 || Ge != Be) && (Ye = !0), Be = Ge;
                      var Ke = O + 1;
                      (Ke >= B.length || A(B[Ke] != Ge)) && (Xe = !0);
                    }
                    var Pe = F.groupIdList[O], it = Ve.groupName;
                    let Te = Ve.chemCompType;
                    var nt = R;
                    let ae = x.has(Te) || !ve[z];
                    for (Q = 0; Q < qe; ++Q) {
                      var ne = Ve.elementList[Q];
                      if (L && ne == "H") {
                        R += 1;
                        continue;
                      }
                      var se = "";
                      P && (se = P[R]);
                      var ue = "";
                      W && W[R] && (ue = String.fromCharCode(W[R]));
                      var $e = "";
                      if (U && ($e = U[R]), ue != "" && ue != y && y != "*") {
                        R += 1;
                        continue;
                      }
                      var Ae = F.atomIdList[R], je = Ve.atomNameList[Q], ze = 0;
                      Ve.atomChargeList && (ze = Ve.atomChargeList[Q]);
                      var re = F.xCoordList[R], xe = F.yCoordList[R], Le = F.zCoordList[R];
                      Se[R] = le.length, le.push({
                        resn: it,
                        x: re,
                        y: xe,
                        z: Le,
                        elem: ne,
                        hetflag: ae,
                        chain: de,
                        resi: Pe,
                        icode: ue,
                        rescode: Pe + (ue != " " ? "^" + ue : ""),
                        // resi
                        // and
                        // icode
                        serial: Ae,
                        altLoc: ue,
                        index: R,
                        atom: je,
                        bonds: [],
                        ss: A(Ze),
                        ssbegin: Ye,
                        ssend: Xe,
                        bondOrder: [],
                        properties: { charge: ze, occupancy: $e },
                        b: se
                      }), R += 1;
                    }
                    var He = Ve.bondAtomList;
                    for (Q = 0, J = Ve.bondOrderList.length; Q < J; ++Q) {
                      var Me = nt + He[Q * 2], Re = nt + He[Q * 2 + 1], ie = Ve.bondOrderList[Q], We = Se[Me], Qe = Se[Re], G = le[We], Fe = le[Qe];
                      G && Fe && (G.bonds.push(Qe), G.bondOrder.push(ie), Fe.bonds.push(We), Fe.bondOrder.push(ie));
                    }
                    O += 1;
                  }
                  for (O = De, j = 0; j < ge; ++j)
                    O += 1;
                  z += 1;
                }
                if (V)
                  for (let Te = ce, ae = V.length; Te < ae; Te += 2) {
                    let Ee = V[Te], Ie = V[Te + 1], lt = K ? K[Te / 2] : 1;
                    if (Ee >= R) {
                      ce = Te;
                      break;
                    }
                    let st = Se[Ee], at = Se[Ie], gt = le[st], Ot = le[at];
                    gt && Ot && (gt.bonds.push(at), gt.bondOrder.push(lt), Ot.bonds.push(st), Ot.bondOrder.push(lt));
                  }
                C.multimodel && (C.onemol || m.push([]));
              }
              if (!w)
                for (let Te = 0; Te < m.length; Te++)
                  (0, b.processSymmetries)(E[Te].symmetries, m[Te], C, E[Te].cryst);
              return v && !o && (0, h.computeSecondaryStructure)(m, C.hbondCutoff), m;
            }
          }
        ),
        /***/
        "./src/parsers/MOL2.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MOL2.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              MOL2: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            let n = {
              "C.1": "C",
              C1: "C",
              "C.2": "C",
              C2: "C",
              "C.3": "C",
              C3: "C",
              "C.ar": "C",
              Car: "C",
              "C.cat": "C",
              Ccat: "C",
              "H.spc": "H",
              Hspc: "H",
              "H.t3p": "H",
              Ht3p: "H",
              "N.1": "N",
              N1: "N",
              "N.2": "N",
              N2: "N",
              "N.3": "N",
              N3: "N",
              "N.4": "N",
              N4: "N",
              "N.am": "N",
              Nam: "N",
              "N.ar": "N",
              Nar: "N",
              "N.p13": "N",
              Np13: "N",
              "O.2": "O",
              O2: "O",
              "O.3": "O",
              O3: "O",
              "O.co2": "O",
              Oco2: "O",
              "O.spc": "O",
              Ospc: "O",
              "O.t3p": "O",
              Ot3p: "O",
              "P.3": "P",
              P3: "P",
              "S.2": "S",
              S2: "S",
              "S.3": "S",
              S3: "S",
              "S.o": "S",
              So: "S",
              "S.o2": "S",
              So2: "S"
            };
            function s(h, b) {
              var g = [[]], _ = !1;
              typeof b.keepH < "u" && (_ = !b.keepH);
              var A = h.search(/@<TRIPOS>MOLECULE/), x = h.search(/@<TRIPOS>ATOM/);
              if (A == -1 || x == -1)
                return g;
              for (var k = h.substring(A).split(/\r?\n|\r/); k.length > 0; ) {
                var $ = [], C = k[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), L = parseInt(C[0]), y = 0;
                C.length > 1 && (y = parseInt(C[1]));
                var o = 4, v;
                for (v = 3; v < k.length; v++)
                  if (k[v] == "@<TRIPOS>ATOM") {
                    o = v + 1;
                    break;
                  }
                var w = g[g.length - 1].length, M = w + L, F;
                for (v = w; v < M; v++) {
                  F = k[o++], C = F.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  var m = {}, E = C[5];
                  if (n[E] !== void 0 ? E = n[E] : (E = E.split(".")[0], E = E[0].toUpperCase() + E.substring(1).toLowerCase()), m.atom = C[1], m.elem = E, !(m.elem == "H" && _)) {
                    var z = g[g.length - 1].length, O = parseInt(C[0]);
                    m.serial = O, m.x = parseFloat(C[2]), m.y = parseFloat(C[3]), m.z = parseFloat(C[4]), m.atom = C[5];
                    var R = parseFloat(C[8]);
                    m.index = z, m.bonds = [], m.bondOrder = [], m.properties = {
                      charge: R,
                      partialCharge: R
                    }, $[O] = z, g[g.length - 1].push(m);
                  }
                }
                for (var B = !1; o < k.length; )
                  if (k[o++] == "@<TRIPOS>BOND") {
                    B = !0;
                    break;
                  }
                if (B && y)
                  for (v = 0; v < y; v++) {
                    F = k[o++], C = F.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                    var P = parseInt(C[1]), W = g[g.length - 1][$[P]], U = parseInt(C[2]), V = g[g.length - 1][$[U]], K = parseInt(C[3]);
                    isNaN(K) && (K = 1), W !== void 0 && V !== void 0 && (W.bonds.push($[U]), W.bondOrder.push(K), V.bonds.push($[P]), V.bondOrder.push(K));
                  }
                if (b.multimodel) {
                  b.onemol || g.push([]), k.splice(0, o), h = k.join(`
`);
                  continue;
                } else
                  break;
              }
              return g;
            }
          }
        ),
        /***/
        "./src/parsers/PDB.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PDB.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              PDB: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/getSinglePDB */
              "./src/parsers/utils/getSinglePDB.ts"
            );
            function s(h, b) {
              b = b || {};
              var g = [], _ = {};
              g.modelData = [];
              for (var A = h.split(/\r?\n|\r/); A.length > 0; ) {
                var x = (0, n.getSinglePDB)(A, b, _), k = x[0], $ = x[1];
                if (A = x[2], k.length != 0) {
                  if (b.multimodel && b.onemol && g.length > 0)
                    for (var C = g[0].length, L = 0; L < k.length; L++) {
                      var y = k[L];
                      y.index = L;
                      for (var o = 0; o < y.bonds.length; o++)
                        y.bonds[o] += C;
                      g[0].push(y);
                    }
                  else
                    g.modelData.push($), g.push(k);
                  if (!b.multimodel)
                    break;
                }
              }
              return g;
            }
          }
        ),
        /***/
        "./src/parsers/PQR.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PQR.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              PQR: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), s = r(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            );
            function h(b, g) {
              var _ = [[]], A = !g.noSecondaryStructure;
              _.modelData = [{ symmetries: [] }];
              var x = [], k = b.split(/\r?\n|\r/), $;
              for (let B = 0; B < k.length; B++) {
                $ = k[B].replace(/^\s*/, "");
                var C = $.substring(0, 6);
                if (C.indexOf("END") == 0)
                  if (g.multimodel) {
                    g.onemol || _.push([]);
                    continue;
                  } else
                    break;
                else if (C == "ATOM  " || C == "HETATM") {
                  var L;
                  let P = parseInt($.substring(6, 11)), W = $.substring(12, 16).replace(/ /g, ""), U = $.substring(17, 20).trim(), V = $.substring(21, 22), K = parseInt($.substring(22, 26));
                  var y = $.substring(30).trim().split(/\s+/), o = parseFloat(y[0]), v = parseFloat(y[1]), w = parseFloat(y[2]), M = parseFloat(y[3]), F = parseFloat(y[4]), m = W[0];
                  W.length > 1 && W[1].toUpperCase() != W[1] && (m = W.substring(0, 2)), $[0] == "H" ? L = !0 : L = !1, x[P] = _[_.length - 1].length, _[_.length - 1].push({
                    resn: U,
                    x: o,
                    y: v,
                    z: w,
                    elem: m,
                    hetflag: L,
                    chain: V,
                    resi: K,
                    serial: P,
                    atom: W,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {
                      charge: M,
                      partialCharge: M,
                      radius: F
                    },
                    pdbline: $
                  });
                } else if (C == "CONECT") {
                  var E = parseInt($.substring(6, 11)), z = _[_.length - 1][x[E]];
                  for (let P = 0; P < 4; P++) {
                    var O = parseInt($.substring([11, 16, 21, 26][P], [11, 16, 21, 26][P] + 5)), R = _[_.length - 1][x[O]];
                    z !== void 0 && R !== void 0 && (z.bonds.push(x[O]), z.bondOrder.push(1));
                  }
                }
              }
              for (let B = 0; B < _.length; B++)
                (0, n.assignPDBBonds)(_[B], g), A && (0, s.computeSecondaryStructure)(_[B], g.hbondCutoff);
              return _;
            }
          }
        ),
        /***/
        "./src/parsers/PRMTOP.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/PRMTOP.ts ***!
            \*******************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              PRMTOP: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s) {
              var h = [], b, g = 0, _ = s.split(/\r?\n|\r/);
              if (_.length > 0 && _[0].includes("VERSION")) {
                var A = _.filter(function(o) {
                  return o.includes("POINTERS") || o.includes("ATOM_NAME") || o.includes("CHARGE") || o.includes("RADII") || o.includes("BONDS_INC_HYDROGEN") || o.includes("BONDS_WITHOUT_HYDROGEN");
                }), x = L("POINTERS");
                if (x == -1)
                  return [];
                var k = y(x), $ = parseInt(_[x + 1].slice(0, k[1]));
                if (isNaN($) || $ <= 0)
                  return [];
                if (x = L("ATOM_NAME"), x == -1)
                  return [];
                k = y(x);
                var C = k[0];
                for (let o = 0; o < $ / k[0]; o++) {
                  o == parseInt($ / k[0]) && (C = $ % k[0]);
                  for (let v = 0; v < C; v++) {
                    let w = {}, M = { charge: "", radii: "" };
                    w.serial = g, w.x = 0, w.y = 0, w.z = 0, w.atom = _[x + 1].slice(k[1] * v, k[1] * (v + 1)).trim(), w.elem = _[x + 1].slice(k[1] * v, k[1] * v + 1).trim(), w.properties = M, w.bonds = [], w.bondOrder = [], h.push(w), g++;
                  }
                  x++;
                }
                if (x = L("CHARGE"), x != -1) {
                  k = y(x), g = 0, C = k[0];
                  for (let o = 0; o < $ / k[0]; o++) {
                    o == parseInt($ / k[0]) && (C = $ % k[0]);
                    for (let v = 0; v < C; v++)
                      h[g].properties.charge = parseFloat(_[x + 1].slice(k[1] * v, k[1] * (v + 1))), g++;
                    x++;
                  }
                }
                if (x = L("RADII"), x != -1) {
                  k = y(x), g = 0, C = k[0];
                  for (let o = 0; o < $ / k[0]; o++) {
                    o == parseInt($ / k[0]) && (C = $ % k[0]);
                    for (let v = 0; v < C; v++)
                      h[g].properties.radii = parseFloat(_[x + 1].slice(k[1] * v, k[1] * (v + 1))), g++;
                    x++;
                  }
                }
                if (x = L("BONDS_WITHOUT_HYDROGEN"), x != -1)
                  for (k = y(x), g = 0, C = k[0], x = x + 1; !_[x].match(/^%FLAG/); ) {
                    _[x + 1].match(/^%FLAG/) && (C = $ % k[0]);
                    for (let o = 0; o < C; o++)
                      g % 3 == 0 ? b = parseInt(_[x].slice(k[1] * o, k[1] * (o + 1)) / 3) : g % 3 == 1 && h[b].bonds.push(parseInt(_[x].slice(k[1] * o, k[1] * (o + 1)) / 3)), g++;
                    x++;
                  }
                if (x = L("BONDS_INC_HYDROGEN"), x != -1)
                  for (k = y(x), g = 0, C = k[0], x = x + 1; !_[x].match(/^%FLAG/); ) {
                    _[x + 1].match(/^%FLAG/) && (C = $ % k[0]);
                    for (let o = 0; o < C; o++)
                      g % 3 == 0 ? b = parseInt(_[x].slice(k[1] * o, k[1] * (o + 1)) / 3) : g % 3 == 1 && h[b].bonds.push(parseInt(_[x].slice(k[1] * o, k[1] * (o + 1)) / 3)), g++;
                    x++;
                  }
              } else
                return [];
              function L(o) {
                var v = _.indexOf(A.filter(function(w) {
                  return w.includes(o);
                })[0]);
                if (Number.isInteger(v) && v > 0) {
                  for (; !_[v].includes("FORMAT"); )
                    v++;
                  return v;
                } else
                  return -1;
              }
              function y(o) {
                var v = _[o].match(/\((\d*)\S*/), w = _[o].match(/[a-zA-Z](\d*)\)\s*/);
                return w == null && (w = _[o].match(/[a-zA-Z](\d*)\.\d*\)\s*/)), [v[1], w[1]];
              }
              return [h];
            }
          }
        ),
        /***/
        "./src/parsers/SDF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/SDF.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              SDF: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = function(b, g) {
              var _ = [[]], A = !1;
              for (typeof g.keepH < "u" && (A = !g.keepH); b.length > 0 && !(b.length < 4); ) {
                var x = parseInt(b[3].substring(0, 3));
                if (isNaN(x) || x <= 0)
                  break;
                var k = parseInt(b[3].substring(3, 6)), $ = 4;
                if (b.length < 4 + x + k)
                  break;
                var C = [], L = _[_.length - 1].length, y = L + x, o, v;
                for (o = L; o < y; o++, $++) {
                  v = b[$];
                  var w = {}, M = v.substring(31, 34).replace(/ /g, "");
                  w.atom = w.elem = M[0].toUpperCase() + M.substring(1).toLowerCase(), (w.elem !== "H" || !A) && (w.serial = o, C[o] = _[_.length - 1].length, w.x = parseFloat(v.substring(0, 10)), w.y = parseFloat(v.substring(10, 20)), w.z = parseFloat(v.substring(20, 30)), w.hetflag = !0, w.bonds = [], w.bondOrder = [], w.properties = {}, w.index = _[_.length - 1].length, _[_.length - 1].push(w));
                }
                for (o = 0; o < k; o++, $++) {
                  v = b[$];
                  var F = C[parseInt(v.substring(0, 3)) - 1 + L], m = C[parseInt(v.substring(3, 6)) - 1 + L], E = parseFloat(v.substring(6));
                  typeof F < "u" && typeof m < "u" && (_[_.length - 1][F].bonds.push(m), _[_.length - 1][F].bondOrder.push(E), _[_.length - 1][m].bonds.push(F), _[_.length - 1][m].bondOrder.push(E));
                }
                if (g.multimodel) {
                  for (g.onemol || _.push([]); b[$] !== "$$$$" && $ < b.length; )
                    $++;
                  b.splice(0, ++$);
                } else
                  break;
              }
              return _;
            }, s = function(b, g) {
              var _ = [[]], A = !1;
              for (typeof g.keepH < "u" && (A = !g.keepH); b.length > 0 && !(b.length < 8 || !b[4].startsWith("M  V30 BEGIN CTAB") || !b[5].startsWith("M  V30 COUNTS") || b[5].length < 14); ) {
                var x = b[5].substring(13).match(/\S+/g);
                if (x.length < 2)
                  break;
                var k = parseInt(x[0]);
                if (isNaN(k) || k <= 0)
                  break;
                var $ = parseInt(x[1]), C = 7;
                if (b.length < 8 + k + $)
                  break;
                var L = [], y = _[_.length - 1].length, o = y + k, v, w;
                for (v = y; v < o; v++, C++) {
                  w = b[C];
                  var M = w.substring(6).match(/\S+/g);
                  if (M.length > 4) {
                    var F = {}, m = M[1].replace(/ /g, "");
                    F.atom = F.elem = m[0].toUpperCase() + m.substring(1).toLowerCase(), (F.elem !== "H" || !A) && (F.serial = v, L[v] = _[_.length - 1].length, F.x = parseFloat(M[2]), F.y = parseFloat(M[3]), F.z = parseFloat(M[4]), F.hetflag = !0, F.bonds = [], F.bondOrder = [], F.properties = {}, F.index = _[_.length - 1].length, _[_.length - 1].push(F));
                  }
                }
                if (b[C] === "M  V30 END ATOM")
                  C++;
                else
                  break;
                if ($ !== 0 && b[C] === "M  V30 BEGIN BOND")
                  C++;
                else
                  break;
                for (v = 0; v < $; v++, C++) {
                  w = b[C];
                  var E = w.substring(6).match(/\S+/g);
                  if (E.length > 3) {
                    var z = L[parseInt(E[2]) - 1 + y], O = L[parseInt(E[3]) - 1 + y], R = parseFloat(E[1]);
                    typeof z < "u" && typeof O < "u" && (_[_.length - 1][z].bonds.push(O), _[_.length - 1][z].bondOrder.push(R), _[_.length - 1][O].bonds.push(z), _[_.length - 1][O].bondOrder.push(R));
                  }
                }
                if (g.multimodel) {
                  for (g.onemol || _.push([]); b[C] !== "$$$$" && C < b.length; )
                    C++;
                  b.splice(0, ++C);
                } else
                  break;
              }
              return _;
            };
            function h(b, g) {
              var _ = "V2000", A = b.split(/\r?\n|\r/);
              return A.length > 3 && A[3].length > 38 && (_ = A[3].substring(34, 39)), _ === "V2000" ? n(A, g) : _ === "V3000" ? s(A, g) : [[""]];
            }
          }
        ),
        /***/
        "./src/parsers/VASP.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/VASP.ts ***!
            \*****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              VASP: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function h(b, g = {}) {
              var _ = [[]], A = {};
              const x = g.assignBonds === void 0 ? !0 : g.assignBonds;
              var k = b.replace(/^\s+/, "").split(/\r?\n/);
              if (k.length < 3)
                return _;
              if (k[1].match(/\d+/))
                A.length = parseFloat(k[1]);
              else
                return console.log("Warning: second line of the vasp structure file must be a number"), _;
              if (A.length < 0)
                return console.log("Warning: Vasp implementation for negative lattice lengths is not yet available"), _;
              A.xVec = new Float32Array(k[2].replace(/^\s+/, "").split(/\s+/)), A.yVec = new Float32Array(k[3].replace(/^\s+/, "").split(/\s+/)), A.zVec = new Float32Array(k[4].replace(/^\s+/, "").split(/\s+/));
              var $ = new n.Matrix3(A.xVec[0], A.xVec[1], A.xVec[2], A.yVec[0], A.yVec[1], A.yVec[2], A.zVec[0], A.zVec[1], A.zVec[2]);
              $.multiplyScalar(A.length), _.modelData = [{ symmetries: [], cryst: { matrix: $ } }];
              var C = k[5].trim().split(/\s+/), L = new Int16Array(k[6].trim().split(/\s+/)), y = k[7].trim(), o = !1;
              if (y.match(/S/) && (o = !0, y = k[8].trim()), y.toLowerCase()[0] == "c")
                y = "cartesian";
              else if (y.toLowerCase()[0] == "d")
                y = "direct";
              else
                return console.log("Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)"), _;
              if (C.length != L.length)
                return console.log("Warning: declaration of atomary species wrong:"), console.log(C), console.log(L), _;
              o ? k.splice(0, 9) : k.splice(0, 8);
              for (var v = 0, w = 0, M = C.length; w < M; w++) {
                for (var F = C[w], m = 0, E = L[w]; m < E; m++) {
                  var z = new Float32Array(k[v + m].trim().split(/\s+/)), O = {};
                  O.elem = F, y == "cartesian" ? (O.x = A.length * z[0], O.y = A.length * z[1], O.z = A.length * z[2]) : (O.x = A.length * (z[0] * A.xVec[0] + z[1] * A.yVec[0] + z[2] * A.zVec[0]), O.y = A.length * (z[0] * A.xVec[1] + z[1] * A.yVec[1] + z[2] * A.zVec[1]), O.z = A.length * (z[0] * A.xVec[2] + z[1] * A.yVec[2] + z[2] * A.zVec[2])), O.bonds = [], O.bondOrder = [], _[0].push(O);
                }
                v += L[w];
              }
              if (x)
                for (let R = 0; R < _.length; R++)
                  (0, s.assignBonds)(_[R], g);
              return _;
            }
          }
        ),
        /***/
        "./src/parsers/XYZ.ts": (
          /*!****************************!*\
            !*** ./src/parsers/XYZ.ts ***!
            \****************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              XYZ: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function h(b, g) {
              g = g || {};
              for (var _ = [[]], A = g.assignBonds === void 0 ? !0 : g.assignBonds, x = b.split(/\r?\n|\r/); x.length > 0 && !(x.length < 3); ) {
                var k = parseInt(x[0]);
                if (isNaN(k) || k <= 0 || x.length < k + 2)
                  break;
                var $ = /Lattice\s*=\s*["\{\}]([^"\{\}]+)["\{\}]\s*/gi, C = $.exec(x[1]);
                if (C != null && C.length > 1) {
                  var L = new Float32Array(C[1].split(/\s+/)), y = new n.Matrix3(L[0], L[3], L[6], L[1], L[4], L[7], L[2], L[5], L[8]);
                  _.modelData = [{ cryst: { matrix: y } }];
                }
                for (var o = 2, v = _[_.length - 1].length, w = v + k, M = v; M < w; M++) {
                  var F = x[o++], m = F.replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), E = {};
                  E.serial = M;
                  var z = m[0];
                  E.atom = E.elem = z[0].toUpperCase() + z.substring(1, 2).toLowerCase(), E.x = parseFloat(m[1]), E.y = parseFloat(m[2]), E.z = parseFloat(m[3]), E.hetflag = !0, E.bonds = [], E.bondOrder = [], E.properties = {}, _[_.length - 1][M] = E, m.length >= 7 && (E.dx = parseFloat(m[4]), E.dy = parseFloat(m[5]), E.dz = parseFloat(m[6]));
                }
                if (g.multimodel)
                  _.push([]), x.splice(0, o);
                else
                  break;
              }
              if (A)
                for (let R = 0; R < _.length; R++)
                  (0, s.assignBonds)(_[R], g);
              if (g.onemol) {
                var O = _;
                _ = [], _.push(O[0]);
                for (let R = 1; R < O.length; R++) {
                  let B = _[0].length;
                  for (let P = 0; P < O[R].length; P++) {
                    let W = O[R][P];
                    for (let U = 0; U < W.bonds.length; U++)
                      W.bonds[U] = W.bonds[U] + B;
                    W.index = _[0].length, W.serial = _[0].length, _[0].push(W);
                  }
                }
              }
              return _;
            }
          }
        ),
        /***/
        "./src/parsers/cifutils/category.ts": (
          /*!******************************************!*\
            !*** ./src/parsers/cifutils/category.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Category: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./decoder */
              "./src/parsers/cifutils/decoder.ts"
            );
            function s(h) {
              const b = /* @__PURE__ */ Object.create(null), g = /* @__PURE__ */ Object.create(null);
              for (const _ of h.columns)
                b[_.name] = _;
              return {
                rowCount: h.rowCount,
                name: h.name.substring(1),
                fieldNames: h.columns.map((_) => _.name),
                getField(_) {
                  const A = b[_];
                  if (A)
                    return g[_] || (g[_] = (0, n.decode)(A.data)), g[_];
                }
              };
            }
          }
        ),
        /***/
        "./src/parsers/cifutils/decoder.ts": (
          /*!*****************************************!*\
            !*** ./src/parsers/cifutils/decoder.ts ***!
            \*****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              decode: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./encoding */
              "./src/parsers/cifutils/encoding.ts"
            );
            const s = new Uint16Array(new Uint8Array([18, 52]).buffer)[0] === 13330;
            function h(B, P) {
              const W = new ArrayBuffer(B.length), U = new Uint8Array(W);
              for (let V = 0, K = B.length; V < K; V += P)
                for (let q = 0; q < P; q++)
                  U[V + P - q - 1] = B[V + q];
              return W;
            }
            function b(B) {
              let P = B.data;
              for (let W = B.encoding.length - 1; W >= 0; W--)
                P = g(P, B.encoding[W]);
              return P;
            }
            function g(B, P) {
              switch (P.kind) {
                case "ByteArray":
                  switch (P.type) {
                    case n.Encoding.IntDataType.Uint8:
                      return B;
                    case n.Encoding.IntDataType.Int8:
                      return x(B);
                    case n.Encoding.IntDataType.Int16:
                      return $(B);
                    case n.Encoding.IntDataType.Uint16:
                      return C(B);
                    case n.Encoding.IntDataType.Int32:
                      return L(B);
                    case n.Encoding.IntDataType.Uint32:
                      return y(B);
                    case n.Encoding.FloatDataType.Float32:
                      return o(B);
                    case n.Encoding.FloatDataType.Float64:
                      return v(B);
                    default:
                      throw new Error("unreachable");
                  }
                case "FixedPoint":
                  return w(B, P);
                case "IntervalQuantization":
                  return M(B, P);
                case "RunLength":
                  return F(B, P);
                case "Delta":
                  return m(B, P);
                case "IntegerPacking":
                  return O(B, P);
                case "StringArray":
                  return R(B, P);
              }
            }
            function _(B, P) {
              switch (B) {
                case n.Encoding.IntDataType.Int8:
                  return new Int8Array(P);
                case n.Encoding.IntDataType.Int16:
                  return new Int16Array(P);
                case n.Encoding.IntDataType.Int32:
                  return new Int32Array(P);
                case n.Encoding.IntDataType.Uint8:
                  return new Uint8Array(P);
                case n.Encoding.IntDataType.Uint16:
                  return new Uint16Array(P);
                case n.Encoding.IntDataType.Uint32:
                  return new Uint32Array(P);
                default:
                  return new Int32Array(P);
              }
            }
            function A(B, P) {
              switch (B) {
                case n.Encoding.FloatDataType.Float32:
                  return new Float32Array(P);
                case n.Encoding.FloatDataType.Float64:
                  return new Float64Array(P);
                default:
                  return new Float64Array(P);
              }
            }
            function x(B) {
              return new Int8Array(B.buffer, B.byteOffset);
            }
            function k(B, P, W) {
              return (B.byteOffset != 0 || B.byteLength != B.buffer.byteLength) && (B = new Uint8Array(B)), s ? new W(B.buffer) : new W(h(B, P));
            }
            function $(B) {
              return k(B, 2, Int16Array);
            }
            function C(B) {
              return k(B, 2, Uint16Array);
            }
            function L(B) {
              return k(B, 4, Int32Array);
            }
            function y(B) {
              return k(B, 4, Uint32Array);
            }
            function o(B) {
              return k(B, 4, Float32Array);
            }
            function v(B) {
              return k(B, 8, Float64Array);
            }
            function w(B, P) {
              const W = B.length, U = A(P.srcType, W), V = 1 / P.factor;
              for (let K = 0; K < W; K++)
                U[K] = V * B[K];
              return U;
            }
            function M(B, P) {
              const W = B.length, U = A(P.srcType, W), V = (P.max - P.min) / (P.numSteps - 1), K = P.min;
              for (let q = 0; q < W; q++)
                U[q] = K + V * B[q];
              return U;
            }
            function F(B, P) {
              const W = _(P.srcType, P.srcSize);
              let U = 0;
              for (let V = 0, K = B.length; V < K; V += 2) {
                const q = B[V], H = B[V + 1];
                for (let j = 0; j < H; ++j)
                  W[U++] = q;
              }
              return W;
            }
            function m(B, P) {
              const W = B.length, U = _(P.srcType, W);
              if (!W)
                return B;
              U[0] = B[0] + (P.origin | 0);
              for (let V = 1; V < W; ++V)
                U[V] = B[V] + U[V - 1];
              return U;
            }
            function E(B, P) {
              const W = P.byteCount === 1 ? 127 : 32767, U = -W - 1, V = B.length, K = new Int32Array(P.srcSize);
              let q = 0, H = 0;
              for (; q < V; ) {
                let j = 0, Q = B[q];
                for (; Q === W || Q === U; )
                  j += Q, q++, Q = B[q];
                j += Q, K[H] = j, q++, H++;
              }
              return K;
            }
            function z(B, P) {
              const W = P.byteCount === 1 ? 255 : 65535, U = B.length, V = new Int32Array(P.srcSize);
              let K = 0, q = 0;
              for (; K < U; ) {
                let H = 0, j = B[K];
                for (; j === W; )
                  H += j, K++, j = B[K];
                H += j, V[q] = H, K++, q++;
              }
              return V;
            }
            function O(B, P) {
              return B.length === P.srcSize ? B : P.isUnsigned ? z(B, P) : E(B, P);
            }
            function R(B, P) {
              const W = b({ encoding: P.offsetEncoding, data: P.offsets }), U = b({ encoding: P.dataEncoding, data: B }), V = P.stringData, K = new Array(W.length);
              K[0] = "";
              for (let j = 1, Q = W.length; j < Q; j++)
                K[j] = V.substring(W[j - 1], W[j]);
              let q = 0;
              const H = new Array(U.length);
              for (let j = 0, Q = U.length; j < Q; j++)
                H[q++] = K[U[j] + 1];
              return H;
            }
          }
        ),
        /***/
        "./src/parsers/cifutils/encoding.ts": (
          /*!******************************************!*\
            !*** ./src/parsers/cifutils/encoding.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Encoding: () => (
                /* binding */
                s
              ),
              /* harmony export */
              VERSION: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = "0.3.0";
            var s;
            (function(h) {
              (function(_) {
                _[_.Int8 = 1] = "Int8", _[_.Int16 = 2] = "Int16", _[_.Int32 = 3] = "Int32", _[_.Uint8 = 4] = "Uint8", _[_.Uint16 = 5] = "Uint16", _[_.Uint32 = 6] = "Uint32";
              })(h.IntDataType || (h.IntDataType = {})), function(_) {
                _[_.Float32 = 32] = "Float32", _[_.Float64 = 33] = "Float64";
              }(h.FloatDataType || (h.FloatDataType = {}));
              function b(_) {
                let A;
                return _ instanceof Int8Array ? A = h.IntDataType.Int8 : _ instanceof Int16Array ? A = h.IntDataType.Int16 : _ instanceof Int32Array ? A = h.IntDataType.Int32 : _ instanceof Uint8Array ? A = h.IntDataType.Uint8 : _ instanceof Uint16Array ? A = h.IntDataType.Uint16 : _ instanceof Uint32Array ? A = h.IntDataType.Uint32 : _ instanceof Float32Array ? A = h.FloatDataType.Float32 : _ instanceof Float64Array ? A = h.FloatDataType.Float64 : A = h.IntDataType.Int32, A;
              }
              h.getDataType = b;
              function g(_) {
                if (_ instanceof Int8Array || _ instanceof Int16Array || _ instanceof Int32Array)
                  return !0;
                for (let A = 0, x = _.length; A < x; A++)
                  if (A < 0)
                    return !1;
                return !0;
              }
              h.isSignedIntegerDataType = g;
            })(s || (s = {}));
          }
        ),
        /***/
        "./src/parsers/index.ts": (
          /*!******************************!*\
            !*** ./src/parsers/index.ts ***!
            \******************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Parsers: () => (
                /* binding */
                w
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                v.bondLength
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                v.setBondLength
              )
              /* harmony export */
            });
            var n = r(
              /*! ./VASP */
              "./src/parsers/VASP.ts"
            ), s = r(
              /*! ./CUBE */
              "./src/parsers/CUBE.ts"
            ), h = r(
              /*! ./XYZ */
              "./src/parsers/XYZ.ts"
            ), b = r(
              /*! ./SDF */
              "./src/parsers/SDF.ts"
            ), g = r(
              /*! ./CDJSON */
              "./src/parsers/CDJSON.ts"
            ), _ = r(
              /*! ./CIF */
              "./src/parsers/CIF.ts"
            ), A = r(
              /*! ./MOL2 */
              "./src/parsers/MOL2.ts"
            ), x = r(
              /*! ./PDB */
              "./src/parsers/PDB.ts"
            ), k = r(
              /*! ./PQR */
              "./src/parsers/PQR.ts"
            ), $ = r(
              /*! ./MMTF */
              "./src/parsers/MMTF.ts"
            ), C = r(
              /*! ./PRMTOP */
              "./src/parsers/PRMTOP.ts"
            ), L = r(
              /*! ./GRO */
              "./src/parsers/GRO.ts"
            ), y = r(
              /*! ./LAMMPSTRJ */
              "./src/parsers/LAMMPSTRJ.ts"
            ), o = r(
              /*! ./BCIF */
              "./src/parsers/BCIF.ts"
            ), v = r(
              /*! ./utils/bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            const w = {
              vasp: n.VASP,
              VASP: n.VASP,
              cube: s.CUBE,
              CUBE: s.CUBE,
              xyz: h.XYZ,
              XYZ: h.XYZ,
              sdf: b.SDF,
              SDF: b.SDF,
              json: g.CDJSON,
              cdjson: g.CDJSON,
              CDJSON: g.CDJSON,
              mcif: _.CIF,
              cif: _.CIF,
              CIF: _.CIF,
              mol2: A.MOL2,
              MOL2: A.MOL2,
              pdb: x.PDB,
              PDB: x.PDB,
              pdbqt: x.PDB,
              PDBQT: x.PDB,
              pqr: k.PQR,
              PQR: k.PQR,
              mmtf: $.MMTFparser,
              MMTF: $.MMTFparser,
              prmtop: C.PRMTOP,
              PRMTOP: C.PRMTOP,
              gro: L.GRO,
              GRO: L.GRO,
              lammpstrj: y.LAMMPSTRJ,
              LAMMPSTRJ: y.LAMMPSTRJ,
              bcif: o.BCIF,
              BCIF: o.BCIF
            };
          }
        ),
        /***/
        "./src/parsers/utils/anumToSymbol.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/anumToSymbol.ts ***!
            \*******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              anumToSymbol: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {
              1: "H",
              2: "He",
              3: "Li",
              4: "Be",
              5: "B",
              6: "C",
              7: "N",
              8: "O",
              9: "F",
              10: "Ne",
              11: "Na",
              12: "Mg",
              13: "Al",
              14: "Si",
              15: "P",
              16: "S",
              17: "Cl",
              18: "Ar",
              19: "K",
              20: "Ca",
              21: "Sc",
              22: "Ti",
              23: "V",
              24: "Cr",
              25: "Mn",
              26: "Fe",
              27: "Co",
              28: "Ni",
              29: "Cu",
              30: "Zn",
              31: "Ga",
              32: "Ge",
              33: "As",
              34: "Se",
              35: "Br",
              36: "Kr",
              37: "Rb",
              38: "Sr",
              39: "Y",
              40: "Zr",
              41: "Nb",
              42: "Mo",
              43: "Tc",
              44: "Ru",
              45: "Rh",
              46: "Pd",
              47: "Ag",
              48: "Cd",
              49: "In",
              50: "Sn",
              51: "Sb",
              52: "Te",
              53: "I",
              54: "Xe",
              55: "Cs",
              56: "Ba",
              71: "Lu",
              72: "Hf",
              73: "Ta",
              74: "W",
              75: "Re",
              76: "Os",
              77: "Ir",
              78: "Pt",
              79: "Au",
              80: "Hg",
              81: "Tl",
              82: "Pb",
              83: "Bi",
              84: "Po",
              85: "At",
              86: "Rn",
              87: "Fr",
              88: "Ra",
              104: "Rf",
              105: "Db",
              106: "Sg",
              107: "Bh",
              108: "Hs",
              109: "Mt",
              110: "Ds",
              111: "Rg",
              112: "Cn",
              113: "Nh",
              114: "Fl",
              115: "Mc",
              116: "Lv",
              117: "Ts",
              118: "Og",
              57: "La",
              58: "Ce",
              59: "Pr",
              60: "Nd",
              61: "Pm",
              62: "Sm",
              63: "Eu",
              64: "Gd",
              65: "Tb",
              66: "Dy",
              67: "Ho",
              68: "Er",
              69: "Tm",
              70: "Yb",
              89: "Ac",
              90: "Th",
              91: "Pa",
              92: "U",
              93: "Np",
              94: "Pu",
              95: "Am",
              96: "Cm",
              97: "Bk",
              98: "Cf",
              99: "Es",
              100: "Fm",
              101: "Md",
              102: "No"
            };
          }
        ),
        /***/
        "./src/parsers/utils/areConnected.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/areConnected.ts ***!
            \*******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              areConnected: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var n = r(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            const s = /* @__PURE__ */ new Set(["Na", "K", "Ca", "Mg", "Mn", "Sr"]);
            function h(b, g, _) {
              if (_ && _.unboundCations && (s.has(b.elem) || s.has(g.elem)))
                return !1;
              let A = (0, n.bondLength)(b.elem) + (0, n.bondLength)(g.elem);
              A += 0.25, A *= A;
              let x = b.x - g.x;
              if (x *= x, x > A)
                return !1;
              let k = b.y - g.y;
              if (k *= k, k > A)
                return !1;
              let $ = b.z - g.z;
              if ($ *= $, $ > A)
                return !1;
              const C = x + k + $;
              return !(isNaN(C) || C < 0.5 || C > A || b.altLoc !== g.altLoc && b.altLoc.trim() !== "" && g.altLoc.trim() !== "");
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBackboneHBonds.ts": (
          /*!***************************************************!*\
            !*** ./src/parsers/utils/assignBackboneHBonds.ts ***!
            \***************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              assignBackboneHBonds: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s, h) {
              const b = h || 3.2, g = b * b, _ = [];
              for (let A = 0, x = s.length; A < x; A++) {
                s[A].index = A;
                const k = s[A];
                !k.hetflag && (k.atom === "N" || k.atom === "O") && (_.push(k), k.hbondOther = null, k.hbondDistanceSq = Number.POSITIVE_INFINITY);
              }
              _.sort(function(A, x) {
                return A.z - x.z;
              });
              for (let A = 0, x = _.length; A < x; A++) {
                const k = _[A];
                for (let $ = A + 1; $ < x; $++) {
                  const C = _[$], L = C.z - k.z;
                  if (L > b)
                    break;
                  if (C.atom == k.atom)
                    continue;
                  const y = Math.abs(C.y - k.y);
                  if (y > b)
                    continue;
                  const o = Math.abs(C.x - k.x);
                  if (o > b)
                    continue;
                  const v = o * o + y * y + L * L;
                  v > g || C.chain == k.chain && Math.abs(C.resi - k.resi) < 4 || (v < k.hbondDistanceSq && (k.hbondOther = C, k.hbondDistanceSq = v), v < C.hbondDistanceSq && (C.hbondOther = k, C.hbondDistanceSq = v));
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBonds.ts": (
          /*!******************************************!*\
            !*** ./src/parsers/utils/assignBonds.ts ***!
            \******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              assignBonds: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            );
            const s = [
              { x: 0, y: 0, z: 1 },
              { x: 0, y: 1, z: -1 },
              { x: 0, y: 1, z: 0 },
              { x: 0, y: 1, z: 1 },
              { x: 1, y: -1, z: -1 },
              { x: 1, y: -1, z: 0 },
              { x: 1, y: -1, z: 1 },
              { x: 1, y: 0, z: -1 },
              { x: 1, y: 0, z: 0 },
              { x: 1, y: 0, z: 1 },
              { x: 1, y: 1, z: -1 },
              { x: 1, y: 1, z: 0 },
              { x: 1, y: 1, z: 1 }
            ], h = 4.95;
            function b(g, _) {
              for (let k = 0, $ = g.length; k < $; k++)
                g[k].index || (g[k].index = k);
              const A = {
                x: {
                  y: {
                    z: []
                  }
                }
              };
              for (let k = 0; k < g.length; k++) {
                const $ = g[k], C = Math.floor($.x / h), L = Math.floor($.y / h), y = Math.floor($.z / h);
                A[C] || (A[C] = {}), A[C][L] || (A[C][L] = {}), A[C][L][y] || (A[C][L][y] = []), A[C][L][y].push($);
              }
              function x(k, $) {
                for (let C = 0; C < k.length; C++) {
                  const L = k[C];
                  for (let y = 0; y < $.length; y++) {
                    const o = $[y];
                    if ((0, n.areConnected)(L, o, _)) {
                      const v = L.bonds.indexOf(o.index), w = o.bonds.indexOf(L.index);
                      v === -1 && w === -1 ? (L.bonds.push(o.index), L.bondOrder.push(1), o.bonds.push(L.index), o.bondOrder.push(1)) : v === -1 ? (L.bonds.push(o.index), L.bondOrder.push(o.bondOrder[w])) : w === -1 && (o.bonds.push(L.index), o.bondOrder.push(L.bondOrder[v]));
                    }
                  }
                }
              }
              for (let k in A) {
                const $ = parseInt(k);
                for (let C in A[$]) {
                  const L = parseInt(C);
                  for (let y in A[$][L]) {
                    const o = parseInt(y), v = A[$][L][o];
                    for (let w = 0; w < v.length; w++) {
                      const M = v[w];
                      for (let F = w + 1; F < v.length; F++) {
                        const m = v[F];
                        (0, n.areConnected)(M, m, _) && M.bonds.indexOf(m.index) == -1 && (M.bonds.push(m.index), M.bondOrder.push(1), m.bonds.push(M.index), m.bondOrder.push(1));
                      }
                    }
                    for (let w = 0; w < s.length; w++) {
                      const M = s[w];
                      if (!A[$ + M.x] || !A[$ + M.x][L + M.y] || !A[$ + M.x][L + M.y][o + M.z])
                        continue;
                      const F = A[$ + M.x][L + M.y][o + M.z];
                      x(v, F);
                    }
                  }
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignPDBBonds.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/assignPDBBonds.ts ***!
            \*********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              assignPDBBonds: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var n = r(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            ), s = r(
              /*! ./assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), h = r(
              /*! ./standardResidues */
              "./src/parsers/utils/standardResidues.ts"
            );
            function b(g, _) {
              const A = [], x = [];
              for (let L = 0, y = g.length; L < y; L++) {
                const o = g[L];
                o.index = L, o.hetflag || !h.standardResidues.has(o.resn) ? x.push(o) : A.push(o);
              }
              (0, s.assignBonds)(x, _), A.sort(function(L, y) {
                return L.chain !== y.chain ? L.chain < y.chain ? -1 : 1 : L.resi - y.resi;
              });
              let k = -1, $ = -1, C;
              for (let L = 0, y = A.length; L < y; L++) {
                const o = A[L];
                o.resi !== k && (k = o.resi, C || $++, C = !1), o.reschain = $;
                for (let v = L + 1; v < A.length; v++) {
                  const w = A[v];
                  if (w.chain !== o.chain || w.resi - o.resi > 1)
                    break;
                  (0, n.areConnected)(o, w, _) && (o.bonds.indexOf(w.index) === -1 && (o.bonds.push(w.index), o.bondOrder.push(1), w.bonds.push(o.index), w.bondOrder.push(1)), o.resi !== w.resi && (C = !0));
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/atomNameToElem.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/atomNameToElem.ts ***!
            \*********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              atomNameToElem: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            function s(h, b) {
              let g = h.replace(/ /g, "");
              return g.length > 0 && g[0] === "H" && g !== "Hg" && g !== "He" && g !== "Hf" && g !== "Hs" && g !== "Ho" && (g = "H"), g.length > 1 && (g = g[0].toUpperCase() + g.substring(1).toLowerCase(), n.bondTable[g] === void 0 ? g = g[0] : b && (g === "Ca" || g === "Cd") && (g = "C")), g;
            }
          }
        ),
        /***/
        "./src/parsers/utils/bondLength.ts": (
          /*!*****************************************!*\
            !*** ./src/parsers/utils/bondLength.ts ***!
            \*****************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              bondLength: () => (
                /* binding */
                s
              ),
              /* harmony export */
              bondTable: () => (
                /* binding */
                n
              ),
              /* harmony export */
              setBondLength: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            let n = {
              H: 0.37,
              He: 0.32,
              Li: 1.34,
              Be: 0.9,
              B: 0.82,
              C: 0.77,
              N: 0.75,
              O: 0.73,
              F: 0.71,
              Ne: 0.69,
              Na: 1.54,
              Mg: 1.3,
              Al: 1.18,
              Si: 1.11,
              P: 1.06,
              S: 1.02,
              Cl: 0.99,
              Ar: 0.97,
              K: 1.96,
              Ca: 1.74,
              Sc: 1.44,
              Ti: 1.56,
              V: 1.25,
              /* Cr */
              Mn: 1.39,
              Fe: 1.25,
              Co: 1.26,
              Ni: 1.21,
              Cu: 1.38,
              Zn: 1.31,
              Ga: 1.26,
              Ge: 1.22,
              /* As */
              Se: 1.16,
              Br: 1.14,
              Kr: 1.1,
              Rb: 2.11,
              Sr: 1.92,
              Y: 1.62,
              Zr: 1.48,
              Nb: 1.37,
              Mo: 1.45,
              Tc: 1.56,
              Ru: 1.26,
              Rh: 1.35,
              Pd: 1.31,
              Ag: 1.53,
              Cd: 1.48,
              In: 1.44,
              Sn: 1.41,
              Sb: 1.38,
              Te: 1.35,
              I: 1.33,
              Xe: 1.3,
              Cs: 2.25,
              Ba: 1.98,
              Lu: 1.6,
              Hf: 1.5,
              Ta: 1.38,
              W: 1.46,
              Re: 1.59,
              Os: 1.44,
              Ir: 1.37,
              Pt: 1.28,
              Au: 1.44,
              Hg: 1.49,
              Tl: 1.48,
              Pb: 1.47,
              Bi: 1.46,
              /* Po */
              /* At */
              Rn: 1.45
              // None of the bottom row or any of the Lanthanides have bond lengths
            };
            function s(b) {
              return n[b] || 1.6;
            }
            function h(b, g) {
              g < 0 && (g = 0), n[b] = g;
            }
          }
        ),
        /***/
        "./src/parsers/utils/computeSecondaryStructure.ts": (
          /*!********************************************************!*\
            !*** ./src/parsers/utils/computeSecondaryStructure.ts ***!
            \********************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              computeSecondaryStructure: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ./assignBackboneHBonds */
              "./src/parsers/utils/assignBackboneHBonds.ts"
            );
            function s(h, b) {
              (0, n.assignBackboneHBonds)(h, b);
              const g = {};
              let _, A, x, k, $, C;
              for (_ = 0, A = h.length; _ < A; _++)
                if ($ = h[_], g[$.chain] === void 0 && (g[$.chain] = []), isFinite($.hbondDistanceSq)) {
                  const L = $.hbondOther;
                  g[L.chain] === void 0 && (g[L.chain] = []), Math.abs(L.resi - $.resi) === 4 && (g[$.chain][$.resi] = "h");
                }
              for (x in g)
                for (k = 1; k < g[x].length - 1; k++) {
                  const L = g[x][k - 1], y = g[x][k + 1];
                  C = g[x][k], L == "h" && L == y && C != L && (g[x][k] = L);
                }
              for (_ = 0, A = h.length; _ < A; _++)
                $ = h[_], isFinite($.hbondDistanceSq) && g[$.chain][$.resi] != "h" && $.ss !== "h" && (g[$.chain][$.resi] = "maybesheet");
              for (let L = 0, y = h.length; L < y; L++)
                if ($ = h[L], isFinite($.hbondDistanceSq) && g[$.chain][$.resi] == "maybesheet") {
                  let o = $.hbondOther, v = g[o.chain][o.resi];
                  (v == "maybesheet" || v == "s") && (g[$.chain][$.resi] = "s", g[o.chain][o.resi] = "s");
                }
              for (let L in g) {
                for (let y = 1; y < g[L].length - 1; y++) {
                  const o = g[L][y - 1], v = g[L][y + 1];
                  C = g[L][y], o == "s" && o == v && C != o && (g[L][y] = o);
                }
                for (let y = 0; y < g[L].length; y++) {
                  const o = g[L][y];
                  (o == "h" || o == "s") && g[L][y - 1] != o && g[L][y + 1] != o && delete g[L][y];
                }
              }
              for (_ = 0, A = h.length; _ < A; _++)
                $ = h[_], C = g[$.chain][$.resi], delete $.hbondOther, delete $.hbondDistanceSq, !(C === void 0 || C === "maybesheet") && ($.ss = C, g[$.chain][$.resi - 1] != C && ($.ssbegin = !0), g[$.chain][$.resi + 1] != C && ($.ssend = !0));
            }
          }
        ),
        /***/
        "./src/parsers/utils/getSinglePDB.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/getSinglePDB.ts ***!
            \*******************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              getSinglePDB: () => (
                /* binding */
                k
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            ), s = r(
              /*! ./atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            ), h = r(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            ), b = r(
              /*! ./computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), g = r(
              /*! ./isEmpty */
              "./src/parsers/utils/isEmpty.ts"
            ), _ = r(
              /*! ./processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), A = r(
              /*! ./assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), x = r(
              /*! ./validateBonds */
              "./src/parsers/utils/validateBonds.ts"
            );
            function k($, C, L) {
              const y = [], o = C.assignBonds === void 0 ? !0 : C.assignBonds, v = !C.keepH, w = !!C.noSecondaryStructure, M = !C.noComputeSecondaryStructure, F = !C.doAssembly, m = C.altLoc ? C.altLoc : "A", E = { symmetries: [], cryst: void 0 };
              let z, O = [];
              const R = [];
              let B;
              const P = {};
              for (let W = 0; W < $.length; W++) {
                B = $[W].replace(/^\s*/, "");
                const U = B.substring(0, 6);
                let V, K, q;
                if (U.indexOf("END") === 0) {
                  if (O = $.slice(W + 1), U === "END")
                    for (const H in L)
                      L.hasOwnProperty(H) && delete L[H];
                  break;
                } else if (U === "ATOM  " || U === "HETATM") {
                  let H, j, Q, J, Y, ee, fe, me, he, we, ye, ve;
                  if (ye = B.substring(16, 17), ye !== " " && ye !== m && m !== "*" || (we = parseInt(B.substring(6, 11)), z = B.substring(12, 16).replace(/ /g, ""), H = B.substring(17, 20).replace(/ /g, ""), j = B.substring(21, 22), Q = parseInt(B.substring(22, 26)), J = B.substring(26, 27), Y = parseFloat(B.substring(30, 38)), ee = parseFloat(B.substring(38, 46)), fe = parseFloat(B.substring(46, 54)), ve = parseFloat(B.substring(60, 68)), he = B.substring(76, 78).replace(/ /g, ""), he === "" || h.bondTable[he] === void 0 ? he = (0, s.atomNameToElem)(B.substring(12, 14), B[0] == "A") : he = he[0].toUpperCase() + he.substring(1).toLowerCase(), he === "H" && v))
                    continue;
                  U[0] == "H" ? me = !0 : me = !1, R[we] = y.length, y.push({
                    resn: H,
                    x: Y,
                    y: ee,
                    z: fe,
                    elem: he,
                    hetflag: me,
                    altLoc: ye,
                    chain: j,
                    resi: Q,
                    icode: J,
                    rescode: Q + (J !== " " ? "^" + J : ""),
                    // resi
                    // and
                    // icode
                    serial: we,
                    atom: z,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {},
                    b: ve,
                    pdbline: B
                  });
                } else if (U === "SHEET ") {
                  V = B.substring(21, 22), K = parseInt(B.substring(22, 26)), q = parseInt(B.substring(33, 37)), V in L || (L[V] = {}), L[V][K] = "s1";
                  for (let H = K + 1; H < q; H++)
                    L[V][H] = "s";
                  L[V][q] = "s2";
                } else if (U === "CONECT") {
                  const H = parseInt(B.substring(6, 11)), j = R[H], Q = y[j], J = [11, 16, 21, 26];
                  for (let Y = 0; Y < 4; Y++) {
                    const ee = parseInt(B.substring(J[Y], J[Y] + 5)), fe = R[ee];
                    let me = j + ":" + fe;
                    const he = y[fe];
                    if (Q !== void 0 && he !== void 0)
                      if (!P[me])
                        P[me] = 1, (Q.bonds.length == 0 || Q.bonds[Q.bonds.length - 1] !== fe) && (Q.bonds.push(fe), Q.bondOrder.push(1));
                      else {
                        P[me] += 1;
                        for (let we = 0; we < Q.bonds.length; we++)
                          if (Q.bonds[we] == fe) {
                            const ye = P[me];
                            ye >= 4 ? Q.bondOrder[we] = 1 : Q.bondOrder[we] = ye;
                          }
                      }
                  }
                } else if (U === "HELIX ") {
                  V = B.substring(19, 20), K = parseInt(B.substring(21, 25)), q = parseInt(B.substring(33, 37)), V in L || (L[V] = {}), L[V][K] = "h1";
                  for (let H = K + 1; H < q; H++)
                    L[V][H] = "h";
                  L[V][q] = "h2";
                } else if (!F && U === "REMARK" && B.substring(13, 18) === "BIOMT") {
                  let H, j = new n.Matrix4();
                  for (H = 1; H <= 3; H++)
                    if (B = $[W].replace(/^\s*/, ""), parseInt(B.substring(18, 19)) == H)
                      j.elements[H - 1] = parseFloat(B.substring(23, 33)), j.elements[H - 1 + 4] = parseFloat(B.substring(33, 43)), j.elements[H - 1 + 8] = parseFloat(B.substring(43, 53)), j.elements[H - 1 + 12] = parseFloat(B.substring(53)), W++;
                    else
                      for (; B.substring(13, 18) === "BIOMT"; )
                        W++, B = $[W].replace(/^\s*/, "");
                  j.elements[3] = 0, j.elements[7] = 0, j.elements[11] = 0, j.elements[15] = 1, E.symmetries.push(j), W--;
                } else if (U === "CRYST1") {
                  let H, j, Q, J, Y, ee;
                  H = parseFloat(B.substring(7, 15)), j = parseFloat(B.substring(16, 24)), Q = parseFloat(B.substring(25, 33)), J = parseFloat(B.substring(34, 40)), Y = parseFloat(B.substring(41, 47)), ee = parseFloat(B.substring(48, 54)), E.cryst = {
                    a: H,
                    b: j,
                    c: Q,
                    alpha: J,
                    beta: Y,
                    gamma: ee
                  };
                } else if (U === "ANISOU") {
                  const H = parseInt(B.substring(6, 11)), j = R[H], Q = y[j];
                  if (Q) {
                    const J = B.substring(30).trim().split(/\s+/), Y = {
                      u11: parseInt(J[0]),
                      u22: parseInt(J[1]),
                      u33: parseInt(J[2]),
                      u12: parseInt(J[3]),
                      u13: parseInt(J[4]),
                      u23: parseInt(J[5])
                    };
                    Q.uMat = Y;
                  }
                }
              }
              if ((0, x.validateBonds)(y, R), o && (0, A.assignPDBBonds)(y, C), F || (0, _.processSymmetries)(E.symmetries, y, C, E.cryst), M && !w && (0, b.computeSecondaryStructure)(y, C.hbondCutoff), !(0, g.isEmpty)(L))
                for (let W = 0; W < y.length; W++) {
                  const U = y[W];
                  if (U !== void 0 && U.chain in L && U.resi in L[U.chain]) {
                    const V = L[U.chain][U.resi];
                    U.ss = V[0], V.length > 1 && (V[1] == "1" ? U.ssbegin = !0 : V[1] == "2" && (U.ssend = !0));
                  }
                }
              return [y, E, O];
            }
          }
        ),
        /***/
        "./src/parsers/utils/isEmpty.ts": (
          /*!**************************************!*\
            !*** ./src/parsers/utils/isEmpty.ts ***!
            \**************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              isEmpty: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s) {
              for (const h in s)
                return !1;
              return !0;
            }
          }
        ),
        /***/
        "./src/parsers/utils/processSymmetries.ts": (
          /*!************************************************!*\
            !*** ./src/parsers/utils/processSymmetries.ts ***!
            \************************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              processSymmetries: () => (
                /* binding */
                s
              )
              /* harmony export */
            });
            var n = r(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            );
            function s(h, b, g, _) {
              const A = !g.duplicateAssemblyAtoms, x = b.length;
              let k = x, $ = -1, C = null, L = null;
              (g.normalizeAssembly || g.wrapAtoms) && _ && (C = (0, n.conversionMatrix3)(_.a, _.b, _.c, _.alpha, _.beta, _.gamma), L = new n.Matrix3(), L.getInverse3(C));
              let y = function(w) {
                let M = w.clone().applyMatrix3(L);
                const F = [M.x, M.y, M.z], m = [0, 0, 0];
                for (let z = 0; z < 3; z++) {
                  for (; F[z] < -1e-3; )
                    F[z] += 1, m[z] += 1;
                  for (; F[z] > 1.001; )
                    F[z] -= 1, m[z] -= 1;
                }
                const E = new n.Vector3(m[0], m[1], m[2]);
                return E.applyMatrix3(C), E;
              };
              if (g.normalizeAssembly && _)
                for (let w = 0; w < h.length; w++) {
                  const M = new n.Vector3(0, 0, 0);
                  for (let m = 0; m < x; m++) {
                    const E = new n.Vector3(b[m].x, b[m].y, b[m].z);
                    E.applyMatrix4(h[w]), M.add(E);
                  }
                  M.divideScalar(x);
                  const F = y(M);
                  h[w].isNearlyIdentity() && F.lengthSq() > 1e-3 && ($ = w), h[w].translate(F);
                }
              if (A) {
                if (h.length > 1)
                  for (let w = 0; w < b.length; w++) {
                    var o = [];
                    for (let M = 0; M < h.length; M++)
                      if (!h[M].isNearlyIdentity()) {
                        var v = new n.Vector3();
                        v.set(b[w].x, b[w].y, b[w].z), v.applyMatrix4(h[M]), o.push(v);
                      }
                    b[w].symmetries = o;
                  }
              } else {
                for (let w = 0; w < x; w++)
                  b[w].sym = -1;
                for (let w = 0; w < h.length; w++)
                  if (!h[w].isNearlyIdentity() && $ != w) {
                    let M = new n.Vector3();
                    for (let F = 0; F < x; F++) {
                      const m = [];
                      for (let z = 0; z < b[F].bonds.length; z++)
                        m.push(b[F].bonds[z] + k);
                      if (M.set(b[F].x, b[F].y, b[F].z), M.applyMatrix4(h[w]), g.wrapAtoms && _) {
                        let z = y(M);
                        M.add(z);
                      }
                      const E = {};
                      for (const z in b[F])
                        E[z] = b[F][z];
                      E.x = M.x, E.y = M.y, E.z = M.z, E.bonds = m, E.sym = w, E.index = b.length, b.push(E);
                    }
                    k = b.length;
                  } else
                    for (let M = 0; M < x; M++)
                      b[M].sym = w;
                if (g.wrapAtoms && _) {
                  let w = new n.Vector3();
                  for (let M = 0; M < x; M++) {
                    w.set(b[M].x, b[M].y, b[M].z);
                    let F = y(w);
                    w.add(F), b[M].x = w.x, b[M].y = w.y, b[M].z = w.z;
                  }
                }
                if ($ >= 0) {
                  const w = new n.Vector3();
                  for (let M = 0; M < x; M++)
                    w.set(b[M].x, b[M].y, b[M].z), w.applyMatrix4(h[$]), b[M].x = w.x, b[M].y = w.y, b[M].z = w.z;
                }
                h.length = 0;
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/standardResidues.ts": (
          /*!***********************************************!*\
            !*** ./src/parsers/utils/standardResidues.ts ***!
            \***********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              standardResidues: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = /* @__PURE__ */ new Set([
              "ABU",
              "ACD",
              "ALA",
              "ALB",
              "ALI",
              "ARG",
              "AR0",
              "ASN",
              "ASP",
              "ASX",
              "BAS",
              "CYS",
              "CYH",
              "CYX",
              "CSS",
              "CSH",
              "GLN",
              "GLU",
              "GLX",
              "GLY",
              "HIS",
              "HIE",
              "HID",
              "HIP",
              "HYP",
              "ILE",
              "ILU",
              "LEU",
              "LYS",
              "MET",
              "PCA",
              "PGA",
              "PHE",
              "PR0",
              "PRO",
              "PRZ",
              "SER",
              "THR",
              "TRP",
              "TYR",
              "VAL",
              "A",
              "1MA",
              "C",
              "5MC",
              "OMC",
              "G",
              "1MG",
              "2MG",
              "M2G",
              "7MG",
              "OMG",
              "YG",
              "I",
              "T",
              "U",
              "+U",
              "H2U",
              "5MU",
              "PSU",
              "ACE",
              "F0R",
              "H2O",
              "HOH",
              "WAT"
            ]);
          }
        ),
        /***/
        "./src/parsers/utils/validateBonds.ts": (
          /*!********************************************!*\
            !*** ./src/parsers/utils/validateBonds.ts ***!
            \********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              validateBonds: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            function n(s, h) {
              for (let b = 0, g = s.length; b < g; b++) {
                const _ = s[b];
                for (let A = 0; A < _.bonds.length; A++) {
                  const x = _.bonds[A], k = s[x], $ = h[_.serial];
                  k && $ && k.bonds.indexOf($) < 0 && (k.bonds.push($), k.bondOrder.push(_.bondOrder[A]));
                }
              }
            }
          }
        ),
        /***/
        "./src/partialCharges.ts": (
          /*!*******************************!*\
            !*** ./src/partialCharges.ts ***!
            \*******************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              applyPartialCharges: () => (
                /* binding */
                s
              ),
              /* harmony export */
              partialCharges: () => (
                /* binding */
                n
              )
              /* harmony export */
            });
            const n = {
              "ALA:N": -0.15,
              "ALA:CA": 0.1,
              "ALA:CB": 0,
              "ALA:C": 0.6,
              "ALA:O": -0.55,
              "ARG:N": -0.15,
              "ARG:CA": 0.1,
              "ARG:CB": 0,
              "ARG:CG": 0,
              "ARG:CD": 0.1,
              "ARG:NE": -0.1,
              "ARG:CZ": 0.5,
              "ARG:NH1": 0.25,
              "ARG:NH2": 0.25,
              "ARG:C": 0.6,
              "ARG:O": -0.55,
              "ASN:N": -0.15,
              "ASN:CA": 0.1,
              "ASN:CB": 0,
              "ASN:CG": 0.55,
              "ASN:OD1": -0.55,
              "ASN:ND2": 0,
              "ASN:C": 0.6,
              "ASN:O": -0.55,
              "ASP:N": -0.15,
              "ASP:CA": 0.1,
              "ASP:CB": 0,
              "ASP:CG": 0.14,
              "ASP:OD1": -0.57,
              "ASP:OD2": -0.57,
              "ASP:C": 0.6,
              "ASP:O": -0.55,
              "CYS:N": -0.15,
              "CYS:CA": 0.1,
              "CYS:CB": 0.19,
              "CYS:SG": -0.19,
              "CYS:C": 0.6,
              "CYS:O": -0.55,
              "GLN:N": -0.15,
              "GLN:CA": 0.1,
              "GLN:CB": 0,
              "GLN:CG": 0,
              "GLN:CD": 0.55,
              "GLN:OE1": -0.55,
              "GLN:NE2": 0,
              "GLN:C": 0.6,
              "GLN:O": -0.55,
              "GLU:N": -0.15,
              "GLU:CA": 0.1,
              "GLU:CB": 0,
              "GLU:CG": 0,
              "GLU:CD": 0.14,
              "GLU:OE1": -0.57,
              "GLU:OE2": -0.57,
              "GLU:C": 0.6,
              "GLU:O": -0.55,
              "GLY:N": -0.15,
              "GLY:CA": 0.1,
              "GLY:C": 0.6,
              "GLY:O": -0.55,
              "HIS:N": -0.15,
              "HIS:CA": 0.1,
              "HIS:CB": 0,
              "HIS:CG": 0.1,
              "HIS:ND1": -0.1,
              "HIS:CD2": 0.1,
              "HIS:NE2": -0.4,
              "HIS:CE1": 0.3,
              "HIS:C": 0.6,
              "HIS:O": -0.55,
              "ILE:N": -0.15,
              "ILE:CA": 0.1,
              "ILE:CB": 0,
              "ILE:CG2": 0,
              "ILE:CG1": 0,
              "ILE:CD": 0,
              "ILE:C": 0.6,
              "ILE:O": -0.55,
              "LEU:N": -0.15,
              "LEU:CA": 0.1,
              "LEU:CB": 0,
              "LEU:CG": 0,
              "LEU:CD1": 0,
              "LEU:CD2": 0,
              "LEU:C": 0.6,
              "LEU:O": -0.55,
              "LYS:N": -0.15,
              "LYS:CA": 0.1,
              "LYS:CB": 0,
              "LYS:CG": 0,
              "LYS:CD": 0,
              "LYS:CE": 0.25,
              "LYS:NZ": 0.75,
              "LYS:C": 0.6,
              "LYS:O": -0.55,
              "MET:N": -0.15,
              "MET:CA": 0.1,
              "MET:CB": 0,
              "MET:CG": 0.06,
              "MET:SD": -0.12,
              "MET:CE": 0.06,
              "MET:C": 0.6,
              "MET:O": -0.55,
              "PHE:N": -0.15,
              "PHE:CA": 0.1,
              "PHE:CB": 0,
              "PHE:CG": 0,
              "PHE:CD1": 0,
              "PHE:CD2": 0,
              "PHE:CE1": 0,
              "PHE:CE2": 0,
              "PHE:CZ": 0,
              "PHE:C": 0.6,
              "PHE:O": -0.55,
              "PRO:N": -0.25,
              "PRO:CD": 0.1,
              "PRO:CA": 0.1,
              "PRO:CB": 0,
              "PRO:CG": 0,
              "PRO:C": 0.6,
              "PRO:O": -0.55,
              "SER:N": -0.15,
              "SER:CA": 0.1,
              "SER:CB": 0.25,
              "SER:OG": -0.25,
              "SER:C": 0.6,
              "SER:O": -0.55,
              "THR:N": -0.15,
              "THR:CA": 0.1,
              "THR:CB": 0.25,
              "THR:OG1": -0.25,
              "THR:CG2": 0,
              "THR:C": 0.6,
              "THR:O": -0.55,
              "TRP:N": -0.15,
              "TRP:CA": 0.1,
              "TRP:CB": 0,
              "TRP:CG": -0.03,
              "TRP:CD2": 0.1,
              "TRP:CE2": -0.04,
              "TRP:CE3": -0.03,
              "TRP:CD1": 0.06,
              "TRP:NE1": -0.06,
              "TRP:CZ2": 0,
              "TRP:CZ3": 0,
              "TRP:CH2": 0,
              "TRP:C": 0.6,
              "TRP:O": -0.55,
              "TYR:N": -0.15,
              "TYR:CA": 0.1,
              "TYR:CB": 0,
              "TYR:CG": 0,
              "TYR:CD1": 0,
              "TYR:CE1": 0,
              "TYR:CD2": 0,
              "TYR:CE2": 0,
              "TYR:CZ": 0.25,
              "TYR:OH": -0.25,
              "TYR:C": 0.6,
              "TYR:O": -0.55,
              "VAL:N": -0.15,
              "VAL:CA": 0.1,
              "VAL:CB": 0,
              "VAL:CG1": 0,
              "VAL:CG2": 0,
              "VAL:C": 0.6,
              "VAL:O": -0.55
            };
            function s(h, b) {
              if ((!b || typeof h.partialCharge > "u") && h.resn && h.atom) {
                var g = h.resn + ":" + h.atom;
                h.properties.partialCharge = n[g];
              }
            }
          }
        ),
        /***/
        "./src/specs.ts": (
          /*!**********************!*\
            !*** ./src/specs.ts ***!
            \**********************/
          /***/
          (a, e, r) => {
            r.r(e);
          }
        ),
        /***/
        "./src/utilities.ts": (
          /*!**************************!*\
            !*** ./src/utilities.ts ***!
            \**************************/
          /***/
          (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              PausableTimer: () => (
                /* binding */
                PausableTimer
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* binding */
                adjustVolumeStyle
              ),
              /* harmony export */
              base64ToArray: () => (
                /* binding */
                base64ToArray
              ),
              /* harmony export */
              deepCopy: () => (
                /* binding */
                deepCopy
              ),
              /* harmony export */
              download: () => (
                /* binding */
                download
              ),
              /* harmony export */
              extend: () => (
                /* binding */
                extend
              ),
              /* harmony export */
              get: () => (
                /* binding */
                get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* binding */
                getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* binding */
                getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* binding */
                getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* binding */
                getExtent
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* binding */
                getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* binding */
                getbin
              ),
              /* harmony export */
              inflateString: () => (
                /* binding */
                inflateString
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* binding */
                isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* binding */
                isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* binding */
                makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* binding */
                mergeGeos
              ),
              /* harmony export */
              specStringToObject: () => (
                /* binding */
                specStringToObject
              )
              /* harmony export */
            });
            var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), _VolumeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
              /*! ./colors */
              "./src/colors.ts"
            ), pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            );
            function extend(a, e) {
              for (var r in e)
                e.hasOwnProperty(r) && e[r] !== void 0 && (a[r] = e[r]);
              return a;
            }
            function deepCopy(a) {
              let e, r, n;
              if (a == null)
                return {};
              if (typeof a != "object" || a === null)
                return a;
              e = Array.isArray(a) ? [] : {};
              for (n in a)
                r = a[n], e[n] = deepCopy(r);
              return e;
            }
            function isNumeric(a) {
              var e = typeof a;
              return (e === "number" || e === "string") && !isNaN(a - parseFloat(a));
            }
            function isEmptyObject(a) {
              var e;
              for (e in a)
                return !1;
              return !0;
            }
            function makeFunction(callback) {
              return callback && typeof callback == "string" && (callback = eval("(" + callback + ")")), callback && typeof callback != "function" ? (console.warn("Invalid callback provided."), () => {
              }) : callback;
            }
            function adjustVolumeStyle(a) {
              a && (a.volformat && !(a.voldata instanceof _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData) && (a.voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData(a.voldata, a.volformat)), a.volscheme && (a.volscheme = _Gradient__WEBPACK_IMPORTED_MODULE_0__.Gradient.getGradient(a.volscheme)));
            }
            function getExtent(a, e) {
              var r, n, s, h, b, g, _, A, x, k, $ = !e;
              if (r = n = s = 9999, h = b = g = -9999, _ = A = x = k = 0, a.length === 0)
                return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
              for (var C = 0; C < a.length; C++) {
                var L = a[C];
                if (!(typeof L > "u" || !isFinite(L.x) || !isFinite(L.y) || !isFinite(L.z)) && (k++, _ += L.x, A += L.y, x += L.z, r = r < L.x ? r : L.x, n = n < L.y ? n : L.y, s = s < L.z ? s : L.z, h = h > L.x ? h : L.x, b = b > L.y ? b : L.y, g = g > L.z ? g : L.z, L.symmetries && $))
                  for (var y = 0; y < L.symmetries.length; y++)
                    k++, _ += L.symmetries[y].x, A += L.symmetries[y].y, x += L.symmetries[y].z, r = r < L.symmetries[y].x ? r : L.symmetries[y].x, n = n < L.symmetries[y].y ? n : L.symmetries[y].y, s = s < L.symmetries[y].z ? s : L.symmetries[y].z, h = h > L.symmetries[y].x ? h : L.symmetries[y].x, b = b > L.symmetries[y].y ? b : L.symmetries[y].y, g = g > L.symmetries[y].z ? g : L.symmetries[y].z;
              }
              return [
                [r, n, s],
                [h, b, g],
                [_ / k, A / k, x / k]
              ];
            }
            function getPropertyRange(a, e) {
              for (var r = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = 0, h = a.length; s < h; s++) {
                var b = a[s], g = getAtomProperty(b, e);
                g != null && (g < r && (r = g), g > n && (n = g));
              }
              return !isFinite(r) && !isFinite(n) ? r = n = 0 : isFinite(r) ? isFinite(n) || (n = r) : r = n, [r, n];
            }
            class PausableTimer {
              constructor(e, r, n) {
                this.total_time_run = 0, this.fn = e, this.arg = n, this.countdown = r, this.start_time = (/* @__PURE__ */ new Date()).getTime(), this.ident = setTimeout(e, r, n);
              }
              cancel() {
                clearTimeout(this.ident);
              }
              pause() {
                clearTimeout(this.ident), this.total_time_run = (/* @__PURE__ */ new Date()).getTime() - this.start_time;
              }
              resume() {
                this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);
              }
            }
            function base64ToArray(a) {
              for (var e = window.atob(a), r = e.length, n = new Uint8Array(r), s = 0; s < r; s++)
                n[s] = e.charCodeAt(s);
              return n;
            }
            function getAtomProperty(a, e) {
              var r = null;
              return a.properties && typeof a.properties[e] < "u" ? r = a.properties[e] : typeof a[e] < "u" && (r = a[e]), r;
            }
            function mergeGeos(a, e) {
              var r = e.geometry;
              r !== void 0 && a.geometryGroups.push(r.geometryGroups[0]);
            }
            function specStringToObject(a) {
              if (typeof a == "object")
                return a;
              if (typeof a > "u" || a == null)
                return a;
              try {
                return JSON.parse(a);
              } catch {
              }
              a = a.replace(/%7E/g, "~");
              var e = function($) {
                return isNumeric($) ? Math.floor(parseFloat($)) == parseInt($) || $.indexOf(".") >= 0 ? parseFloat($) : parseInt($) : $ === "true" ? !0 : $ === "false" ? !1 : $;
              }, r = {};
              if (a === "all")
                return r;
              for (var n = a.split(";"), s = 0; s < n.length; s++) {
                var h = n[s].split(":"), b = h[0], g = {}, _ = h[1];
                if (_)
                  if (_ = _.replace(/~/g, "="), _.indexOf("=") !== -1)
                    for (var A = _.split(","), x = 0; x < A.length; x++) {
                      var k = A[x].split("=", 2);
                      g[k[0]] = e(k[1]);
                    }
                  else _.indexOf(",") !== -1 ? g = _.split(",") : g = e(_);
                r[b] = g;
              }
              return r;
            }
            function checkStatus(a) {
              if (!a.ok)
                throw new Error(`HTTP ${a.status} - ${a.statusText}`);
              return a;
            }
            function get(a, e) {
              var r = fetch(a).then(checkStatus).then((n) => n.text());
              return e ? r.then(e) : r;
            }
            function getbin(a, e, r, n) {
              var s;
              return r == "POST" ? s = fetch(a, { method: "POST", body: n }).then((h) => checkStatus(h)).then((h) => h.arrayBuffer()) : s = fetch(a).then((h) => checkStatus(h)).then((h) => h.arrayBuffer()), e ? s.then(e) : s;
            }
            function download(a, e, r, n) {
              var s = "", h = "", b = "", g = null, _ = e.addModel();
              if (a.indexOf(":") < 0 && (a.length == 4 ? a = "pdb:" + a : isNaN(a) ? a = "url:" + a : a = "cid:" + a), a.substring(0, 5) == "mmtf:" && (console.warn("WARNING: MMTF now deprecated.  Reverting to bcif."), a = "bcif:" + a.slice(5)), a.substring(0, 5) === "bcif:")
                a = a.substring(5).toUpperCase(), b = "https://models.rcsb.org/" + a + ".bcif.gz", r && typeof r.noComputeSecondaryStructure > "u" && (r.noComputeSecondaryStructure = !0), g = new Promise(function(x) {
                  getbin(b).then(function(k) {
                    _.addMolData(k, "bcif.gz", r), e.zoomTo(), e.render(), x(_);
                  }, function() {
                    console.error("fetch of " + b + " failed.");
                  });
                });
              else {
                if (a.substring(0, 4) === "pdb:") {
                  if (s = "bcif", r && r.format && (s = r.format), r && typeof r.noComputeSecondaryStructure > "u" && (r.noComputeSecondaryStructure = !0), a = a.substring(4).toUpperCase(), !a.match(/^[1-9][A-Za-z0-9]{3}$/)) {
                    alert("Wrong PDB ID");
                    return;
                  }
                  s == "bcif" ? b = "https://models.rcsb.org/" + a.toUpperCase() + ".bcif.gz" : (h = r && r.pdbUri ? r.pdbUri : "https://files.rcsb.org/view/", b = h + a + "." + s);
                } else if (a.substring(0, 4) == "cid:") {
                  if (s = "sdf", a = a.substring(4), !a.match(/^[0-9]+$/)) {
                    alert("Wrong Compound ID");
                    return;
                  }
                  b = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + a + "/SDF?record_type=3d";
                } else a.substring(0, 4) == "url:" && (b = a.substring(4), s = b);
                var A = function(x) {
                  _.addMolData(x, s, r), e.zoomTo(), e.render();
                };
                g = new Promise(function(x) {
                  s == "bcif" ? getbin(b).then(function(k) {
                    A(k), x(_);
                  }).catch(function() {
                    h = r && r.pdbUri ? r.pdbUri : "https://files.rcsb.org/view/", b = h + a + ".pdb", s = "pdb", console.warn("falling back to pdb format"), get(b).then(function(k) {
                      A(k), x(_);
                    }).catch(function(k) {
                      A(""), x(_), console.error("fetch of " + b + " failed: " + k.statusText);
                    });
                  }) : get(b).then(function(k) {
                    A(k), x(_);
                  }).catch(function(k) {
                    A(""), x(_), console.error("fetch of " + b + " failed: " + k.statusText);
                  });
                });
              }
              return n ? (g.then(function(x) {
                n(x);
              }), _) : g;
            }
            function getColorFromStyle(a, e) {
              let r = e.colorscheme;
              if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[r] < "u")
                r = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[r];
              else if (typeof r == "string" && r.endsWith("Carbon")) {
                let b = r.substring(0, r.lastIndexOf("Carbon")).toLowerCase();
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[b] < "u") {
                  let g = Object.assign({}, _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors);
                  g.C = _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[b], _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[r] = { prop: "elem", map: g }, r = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[r];
                }
              }
              let n = a.color;
              if (typeof e.color < "u" && e.color != "spectrum" && (n = e.color), typeof r < "u") {
                let b, g;
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[r] < "u")
                  r = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[r], typeof r[a[r.prop]] < "u" && (n = r.map[a[r.prop]]);
                else if (typeof r[a[r.prop]] < "u")
                  n = r.map[a[r.prop]];
                else if (typeof r.prop < "u" && typeof r.gradient < "u") {
                  b = r.prop;
                  var s = r.gradient;
                  s instanceof _Gradient__WEBPACK_IMPORTED_MODULE_0__.GradientType || (s = (0, _Gradient__WEBPACK_IMPORTED_MODULE_0__.getGradient)(r));
                  let _ = s.range() || [-1, 1];
                  g = getAtomProperty(a, b), g != null && (n = s.valueToHex(g, _));
                } else typeof r.prop < "u" && typeof r.map < "u" ? (b = r.prop, g = getAtomProperty(a, b), typeof r.map[g] < "u" && (n = r.map[g])) : typeof e.colorscheme[a.elem] < "u" ? n = e.colorscheme[a.elem] : console.warn("Could not interpret colorscheme " + r);
              } else typeof e.colorfunc < "u" && (n = e.colorfunc(a));
              return _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(n);
            }
            function getElement(a) {
              let e = a;
              return typeof a == "string" ? e = document.querySelector("#" + a) : typeof a == "object" && a.get && (e = a.get(0)), e;
            }
            function inflateString(a, e = !0) {
              let r;
              return typeof a == "string" ? r = new TextEncoder().encode(a) : r = new Uint8Array(a), (0, pako__WEBPACK_IMPORTED_MODULE_3__.inflate)(r, {
                to: e ? "string" : null
              });
            }
          }
        ),
        /***/
        "./node_modules/upng-js/UPNG.js": (
          /*!**************************************!*\
            !*** ./node_modules/upng-js/UPNG.js ***!
            \**************************************/
          /***/
          (a, e, r) => {
            (function() {
              var n = {}, s;
              a.exports = n, s = r(
                /*! pako */
                "./node_modules/upng-js/node_modules/pako/index.js"
              ), function(h, b) {
                h.toRGBA8 = function(g) {
                  var _ = g.width, A = g.height;
                  if (g.tabs.acTL == null) return [h.toRGBA8.decodeImage(g.data, _, A, g).buffer];
                  var x = [];
                  g.frames[0].data == null && (g.frames[0].data = g.data);
                  for (var k, $ = new Uint8Array(_ * A * 4), C = 0; C < g.frames.length; C++) {
                    var L = g.frames[C], y = L.rect.x, o = L.rect.y, v = L.rect.width, w = L.rect.height, M = h.toRGBA8.decodeImage(L.data, v, w, g);
                    if (C == 0 ? k = M : L.blend == 0 ? h._copyTile(M, v, w, k, _, A, y, o, 0) : L.blend == 1 && h._copyTile(M, v, w, k, _, A, y, o, 1), x.push(k.buffer), k = k.slice(0), L.dispose != 0) {
                      if (L.dispose == 1) h._copyTile($, v, w, k, _, A, y, o, 0);
                      else if (L.dispose == 2) {
                        for (var F = C - 1; g.frames[F].dispose == 2; ) F--;
                        k = new Uint8Array(x[F]).slice(0);
                      }
                    }
                  }
                  return x;
                }, h.toRGBA8.decodeImage = function(g, _, A, x) {
                  var k = _ * A, $ = h.decode._getBPP(x), C = Math.ceil(_ * $ / 8), L = new Uint8Array(k * 4), y = new Uint32Array(L.buffer), o = x.ctype, v = x.depth, w = h._bin.readUshort;
                  if (o == 6) {
                    var M = k << 2;
                    if (v == 8) for (var F = 0; F < M; F++)
                      L[F] = g[F];
                    if (v == 16) for (var F = 0; F < M; F++)
                      L[F] = g[F << 1];
                  } else if (o == 2) {
                    var m = x.tabs.tRNS, E = -1, z = -1, O = -1;
                    if (m && (E = m[0], z = m[1], O = m[2]), v == 8) for (var F = 0; F < k; F++) {
                      var R = F << 2, B = F * 3;
                      L[R] = g[B], L[R + 1] = g[B + 1], L[R + 2] = g[B + 2], L[R + 3] = 255, E != -1 && g[B] == E && g[B + 1] == z && g[B + 2] == O && (L[R + 3] = 0);
                    }
                    if (v == 16) for (var F = 0; F < k; F++) {
                      var R = F << 2, B = F * 6;
                      L[R] = g[B], L[R + 1] = g[B + 2], L[R + 2] = g[B + 4], L[R + 3] = 255, E != -1 && w(g, B) == E && w(g, B + 2) == z && w(g, B + 4) == O && (L[R + 3] = 0);
                    }
                  } else if (o == 3) {
                    var P = x.tabs.PLTE, W = x.tabs.tRNS, U = W ? W.length : 0;
                    if (v == 1) for (var V = 0; V < A; V++)
                      for (var K = V * C, q = V * _, F = 0; F < _; F++) {
                        var R = q + F << 2, H = g[K + (F >> 3)] >> 7 - ((F & 7) << 0) & 1, j = 3 * H;
                        L[R] = P[j], L[R + 1] = P[j + 1], L[R + 2] = P[j + 2], L[R + 3] = H < U ? W[H] : 255;
                      }
                    if (v == 2) for (var V = 0; V < A; V++)
                      for (var K = V * C, q = V * _, F = 0; F < _; F++) {
                        var R = q + F << 2, H = g[K + (F >> 2)] >> 6 - ((F & 3) << 1) & 3, j = 3 * H;
                        L[R] = P[j], L[R + 1] = P[j + 1], L[R + 2] = P[j + 2], L[R + 3] = H < U ? W[H] : 255;
                      }
                    if (v == 4) for (var V = 0; V < A; V++)
                      for (var K = V * C, q = V * _, F = 0; F < _; F++) {
                        var R = q + F << 2, H = g[K + (F >> 1)] >> 4 - ((F & 1) << 2) & 15, j = 3 * H;
                        L[R] = P[j], L[R + 1] = P[j + 1], L[R + 2] = P[j + 2], L[R + 3] = H < U ? W[H] : 255;
                      }
                    if (v == 8) for (var F = 0; F < k; F++) {
                      var R = F << 2, H = g[F], j = 3 * H;
                      L[R] = P[j], L[R + 1] = P[j + 1], L[R + 2] = P[j + 2], L[R + 3] = H < U ? W[H] : 255;
                    }
                  } else if (o == 4) {
                    if (v == 8) for (var F = 0; F < k; F++) {
                      var R = F << 2, Q = F << 1, J = g[Q];
                      L[R] = J, L[R + 1] = J, L[R + 2] = J, L[R + 3] = g[Q + 1];
                    }
                    if (v == 16) for (var F = 0; F < k; F++) {
                      var R = F << 2, Q = F << 2, J = g[Q];
                      L[R] = J, L[R + 1] = J, L[R + 2] = J, L[R + 3] = g[Q + 2];
                    }
                  } else if (o == 0) {
                    var E = x.tabs.tRNS ? x.tabs.tRNS : -1;
                    if (v == 1) for (var F = 0; F < k; F++) {
                      var J = 255 * (g[F >> 3] >> 7 - (F & 7) & 1), Y = J == E * 255 ? 0 : 255;
                      y[F] = Y << 24 | J << 16 | J << 8 | J;
                    }
                    if (v == 2) for (var F = 0; F < k; F++) {
                      var J = 85 * (g[F >> 2] >> 6 - ((F & 3) << 1) & 3), Y = J == E * 85 ? 0 : 255;
                      y[F] = Y << 24 | J << 16 | J << 8 | J;
                    }
                    if (v == 4) for (var F = 0; F < k; F++) {
                      var J = 17 * (g[F >> 1] >> 4 - ((F & 1) << 2) & 15), Y = J == E * 17 ? 0 : 255;
                      y[F] = Y << 24 | J << 16 | J << 8 | J;
                    }
                    if (v == 8) for (var F = 0; F < k; F++) {
                      var J = g[F], Y = J == E ? 0 : 255;
                      y[F] = Y << 24 | J << 16 | J << 8 | J;
                    }
                    if (v == 16) for (var F = 0; F < k; F++) {
                      var J = g[F << 1], Y = w(g, F << 1) == E ? 0 : 255;
                      y[F] = Y << 24 | J << 16 | J << 8 | J;
                    }
                  }
                  return L;
                }, h.decode = function(g) {
                  for (var _ = new Uint8Array(g), A = 8, x = h._bin, k = x.readUshort, $ = x.readUint, C = { tabs: {}, frames: [] }, L = new Uint8Array(_.length), y = 0, o, v = 0, w = [137, 80, 78, 71, 13, 10, 26, 10], M = 0; M < 8; M++) if (_[M] != w[M]) throw "The input is not a PNG file!";
                  for (; A < _.length; ) {
                    var F = x.readUint(_, A);
                    A += 4;
                    var m = x.readASCII(_, A, 4);
                    if (A += 4, m == "IHDR")
                      h.decode._IHDR(_, A, C);
                    else if (m == "IDAT") {
                      for (var M = 0; M < F; M++) L[y + M] = _[A + M];
                      y += F;
                    } else if (m == "acTL")
                      C.tabs[m] = { num_frames: $(_, A), num_plays: $(_, A + 4) }, o = new Uint8Array(_.length);
                    else if (m == "fcTL") {
                      if (v != 0) {
                        var E = C.frames[C.frames.length - 1];
                        E.data = h.decode._decompress(C, o.slice(0, v), E.rect.width, E.rect.height), v = 0;
                      }
                      var z = { x: $(_, A + 12), y: $(_, A + 16), width: $(_, A + 4), height: $(_, A + 8) }, O = k(_, A + 22);
                      O = k(_, A + 20) / (O == 0 ? 100 : O);
                      var R = { rect: z, delay: Math.round(O * 1e3), dispose: _[A + 24], blend: _[A + 25] };
                      C.frames.push(R);
                    } else if (m == "fdAT") {
                      for (var M = 0; M < F - 4; M++) o[v + M] = _[A + M + 4];
                      v += F - 4;
                    } else if (m == "pHYs")
                      C.tabs[m] = [x.readUint(_, A), x.readUint(_, A + 4), _[A + 8]];
                    else if (m == "cHRM") {
                      C.tabs[m] = [];
                      for (var M = 0; M < 8; M++) C.tabs[m].push(x.readUint(_, A + M * 4));
                    } else if (m == "tEXt") {
                      C.tabs[m] == null && (C.tabs[m] = {});
                      var B = x.nextZero(_, A), P = x.readASCII(_, A, B - A), W = x.readASCII(_, B + 1, A + F - B - 1);
                      C.tabs[m][P] = W;
                    } else if (m == "iTXt") {
                      C.tabs[m] == null && (C.tabs[m] = {});
                      var B = 0, U = A;
                      B = x.nextZero(_, U);
                      var P = x.readASCII(_, U, B - U);
                      U = B + 1, _[U], _[U + 1], U += 2, B = x.nextZero(_, U), x.readASCII(_, U, B - U), U = B + 1, B = x.nextZero(_, U), x.readUTF8(_, U, B - U), U = B + 1;
                      var W = x.readUTF8(_, U, F - (U - A));
                      C.tabs[m][P] = W;
                    } else if (m == "PLTE")
                      C.tabs[m] = x.readBytes(_, A, F);
                    else if (m == "hIST") {
                      var V = C.tabs.PLTE.length / 3;
                      C.tabs[m] = [];
                      for (var M = 0; M < V; M++) C.tabs[m].push(k(_, A + M * 2));
                    } else if (m == "tRNS")
                      C.ctype == 3 ? C.tabs[m] = x.readBytes(_, A, F) : C.ctype == 0 ? C.tabs[m] = k(_, A) : C.ctype == 2 && (C.tabs[m] = [k(_, A), k(_, A + 2), k(_, A + 4)]);
                    else if (m == "gAMA") C.tabs[m] = x.readUint(_, A) / 1e5;
                    else if (m == "sRGB") C.tabs[m] = _[A];
                    else if (m == "bKGD")
                      C.ctype == 0 || C.ctype == 4 ? C.tabs[m] = [k(_, A)] : C.ctype == 2 || C.ctype == 6 ? C.tabs[m] = [k(_, A), k(_, A + 2), k(_, A + 4)] : C.ctype == 3 && (C.tabs[m] = _[A]);
                    else if (m == "IEND") {
                      if (v != 0) {
                        var E = C.frames[C.frames.length - 1];
                        E.data = h.decode._decompress(C, o.slice(0, v), E.rect.width, E.rect.height), v = 0;
                      }
                      C.data = h.decode._decompress(C, L, C.width, C.height);
                      break;
                    }
                    A += F, x.readUint(_, A), A += 4;
                  }
                  return delete C.compress, delete C.interlace, delete C.filter, C;
                }, h.decode._decompress = function(g, _, A, x) {
                  return g.compress == 0 && (_ = h.decode._inflate(_)), g.interlace == 0 ? _ = h.decode._filterZero(_, g, 0, A, x) : g.interlace == 1 && (_ = h.decode._readInterlace(_, g)), _;
                }, h.decode._inflate = function(g) {
                  return b.inflate(g);
                }, h.decode._readInterlace = function(g, _) {
                  for (var A = _.width, x = _.height, k = h.decode._getBPP(_), $ = k >> 3, C = Math.ceil(A * k / 8), L = new Uint8Array(x * C), y = 0, o = [0, 0, 4, 0, 2, 0, 1], v = [0, 4, 0, 2, 0, 1, 0], w = [8, 8, 8, 4, 4, 2, 2], M = [8, 8, 4, 4, 2, 2, 1], F = 0; F < 7; ) {
                    for (var m = w[F], E = M[F], z = 0, O = 0, R = o[F]; R < x; )
                      R += m, O++;
                    for (var B = v[F]; B < A; )
                      B += E, z++;
                    var P = Math.ceil(z * k / 8);
                    h.decode._filterZero(g, _, y, z, O);
                    for (var W = 0, U = o[F]; U < x; ) {
                      for (var V = v[F], K = y + W * P << 3; V < A; ) {
                        if (k == 1) {
                          var q = g[K >> 3];
                          q = q >> 7 - (K & 7) & 1, L[U * C + (V >> 3)] |= q << 7 - ((V & 3) << 0);
                        }
                        if (k == 2) {
                          var q = g[K >> 3];
                          q = q >> 6 - (K & 7) & 3, L[U * C + (V >> 2)] |= q << 6 - ((V & 3) << 1);
                        }
                        if (k == 4) {
                          var q = g[K >> 3];
                          q = q >> 4 - (K & 7) & 15, L[U * C + (V >> 1)] |= q << 4 - ((V & 1) << 2);
                        }
                        if (k >= 8)
                          for (var H = U * C + V * $, j = 0; j < $; j++) L[H + j] = g[(K >> 3) + j];
                        K += k, V += E;
                      }
                      W++, U += m;
                    }
                    z * O != 0 && (y += O * (1 + P)), F = F + 1;
                  }
                  return L;
                }, h.decode._getBPP = function(g) {
                  var _ = [1, null, 3, 1, 2, null, 4][g.ctype];
                  return _ * g.depth;
                }, h.decode._filterZero = function(g, _, A, x, k) {
                  var $ = h.decode._getBPP(_), C = Math.ceil(x * $ / 8), L = h.decode._paeth;
                  $ = Math.ceil($ / 8);
                  for (var y = 0; y < k; y++) {
                    var o = A + y * C, v = o + y + 1, w = g[v - 1];
                    if (w == 0) for (var M = 0; M < C; M++) g[o + M] = g[v + M];
                    else if (w == 1) {
                      for (var M = 0; M < $; M++) g[o + M] = g[v + M];
                      for (var M = $; M < C; M++) g[o + M] = g[v + M] + g[o + M - $] & 255;
                    } else if (y == 0) {
                      for (var M = 0; M < $; M++) g[o + M] = g[v + M];
                      if (w == 2) for (var M = $; M < C; M++) g[o + M] = g[v + M] & 255;
                      if (w == 3) for (var M = $; M < C; M++) g[o + M] = g[v + M] + (g[o + M - $] >> 1) & 255;
                      if (w == 4) for (var M = $; M < C; M++) g[o + M] = g[v + M] + L(g[o + M - $], 0, 0) & 255;
                    } else {
                      if (w == 2)
                        for (var M = 0; M < C; M++) g[o + M] = g[v + M] + g[o + M - C] & 255;
                      if (w == 3) {
                        for (var M = 0; M < $; M++) g[o + M] = g[v + M] + (g[o + M - C] >> 1) & 255;
                        for (var M = $; M < C; M++) g[o + M] = g[v + M] + (g[o + M - C] + g[o + M - $] >> 1) & 255;
                      }
                      if (w == 4) {
                        for (var M = 0; M < $; M++) g[o + M] = g[v + M] + L(0, g[o + M - C], 0) & 255;
                        for (var M = $; M < C; M++) g[o + M] = g[v + M] + L(g[o + M - $], g[o + M - C], g[o + M - $ - C]) & 255;
                      }
                    }
                  }
                  return g;
                }, h.decode._paeth = function(g, _, A) {
                  var x = g + _ - A, k = Math.abs(x - g), $ = Math.abs(x - _), C = Math.abs(x - A);
                  return k <= $ && k <= C ? g : $ <= C ? _ : A;
                }, h.decode._IHDR = function(g, _, A) {
                  var x = h._bin;
                  A.width = x.readUint(g, _), _ += 4, A.height = x.readUint(g, _), _ += 4, A.depth = g[_], _++, A.ctype = g[_], _++, A.compress = g[_], _++, A.filter = g[_], _++, A.interlace = g[_], _++;
                }, h._bin = {
                  nextZero: function(g, _) {
                    for (; g[_] != 0; ) _++;
                    return _;
                  },
                  readUshort: function(g, _) {
                    return g[_] << 8 | g[_ + 1];
                  },
                  writeUshort: function(g, _, A) {
                    g[_] = A >> 8 & 255, g[_ + 1] = A & 255;
                  },
                  readUint: function(g, _) {
                    return g[_] * 16777216 + (g[_ + 1] << 16 | g[_ + 2] << 8 | g[_ + 3]);
                  },
                  writeUint: function(g, _, A) {
                    g[_] = A >> 24 & 255, g[_ + 1] = A >> 16 & 255, g[_ + 2] = A >> 8 & 255, g[_ + 3] = A & 255;
                  },
                  readASCII: function(g, _, A) {
                    for (var x = "", k = 0; k < A; k++) x += String.fromCharCode(g[_ + k]);
                    return x;
                  },
                  writeASCII: function(g, _, A) {
                    for (var x = 0; x < A.length; x++) g[_ + x] = A.charCodeAt(x);
                  },
                  readBytes: function(g, _, A) {
                    for (var x = [], k = 0; k < A; k++) x.push(g[_ + k]);
                    return x;
                  },
                  pad: function(g) {
                    return g.length < 2 ? "0" + g : g;
                  },
                  readUTF8: function(g, _, A) {
                    for (var x = "", k, $ = 0; $ < A; $++) x += "%" + h._bin.pad(g[_ + $].toString(16));
                    try {
                      k = decodeURIComponent(x);
                    } catch {
                      return h._bin.readASCII(g, _, A);
                    }
                    return k;
                  }
                }, h._copyTile = function(g, _, A, x, k, $, C, L, y) {
                  for (var o = Math.min(_, k), v = Math.min(A, $), w = 0, M = 0, F = 0; F < v; F++)
                    for (var m = 0; m < o; m++)
                      if (C >= 0 && L >= 0 ? (w = F * _ + m << 2, M = (L + F) * k + C + m << 2) : (w = (-L + F) * _ - C + m << 2, M = F * k + m << 2), y == 0)
                        x[M] = g[w], x[M + 1] = g[w + 1], x[M + 2] = g[w + 2], x[M + 3] = g[w + 3];
                      else if (y == 1) {
                        var E = g[w + 3] * 0.00392156862745098, z = g[w] * E, O = g[w + 1] * E, R = g[w + 2] * E, B = x[M + 3] * (1 / 255), P = x[M] * B, W = x[M + 1] * B, U = x[M + 2] * B, V = 1 - E, K = E + B * V, q = K == 0 ? 0 : 1 / K;
                        x[M + 3] = 255 * K, x[M + 0] = (z + P * V) * q, x[M + 1] = (O + W * V) * q, x[M + 2] = (R + U * V) * q;
                      } else if (y == 2) {
                        var E = g[w + 3], z = g[w], O = g[w + 1], R = g[w + 2], B = x[M + 3], P = x[M], W = x[M + 1], U = x[M + 2];
                        E == B && z == P && O == W && R == U ? (x[M] = 0, x[M + 1] = 0, x[M + 2] = 0, x[M + 3] = 0) : (x[M] = z, x[M + 1] = O, x[M + 2] = R, x[M + 3] = E);
                      } else if (y == 3) {
                        var E = g[w + 3], z = g[w], O = g[w + 1], R = g[w + 2], B = x[M + 3], P = x[M], W = x[M + 1], U = x[M + 2];
                        if (E == B && z == P && O == W && R == U) continue;
                        if (E < 220 && B > 20) return !1;
                      }
                  return !0;
                }, h.encode = function(g, _, A, x, k, $) {
                  x == null && (x = 0), $ == null && ($ = !1);
                  for (var C = new Uint8Array(g[0].byteLength * g.length + 100), L = [137, 80, 78, 71, 13, 10, 26, 10], y = 0; y < 8; y++) C[y] = L[y];
                  var o = 8, v = h._bin, w = h.crc.crc, M = v.writeUint, F = v.writeUshort, m = v.writeASCII, E = h.encode.compressPNG(g, _, A, x, $);
                  M(C, o, 13), o += 4, m(C, o, "IHDR"), o += 4, M(C, o, _), o += 4, M(C, o, A), o += 4, C[o] = E.depth, o++, C[o] = E.ctype, o++, C[o] = 0, o++, C[o] = 0, o++, C[o] = 0, o++, M(C, o, w(C, o - 17, 17)), o += 4, M(C, o, 1), o += 4, m(C, o, "sRGB"), o += 4, C[o] = 1, o++, M(C, o, w(C, o - 5, 5)), o += 4;
                  var z = g.length > 1;
                  if (z && (M(C, o, 8), o += 4, m(C, o, "acTL"), o += 4, M(C, o, g.length), o += 4, M(C, o, 0), o += 4, M(C, o, w(C, o - 12, 12)), o += 4), E.ctype == 3) {
                    var O = E.plte.length;
                    M(C, o, O * 3), o += 4, m(C, o, "PLTE"), o += 4;
                    for (var y = 0; y < O; y++) {
                      var R = y * 3, B = E.plte[y], P = B & 255, W = B >> 8 & 255, U = B >> 16 & 255;
                      C[o + R + 0] = P, C[o + R + 1] = W, C[o + R + 2] = U;
                    }
                    if (o += O * 3, M(C, o, w(C, o - O * 3 - 4, O * 3 + 4)), o += 4, E.gotAlpha) {
                      M(C, o, O), o += 4, m(C, o, "tRNS"), o += 4;
                      for (var y = 0; y < O; y++) C[o + y] = E.plte[y] >> 24 & 255;
                      o += O, M(C, o, w(C, o - O - 4, O + 4)), o += 4;
                    }
                  }
                  for (var V = 0, K = 0; K < E.frames.length; K++) {
                    var q = E.frames[K];
                    z && (M(C, o, 26), o += 4, m(C, o, "fcTL"), o += 4, M(C, o, V++), o += 4, M(C, o, q.rect.width), o += 4, M(C, o, q.rect.height), o += 4, M(C, o, q.rect.x), o += 4, M(C, o, q.rect.y), o += 4, F(C, o, k[K]), o += 2, F(C, o, 1e3), o += 2, C[o] = q.dispose, o++, C[o] = q.blend, o++, M(C, o, w(C, o - 30, 30)), o += 4);
                    var H = q.cimg, O = H.length;
                    M(C, o, O + (K == 0 ? 0 : 4)), o += 4;
                    var j = o;
                    m(C, o, K == 0 ? "IDAT" : "fdAT"), o += 4, K != 0 && (M(C, o, V++), o += 4);
                    for (var y = 0; y < O; y++) C[o + y] = H[y];
                    o += O, M(C, o, w(C, j, o - j)), o += 4;
                  }
                  return M(C, o, 0), o += 4, m(C, o, "IEND"), o += 4, M(C, o, w(C, o - 4, 4)), o += 4, C.buffer.slice(0, o);
                }, h.encode.compressPNG = function(g, _, A, x, k) {
                  for (var $ = h.encode.compress(g, _, A, x, !1, k), C = 0; C < g.length; C++) {
                    var L = $.frames[C];
                    L.rect.width;
                    var y = L.rect.height, o = L.bpl, v = L.bpp, w = new Uint8Array(y * o + y);
                    L.cimg = h.encode._filterZero(L.img, y, v, o, w);
                  }
                  return $;
                }, h.encode.compress = function(g, _, A, x, k, $) {
                  $ == null && ($ = !1);
                  for (var C = 6, L = 8, y = 4, o = 255, v = 0; v < g.length; v++)
                    for (var w = new Uint8Array(g[v]), M = w.length, F = 0; F < M; F += 4) o &= w[F + 3];
                  var m = o != 255, E = {}, z = [];
                  if (g.length != 0 && (E[0] = 0, z.push(0), x != 0 && x--), x != 0) {
                    var O = h.quantize(g, x, k);
                    g = O.bufs;
                    for (var F = 0; F < O.plte.length; F++) {
                      var R = O.plte[F].est.rgba;
                      E[R] == null && (E[R] = z.length, z.push(R));
                    }
                  } else
                    for (var v = 0; v < g.length; v++)
                      for (var B = new Uint32Array(g[v]), M = B.length, F = 0; F < M; F++) {
                        var R = B[F];
                        if ((F < _ || R != B[F - 1] && R != B[F - _]) && E[R] == null && (E[R] = z.length, z.push(R), z.length >= 300))
                          break;
                      }
                  var P = m ? k : !1, W = z.length;
                  W <= 256 && $ == !1 && (W <= 2 ? L = 1 : W <= 4 ? L = 2 : W <= 16 ? L = 4 : L = 8, k && (L = 8), m = !0);
                  for (var U = [], v = 0; v < g.length; v++) {
                    var V = new Uint8Array(g[v]), K = new Uint32Array(V.buffer), q = 0, H = 0, j = _, Q = A, J = 0;
                    if (v != 0 && !P) {
                      for (var Y = k || v == 1 || U[U.length - 2].dispose == 2 ? 1 : 2, ee = 0, fe = 1e9, me = 0; me < Y; me++) {
                        for (var ge = new Uint8Array(g[v - 1 - me]), he = new Uint32Array(g[v - 1 - me]), we = _, ye = A, ve = -1, ce = -1, be = 0; be < A; be++) for (var le = 0; le < _; le++) {
                          var F = be * _ + le;
                          K[F] != he[F] && (le < we && (we = le), le > ve && (ve = le), be < ye && (ye = be), be > ce && (ce = be));
                        }
                        var Se = ve == -1 ? 1 : (ve - we + 1) * (ce - ye + 1);
                        Se < fe && (fe = Se, ee = me, ve == -1 ? (q = H = 0, j = Q = 1) : (q = we, H = ye, j = ve - we + 1, Q = ce - ye + 1));
                      }
                      var ge = new Uint8Array(g[v - 1 - ee]);
                      ee == 1 && (U[U.length - 1].dispose = 2);
                      var de = new Uint8Array(j * Q * 4);
                      new Uint32Array(de.buffer), h._copyTile(ge, _, A, de, j, Q, -q, -H, 0), h._copyTile(V, _, A, de, j, Q, -q, -H, 3) ? (h._copyTile(V, _, A, de, j, Q, -q, -H, 2), J = 1) : (h._copyTile(V, _, A, de, j, Q, -q, -H, 0), J = 0), V = de, K = new Uint32Array(V.buffer);
                    }
                    var De = 4 * j;
                    if (W <= 256 && $ == !1) {
                      De = Math.ceil(L * j / 8);
                      for (var de = new Uint8Array(De * Q), be = 0; be < Q; be++) {
                        var F = be * De, Be = be * j;
                        if (L == 8) for (var le = 0; le < j; le++) de[F + le] = E[K[Be + le]];
                        else if (L == 4) for (var le = 0; le < j; le++) de[F + (le >> 1)] |= E[K[Be + le]] << 4 - (le & 1) * 4;
                        else if (L == 2) for (var le = 0; le < j; le++) de[F + (le >> 2)] |= E[K[Be + le]] << 6 - (le & 3) * 2;
                        else if (L == 1) for (var le = 0; le < j; le++) de[F + (le >> 3)] |= E[K[Be + le]] << 7 - (le & 7) * 1;
                      }
                      V = de, C = 3, y = 1;
                    } else if (m == !1 && g.length == 1) {
                      for (var de = new Uint8Array(j * Q * 3), Ve = j * Q, F = 0; F < Ve; F++) {
                        var qe = F * 3, Ze = F * 4;
                        de[qe] = V[Ze], de[qe + 1] = V[Ze + 1], de[qe + 2] = V[Ze + 2];
                      }
                      V = de, C = 2, y = 3, De = 3 * j;
                    }
                    U.push({ rect: { x: q, y: H, width: j, height: Q }, img: V, bpl: De, bpp: y, blend: J, dispose: P ? 1 : 0 });
                  }
                  return { ctype: C, depth: L, plte: z, gotAlpha: m, frames: U };
                }, h.encode._filterZero = function(g, _, A, x, k) {
                  for (var $ = [], C = 0; C < 5; C++)
                    if (!(_ * x > 5e5 && (C == 2 || C == 3 || C == 4))) {
                      for (var L = 0; L < _; L++) h.encode._filterLine(k, g, L, x, A, C);
                      if ($.push(b.deflate(k)), A == 1) break;
                    }
                  for (var y, o = 1e9, v = 0; v < $.length; v++) $[v].length < o && (y = v, o = $[v].length);
                  return $[y];
                }, h.encode._filterLine = function(g, _, A, x, k, $) {
                  var C = A * x, L = C + A, y = h.decode._paeth;
                  if (g[L] = $, L++, $ == 0) for (var o = 0; o < x; o++) g[L + o] = _[C + o];
                  else if ($ == 1) {
                    for (var o = 0; o < k; o++) g[L + o] = _[C + o];
                    for (var o = k; o < x; o++) g[L + o] = _[C + o] - _[C + o - k] + 256 & 255;
                  } else if (A == 0) {
                    for (var o = 0; o < k; o++) g[L + o] = _[C + o];
                    if ($ == 2) for (var o = k; o < x; o++) g[L + o] = _[C + o];
                    if ($ == 3) for (var o = k; o < x; o++) g[L + o] = _[C + o] - (_[C + o - k] >> 1) + 256 & 255;
                    if ($ == 4) for (var o = k; o < x; o++) g[L + o] = _[C + o] - y(_[C + o - k], 0, 0) + 256 & 255;
                  } else {
                    if ($ == 2)
                      for (var o = 0; o < x; o++) g[L + o] = _[C + o] + 256 - _[C + o - x] & 255;
                    if ($ == 3) {
                      for (var o = 0; o < k; o++) g[L + o] = _[C + o] + 256 - (_[C + o - x] >> 1) & 255;
                      for (var o = k; o < x; o++) g[L + o] = _[C + o] + 256 - (_[C + o - x] + _[C + o - k] >> 1) & 255;
                    }
                    if ($ == 4) {
                      for (var o = 0; o < k; o++) g[L + o] = _[C + o] + 256 - y(0, _[C + o - x], 0) & 255;
                      for (var o = k; o < x; o++) g[L + o] = _[C + o] + 256 - y(_[C + o - k], _[C + o - x], _[C + o - k - x]) & 255;
                    }
                  }
                }, h.crc = {
                  table: function() {
                    for (var g = new Uint32Array(256), _ = 0; _ < 256; _++) {
                      for (var A = _, x = 0; x < 8; x++)
                        A & 1 ? A = 3988292384 ^ A >>> 1 : A = A >>> 1;
                      g[_] = A;
                    }
                    return g;
                  }(),
                  update: function(g, _, A, x) {
                    for (var k = 0; k < x; k++) g = h.crc.table[(g ^ _[A + k]) & 255] ^ g >>> 8;
                    return g;
                  },
                  crc: function(g, _, A) {
                    return h.crc.update(4294967295, g, _, A) ^ 4294967295;
                  }
                }, h.quantize = function(g, _, A) {
                  for (var x = [], k = 0, $ = 0; $ < g.length; $++)
                    x.push(h.encode.alphaMul(new Uint8Array(g[$]), A)), k += g[$].byteLength;
                  for (var C = new Uint8Array(k), L = new Uint32Array(C.buffer), y = 0, $ = 0; $ < x.length; $++) {
                    for (var o = x[$], v = o.length, w = 0; w < v; w++) C[y + w] = o[w];
                    y += v;
                  }
                  var M = { i0: 0, i1: C.length, bst: null, est: null, tdst: 0, left: null, right: null };
                  M.bst = h.quantize.stats(C, M.i0, M.i1), M.est = h.quantize.estats(M.bst);
                  for (var F = [M]; F.length < _; ) {
                    for (var m = 0, E = 0, $ = 0; $ < F.length; $++) F[$].est.L > m && (m = F[$].est.L, E = $);
                    if (m < 1e-3) break;
                    var z = F[E], O = h.quantize.splitPixels(C, L, z.i0, z.i1, z.est.e, z.est.eMq255), R = { i0: z.i0, i1: O, bst: null, est: null, tdst: 0, left: null, right: null };
                    R.bst = h.quantize.stats(C, R.i0, R.i1), R.est = h.quantize.estats(R.bst);
                    var B = { i0: O, i1: z.i1, bst: null, est: null, tdst: 0, left: null, right: null };
                    B.bst = { R: [], m: [], N: z.bst.N - R.bst.N };
                    for (var $ = 0; $ < 16; $++) B.bst.R[$] = z.bst.R[$] - R.bst.R[$];
                    for (var $ = 0; $ < 4; $++) B.bst.m[$] = z.bst.m[$] - R.bst.m[$];
                    B.est = h.quantize.estats(B.bst), z.left = R, z.right = B, F[E] = R, F.push(B);
                  }
                  F.sort(function(Y, ee) {
                    return ee.bst.N - Y.bst.N;
                  });
                  for (var P = 0; P < x.length; P++) {
                    for (var W = h.quantize.planeDst, U = new Uint8Array(x[P].buffer), V = new Uint32Array(x[P].buffer), K = U.length, $ = 0; $ < K; $ += 4) {
                      for (var q = U[$] * 0.00392156862745098, H = U[$ + 1] * (1 / 255), j = U[$ + 2] * (1 / 255), Q = U[$ + 3] * (1 / 255), J = M; J.left; ) J = W(J.est, q, H, j, Q) <= 0 ? J.left : J.right;
                      V[$ >> 2] = J.est.rgba;
                    }
                    x[P] = V.buffer;
                  }
                  return { bufs: x, plte: F };
                }, h.quantize.getNearest = function(g, _, A, x, k) {
                  if (g.left == null)
                    return g.tdst = h.quantize.dist(g.est.q, _, A, x, k), g;
                  var $ = h.quantize.planeDst(g.est, _, A, x, k), C = g.left, L = g.right;
                  $ > 0 && (C = g.right, L = g.left);
                  var y = h.quantize.getNearest(C, _, A, x, k);
                  if (y.tdst <= $ * $) return y;
                  var o = h.quantize.getNearest(L, _, A, x, k);
                  return o.tdst < y.tdst ? o : y;
                }, h.quantize.planeDst = function(g, _, A, x, k) {
                  var $ = g.e;
                  return $[0] * _ + $[1] * A + $[2] * x + $[3] * k - g.eMq;
                }, h.quantize.dist = function(g, _, A, x, k) {
                  var $ = _ - g[0], C = A - g[1], L = x - g[2], y = k - g[3];
                  return $ * $ + C * C + L * L + y * y;
                }, h.quantize.splitPixels = function(g, _, A, x, k, $) {
                  var C = h.quantize.vecDot;
                  for (x -= 4; A < x; ) {
                    for (; C(g, A, k) <= $; ) A += 4;
                    for (; C(g, x, k) > $; ) x -= 4;
                    if (A >= x) break;
                    var L = _[A >> 2];
                    _[A >> 2] = _[x >> 2], _[x >> 2] = L, A += 4, x -= 4;
                  }
                  for (; C(g, A, k) > $; ) A -= 4;
                  return A + 4;
                }, h.quantize.vecDot = function(g, _, A) {
                  return g[_] * A[0] + g[_ + 1] * A[1] + g[_ + 2] * A[2] + g[_ + 3] * A[3];
                }, h.quantize.stats = function(g, _, A) {
                  for (var x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], k = [0, 0, 0, 0], $ = A - _ >> 2, C = _; C < A; C += 4) {
                    var L = g[C] * 0.00392156862745098, y = g[C + 1] * (1 / 255), o = g[C + 2] * (1 / 255), v = g[C + 3] * (1 / 255);
                    k[0] += L, k[1] += y, k[2] += o, k[3] += v, x[0] += L * L, x[1] += L * y, x[2] += L * o, x[3] += L * v, x[5] += y * y, x[6] += y * o, x[7] += y * v, x[10] += o * o, x[11] += o * v, x[15] += v * v;
                  }
                  return x[4] = x[1], x[8] = x[2], x[12] = x[3], x[9] = x[6], x[13] = x[7], x[14] = x[11], { R: x, m: k, N: $ };
                }, h.quantize.estats = function(g) {
                  var _ = g.R, A = g.m, x = g.N, k = A[0], $ = A[1], C = A[2], L = A[3], y = x == 0 ? 0 : 1 / x, o = [
                    _[0] - k * k * y,
                    _[1] - k * $ * y,
                    _[2] - k * C * y,
                    _[3] - k * L * y,
                    _[4] - $ * k * y,
                    _[5] - $ * $ * y,
                    _[6] - $ * C * y,
                    _[7] - $ * L * y,
                    _[8] - C * k * y,
                    _[9] - C * $ * y,
                    _[10] - C * C * y,
                    _[11] - C * L * y,
                    _[12] - L * k * y,
                    _[13] - L * $ * y,
                    _[14] - L * C * y,
                    _[15] - L * L * y
                  ], v = o, w = h.M4, M = [0.5, 0.5, 0.5, 0.5], F = 0, m = 0;
                  if (x != 0)
                    for (var E = 0; E < 10 && (M = w.multVec(v, M), m = Math.sqrt(w.dot(M, M)), M = w.sml(1 / m, M), !(Math.abs(m - F) < 1e-9)); E++)
                      F = m;
                  var z = [k * y, $ * y, C * y, L * y], O = w.dot(w.sml(255, z), M), R = z[3] < 1e-3 ? 0 : 1 / z[3];
                  return {
                    Cov: o,
                    q: z,
                    e: M,
                    L: F,
                    eMq255: O,
                    eMq: w.dot(M, z),
                    rgba: (Math.round(255 * z[3]) << 24 | Math.round(255 * z[2] * R) << 16 | Math.round(255 * z[1] * R) << 8 | Math.round(255 * z[0] * R) << 0) >>> 0
                  };
                }, h.M4 = {
                  multVec: function(g, _) {
                    return [
                      g[0] * _[0] + g[1] * _[1] + g[2] * _[2] + g[3] * _[3],
                      g[4] * _[0] + g[5] * _[1] + g[6] * _[2] + g[7] * _[3],
                      g[8] * _[0] + g[9] * _[1] + g[10] * _[2] + g[11] * _[3],
                      g[12] * _[0] + g[13] * _[1] + g[14] * _[2] + g[15] * _[3]
                    ];
                  },
                  dot: function(g, _) {
                    return g[0] * _[0] + g[1] * _[1] + g[2] * _[2] + g[3] * _[3];
                  },
                  sml: function(g, _) {
                    return [g * _[0], g * _[1], g * _[2], g * _[3]];
                  }
                }, h.encode.alphaMul = function(g, _) {
                  for (var A = new Uint8Array(g.length), x = g.length >> 2, k = 0; k < x; k++) {
                    var $ = k << 2, C = g[$ + 3];
                    _ && (C = C < 128 ? 0 : 255);
                    var L = C * (1 / 255);
                    A[$ + 0] = g[$ + 0] * L, A[$ + 1] = g[$ + 1] * L, A[$ + 2] = g[$ + 2] * L, A[$ + 3] = C;
                  }
                  return A;
                };
              }(n, s);
            })();
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/index.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/index.js ***!
            \*********************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ./lib/utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ).assign, s = r(
              /*! ./lib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/deflate.js"
            ), h = r(
              /*! ./lib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/inflate.js"
            ), b = r(
              /*! ./lib/zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), g = {};
            n(g, s, h, b), a.exports = g;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/deflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/deflate.js ***!
            \***************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ./zlib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js"
            ), s = r(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), h = r(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), b = r(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), g = r(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), _ = Object.prototype.toString, A = 0, x = 4, k = 0, $ = 1, C = 2, L = -1, y = 0, o = 8;
            function v(m) {
              if (!(this instanceof v)) return new v(m);
              this.options = s.assign({
                level: L,
                method: o,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: y,
                to: ""
              }, m || {});
              var E = this.options;
              E.raw && E.windowBits > 0 ? E.windowBits = -E.windowBits : E.gzip && E.windowBits > 0 && E.windowBits < 16 && (E.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new g(), this.strm.avail_out = 0;
              var z = n.deflateInit2(
                this.strm,
                E.level,
                E.method,
                E.windowBits,
                E.memLevel,
                E.strategy
              );
              if (z !== k)
                throw new Error(b[z]);
              if (E.header && n.deflateSetHeader(this.strm, E.header), E.dictionary) {
                var O;
                if (typeof E.dictionary == "string" ? O = h.string2buf(E.dictionary) : _.call(E.dictionary) === "[object ArrayBuffer]" ? O = new Uint8Array(E.dictionary) : O = E.dictionary, z = n.deflateSetDictionary(this.strm, O), z !== k)
                  throw new Error(b[z]);
                this._dict_set = !0;
              }
            }
            v.prototype.push = function(m, E) {
              var z = this.strm, O = this.options.chunkSize, R, B;
              if (this.ended)
                return !1;
              B = E === ~~E ? E : E === !0 ? x : A, typeof m == "string" ? z.input = h.string2buf(m) : _.call(m) === "[object ArrayBuffer]" ? z.input = new Uint8Array(m) : z.input = m, z.next_in = 0, z.avail_in = z.input.length;
              do {
                if (z.avail_out === 0 && (z.output = new s.Buf8(O), z.next_out = 0, z.avail_out = O), R = n.deflate(z, B), R !== $ && R !== k)
                  return this.onEnd(R), this.ended = !0, !1;
                (z.avail_out === 0 || z.avail_in === 0 && (B === x || B === C)) && (this.options.to === "string" ? this.onData(h.buf2binstring(s.shrinkBuf(z.output, z.next_out))) : this.onData(s.shrinkBuf(z.output, z.next_out)));
              } while ((z.avail_in > 0 || z.avail_out === 0) && R !== $);
              return B === x ? (R = n.deflateEnd(this.strm), this.onEnd(R), this.ended = !0, R === k) : (B === C && (this.onEnd(k), z.avail_out = 0), !0);
            }, v.prototype.onData = function(m) {
              this.chunks.push(m);
            }, v.prototype.onEnd = function(m) {
              m === k && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
            };
            function w(m, E) {
              var z = new v(E);
              if (z.push(m, !0), z.err)
                throw z.msg || b[z.err];
              return z.result;
            }
            function M(m, E) {
              return E = E || {}, E.raw = !0, w(m, E);
            }
            function F(m, E) {
              return E = E || {}, E.gzip = !0, w(m, E);
            }
            e.Deflate = v, e.deflate = w, e.deflateRaw = M, e.gzip = F;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/inflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/inflate.js ***!
            \***************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ./zlib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js"
            ), s = r(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), h = r(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), b = r(
              /*! ./zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), g = r(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), _ = r(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), A = r(
              /*! ./zlib/gzheader */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js"
            ), x = Object.prototype.toString;
            function k(L) {
              if (!(this instanceof k)) return new k(L);
              this.options = s.assign({
                chunkSize: 16384,
                windowBits: 0,
                to: ""
              }, L || {});
              var y = this.options;
              y.raw && y.windowBits >= 0 && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), y.windowBits >= 0 && y.windowBits < 16 && !(L && L.windowBits) && (y.windowBits += 32), y.windowBits > 15 && y.windowBits < 48 && (y.windowBits & 15 || (y.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new _(), this.strm.avail_out = 0;
              var o = n.inflateInit2(
                this.strm,
                y.windowBits
              );
              if (o !== b.Z_OK)
                throw new Error(g[o]);
              if (this.header = new A(), n.inflateGetHeader(this.strm, this.header), y.dictionary && (typeof y.dictionary == "string" ? y.dictionary = h.string2buf(y.dictionary) : x.call(y.dictionary) === "[object ArrayBuffer]" && (y.dictionary = new Uint8Array(y.dictionary)), y.raw && (o = n.inflateSetDictionary(this.strm, y.dictionary), o !== b.Z_OK)))
                throw new Error(g[o]);
            }
            k.prototype.push = function(L, y) {
              var o = this.strm, v = this.options.chunkSize, w = this.options.dictionary, M, F, m, E, z, O = !1;
              if (this.ended)
                return !1;
              F = y === ~~y ? y : y === !0 ? b.Z_FINISH : b.Z_NO_FLUSH, typeof L == "string" ? o.input = h.binstring2buf(L) : x.call(L) === "[object ArrayBuffer]" ? o.input = new Uint8Array(L) : o.input = L, o.next_in = 0, o.avail_in = o.input.length;
              do {
                if (o.avail_out === 0 && (o.output = new s.Buf8(v), o.next_out = 0, o.avail_out = v), M = n.inflate(o, b.Z_NO_FLUSH), M === b.Z_NEED_DICT && w && (M = n.inflateSetDictionary(this.strm, w)), M === b.Z_BUF_ERROR && O === !0 && (M = b.Z_OK, O = !1), M !== b.Z_STREAM_END && M !== b.Z_OK)
                  return this.onEnd(M), this.ended = !0, !1;
                o.next_out && (o.avail_out === 0 || M === b.Z_STREAM_END || o.avail_in === 0 && (F === b.Z_FINISH || F === b.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (m = h.utf8border(o.output, o.next_out), E = o.next_out - m, z = h.buf2string(o.output, m), o.next_out = E, o.avail_out = v - E, E && s.arraySet(o.output, o.output, m, E, 0), this.onData(z)) : this.onData(s.shrinkBuf(o.output, o.next_out))), o.avail_in === 0 && o.avail_out === 0 && (O = !0);
              } while ((o.avail_in > 0 || o.avail_out === 0) && M !== b.Z_STREAM_END);
              return M === b.Z_STREAM_END && (F = b.Z_FINISH), F === b.Z_FINISH ? (M = n.inflateEnd(this.strm), this.onEnd(M), this.ended = !0, M === b.Z_OK) : (F === b.Z_SYNC_FLUSH && (this.onEnd(b.Z_OK), o.avail_out = 0), !0);
            }, k.prototype.onData = function(L) {
              this.chunks.push(L);
            }, k.prototype.onEnd = function(L) {
              L === b.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = L, this.msg = this.strm.msg;
            };
            function $(L, y) {
              var o = new k(y);
              if (o.push(L, !0), o.err)
                throw o.msg || g[o.err];
              return o.result;
            }
            function C(L, y) {
              return y = y || {}, y.raw = !0, $(L, y);
            }
            e.Inflate = k, e.inflate = $, e.inflateRaw = C, e.ungzip = $;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/common.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/common.js ***!
            \********************************************************************/
          /***/
          (a, e) => {
            var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            function n(b, g) {
              return Object.prototype.hasOwnProperty.call(b, g);
            }
            e.assign = function(b) {
              for (var g = Array.prototype.slice.call(arguments, 1); g.length; ) {
                var _ = g.shift();
                if (_) {
                  if (typeof _ != "object")
                    throw new TypeError(_ + "must be non-object");
                  for (var A in _)
                    n(_, A) && (b[A] = _[A]);
                }
              }
              return b;
            }, e.shrinkBuf = function(b, g) {
              return b.length === g ? b : b.subarray ? b.subarray(0, g) : (b.length = g, b);
            };
            var s = {
              arraySet: function(b, g, _, A, x) {
                if (g.subarray && b.subarray) {
                  b.set(g.subarray(_, _ + A), x);
                  return;
                }
                for (var k = 0; k < A; k++)
                  b[x + k] = g[_ + k];
              },
              // Join array of chunks to single array.
              flattenChunks: function(b) {
                var g, _, A, x, k, $;
                for (A = 0, g = 0, _ = b.length; g < _; g++)
                  A += b[g].length;
                for ($ = new Uint8Array(A), x = 0, g = 0, _ = b.length; g < _; g++)
                  k = b[g], $.set(k, x), x += k.length;
                return $;
              }
            }, h = {
              arraySet: function(b, g, _, A, x) {
                for (var k = 0; k < A; k++)
                  b[x + k] = g[_ + k];
              },
              // Join array of chunks to single array.
              flattenChunks: function(b) {
                return [].concat.apply([], b);
              }
            };
            e.setTyped = function(b) {
              b ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, s)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, h));
            }, e.setTyped(r);
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/strings.js ***!
            \*********************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ./common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), s = !0, h = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              s = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              h = !1;
            }
            for (var b = new n.Buf8(256), g = 0; g < 256; g++)
              b[g] = g >= 252 ? 6 : g >= 248 ? 5 : g >= 240 ? 4 : g >= 224 ? 3 : g >= 192 ? 2 : 1;
            b[254] = b[254] = 1, e.string2buf = function(A) {
              var x, k, $, C, L, y = A.length, o = 0;
              for (C = 0; C < y; C++)
                k = A.charCodeAt(C), (k & 64512) === 55296 && C + 1 < y && ($ = A.charCodeAt(C + 1), ($ & 64512) === 56320 && (k = 65536 + (k - 55296 << 10) + ($ - 56320), C++)), o += k < 128 ? 1 : k < 2048 ? 2 : k < 65536 ? 3 : 4;
              for (x = new n.Buf8(o), L = 0, C = 0; L < o; C++)
                k = A.charCodeAt(C), (k & 64512) === 55296 && C + 1 < y && ($ = A.charCodeAt(C + 1), ($ & 64512) === 56320 && (k = 65536 + (k - 55296 << 10) + ($ - 56320), C++)), k < 128 ? x[L++] = k : k < 2048 ? (x[L++] = 192 | k >>> 6, x[L++] = 128 | k & 63) : k < 65536 ? (x[L++] = 224 | k >>> 12, x[L++] = 128 | k >>> 6 & 63, x[L++] = 128 | k & 63) : (x[L++] = 240 | k >>> 18, x[L++] = 128 | k >>> 12 & 63, x[L++] = 128 | k >>> 6 & 63, x[L++] = 128 | k & 63);
              return x;
            };
            function _(A, x) {
              if (x < 65534 && (A.subarray && h || !A.subarray && s))
                return String.fromCharCode.apply(null, n.shrinkBuf(A, x));
              for (var k = "", $ = 0; $ < x; $++)
                k += String.fromCharCode(A[$]);
              return k;
            }
            e.buf2binstring = function(A) {
              return _(A, A.length);
            }, e.binstring2buf = function(A) {
              for (var x = new n.Buf8(A.length), k = 0, $ = x.length; k < $; k++)
                x[k] = A.charCodeAt(k);
              return x;
            }, e.buf2string = function(A, x) {
              var k, $, C, L, y = x || A.length, o = new Array(y * 2);
              for ($ = 0, k = 0; k < y; ) {
                if (C = A[k++], C < 128) {
                  o[$++] = C;
                  continue;
                }
                if (L = b[C], L > 4) {
                  o[$++] = 65533, k += L - 1;
                  continue;
                }
                for (C &= L === 2 ? 31 : L === 3 ? 15 : 7; L > 1 && k < y; )
                  C = C << 6 | A[k++] & 63, L--;
                if (L > 1) {
                  o[$++] = 65533;
                  continue;
                }
                C < 65536 ? o[$++] = C : (C -= 65536, o[$++] = 55296 | C >> 10 & 1023, o[$++] = 56320 | C & 1023);
              }
              return _(o, $);
            }, e.utf8border = function(A, x) {
              var k;
              for (x = x || A.length, x > A.length && (x = A.length), k = x - 1; k >= 0 && (A[k] & 192) === 128; )
                k--;
              return k < 0 || k === 0 ? x : k + b[A[k]] > x ? k : x;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js ***!
            \********************************************************************/
          /***/
          (a) => {
            function e(r, n, s, h) {
              for (var b = r & 65535 | 0, g = r >>> 16 & 65535 | 0, _ = 0; s !== 0; ) {
                _ = s > 2e3 ? 2e3 : s, s -= _;
                do
                  b = b + n[h++] | 0, g = g + b | 0;
                while (--_);
                b %= 65521, g %= 65521;
              }
              return b | g << 16 | 0;
            }
            a.exports = e;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js": (
          /*!**********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js ***!
            \**********************************************************************/
          /***/
          (a) => {
            a.exports = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              //Z_MEM_ERROR:     -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js ***!
            \******************************************************************/
          /***/
          (a) => {
            function e() {
              for (var s, h = [], b = 0; b < 256; b++) {
                s = b;
                for (var g = 0; g < 8; g++)
                  s = s & 1 ? 3988292384 ^ s >>> 1 : s >>> 1;
                h[b] = s;
              }
              return h;
            }
            var r = e();
            function n(s, h, b, g) {
              var _ = r, A = g + b;
              s ^= -1;
              for (var x = g; x < A; x++)
                s = s >>> 8 ^ _[(s ^ h[x]) & 255];
              return s ^ -1;
            }
            a.exports = n;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js ***!
            \********************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), s = r(
              /*! ./trees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js"
            ), h = r(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), b = r(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), g = r(
              /*! ./messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), _ = 0, A = 1, x = 3, k = 4, $ = 5, C = 0, L = 1, y = -2, o = -3, v = -5, w = -1, M = 1, F = 2, m = 3, E = 4, z = 0, O = 2, R = 8, B = 9, P = 15, W = 8, U = 29, V = 256, K = V + 1 + U, q = 30, H = 19, j = 2 * K + 1, Q = 15, J = 3, Y = 258, ee = Y + J + 1, fe = 32, me = 42, he = 69, we = 73, ye = 91, ve = 103, ce = 113, be = 666, le = 1, Se = 2, ge = 3, de = 4, De = 3;
            function Be(G, Fe) {
              return G.msg = g[Fe], Fe;
            }
            function Ve(G) {
              return (G << 1) - (G > 4 ? 9 : 0);
            }
            function qe(G) {
              for (var Fe = G.length; --Fe >= 0; )
                G[Fe] = 0;
            }
            function Ze(G) {
              var Fe = G.state, Te = Fe.pending;
              Te > G.avail_out && (Te = G.avail_out), Te !== 0 && (n.arraySet(G.output, Fe.pending_buf, Fe.pending_out, Te, G.next_out), G.next_out += Te, Fe.pending_out += Te, G.total_out += Te, G.avail_out -= Te, Fe.pending -= Te, Fe.pending === 0 && (Fe.pending_out = 0));
            }
            function Ye(G, Fe) {
              s._tr_flush_block(G, G.block_start >= 0 ? G.block_start : -1, G.strstart - G.block_start, Fe), G.block_start = G.strstart, Ze(G.strm);
            }
            function Xe(G, Fe) {
              G.pending_buf[G.pending++] = Fe;
            }
            function Ge(G, Fe) {
              G.pending_buf[G.pending++] = Fe >>> 8 & 255, G.pending_buf[G.pending++] = Fe & 255;
            }
            function Ke(G, Fe, Te, ae) {
              var Ee = G.avail_in;
              return Ee > ae && (Ee = ae), Ee === 0 ? 0 : (G.avail_in -= Ee, n.arraySet(Fe, G.input, G.next_in, Ee, Te), G.state.wrap === 1 ? G.adler = h(G.adler, Fe, Ee, Te) : G.state.wrap === 2 && (G.adler = b(G.adler, Fe, Ee, Te)), G.next_in += Ee, G.total_in += Ee, Ee);
            }
            function Pe(G, Fe) {
              var Te = G.max_chain_length, ae = G.strstart, Ee, Ie, lt = G.prev_length, st = G.nice_match, at = G.strstart > G.w_size - ee ? G.strstart - (G.w_size - ee) : 0, gt = G.window, Ot = G.w_mask, vt = G.prev, yt = G.strstart + Y, _t = gt[ae + lt - 1], Bt = gt[ae + lt];
              G.prev_length >= G.good_match && (Te >>= 2), st > G.lookahead && (st = G.lookahead);
              do
                if (Ee = Fe, !(gt[Ee + lt] !== Bt || gt[Ee + lt - 1] !== _t || gt[Ee] !== gt[ae] || gt[++Ee] !== gt[ae + 1])) {
                  ae += 2, Ee++;
                  do
                    ;
                  while (gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && gt[++ae] === gt[++Ee] && ae < yt);
                  if (Ie = Y - (yt - ae), ae = yt - Y, Ie > lt) {
                    if (G.match_start = Fe, lt = Ie, Ie >= st)
                      break;
                    _t = gt[ae + lt - 1], Bt = gt[ae + lt];
                  }
                }
              while ((Fe = vt[Fe & Ot]) > at && --Te !== 0);
              return lt <= G.lookahead ? lt : G.lookahead;
            }
            function it(G) {
              var Fe = G.w_size, Te, ae, Ee, Ie, lt;
              do {
                if (Ie = G.window_size - G.lookahead - G.strstart, G.strstart >= Fe + (Fe - ee)) {
                  n.arraySet(G.window, G.window, Fe, Fe, 0), G.match_start -= Fe, G.strstart -= Fe, G.block_start -= Fe, ae = G.hash_size, Te = ae;
                  do
                    Ee = G.head[--Te], G.head[Te] = Ee >= Fe ? Ee - Fe : 0;
                  while (--ae);
                  ae = Fe, Te = ae;
                  do
                    Ee = G.prev[--Te], G.prev[Te] = Ee >= Fe ? Ee - Fe : 0;
                  while (--ae);
                  Ie += Fe;
                }
                if (G.strm.avail_in === 0)
                  break;
                if (ae = Ke(G.strm, G.window, G.strstart + G.lookahead, Ie), G.lookahead += ae, G.lookahead + G.insert >= J)
                  for (lt = G.strstart - G.insert, G.ins_h = G.window[lt], G.ins_h = (G.ins_h << G.hash_shift ^ G.window[lt + 1]) & G.hash_mask; G.insert && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[lt + J - 1]) & G.hash_mask, G.prev[lt & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = lt, lt++, G.insert--, !(G.lookahead + G.insert < J)); )
                    ;
              } while (G.lookahead < ee && G.strm.avail_in !== 0);
            }
            function nt(G, Fe) {
              var Te = 65535;
              for (Te > G.pending_buf_size - 5 && (Te = G.pending_buf_size - 5); ; ) {
                if (G.lookahead <= 1) {
                  if (it(G), G.lookahead === 0 && Fe === _)
                    return le;
                  if (G.lookahead === 0)
                    break;
                }
                G.strstart += G.lookahead, G.lookahead = 0;
                var ae = G.block_start + Te;
                if ((G.strstart === 0 || G.strstart >= ae) && (G.lookahead = G.strstart - ae, G.strstart = ae, Ye(G, !1), G.strm.avail_out === 0) || G.strstart - G.block_start >= G.w_size - ee && (Ye(G, !1), G.strm.avail_out === 0))
                  return le;
              }
              return G.insert = 0, Fe === k ? (Ye(G, !0), G.strm.avail_out === 0 ? ge : de) : (G.strstart > G.block_start && (Ye(G, !1), G.strm.avail_out === 0), le);
            }
            function ne(G, Fe) {
              for (var Te, ae; ; ) {
                if (G.lookahead < ee) {
                  if (it(G), G.lookahead < ee && Fe === _)
                    return le;
                  if (G.lookahead === 0)
                    break;
                }
                if (Te = 0, G.lookahead >= J && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + J - 1]) & G.hash_mask, Te = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart), Te !== 0 && G.strstart - Te <= G.w_size - ee && (G.match_length = Pe(G, Te)), G.match_length >= J)
                  if (ae = s._tr_tally(G, G.strstart - G.match_start, G.match_length - J), G.lookahead -= G.match_length, G.match_length <= G.max_lazy_match && G.lookahead >= J) {
                    G.match_length--;
                    do
                      G.strstart++, G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + J - 1]) & G.hash_mask, Te = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart;
                    while (--G.match_length !== 0);
                    G.strstart++;
                  } else
                    G.strstart += G.match_length, G.match_length = 0, G.ins_h = G.window[G.strstart], G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + 1]) & G.hash_mask;
                else
                  ae = s._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++;
                if (ae && (Ye(G, !1), G.strm.avail_out === 0))
                  return le;
              }
              return G.insert = G.strstart < J - 1 ? G.strstart : J - 1, Fe === k ? (Ye(G, !0), G.strm.avail_out === 0 ? ge : de) : G.last_lit && (Ye(G, !1), G.strm.avail_out === 0) ? le : Se;
            }
            function se(G, Fe) {
              for (var Te, ae, Ee; ; ) {
                if (G.lookahead < ee) {
                  if (it(G), G.lookahead < ee && Fe === _)
                    return le;
                  if (G.lookahead === 0)
                    break;
                }
                if (Te = 0, G.lookahead >= J && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + J - 1]) & G.hash_mask, Te = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart), G.prev_length = G.match_length, G.prev_match = G.match_start, G.match_length = J - 1, Te !== 0 && G.prev_length < G.max_lazy_match && G.strstart - Te <= G.w_size - ee && (G.match_length = Pe(G, Te), G.match_length <= 5 && (G.strategy === M || G.match_length === J && G.strstart - G.match_start > 4096) && (G.match_length = J - 1)), G.prev_length >= J && G.match_length <= G.prev_length) {
                  Ee = G.strstart + G.lookahead - J, ae = s._tr_tally(G, G.strstart - 1 - G.prev_match, G.prev_length - J), G.lookahead -= G.prev_length - 1, G.prev_length -= 2;
                  do
                    ++G.strstart <= Ee && (G.ins_h = (G.ins_h << G.hash_shift ^ G.window[G.strstart + J - 1]) & G.hash_mask, Te = G.prev[G.strstart & G.w_mask] = G.head[G.ins_h], G.head[G.ins_h] = G.strstart);
                  while (--G.prev_length !== 0);
                  if (G.match_available = 0, G.match_length = J - 1, G.strstart++, ae && (Ye(G, !1), G.strm.avail_out === 0))
                    return le;
                } else if (G.match_available) {
                  if (ae = s._tr_tally(G, 0, G.window[G.strstart - 1]), ae && Ye(G, !1), G.strstart++, G.lookahead--, G.strm.avail_out === 0)
                    return le;
                } else
                  G.match_available = 1, G.strstart++, G.lookahead--;
              }
              return G.match_available && (ae = s._tr_tally(G, 0, G.window[G.strstart - 1]), G.match_available = 0), G.insert = G.strstart < J - 1 ? G.strstart : J - 1, Fe === k ? (Ye(G, !0), G.strm.avail_out === 0 ? ge : de) : G.last_lit && (Ye(G, !1), G.strm.avail_out === 0) ? le : Se;
            }
            function ue(G, Fe) {
              for (var Te, ae, Ee, Ie, lt = G.window; ; ) {
                if (G.lookahead <= Y) {
                  if (it(G), G.lookahead <= Y && Fe === _)
                    return le;
                  if (G.lookahead === 0)
                    break;
                }
                if (G.match_length = 0, G.lookahead >= J && G.strstart > 0 && (Ee = G.strstart - 1, ae = lt[Ee], ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee])) {
                  Ie = G.strstart + Y;
                  do
                    ;
                  while (ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && ae === lt[++Ee] && Ee < Ie);
                  G.match_length = Y - (Ie - Ee), G.match_length > G.lookahead && (G.match_length = G.lookahead);
                }
                if (G.match_length >= J ? (Te = s._tr_tally(G, 1, G.match_length - J), G.lookahead -= G.match_length, G.strstart += G.match_length, G.match_length = 0) : (Te = s._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++), Te && (Ye(G, !1), G.strm.avail_out === 0))
                  return le;
              }
              return G.insert = 0, Fe === k ? (Ye(G, !0), G.strm.avail_out === 0 ? ge : de) : G.last_lit && (Ye(G, !1), G.strm.avail_out === 0) ? le : Se;
            }
            function $e(G, Fe) {
              for (var Te; ; ) {
                if (G.lookahead === 0 && (it(G), G.lookahead === 0)) {
                  if (Fe === _)
                    return le;
                  break;
                }
                if (G.match_length = 0, Te = s._tr_tally(G, 0, G.window[G.strstart]), G.lookahead--, G.strstart++, Te && (Ye(G, !1), G.strm.avail_out === 0))
                  return le;
              }
              return G.insert = 0, Fe === k ? (Ye(G, !0), G.strm.avail_out === 0 ? ge : de) : G.last_lit && (Ye(G, !1), G.strm.avail_out === 0) ? le : Se;
            }
            function Ae(G, Fe, Te, ae, Ee) {
              this.good_length = G, this.max_lazy = Fe, this.nice_length = Te, this.max_chain = ae, this.func = Ee;
            }
            var je;
            je = [
              /*      good lazy nice chain */
              new Ae(0, 0, 0, 0, nt),
              /* 0 store only */
              new Ae(4, 4, 8, 4, ne),
              /* 1 max speed, no lazy matches */
              new Ae(4, 5, 16, 8, ne),
              /* 2 */
              new Ae(4, 6, 32, 32, ne),
              /* 3 */
              new Ae(4, 4, 16, 16, se),
              /* 4 lazy matches */
              new Ae(8, 16, 32, 32, se),
              /* 5 */
              new Ae(8, 16, 128, 128, se),
              /* 6 */
              new Ae(8, 32, 128, 256, se),
              /* 7 */
              new Ae(32, 128, 258, 1024, se),
              /* 8 */
              new Ae(32, 258, 258, 4096, se)
              /* 9 max compression */
            ];
            function ze(G) {
              G.window_size = 2 * G.w_size, qe(G.head), G.max_lazy_match = je[G.level].max_lazy, G.good_match = je[G.level].good_length, G.nice_match = je[G.level].nice_length, G.max_chain_length = je[G.level].max_chain, G.strstart = 0, G.block_start = 0, G.lookahead = 0, G.insert = 0, G.match_length = G.prev_length = J - 1, G.match_available = 0, G.ins_h = 0;
            }
            function re() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = R, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(j * 2), this.dyn_dtree = new n.Buf16((2 * q + 1) * 2), this.bl_tree = new n.Buf16((2 * H + 1) * 2), qe(this.dyn_ltree), qe(this.dyn_dtree), qe(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(Q + 1), this.heap = new n.Buf16(2 * K + 1), qe(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * K + 1), qe(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function xe(G) {
              var Fe;
              return !G || !G.state ? Be(G, y) : (G.total_in = G.total_out = 0, G.data_type = O, Fe = G.state, Fe.pending = 0, Fe.pending_out = 0, Fe.wrap < 0 && (Fe.wrap = -Fe.wrap), Fe.status = Fe.wrap ? me : ce, G.adler = Fe.wrap === 2 ? 0 : 1, Fe.last_flush = _, s._tr_init(Fe), C);
            }
            function Le(G) {
              var Fe = xe(G);
              return Fe === C && ze(G.state), Fe;
            }
            function He(G, Fe) {
              return !G || !G.state || G.state.wrap !== 2 ? y : (G.state.gzhead = Fe, C);
            }
            function Me(G, Fe, Te, ae, Ee, Ie) {
              if (!G)
                return y;
              var lt = 1;
              if (Fe === w && (Fe = 6), ae < 0 ? (lt = 0, ae = -ae) : ae > 15 && (lt = 2, ae -= 16), Ee < 1 || Ee > B || Te !== R || ae < 8 || ae > 15 || Fe < 0 || Fe > 9 || Ie < 0 || Ie > E)
                return Be(G, y);
              ae === 8 && (ae = 9);
              var st = new re();
              return G.state = st, st.strm = G, st.wrap = lt, st.gzhead = null, st.w_bits = ae, st.w_size = 1 << st.w_bits, st.w_mask = st.w_size - 1, st.hash_bits = Ee + 7, st.hash_size = 1 << st.hash_bits, st.hash_mask = st.hash_size - 1, st.hash_shift = ~~((st.hash_bits + J - 1) / J), st.window = new n.Buf8(st.w_size * 2), st.head = new n.Buf16(st.hash_size), st.prev = new n.Buf16(st.w_size), st.lit_bufsize = 1 << Ee + 6, st.pending_buf_size = st.lit_bufsize * 4, st.pending_buf = new n.Buf8(st.pending_buf_size), st.d_buf = 1 * st.lit_bufsize, st.l_buf = 3 * st.lit_bufsize, st.level = Fe, st.strategy = Ie, st.method = Te, Le(G);
            }
            function Re(G, Fe) {
              return Me(G, Fe, R, P, W, z);
            }
            function ie(G, Fe) {
              var Te, ae, Ee, Ie;
              if (!G || !G.state || Fe > $ || Fe < 0)
                return G ? Be(G, y) : y;
              if (ae = G.state, !G.output || !G.input && G.avail_in !== 0 || ae.status === be && Fe !== k)
                return Be(G, G.avail_out === 0 ? v : y);
              if (ae.strm = G, Te = ae.last_flush, ae.last_flush = Fe, ae.status === me)
                if (ae.wrap === 2)
                  G.adler = 0, Xe(ae, 31), Xe(ae, 139), Xe(ae, 8), ae.gzhead ? (Xe(
                    ae,
                    (ae.gzhead.text ? 1 : 0) + (ae.gzhead.hcrc ? 2 : 0) + (ae.gzhead.extra ? 4 : 0) + (ae.gzhead.name ? 8 : 0) + (ae.gzhead.comment ? 16 : 0)
                  ), Xe(ae, ae.gzhead.time & 255), Xe(ae, ae.gzhead.time >> 8 & 255), Xe(ae, ae.gzhead.time >> 16 & 255), Xe(ae, ae.gzhead.time >> 24 & 255), Xe(ae, ae.level === 9 ? 2 : ae.strategy >= F || ae.level < 2 ? 4 : 0), Xe(ae, ae.gzhead.os & 255), ae.gzhead.extra && ae.gzhead.extra.length && (Xe(ae, ae.gzhead.extra.length & 255), Xe(ae, ae.gzhead.extra.length >> 8 & 255)), ae.gzhead.hcrc && (G.adler = b(G.adler, ae.pending_buf, ae.pending, 0)), ae.gzindex = 0, ae.status = he) : (Xe(ae, 0), Xe(ae, 0), Xe(ae, 0), Xe(ae, 0), Xe(ae, 0), Xe(ae, ae.level === 9 ? 2 : ae.strategy >= F || ae.level < 2 ? 4 : 0), Xe(ae, De), ae.status = ce);
                else {
                  var lt = R + (ae.w_bits - 8 << 4) << 8, st = -1;
                  ae.strategy >= F || ae.level < 2 ? st = 0 : ae.level < 6 ? st = 1 : ae.level === 6 ? st = 2 : st = 3, lt |= st << 6, ae.strstart !== 0 && (lt |= fe), lt += 31 - lt % 31, ae.status = ce, Ge(ae, lt), ae.strstart !== 0 && (Ge(ae, G.adler >>> 16), Ge(ae, G.adler & 65535)), G.adler = 1;
                }
              if (ae.status === he)
                if (ae.gzhead.extra) {
                  for (Ee = ae.pending; ae.gzindex < (ae.gzhead.extra.length & 65535) && !(ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), Ze(G), Ee = ae.pending, ae.pending === ae.pending_buf_size)); )
                    Xe(ae, ae.gzhead.extra[ae.gzindex] & 255), ae.gzindex++;
                  ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), ae.gzindex === ae.gzhead.extra.length && (ae.gzindex = 0, ae.status = we);
                } else
                  ae.status = we;
              if (ae.status === we)
                if (ae.gzhead.name) {
                  Ee = ae.pending;
                  do {
                    if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), Ze(G), Ee = ae.pending, ae.pending === ae.pending_buf_size)) {
                      Ie = 1;
                      break;
                    }
                    ae.gzindex < ae.gzhead.name.length ? Ie = ae.gzhead.name.charCodeAt(ae.gzindex++) & 255 : Ie = 0, Xe(ae, Ie);
                  } while (Ie !== 0);
                  ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), Ie === 0 && (ae.gzindex = 0, ae.status = ye);
                } else
                  ae.status = ye;
              if (ae.status === ye)
                if (ae.gzhead.comment) {
                  Ee = ae.pending;
                  do {
                    if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), Ze(G), Ee = ae.pending, ae.pending === ae.pending_buf_size)) {
                      Ie = 1;
                      break;
                    }
                    ae.gzindex < ae.gzhead.comment.length ? Ie = ae.gzhead.comment.charCodeAt(ae.gzindex++) & 255 : Ie = 0, Xe(ae, Ie);
                  } while (Ie !== 0);
                  ae.gzhead.hcrc && ae.pending > Ee && (G.adler = b(G.adler, ae.pending_buf, ae.pending - Ee, Ee)), Ie === 0 && (ae.status = ve);
                } else
                  ae.status = ve;
              if (ae.status === ve && (ae.gzhead.hcrc ? (ae.pending + 2 > ae.pending_buf_size && Ze(G), ae.pending + 2 <= ae.pending_buf_size && (Xe(ae, G.adler & 255), Xe(ae, G.adler >> 8 & 255), G.adler = 0, ae.status = ce)) : ae.status = ce), ae.pending !== 0) {
                if (Ze(G), G.avail_out === 0)
                  return ae.last_flush = -1, C;
              } else if (G.avail_in === 0 && Ve(Fe) <= Ve(Te) && Fe !== k)
                return Be(G, v);
              if (ae.status === be && G.avail_in !== 0)
                return Be(G, v);
              if (G.avail_in !== 0 || ae.lookahead !== 0 || Fe !== _ && ae.status !== be) {
                var at = ae.strategy === F ? $e(ae, Fe) : ae.strategy === m ? ue(ae, Fe) : je[ae.level].func(ae, Fe);
                if ((at === ge || at === de) && (ae.status = be), at === le || at === ge)
                  return G.avail_out === 0 && (ae.last_flush = -1), C;
                if (at === Se && (Fe === A ? s._tr_align(ae) : Fe !== $ && (s._tr_stored_block(ae, 0, 0, !1), Fe === x && (qe(ae.head), ae.lookahead === 0 && (ae.strstart = 0, ae.block_start = 0, ae.insert = 0))), Ze(G), G.avail_out === 0))
                  return ae.last_flush = -1, C;
              }
              return Fe !== k ? C : ae.wrap <= 0 ? L : (ae.wrap === 2 ? (Xe(ae, G.adler & 255), Xe(ae, G.adler >> 8 & 255), Xe(ae, G.adler >> 16 & 255), Xe(ae, G.adler >> 24 & 255), Xe(ae, G.total_in & 255), Xe(ae, G.total_in >> 8 & 255), Xe(ae, G.total_in >> 16 & 255), Xe(ae, G.total_in >> 24 & 255)) : (Ge(ae, G.adler >>> 16), Ge(ae, G.adler & 65535)), Ze(G), ae.wrap > 0 && (ae.wrap = -ae.wrap), ae.pending !== 0 ? C : L);
            }
            function We(G) {
              var Fe;
              return !G || !G.state ? y : (Fe = G.state.status, Fe !== me && Fe !== he && Fe !== we && Fe !== ye && Fe !== ve && Fe !== ce && Fe !== be ? Be(G, y) : (G.state = null, Fe === ce ? Be(G, o) : C));
            }
            function Qe(G, Fe) {
              var Te = Fe.length, ae, Ee, Ie, lt, st, at, gt, Ot;
              if (!G || !G.state || (ae = G.state, lt = ae.wrap, lt === 2 || lt === 1 && ae.status !== me || ae.lookahead))
                return y;
              for (lt === 1 && (G.adler = h(G.adler, Fe, Te, 0)), ae.wrap = 0, Te >= ae.w_size && (lt === 0 && (qe(ae.head), ae.strstart = 0, ae.block_start = 0, ae.insert = 0), Ot = new n.Buf8(ae.w_size), n.arraySet(Ot, Fe, Te - ae.w_size, ae.w_size, 0), Fe = Ot, Te = ae.w_size), st = G.avail_in, at = G.next_in, gt = G.input, G.avail_in = Te, G.next_in = 0, G.input = Fe, it(ae); ae.lookahead >= J; ) {
                Ee = ae.strstart, Ie = ae.lookahead - (J - 1);
                do
                  ae.ins_h = (ae.ins_h << ae.hash_shift ^ ae.window[Ee + J - 1]) & ae.hash_mask, ae.prev[Ee & ae.w_mask] = ae.head[ae.ins_h], ae.head[ae.ins_h] = Ee, Ee++;
                while (--Ie);
                ae.strstart = Ee, ae.lookahead = J - 1, it(ae);
              }
              return ae.strstart += ae.lookahead, ae.block_start = ae.strstart, ae.insert = ae.lookahead, ae.lookahead = 0, ae.match_length = ae.prev_length = J - 1, ae.match_available = 0, G.next_in = at, G.input = gt, G.avail_in = st, ae.wrap = lt, C;
            }
            e.deflateInit = Re, e.deflateInit2 = Me, e.deflateReset = Le, e.deflateResetKeep = xe, e.deflateSetHeader = He, e.deflate = ie, e.deflateEnd = We, e.deflateSetDictionary = Qe, e.deflateInfo = "pako deflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js ***!
            \*********************************************************************/
          /***/
          (a) => {
            function e() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            a.exports = e;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js ***!
            \********************************************************************/
          /***/
          (a) => {
            var e = 30, r = 12;
            a.exports = function(s, h) {
              var b, g, _, A, x, k, $, C, L, y, o, v, w, M, F, m, E, z, O, R, B, P, W, U, V;
              b = s.state, g = s.next_in, U = s.input, _ = g + (s.avail_in - 5), A = s.next_out, V = s.output, x = A - (h - s.avail_out), k = A + (s.avail_out - 257), $ = b.dmax, C = b.wsize, L = b.whave, y = b.wnext, o = b.window, v = b.hold, w = b.bits, M = b.lencode, F = b.distcode, m = (1 << b.lenbits) - 1, E = (1 << b.distbits) - 1;
              e:
                do {
                  w < 15 && (v += U[g++] << w, w += 8, v += U[g++] << w, w += 8), z = M[v & m];
                  t:
                    for (; ; ) {
                      if (O = z >>> 24, v >>>= O, w -= O, O = z >>> 16 & 255, O === 0)
                        V[A++] = z & 65535;
                      else if (O & 16) {
                        R = z & 65535, O &= 15, O && (w < O && (v += U[g++] << w, w += 8), R += v & (1 << O) - 1, v >>>= O, w -= O), w < 15 && (v += U[g++] << w, w += 8, v += U[g++] << w, w += 8), z = F[v & E];
                        r:
                          for (; ; ) {
                            if (O = z >>> 24, v >>>= O, w -= O, O = z >>> 16 & 255, O & 16) {
                              if (B = z & 65535, O &= 15, w < O && (v += U[g++] << w, w += 8, w < O && (v += U[g++] << w, w += 8)), B += v & (1 << O) - 1, B > $) {
                                s.msg = "invalid distance too far back", b.mode = e;
                                break e;
                              }
                              if (v >>>= O, w -= O, O = A - x, B > O) {
                                if (O = B - O, O > L && b.sane) {
                                  s.msg = "invalid distance too far back", b.mode = e;
                                  break e;
                                }
                                if (P = 0, W = o, y === 0) {
                                  if (P += C - O, O < R) {
                                    R -= O;
                                    do
                                      V[A++] = o[P++];
                                    while (--O);
                                    P = A - B, W = V;
                                  }
                                } else if (y < O) {
                                  if (P += C + y - O, O -= y, O < R) {
                                    R -= O;
                                    do
                                      V[A++] = o[P++];
                                    while (--O);
                                    if (P = 0, y < R) {
                                      O = y, R -= O;
                                      do
                                        V[A++] = o[P++];
                                      while (--O);
                                      P = A - B, W = V;
                                    }
                                  }
                                } else if (P += y - O, O < R) {
                                  R -= O;
                                  do
                                    V[A++] = o[P++];
                                  while (--O);
                                  P = A - B, W = V;
                                }
                                for (; R > 2; )
                                  V[A++] = W[P++], V[A++] = W[P++], V[A++] = W[P++], R -= 3;
                                R && (V[A++] = W[P++], R > 1 && (V[A++] = W[P++]));
                              } else {
                                P = A - B;
                                do
                                  V[A++] = V[P++], V[A++] = V[P++], V[A++] = V[P++], R -= 3;
                                while (R > 2);
                                R && (V[A++] = V[P++], R > 1 && (V[A++] = V[P++]));
                              }
                            } else if (O & 64) {
                              s.msg = "invalid distance code", b.mode = e;
                              break e;
                            } else {
                              z = F[(z & 65535) + (v & (1 << O) - 1)];
                              continue r;
                            }
                            break;
                          }
                      } else if (O & 64)
                        if (O & 32) {
                          b.mode = r;
                          break e;
                        } else {
                          s.msg = "invalid literal/length code", b.mode = e;
                          break e;
                        }
                      else {
                        z = M[(z & 65535) + (v & (1 << O) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (g < _ && A < k);
              R = w >> 3, g -= R, w -= R << 3, v &= (1 << w) - 1, s.next_in = g, s.next_out = A, s.avail_in = g < _ ? 5 + (_ - g) : 5 - (g - _), s.avail_out = A < k ? 257 + (k - A) : 257 - (A - k), b.hold = v, b.bits = w;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js ***!
            \********************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), s = r(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), h = r(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), b = r(
              /*! ./inffast */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js"
            ), g = r(
              /*! ./inftrees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js"
            ), _ = 0, A = 1, x = 2, k = 4, $ = 5, C = 6, L = 0, y = 1, o = 2, v = -2, w = -3, M = -4, F = -5, m = 8, E = 1, z = 2, O = 3, R = 4, B = 5, P = 6, W = 7, U = 8, V = 9, K = 10, q = 11, H = 12, j = 13, Q = 14, J = 15, Y = 16, ee = 17, fe = 18, me = 19, he = 20, we = 21, ye = 22, ve = 23, ce = 24, be = 25, le = 26, Se = 27, ge = 28, de = 29, De = 30, Be = 31, Ve = 32, qe = 852, Ze = 592, Ye = 15, Xe = Ye;
            function Ge(Me) {
              return (Me >>> 24 & 255) + (Me >>> 8 & 65280) + ((Me & 65280) << 8) + ((Me & 255) << 24);
            }
            function Ke() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function Pe(Me) {
              var Re;
              return !Me || !Me.state ? v : (Re = Me.state, Me.total_in = Me.total_out = Re.total = 0, Me.msg = "", Re.wrap && (Me.adler = Re.wrap & 1), Re.mode = E, Re.last = 0, Re.havedict = 0, Re.dmax = 32768, Re.head = null, Re.hold = 0, Re.bits = 0, Re.lencode = Re.lendyn = new n.Buf32(qe), Re.distcode = Re.distdyn = new n.Buf32(Ze), Re.sane = 1, Re.back = -1, L);
            }
            function it(Me) {
              var Re;
              return !Me || !Me.state ? v : (Re = Me.state, Re.wsize = 0, Re.whave = 0, Re.wnext = 0, Pe(Me));
            }
            function nt(Me, Re) {
              var ie, We;
              return !Me || !Me.state || (We = Me.state, Re < 0 ? (ie = 0, Re = -Re) : (ie = (Re >> 4) + 1, Re < 48 && (Re &= 15)), Re && (Re < 8 || Re > 15)) ? v : (We.window !== null && We.wbits !== Re && (We.window = null), We.wrap = ie, We.wbits = Re, it(Me));
            }
            function ne(Me, Re) {
              var ie, We;
              return Me ? (We = new Ke(), Me.state = We, We.window = null, ie = nt(Me, Re), ie !== L && (Me.state = null), ie) : v;
            }
            function se(Me) {
              return ne(Me, Xe);
            }
            var ue = !0, $e, Ae;
            function je(Me) {
              if (ue) {
                var Re;
                for ($e = new n.Buf32(512), Ae = new n.Buf32(32), Re = 0; Re < 144; )
                  Me.lens[Re++] = 8;
                for (; Re < 256; )
                  Me.lens[Re++] = 9;
                for (; Re < 280; )
                  Me.lens[Re++] = 7;
                for (; Re < 288; )
                  Me.lens[Re++] = 8;
                for (g(A, Me.lens, 0, 288, $e, 0, Me.work, { bits: 9 }), Re = 0; Re < 32; )
                  Me.lens[Re++] = 5;
                g(x, Me.lens, 0, 32, Ae, 0, Me.work, { bits: 5 }), ue = !1;
              }
              Me.lencode = $e, Me.lenbits = 9, Me.distcode = Ae, Me.distbits = 5;
            }
            function ze(Me, Re, ie, We) {
              var Qe, G = Me.state;
              return G.window === null && (G.wsize = 1 << G.wbits, G.wnext = 0, G.whave = 0, G.window = new n.Buf8(G.wsize)), We >= G.wsize ? (n.arraySet(G.window, Re, ie - G.wsize, G.wsize, 0), G.wnext = 0, G.whave = G.wsize) : (Qe = G.wsize - G.wnext, Qe > We && (Qe = We), n.arraySet(G.window, Re, ie - We, Qe, G.wnext), We -= Qe, We ? (n.arraySet(G.window, Re, ie - We, We, 0), G.wnext = We, G.whave = G.wsize) : (G.wnext += Qe, G.wnext === G.wsize && (G.wnext = 0), G.whave < G.wsize && (G.whave += Qe))), 0;
            }
            function re(Me, Re) {
              var ie, We, Qe, G, Fe, Te, ae, Ee, Ie, lt, st, at, gt, Ot, vt = 0, yt, _t, Bt, Ct, Gt, Zt, zt, It, Lt = new n.Buf8(4), Kt, ct, ke = (
                /* permutation of code lengths */
                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
              );
              if (!Me || !Me.state || !Me.output || !Me.input && Me.avail_in !== 0)
                return v;
              ie = Me.state, ie.mode === H && (ie.mode = j), Fe = Me.next_out, Qe = Me.output, ae = Me.avail_out, G = Me.next_in, We = Me.input, Te = Me.avail_in, Ee = ie.hold, Ie = ie.bits, lt = Te, st = ae, It = L;
              e:
                for (; ; )
                  switch (ie.mode) {
                    case E:
                      if (ie.wrap === 0) {
                        ie.mode = j;
                        break;
                      }
                      for (; Ie < 16; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if (ie.wrap & 2 && Ee === 35615) {
                        ie.check = 0, Lt[0] = Ee & 255, Lt[1] = Ee >>> 8 & 255, ie.check = h(ie.check, Lt, 2, 0), Ee = 0, Ie = 0, ie.mode = z;
                        break;
                      }
                      if (ie.flags = 0, ie.head && (ie.head.done = !1), !(ie.wrap & 1) || /* check if zlib header allowed */
                      (((Ee & 255) << 8) + (Ee >> 8)) % 31) {
                        Me.msg = "incorrect header check", ie.mode = De;
                        break;
                      }
                      if ((Ee & 15) !== m) {
                        Me.msg = "unknown compression method", ie.mode = De;
                        break;
                      }
                      if (Ee >>>= 4, Ie -= 4, zt = (Ee & 15) + 8, ie.wbits === 0)
                        ie.wbits = zt;
                      else if (zt > ie.wbits) {
                        Me.msg = "invalid window size", ie.mode = De;
                        break;
                      }
                      ie.dmax = 1 << zt, Me.adler = ie.check = 1, ie.mode = Ee & 512 ? K : H, Ee = 0, Ie = 0;
                      break;
                    case z:
                      for (; Ie < 16; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if (ie.flags = Ee, (ie.flags & 255) !== m) {
                        Me.msg = "unknown compression method", ie.mode = De;
                        break;
                      }
                      if (ie.flags & 57344) {
                        Me.msg = "unknown header flags set", ie.mode = De;
                        break;
                      }
                      ie.head && (ie.head.text = Ee >> 8 & 1), ie.flags & 512 && (Lt[0] = Ee & 255, Lt[1] = Ee >>> 8 & 255, ie.check = h(ie.check, Lt, 2, 0)), Ee = 0, Ie = 0, ie.mode = O;
                    case O:
                      for (; Ie < 32; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      ie.head && (ie.head.time = Ee), ie.flags & 512 && (Lt[0] = Ee & 255, Lt[1] = Ee >>> 8 & 255, Lt[2] = Ee >>> 16 & 255, Lt[3] = Ee >>> 24 & 255, ie.check = h(ie.check, Lt, 4, 0)), Ee = 0, Ie = 0, ie.mode = R;
                    case R:
                      for (; Ie < 16; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      ie.head && (ie.head.xflags = Ee & 255, ie.head.os = Ee >> 8), ie.flags & 512 && (Lt[0] = Ee & 255, Lt[1] = Ee >>> 8 & 255, ie.check = h(ie.check, Lt, 2, 0)), Ee = 0, Ie = 0, ie.mode = B;
                    case B:
                      if (ie.flags & 1024) {
                        for (; Ie < 16; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        ie.length = Ee, ie.head && (ie.head.extra_len = Ee), ie.flags & 512 && (Lt[0] = Ee & 255, Lt[1] = Ee >>> 8 & 255, ie.check = h(ie.check, Lt, 2, 0)), Ee = 0, Ie = 0;
                      } else ie.head && (ie.head.extra = null);
                      ie.mode = P;
                    case P:
                      if (ie.flags & 1024 && (at = ie.length, at > Te && (at = Te), at && (ie.head && (zt = ie.head.extra_len - ie.length, ie.head.extra || (ie.head.extra = new Array(ie.head.extra_len)), n.arraySet(
                        ie.head.extra,
                        We,
                        G,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        at,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        zt
                      )), ie.flags & 512 && (ie.check = h(ie.check, We, at, G)), Te -= at, G += at, ie.length -= at), ie.length))
                        break e;
                      ie.length = 0, ie.mode = W;
                    case W:
                      if (ie.flags & 2048) {
                        if (Te === 0)
                          break e;
                        at = 0;
                        do
                          zt = We[G + at++], ie.head && zt && ie.length < 65536 && (ie.head.name += String.fromCharCode(zt));
                        while (zt && at < Te);
                        if (ie.flags & 512 && (ie.check = h(ie.check, We, at, G)), Te -= at, G += at, zt)
                          break e;
                      } else ie.head && (ie.head.name = null);
                      ie.length = 0, ie.mode = U;
                    case U:
                      if (ie.flags & 4096) {
                        if (Te === 0)
                          break e;
                        at = 0;
                        do
                          zt = We[G + at++], ie.head && zt && ie.length < 65536 && (ie.head.comment += String.fromCharCode(zt));
                        while (zt && at < Te);
                        if (ie.flags & 512 && (ie.check = h(ie.check, We, at, G)), Te -= at, G += at, zt)
                          break e;
                      } else ie.head && (ie.head.comment = null);
                      ie.mode = V;
                    case V:
                      if (ie.flags & 512) {
                        for (; Ie < 16; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        if (Ee !== (ie.check & 65535)) {
                          Me.msg = "header crc mismatch", ie.mode = De;
                          break;
                        }
                        Ee = 0, Ie = 0;
                      }
                      ie.head && (ie.head.hcrc = ie.flags >> 9 & 1, ie.head.done = !0), Me.adler = ie.check = 0, ie.mode = H;
                      break;
                    case K:
                      for (; Ie < 32; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      Me.adler = ie.check = Ge(Ee), Ee = 0, Ie = 0, ie.mode = q;
                    case q:
                      if (ie.havedict === 0)
                        return Me.next_out = Fe, Me.avail_out = ae, Me.next_in = G, Me.avail_in = Te, ie.hold = Ee, ie.bits = Ie, o;
                      Me.adler = ie.check = 1, ie.mode = H;
                    case H:
                      if (Re === $ || Re === C)
                        break e;
                    case j:
                      if (ie.last) {
                        Ee >>>= Ie & 7, Ie -= Ie & 7, ie.mode = Se;
                        break;
                      }
                      for (; Ie < 3; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      switch (ie.last = Ee & 1, Ee >>>= 1, Ie -= 1, Ee & 3) {
                        case 0:
                          ie.mode = Q;
                          break;
                        case 1:
                          if (je(ie), ie.mode = he, Re === C) {
                            Ee >>>= 2, Ie -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          ie.mode = ee;
                          break;
                        case 3:
                          Me.msg = "invalid block type", ie.mode = De;
                      }
                      Ee >>>= 2, Ie -= 2;
                      break;
                    case Q:
                      for (Ee >>>= Ie & 7, Ie -= Ie & 7; Ie < 32; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if ((Ee & 65535) !== (Ee >>> 16 ^ 65535)) {
                        Me.msg = "invalid stored block lengths", ie.mode = De;
                        break;
                      }
                      if (ie.length = Ee & 65535, Ee = 0, Ie = 0, ie.mode = J, Re === C)
                        break e;
                    case J:
                      ie.mode = Y;
                    case Y:
                      if (at = ie.length, at) {
                        if (at > Te && (at = Te), at > ae && (at = ae), at === 0)
                          break e;
                        n.arraySet(Qe, We, G, at, Fe), Te -= at, G += at, ae -= at, Fe += at, ie.length -= at;
                        break;
                      }
                      ie.mode = H;
                      break;
                    case ee:
                      for (; Ie < 14; ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if (ie.nlen = (Ee & 31) + 257, Ee >>>= 5, Ie -= 5, ie.ndist = (Ee & 31) + 1, Ee >>>= 5, Ie -= 5, ie.ncode = (Ee & 15) + 4, Ee >>>= 4, Ie -= 4, ie.nlen > 286 || ie.ndist > 30) {
                        Me.msg = "too many length or distance symbols", ie.mode = De;
                        break;
                      }
                      ie.have = 0, ie.mode = fe;
                    case fe:
                      for (; ie.have < ie.ncode; ) {
                        for (; Ie < 3; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        ie.lens[ke[ie.have++]] = Ee & 7, Ee >>>= 3, Ie -= 3;
                      }
                      for (; ie.have < 19; )
                        ie.lens[ke[ie.have++]] = 0;
                      if (ie.lencode = ie.lendyn, ie.lenbits = 7, Kt = { bits: ie.lenbits }, It = g(_, ie.lens, 0, 19, ie.lencode, 0, ie.work, Kt), ie.lenbits = Kt.bits, It) {
                        Me.msg = "invalid code lengths set", ie.mode = De;
                        break;
                      }
                      ie.have = 0, ie.mode = me;
                    case me:
                      for (; ie.have < ie.nlen + ie.ndist; ) {
                        for (; vt = ie.lencode[Ee & (1 << ie.lenbits) - 1], yt = vt >>> 24, _t = vt >>> 16 & 255, Bt = vt & 65535, !(yt <= Ie); ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        if (Bt < 16)
                          Ee >>>= yt, Ie -= yt, ie.lens[ie.have++] = Bt;
                        else {
                          if (Bt === 16) {
                            for (ct = yt + 2; Ie < ct; ) {
                              if (Te === 0)
                                break e;
                              Te--, Ee += We[G++] << Ie, Ie += 8;
                            }
                            if (Ee >>>= yt, Ie -= yt, ie.have === 0) {
                              Me.msg = "invalid bit length repeat", ie.mode = De;
                              break;
                            }
                            zt = ie.lens[ie.have - 1], at = 3 + (Ee & 3), Ee >>>= 2, Ie -= 2;
                          } else if (Bt === 17) {
                            for (ct = yt + 3; Ie < ct; ) {
                              if (Te === 0)
                                break e;
                              Te--, Ee += We[G++] << Ie, Ie += 8;
                            }
                            Ee >>>= yt, Ie -= yt, zt = 0, at = 3 + (Ee & 7), Ee >>>= 3, Ie -= 3;
                          } else {
                            for (ct = yt + 7; Ie < ct; ) {
                              if (Te === 0)
                                break e;
                              Te--, Ee += We[G++] << Ie, Ie += 8;
                            }
                            Ee >>>= yt, Ie -= yt, zt = 0, at = 11 + (Ee & 127), Ee >>>= 7, Ie -= 7;
                          }
                          if (ie.have + at > ie.nlen + ie.ndist) {
                            Me.msg = "invalid bit length repeat", ie.mode = De;
                            break;
                          }
                          for (; at--; )
                            ie.lens[ie.have++] = zt;
                        }
                      }
                      if (ie.mode === De)
                        break;
                      if (ie.lens[256] === 0) {
                        Me.msg = "invalid code -- missing end-of-block", ie.mode = De;
                        break;
                      }
                      if (ie.lenbits = 9, Kt = { bits: ie.lenbits }, It = g(A, ie.lens, 0, ie.nlen, ie.lencode, 0, ie.work, Kt), ie.lenbits = Kt.bits, It) {
                        Me.msg = "invalid literal/lengths set", ie.mode = De;
                        break;
                      }
                      if (ie.distbits = 6, ie.distcode = ie.distdyn, Kt = { bits: ie.distbits }, It = g(x, ie.lens, ie.nlen, ie.ndist, ie.distcode, 0, ie.work, Kt), ie.distbits = Kt.bits, It) {
                        Me.msg = "invalid distances set", ie.mode = De;
                        break;
                      }
                      if (ie.mode = he, Re === C)
                        break e;
                    case he:
                      ie.mode = we;
                    case we:
                      if (Te >= 6 && ae >= 258) {
                        Me.next_out = Fe, Me.avail_out = ae, Me.next_in = G, Me.avail_in = Te, ie.hold = Ee, ie.bits = Ie, b(Me, st), Fe = Me.next_out, Qe = Me.output, ae = Me.avail_out, G = Me.next_in, We = Me.input, Te = Me.avail_in, Ee = ie.hold, Ie = ie.bits, ie.mode === H && (ie.back = -1);
                        break;
                      }
                      for (ie.back = 0; vt = ie.lencode[Ee & (1 << ie.lenbits) - 1], yt = vt >>> 24, _t = vt >>> 16 & 255, Bt = vt & 65535, !(yt <= Ie); ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if (_t && !(_t & 240)) {
                        for (Ct = yt, Gt = _t, Zt = Bt; vt = ie.lencode[Zt + ((Ee & (1 << Ct + Gt) - 1) >> Ct)], yt = vt >>> 24, _t = vt >>> 16 & 255, Bt = vt & 65535, !(Ct + yt <= Ie); ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        Ee >>>= Ct, Ie -= Ct, ie.back += Ct;
                      }
                      if (Ee >>>= yt, Ie -= yt, ie.back += yt, ie.length = Bt, _t === 0) {
                        ie.mode = le;
                        break;
                      }
                      if (_t & 32) {
                        ie.back = -1, ie.mode = H;
                        break;
                      }
                      if (_t & 64) {
                        Me.msg = "invalid literal/length code", ie.mode = De;
                        break;
                      }
                      ie.extra = _t & 15, ie.mode = ye;
                    case ye:
                      if (ie.extra) {
                        for (ct = ie.extra; Ie < ct; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        ie.length += Ee & (1 << ie.extra) - 1, Ee >>>= ie.extra, Ie -= ie.extra, ie.back += ie.extra;
                      }
                      ie.was = ie.length, ie.mode = ve;
                    case ve:
                      for (; vt = ie.distcode[Ee & (1 << ie.distbits) - 1], yt = vt >>> 24, _t = vt >>> 16 & 255, Bt = vt & 65535, !(yt <= Ie); ) {
                        if (Te === 0)
                          break e;
                        Te--, Ee += We[G++] << Ie, Ie += 8;
                      }
                      if (!(_t & 240)) {
                        for (Ct = yt, Gt = _t, Zt = Bt; vt = ie.distcode[Zt + ((Ee & (1 << Ct + Gt) - 1) >> Ct)], yt = vt >>> 24, _t = vt >>> 16 & 255, Bt = vt & 65535, !(Ct + yt <= Ie); ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        Ee >>>= Ct, Ie -= Ct, ie.back += Ct;
                      }
                      if (Ee >>>= yt, Ie -= yt, ie.back += yt, _t & 64) {
                        Me.msg = "invalid distance code", ie.mode = De;
                        break;
                      }
                      ie.offset = Bt, ie.extra = _t & 15, ie.mode = ce;
                    case ce:
                      if (ie.extra) {
                        for (ct = ie.extra; Ie < ct; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        ie.offset += Ee & (1 << ie.extra) - 1, Ee >>>= ie.extra, Ie -= ie.extra, ie.back += ie.extra;
                      }
                      if (ie.offset > ie.dmax) {
                        Me.msg = "invalid distance too far back", ie.mode = De;
                        break;
                      }
                      ie.mode = be;
                    case be:
                      if (ae === 0)
                        break e;
                      if (at = st - ae, ie.offset > at) {
                        if (at = ie.offset - at, at > ie.whave && ie.sane) {
                          Me.msg = "invalid distance too far back", ie.mode = De;
                          break;
                        }
                        at > ie.wnext ? (at -= ie.wnext, gt = ie.wsize - at) : gt = ie.wnext - at, at > ie.length && (at = ie.length), Ot = ie.window;
                      } else
                        Ot = Qe, gt = Fe - ie.offset, at = ie.length;
                      at > ae && (at = ae), ae -= at, ie.length -= at;
                      do
                        Qe[Fe++] = Ot[gt++];
                      while (--at);
                      ie.length === 0 && (ie.mode = we);
                      break;
                    case le:
                      if (ae === 0)
                        break e;
                      Qe[Fe++] = ie.length, ae--, ie.mode = we;
                      break;
                    case Se:
                      if (ie.wrap) {
                        for (; Ie < 32; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee |= We[G++] << Ie, Ie += 8;
                        }
                        if (st -= ae, Me.total_out += st, ie.total += st, st && (Me.adler = ie.check = /*UPDATE(state.check, put - _out, _out);*/
                        ie.flags ? h(ie.check, Qe, st, Fe - st) : s(ie.check, Qe, st, Fe - st)), st = ae, (ie.flags ? Ee : Ge(Ee)) !== ie.check) {
                          Me.msg = "incorrect data check", ie.mode = De;
                          break;
                        }
                        Ee = 0, Ie = 0;
                      }
                      ie.mode = ge;
                    case ge:
                      if (ie.wrap && ie.flags) {
                        for (; Ie < 32; ) {
                          if (Te === 0)
                            break e;
                          Te--, Ee += We[G++] << Ie, Ie += 8;
                        }
                        if (Ee !== (ie.total & 4294967295)) {
                          Me.msg = "incorrect length check", ie.mode = De;
                          break;
                        }
                        Ee = 0, Ie = 0;
                      }
                      ie.mode = de;
                    case de:
                      It = y;
                      break e;
                    case De:
                      It = w;
                      break e;
                    case Be:
                      return M;
                    case Ve:
                    default:
                      return v;
                  }
              return Me.next_out = Fe, Me.avail_out = ae, Me.next_in = G, Me.avail_in = Te, ie.hold = Ee, ie.bits = Ie, (ie.wsize || st !== Me.avail_out && ie.mode < De && (ie.mode < Se || Re !== k)) && ze(Me, Me.output, Me.next_out, st - Me.avail_out), lt -= Me.avail_in, st -= Me.avail_out, Me.total_in += lt, Me.total_out += st, ie.total += st, ie.wrap && st && (Me.adler = ie.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
              ie.flags ? h(ie.check, Qe, st, Me.next_out - st) : s(ie.check, Qe, st, Me.next_out - st)), Me.data_type = ie.bits + (ie.last ? 64 : 0) + (ie.mode === H ? 128 : 0) + (ie.mode === he || ie.mode === J ? 256 : 0), (lt === 0 && st === 0 || Re === k) && It === L && (It = F), It;
            }
            function xe(Me) {
              if (!Me || !Me.state)
                return v;
              var Re = Me.state;
              return Re.window && (Re.window = null), Me.state = null, L;
            }
            function Le(Me, Re) {
              var ie;
              return !Me || !Me.state || (ie = Me.state, !(ie.wrap & 2)) ? v : (ie.head = Re, Re.done = !1, L);
            }
            function He(Me, Re) {
              var ie = Re.length, We, Qe, G;
              return !Me || !Me.state || (We = Me.state, We.wrap !== 0 && We.mode !== q) ? v : We.mode === q && (Qe = 1, Qe = s(Qe, Re, ie, 0), Qe !== We.check) ? w : (G = ze(Me, Re, ie, ie), G ? (We.mode = Be, M) : (We.havedict = 1, L));
            }
            e.inflateReset = it, e.inflateReset2 = nt, e.inflateResetKeep = Pe, e.inflateInit = se, e.inflateInit2 = ne, e.inflate = re, e.inflateEnd = xe, e.inflateGetHeader = Le, e.inflateSetDictionary = He, e.inflateInfo = "pako inflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js ***!
            \*********************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), s = 15, h = 852, b = 592, g = 0, _ = 1, A = 2, x = [
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ], k = [
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ], $ = [
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ], C = [
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ];
            a.exports = function(y, o, v, w, M, F, m, E) {
              var z = E.bits, O = 0, R = 0, B = 0, P = 0, W = 0, U = 0, V = 0, K = 0, q = 0, H = 0, j, Q, J, Y, ee, fe = null, me = 0, he, we = new n.Buf16(s + 1), ye = new n.Buf16(s + 1), ve = null, ce = 0, be, le, Se;
              for (O = 0; O <= s; O++)
                we[O] = 0;
              for (R = 0; R < w; R++)
                we[o[v + R]]++;
              for (W = z, P = s; P >= 1 && we[P] === 0; P--)
                ;
              if (W > P && (W = P), P === 0)
                return M[F++] = 20971520, M[F++] = 20971520, E.bits = 1, 0;
              for (B = 1; B < P && we[B] === 0; B++)
                ;
              for (W < B && (W = B), K = 1, O = 1; O <= s; O++)
                if (K <<= 1, K -= we[O], K < 0)
                  return -1;
              if (K > 0 && (y === g || P !== 1))
                return -1;
              for (ye[1] = 0, O = 1; O < s; O++)
                ye[O + 1] = ye[O] + we[O];
              for (R = 0; R < w; R++)
                o[v + R] !== 0 && (m[ye[o[v + R]]++] = R);
              if (y === g ? (fe = ve = m, he = 19) : y === _ ? (fe = x, me -= 257, ve = k, ce -= 257, he = 256) : (fe = $, ve = C, he = -1), H = 0, R = 0, O = B, ee = F, U = W, V = 0, J = -1, q = 1 << W, Y = q - 1, y === _ && q > h || y === A && q > b)
                return 1;
              for (; ; ) {
                be = O - V, m[R] < he ? (le = 0, Se = m[R]) : m[R] > he ? (le = ve[ce + m[R]], Se = fe[me + m[R]]) : (le = 96, Se = 0), j = 1 << O - V, Q = 1 << U, B = Q;
                do
                  Q -= j, M[ee + (H >> V) + Q] = be << 24 | le << 16 | Se | 0;
                while (Q !== 0);
                for (j = 1 << O - 1; H & j; )
                  j >>= 1;
                if (j !== 0 ? (H &= j - 1, H += j) : H = 0, R++, --we[O] === 0) {
                  if (O === P)
                    break;
                  O = o[v + m[R]];
                }
                if (O > W && (H & Y) !== J) {
                  for (V === 0 && (V = W), ee += B, U = O - V, K = 1 << U; U + V < P && (K -= we[U + V], !(K <= 0)); )
                    U++, K <<= 1;
                  if (q += 1 << U, y === _ && q > h || y === A && q > b)
                    return 1;
                  J = H & Y, M[J] = W << 24 | U << 16 | ee - F | 0;
                }
              }
              return H !== 0 && (M[ee + H] = O - V << 24 | 4194304 | 0), E.bits = W, 0;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js ***!
            \*********************************************************************/
          /***/
          (a) => {
            a.exports = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js ***!
            \******************************************************************/
          /***/
          (a, e, r) => {
            var n = r(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), s = 4, h = 0, b = 1, g = 2;
            function _(re) {
              for (var xe = re.length; --xe >= 0; )
                re[xe] = 0;
            }
            var A = 0, x = 1, k = 2, $ = 3, C = 258, L = 29, y = 256, o = y + 1 + L, v = 30, w = 19, M = 2 * o + 1, F = 15, m = 16, E = 7, z = 256, O = 16, R = 17, B = 18, P = (
              /* extra bits for each length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
            ), W = (
              /* extra bits for each distance code */
              [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
            ), U = (
              /* extra bits for each bit length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
            ), V = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], K = 512, q = new Array((o + 2) * 2);
            _(q);
            var H = new Array(v * 2);
            _(H);
            var j = new Array(K);
            _(j);
            var Q = new Array(C - $ + 1);
            _(Q);
            var J = new Array(L);
            _(J);
            var Y = new Array(v);
            _(Y);
            function ee(re, xe, Le, He, Me) {
              this.static_tree = re, this.extra_bits = xe, this.extra_base = Le, this.elems = He, this.max_length = Me, this.has_stree = re && re.length;
            }
            var fe, me, he;
            function we(re, xe) {
              this.dyn_tree = re, this.max_code = 0, this.stat_desc = xe;
            }
            function ye(re) {
              return re < 256 ? j[re] : j[256 + (re >>> 7)];
            }
            function ve(re, xe) {
              re.pending_buf[re.pending++] = xe & 255, re.pending_buf[re.pending++] = xe >>> 8 & 255;
            }
            function ce(re, xe, Le) {
              re.bi_valid > m - Le ? (re.bi_buf |= xe << re.bi_valid & 65535, ve(re, re.bi_buf), re.bi_buf = xe >> m - re.bi_valid, re.bi_valid += Le - m) : (re.bi_buf |= xe << re.bi_valid & 65535, re.bi_valid += Le);
            }
            function be(re, xe, Le) {
              ce(
                re,
                Le[xe * 2],
                Le[xe * 2 + 1]
                /*.Len*/
              );
            }
            function le(re, xe) {
              var Le = 0;
              do
                Le |= re & 1, re >>>= 1, Le <<= 1;
              while (--xe > 0);
              return Le >>> 1;
            }
            function Se(re) {
              re.bi_valid === 16 ? (ve(re, re.bi_buf), re.bi_buf = 0, re.bi_valid = 0) : re.bi_valid >= 8 && (re.pending_buf[re.pending++] = re.bi_buf & 255, re.bi_buf >>= 8, re.bi_valid -= 8);
            }
            function ge(re, xe) {
              var Le = xe.dyn_tree, He = xe.max_code, Me = xe.stat_desc.static_tree, Re = xe.stat_desc.has_stree, ie = xe.stat_desc.extra_bits, We = xe.stat_desc.extra_base, Qe = xe.stat_desc.max_length, G, Fe, Te, ae, Ee, Ie, lt = 0;
              for (ae = 0; ae <= F; ae++)
                re.bl_count[ae] = 0;
              for (Le[re.heap[re.heap_max] * 2 + 1] = 0, G = re.heap_max + 1; G < M; G++)
                Fe = re.heap[G], ae = Le[Le[Fe * 2 + 1] * 2 + 1] + 1, ae > Qe && (ae = Qe, lt++), Le[Fe * 2 + 1] = ae, !(Fe > He) && (re.bl_count[ae]++, Ee = 0, Fe >= We && (Ee = ie[Fe - We]), Ie = Le[Fe * 2], re.opt_len += Ie * (ae + Ee), Re && (re.static_len += Ie * (Me[Fe * 2 + 1] + Ee)));
              if (lt !== 0) {
                do {
                  for (ae = Qe - 1; re.bl_count[ae] === 0; )
                    ae--;
                  re.bl_count[ae]--, re.bl_count[ae + 1] += 2, re.bl_count[Qe]--, lt -= 2;
                } while (lt > 0);
                for (ae = Qe; ae !== 0; ae--)
                  for (Fe = re.bl_count[ae]; Fe !== 0; )
                    Te = re.heap[--G], !(Te > He) && (Le[Te * 2 + 1] !== ae && (re.opt_len += (ae - Le[Te * 2 + 1]) * Le[Te * 2], Le[Te * 2 + 1] = ae), Fe--);
              }
            }
            function de(re, xe, Le) {
              var He = new Array(F + 1), Me = 0, Re, ie;
              for (Re = 1; Re <= F; Re++)
                He[Re] = Me = Me + Le[Re - 1] << 1;
              for (ie = 0; ie <= xe; ie++) {
                var We = re[ie * 2 + 1];
                We !== 0 && (re[ie * 2] = le(He[We]++, We));
              }
            }
            function De() {
              var re, xe, Le, He, Me, Re = new Array(F + 1);
              for (Le = 0, He = 0; He < L - 1; He++)
                for (J[He] = Le, re = 0; re < 1 << P[He]; re++)
                  Q[Le++] = He;
              for (Q[Le - 1] = He, Me = 0, He = 0; He < 16; He++)
                for (Y[He] = Me, re = 0; re < 1 << W[He]; re++)
                  j[Me++] = He;
              for (Me >>= 7; He < v; He++)
                for (Y[He] = Me << 7, re = 0; re < 1 << W[He] - 7; re++)
                  j[256 + Me++] = He;
              for (xe = 0; xe <= F; xe++)
                Re[xe] = 0;
              for (re = 0; re <= 143; )
                q[re * 2 + 1] = 8, re++, Re[8]++;
              for (; re <= 255; )
                q[re * 2 + 1] = 9, re++, Re[9]++;
              for (; re <= 279; )
                q[re * 2 + 1] = 7, re++, Re[7]++;
              for (; re <= 287; )
                q[re * 2 + 1] = 8, re++, Re[8]++;
              for (de(q, o + 1, Re), re = 0; re < v; re++)
                H[re * 2 + 1] = 5, H[re * 2] = le(re, 5);
              fe = new ee(q, P, y + 1, o, F), me = new ee(H, W, 0, v, F), he = new ee(new Array(0), U, 0, w, E);
            }
            function Be(re) {
              var xe;
              for (xe = 0; xe < o; xe++)
                re.dyn_ltree[xe * 2] = 0;
              for (xe = 0; xe < v; xe++)
                re.dyn_dtree[xe * 2] = 0;
              for (xe = 0; xe < w; xe++)
                re.bl_tree[xe * 2] = 0;
              re.dyn_ltree[z * 2] = 1, re.opt_len = re.static_len = 0, re.last_lit = re.matches = 0;
            }
            function Ve(re) {
              re.bi_valid > 8 ? ve(re, re.bi_buf) : re.bi_valid > 0 && (re.pending_buf[re.pending++] = re.bi_buf), re.bi_buf = 0, re.bi_valid = 0;
            }
            function qe(re, xe, Le, He) {
              Ve(re), ve(re, Le), ve(re, ~Le), n.arraySet(re.pending_buf, re.window, xe, Le, re.pending), re.pending += Le;
            }
            function Ze(re, xe, Le, He) {
              var Me = xe * 2, Re = Le * 2;
              return re[Me] < re[Re] || re[Me] === re[Re] && He[xe] <= He[Le];
            }
            function Ye(re, xe, Le) {
              for (var He = re.heap[Le], Me = Le << 1; Me <= re.heap_len && (Me < re.heap_len && Ze(xe, re.heap[Me + 1], re.heap[Me], re.depth) && Me++, !Ze(xe, He, re.heap[Me], re.depth)); )
                re.heap[Le] = re.heap[Me], Le = Me, Me <<= 1;
              re.heap[Le] = He;
            }
            function Xe(re, xe, Le) {
              var He, Me, Re = 0, ie, We;
              if (re.last_lit !== 0)
                do
                  He = re.pending_buf[re.d_buf + Re * 2] << 8 | re.pending_buf[re.d_buf + Re * 2 + 1], Me = re.pending_buf[re.l_buf + Re], Re++, He === 0 ? be(re, Me, xe) : (ie = Q[Me], be(re, ie + y + 1, xe), We = P[ie], We !== 0 && (Me -= J[ie], ce(re, Me, We)), He--, ie = ye(He), be(re, ie, Le), We = W[ie], We !== 0 && (He -= Y[ie], ce(re, He, We)));
                while (Re < re.last_lit);
              be(re, z, xe);
            }
            function Ge(re, xe) {
              var Le = xe.dyn_tree, He = xe.stat_desc.static_tree, Me = xe.stat_desc.has_stree, Re = xe.stat_desc.elems, ie, We, Qe = -1, G;
              for (re.heap_len = 0, re.heap_max = M, ie = 0; ie < Re; ie++)
                Le[ie * 2] !== 0 ? (re.heap[++re.heap_len] = Qe = ie, re.depth[ie] = 0) : Le[ie * 2 + 1] = 0;
              for (; re.heap_len < 2; )
                G = re.heap[++re.heap_len] = Qe < 2 ? ++Qe : 0, Le[G * 2] = 1, re.depth[G] = 0, re.opt_len--, Me && (re.static_len -= He[G * 2 + 1]);
              for (xe.max_code = Qe, ie = re.heap_len >> 1; ie >= 1; ie--)
                Ye(re, Le, ie);
              G = Re;
              do
                ie = re.heap[
                  1
                  /*SMALLEST*/
                ], re.heap[
                  1
                  /*SMALLEST*/
                ] = re.heap[re.heap_len--], Ye(
                  re,
                  Le,
                  1
                  /*SMALLEST*/
                ), We = re.heap[
                  1
                  /*SMALLEST*/
                ], re.heap[--re.heap_max] = ie, re.heap[--re.heap_max] = We, Le[G * 2] = Le[ie * 2] + Le[We * 2], re.depth[G] = (re.depth[ie] >= re.depth[We] ? re.depth[ie] : re.depth[We]) + 1, Le[ie * 2 + 1] = Le[We * 2 + 1] = G, re.heap[
                  1
                  /*SMALLEST*/
                ] = G++, Ye(
                  re,
                  Le,
                  1
                  /*SMALLEST*/
                );
              while (re.heap_len >= 2);
              re.heap[--re.heap_max] = re.heap[
                1
                /*SMALLEST*/
              ], ge(re, xe), de(Le, Qe, re.bl_count);
            }
            function Ke(re, xe, Le) {
              var He, Me = -1, Re, ie = xe[0 * 2 + 1], We = 0, Qe = 7, G = 4;
              for (ie === 0 && (Qe = 138, G = 3), xe[(Le + 1) * 2 + 1] = 65535, He = 0; He <= Le; He++)
                Re = ie, ie = xe[(He + 1) * 2 + 1], !(++We < Qe && Re === ie) && (We < G ? re.bl_tree[Re * 2] += We : Re !== 0 ? (Re !== Me && re.bl_tree[Re * 2]++, re.bl_tree[O * 2]++) : We <= 10 ? re.bl_tree[R * 2]++ : re.bl_tree[B * 2]++, We = 0, Me = Re, ie === 0 ? (Qe = 138, G = 3) : Re === ie ? (Qe = 6, G = 3) : (Qe = 7, G = 4));
            }
            function Pe(re, xe, Le) {
              var He, Me = -1, Re, ie = xe[0 * 2 + 1], We = 0, Qe = 7, G = 4;
              for (ie === 0 && (Qe = 138, G = 3), He = 0; He <= Le; He++)
                if (Re = ie, ie = xe[(He + 1) * 2 + 1], !(++We < Qe && Re === ie)) {
                  if (We < G)
                    do
                      be(re, Re, re.bl_tree);
                    while (--We !== 0);
                  else Re !== 0 ? (Re !== Me && (be(re, Re, re.bl_tree), We--), be(re, O, re.bl_tree), ce(re, We - 3, 2)) : We <= 10 ? (be(re, R, re.bl_tree), ce(re, We - 3, 3)) : (be(re, B, re.bl_tree), ce(re, We - 11, 7));
                  We = 0, Me = Re, ie === 0 ? (Qe = 138, G = 3) : Re === ie ? (Qe = 6, G = 3) : (Qe = 7, G = 4);
                }
            }
            function it(re) {
              var xe;
              for (Ke(re, re.dyn_ltree, re.l_desc.max_code), Ke(re, re.dyn_dtree, re.d_desc.max_code), Ge(re, re.bl_desc), xe = w - 1; xe >= 3 && re.bl_tree[V[xe] * 2 + 1] === 0; xe--)
                ;
              return re.opt_len += 3 * (xe + 1) + 5 + 5 + 4, xe;
            }
            function nt(re, xe, Le, He) {
              var Me;
              for (ce(re, xe - 257, 5), ce(re, Le - 1, 5), ce(re, He - 4, 4), Me = 0; Me < He; Me++)
                ce(re, re.bl_tree[V[Me] * 2 + 1], 3);
              Pe(re, re.dyn_ltree, xe - 1), Pe(re, re.dyn_dtree, Le - 1);
            }
            function ne(re) {
              var xe = 4093624447, Le;
              for (Le = 0; Le <= 31; Le++, xe >>>= 1)
                if (xe & 1 && re.dyn_ltree[Le * 2] !== 0)
                  return h;
              if (re.dyn_ltree[18] !== 0 || re.dyn_ltree[20] !== 0 || re.dyn_ltree[26] !== 0)
                return b;
              for (Le = 32; Le < y; Le++)
                if (re.dyn_ltree[Le * 2] !== 0)
                  return b;
              return h;
            }
            var se = !1;
            function ue(re) {
              se || (De(), se = !0), re.l_desc = new we(re.dyn_ltree, fe), re.d_desc = new we(re.dyn_dtree, me), re.bl_desc = new we(re.bl_tree, he), re.bi_buf = 0, re.bi_valid = 0, Be(re);
            }
            function $e(re, xe, Le, He) {
              ce(re, (A << 1) + (He ? 1 : 0), 3), qe(re, xe, Le);
            }
            function Ae(re) {
              ce(re, x << 1, 3), be(re, z, q), Se(re);
            }
            function je(re, xe, Le, He) {
              var Me, Re, ie = 0;
              re.level > 0 ? (re.strm.data_type === g && (re.strm.data_type = ne(re)), Ge(re, re.l_desc), Ge(re, re.d_desc), ie = it(re), Me = re.opt_len + 3 + 7 >>> 3, Re = re.static_len + 3 + 7 >>> 3, Re <= Me && (Me = Re)) : Me = Re = Le + 5, Le + 4 <= Me && xe !== -1 ? $e(re, xe, Le, He) : re.strategy === s || Re === Me ? (ce(re, (x << 1) + (He ? 1 : 0), 3), Xe(re, q, H)) : (ce(re, (k << 1) + (He ? 1 : 0), 3), nt(re, re.l_desc.max_code + 1, re.d_desc.max_code + 1, ie + 1), Xe(re, re.dyn_ltree, re.dyn_dtree)), Be(re), He && Ve(re);
            }
            function ze(re, xe, Le) {
              return re.pending_buf[re.d_buf + re.last_lit * 2] = xe >>> 8 & 255, re.pending_buf[re.d_buf + re.last_lit * 2 + 1] = xe & 255, re.pending_buf[re.l_buf + re.last_lit] = Le & 255, re.last_lit++, xe === 0 ? re.dyn_ltree[Le * 2]++ : (re.matches++, xe--, re.dyn_ltree[(Q[Le] + y + 1) * 2]++, re.dyn_dtree[ye(xe) * 2]++), re.last_lit === re.lit_bufsize - 1;
            }
            e._tr_init = ue, e._tr_stored_block = $e, e._tr_flush_block = je, e._tr_tally = ze, e._tr_align = Ae;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js ***!
            \********************************************************************/
          /***/
          (a) => {
            function e() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            a.exports = e;
          }
        ),
        /***/
        "./src/SurfaceWorker.js": (
          /*!******************************!*\
            !*** ./src/SurfaceWorker.js ***!
            \******************************/
          /***/
          () => {
            $3Dmol.workerString = function() {
              self.onmessage = function(a) {
                var e = a.data, r = e.type;
                if (r < 0)
                  self.atomData = e.atoms, self.volume = e.volume, self.ps = new ProteinSurface();
                else {
                  var n = self.ps;
                  n.initparm(e.expandedExtent, r != 1, self.volume), n.fillvoxels(self.atomData, e.extendedAtoms), n.buildboundary(), (r === 4 || r === 2) && (n.fastdistancemap(), n.boundingatom(!1), n.fillvoxelswaals(self.atomData, e.extendedAtoms)), n.marchingcube(r);
                  var s = n.getFacesAndVertices(e.atomsToShow);
                  self.postMessage(s);
                }
              };
            }.toString().replace(/(^.*?\{|\}$)/g, ""), $3Dmol.workerString += `;
function _classCallCheck() {};`, $3Dmol.workerString += `;
` + $3Dmol.Vector3.toString(), $3Dmol.workerString += `;
` + $3Dmol.MarchingCubeInitializer.toString() + `;

`, $3Dmol.workerString += `;
` + $3Dmol.PointGrid.toString() + `;
`, $3Dmol.workerString += `;
var ProteinSurface = ` + $3Dmol.ProteinSurface.toString() + `;
`, $3Dmol.SurfaceWorker = window.URL ? window.URL.createObjectURL(new Blob([$3Dmol.workerString], { type: "text/javascript" })) : void 0;
          }
        ),
        /***/
        "./src/exporter.js": (
          /*!*************************!*\
            !*** ./src/exporter.js ***!
            \*************************/
          /***/
          (a) => {
            typeof a.exports == "object" && (a.exports = window.$3Dmol);
          }
        ),
        /***/
        "./src/vendor/mmtf.js": (
          /*!****************************!*\
            !*** ./src/vendor/mmtf.js ***!
            \****************************/
          /***/
          function(a, e) {
            (function(r, n) {
              n(e);
            })(this, function(r) {
              function n(ne, se, ue) {
                for (var $e = (ne.byteLength, 0), Ae = ue.length; Ae > $e; $e++) {
                  var je = ue.charCodeAt($e);
                  if (128 > je) ne.setUint8(se++, je >>> 0 & 127 | 0);
                  else if (2048 > je) ne.setUint8(se++, je >>> 6 & 31 | 192), ne.setUint8(se++, je >>> 0 & 63 | 128);
                  else if (65536 > je) ne.setUint8(se++, je >>> 12 & 15 | 224), ne.setUint8(se++, je >>> 6 & 63 | 128), ne.setUint8(se++, je >>> 0 & 63 | 128);
                  else {
                    if (!(1114112 > je)) throw new Error("bad codepoint " + je);
                    ne.setUint8(se++, je >>> 18 & 7 | 240), ne.setUint8(se++, je >>> 12 & 63 | 128), ne.setUint8(se++, je >>> 6 & 63 | 128), ne.setUint8(se++, je >>> 0 & 63 | 128);
                  }
                }
              }
              function s(ne) {
                for (var se = 0, ue = 0, $e = ne.length; $e > ue; ue++) {
                  var Ae = ne.charCodeAt(ue);
                  if (128 > Ae) se += 1;
                  else if (2048 > Ae) se += 2;
                  else if (65536 > Ae) se += 3;
                  else {
                    if (!(1114112 > Ae)) throw new Error("bad codepoint " + Ae);
                    se += 4;
                  }
                }
                return se;
              }
              function h(ne, se, ue) {
                var $e = typeof ne;
                if ($e === "string") {
                  var Ae = s(ne);
                  if (32 > Ae) return se.setUint8(ue, 160 | Ae), n(se, ue + 1, ne), 1 + Ae;
                  if (256 > Ae) return se.setUint8(ue, 217), se.setUint8(ue + 1, Ae), n(se, ue + 2, ne), 2 + Ae;
                  if (65536 > Ae) return se.setUint8(ue, 218), se.setUint16(ue + 1, Ae), n(se, ue + 3, ne), 3 + Ae;
                  if (4294967296 > Ae) return se.setUint8(ue, 219), se.setUint32(ue + 1, Ae), n(se, ue + 5, ne), 5 + Ae;
                }
                if (ne instanceof Uint8Array) {
                  var Ae = ne.byteLength, je = new Uint8Array(se.buffer);
                  if (256 > Ae) return se.setUint8(ue, 196), se.setUint8(ue + 1, Ae), je.set(ne, ue + 2), 2 + Ae;
                  if (65536 > Ae) return se.setUint8(ue, 197), se.setUint16(ue + 1, Ae), je.set(ne, ue + 3), 3 + Ae;
                  if (4294967296 > Ae) return se.setUint8(ue, 198), se.setUint32(ue + 1, Ae), je.set(ne, ue + 5), 5 + Ae;
                }
                if ($e === "number") {
                  if (!isFinite(ne)) throw new Error("Number not finite: " + ne);
                  if (Math.floor(ne) !== ne) return se.setUint8(ue, 203), se.setFloat64(ue + 1, ne), 9;
                  if (ne >= 0) {
                    if (128 > ne) return se.setUint8(ue, ne), 1;
                    if (256 > ne) return se.setUint8(ue, 204), se.setUint8(ue + 1, ne), 2;
                    if (65536 > ne) return se.setUint8(ue, 205), se.setUint16(ue + 1, ne), 3;
                    if (4294967296 > ne) return se.setUint8(ue, 206), se.setUint32(ue + 1, ne), 5;
                    throw new Error("Number too big 0x" + ne.toString(16));
                  }
                  if (ne >= -32) return se.setInt8(ue, ne), 1;
                  if (ne >= -128) return se.setUint8(ue, 208), se.setInt8(ue + 1, ne), 2;
                  if (ne >= -32768) return se.setUint8(ue, 209), se.setInt16(ue + 1, ne), 3;
                  if (ne >= -2147483648) return se.setUint8(ue, 210), se.setInt32(ue + 1, ne), 5;
                  throw new Error("Number too small -0x" + (-ne).toString(16).substr(1));
                }
                if (ne === null) return se.setUint8(ue, 192), 1;
                if ($e === "boolean") return se.setUint8(ue, ne ? 195 : 194), 1;
                if ($e === "object") {
                  var Ae, xe = 0, ze = Array.isArray(ne);
                  if (ze) Ae = ne.length;
                  else {
                    var re = Object.keys(ne);
                    Ae = re.length;
                  }
                  var xe;
                  if (16 > Ae ? (se.setUint8(ue, Ae | (ze ? 144 : 128)), xe = 1) : 65536 > Ae ? (se.setUint8(ue, ze ? 220 : 222), se.setUint16(ue + 1, Ae), xe = 3) : 4294967296 > Ae && (se.setUint8(ue, ze ? 221 : 223), se.setUint32(ue + 1, Ae), xe = 5), ze) for (var Le = 0; Ae > Le; Le++) xe += h(ne[Le], se, ue + xe);
                  else for (var Le = 0; Ae > Le; Le++) {
                    var He = re[Le];
                    xe += h(He, se, ue + xe), xe += h(ne[He], se, ue + xe);
                  }
                  return xe;
                }
                throw new Error("Unknown type " + $e);
              }
              function b(ne) {
                var se = typeof ne;
                if (se === "string") {
                  var ue = s(ne);
                  if (32 > ue) return 1 + ue;
                  if (256 > ue) return 2 + ue;
                  if (65536 > ue) return 3 + ue;
                  if (4294967296 > ue) return 5 + ue;
                }
                if (ne instanceof Uint8Array) {
                  var ue = ne.byteLength;
                  if (256 > ue) return 2 + ue;
                  if (65536 > ue) return 3 + ue;
                  if (4294967296 > ue) return 5 + ue;
                }
                if (se === "number") {
                  if (Math.floor(ne) !== ne) return 9;
                  if (ne >= 0) {
                    if (128 > ne) return 1;
                    if (256 > ne) return 2;
                    if (65536 > ne) return 3;
                    if (4294967296 > ne) return 5;
                    throw new Error("Number too big 0x" + ne.toString(16));
                  }
                  if (ne >= -32) return 1;
                  if (ne >= -128) return 2;
                  if (ne >= -32768) return 3;
                  if (ne >= -2147483648) return 5;
                  throw new Error("Number too small -0x" + ne.toString(16).substr(1));
                }
                if (se === "boolean" || ne === null) return 1;
                if (se === "object") {
                  var ue, $e = 0;
                  if (Array.isArray(ne)) {
                    ue = ne.length;
                    for (var Ae = 0; ue > Ae; Ae++) $e += b(ne[Ae]);
                  } else {
                    var je = Object.keys(ne);
                    ue = je.length;
                    for (var Ae = 0; ue > Ae; Ae++) {
                      var ze = je[Ae];
                      $e += b(ze) + b(ne[ze]);
                    }
                  }
                  if (16 > ue) return 1 + $e;
                  if (65536 > ue) return 3 + $e;
                  if (4294967296 > ue) return 5 + $e;
                  throw new Error("Array or object too long 0x" + ue.toString(16));
                }
                throw new Error("Unknown type " + se);
              }
              function g(ne) {
                var se = new ArrayBuffer(b(ne)), ue = new DataView(se);
                return h(ne, ue, 0), new Uint8Array(se);
              }
              function _(ne, se, ue) {
                return se ? new ne(se.buffer, se.byteOffset, se.byteLength / (ue || 1)) : void 0;
              }
              function A(ne) {
                return _(DataView, ne);
              }
              function x(ne) {
                return _(Uint8Array, ne);
              }
              function k(ne) {
                return _(Int8Array, ne);
              }
              function $(ne) {
                return _(Int32Array, ne, 4);
              }
              function C(ne) {
                return _(Float32Array, ne, 4);
              }
              function L(ne, se) {
                var ue = ne.length / 2;
                se || (se = new Int16Array(ue));
                for (var $e = 0, Ae = 0; ue > $e; ++$e, Ae += 2) se[$e] = ne[Ae] << 8 ^ ne[Ae + 1] << 0;
                return se;
              }
              function y(ne, se) {
                var ue = ne.length;
                se || (se = new Uint8Array(2 * ue));
                for (var $e = A(se), Ae = 0; ue > Ae; ++Ae) $e.setInt16(2 * Ae, ne[Ae]);
                return x(se);
              }
              function o(ne, se) {
                var ue = ne.length / 4;
                se || (se = new Int32Array(ue));
                for (var $e = 0, Ae = 0; ue > $e; ++$e, Ae += 4) se[$e] = ne[Ae] << 24 ^ ne[Ae + 1] << 16 ^ ne[Ae + 2] << 8 ^ ne[Ae + 3] << 0;
                return se;
              }
              function v(ne, se) {
                var ue = ne.length;
                se || (se = new Uint8Array(4 * ue));
                for (var $e = A(se), Ae = 0; ue > Ae; ++Ae) $e.setInt32(4 * Ae, ne[Ae]);
                return x(se);
              }
              function w(ne, se) {
                var ue = ne.length;
                se || (se = new Float32Array(ue / 4));
                for (var $e = A(se), Ae = A(ne), je = 0, ze = 0, re = ue / 4; re > je; ++je, ze += 4) $e.setFloat32(ze, Ae.getFloat32(ze), !0);
                return se;
              }
              function M(ne, se, ue) {
                var $e = ne.length, Ae = 1 / se;
                ue || (ue = new Float32Array($e));
                for (var je = 0; $e > je; ++je) ue[je] = ne[je] * Ae;
                return ue;
              }
              function F(ne, se, ue) {
                var $e = ne.length;
                ue || (ue = new Int32Array($e));
                for (var Ae = 0; $e > Ae; ++Ae) ue[Ae] = Math.round(ne[Ae] * se);
                return ue;
              }
              function m(ne, se) {
                var ue, $e;
                if (!se) {
                  var Ae = 0;
                  for (ue = 0, $e = ne.length; $e > ue; ue += 2) Ae += ne[ue + 1];
                  se = new ne.constructor(Ae);
                }
                var je = 0;
                for (ue = 0, $e = ne.length; $e > ue; ue += 2) for (var ze = ne[ue], re = ne[ue + 1], xe = 0; re > xe; ++xe) se[je] = ze, ++je;
                return se;
              }
              function E(ne) {
                if (ne.length === 0) return new Int32Array();
                var se, ue, $e = 2;
                for (se = 1, ue = ne.length; ue > se; ++se) ne[se - 1] !== ne[se] && ($e += 2);
                var Ae = new Int32Array($e), je = 0, ze = 1;
                for (se = 1, ue = ne.length; ue > se; ++se) ne[se - 1] !== ne[se] ? (Ae[je] = ne[se - 1], Ae[je + 1] = ze, ze = 1, je += 2) : ++ze;
                return Ae[je] = ne[ne.length - 1], Ae[je + 1] = ze, Ae;
              }
              function z(ne, se) {
                var ue = ne.length;
                se || (se = new ne.constructor(ue)), ue && (se[0] = ne[0]);
                for (var $e = 1; ue > $e; ++$e) se[$e] = ne[$e] + se[$e - 1];
                return se;
              }
              function O(ne, se) {
                var ue = ne.length;
                se || (se = new ne.constructor(ue)), se[0] = ne[0];
                for (var $e = 1; ue > $e; ++$e) se[$e] = ne[$e] - ne[$e - 1];
                return se;
              }
              function R(ne, se) {
                var ue, $e, Ae = ne instanceof Int8Array ? 127 : 32767, je = -Ae - 1, ze = ne.length;
                if (!se) {
                  var re = 0;
                  for (ue = 0; ze > ue; ++ue) ne[ue] < Ae && ne[ue] > je && ++re;
                  se = new Int32Array(re);
                }
                for (ue = 0, $e = 0; ze > ue; ) {
                  for (var xe = 0; ne[ue] === Ae || ne[ue] === je; ) xe += ne[ue], ++ue;
                  xe += ne[ue], ++ue, se[$e] = xe, ++$e;
                }
                return se;
              }
              function B(ne, se) {
                var ue, $e = 32767, Ae = -$e - 1, je = ne.length, ze = 0;
                for (ue = 0; je > ue; ++ue) {
                  var re = ne[ue];
                  re === 0 ? ++ze : re > 0 ? (ze += Math.ceil(re / $e), re % $e === 0 && (ze += 1)) : (ze += Math.ceil(re / Ae), re % Ae === 0 && (ze += 1));
                }
                var xe = new Int16Array(ze), Le = 0;
                for (ue = 0; je > ue; ++ue) {
                  var re = ne[ue];
                  if (re >= 0) for (; re >= $e; ) xe[Le] = $e, ++Le, re -= $e;
                  else for (; Ae >= re; ) xe[Le] = Ae, ++Le, re -= Ae;
                  xe[Le] = re, ++Le;
                }
                return xe;
              }
              function P(ne, se) {
                return z(m(ne), se);
              }
              function W(ne) {
                return E(O(ne));
              }
              function U(ne, se, ue) {
                return M(m(ne, $(ue)), se, ue);
              }
              function V(ne, se) {
                return E(F(ne, se));
              }
              function K(ne, se, ue) {
                return M(z(ne, $(ue)), se, ue);
              }
              function q(ne, se, ue) {
                return O(F(ne, se), ue);
              }
              function H(ne, se, ue) {
                return M(R(ne, $(ue)), se, ue);
              }
              function j(ne, se, ue) {
                var $e = R(ne, $(ue));
                return K($e, se, C($e));
              }
              function Q(ne, se, ue) {
                return B(q(ne, se));
              }
              function J(je) {
                var se = A(je), ue = se.getInt32(0), $e = se.getInt32(4), Ae = je.subarray(8, 12), je = je.subarray(12);
                return [ue, je, $e, Ae];
              }
              function Y(ne, se, ue, $e) {
                var Ae = new ArrayBuffer(12 + $e.byteLength), je = new Uint8Array(Ae), ze = new DataView(Ae);
                return ze.setInt32(0, ne), ze.setInt32(4, se), ue && je.set(ue, 8), je.set($e, 12), je;
              }
              function ee(ne) {
                var se = ne.length, ue = x(ne);
                return Y(2, se, void 0, ue);
              }
              function fe(ne) {
                var se = ne.length, ue = v(ne);
                return Y(4, se, void 0, ue);
              }
              function me(ne, se) {
                var ue = ne.length / se, $e = v([se]), Ae = x(ne);
                return Y(5, ue, $e, Ae);
              }
              function he(ne) {
                var se = ne.length, ue = v(E(ne));
                return Y(6, se, void 0, ue);
              }
              function we(ne) {
                var se = ne.length, ue = v(W(ne));
                return Y(8, se, void 0, ue);
              }
              function ye(ne, se) {
                var ue = ne.length, $e = v([se]), Ae = v(V(ne, se));
                return Y(9, ue, $e, Ae);
              }
              function ve(ne, se) {
                var ue = ne.length, $e = v([se]), Ae = y(Q(ne, se));
                return Y(10, ue, $e, Ae);
              }
              function ce(ne) {
                var se = {};
                return Ye.forEach(function(ue) {
                  ne[ue] !== void 0 && (se[ue] = ne[ue]);
                }), ne.bondAtomList && (se.bondAtomList = fe(ne.bondAtomList)), ne.bondOrderList && (se.bondOrderList = ee(ne.bondOrderList)), se.xCoordList = ve(ne.xCoordList, 1e3), se.yCoordList = ve(ne.yCoordList, 1e3), se.zCoordList = ve(ne.zCoordList, 1e3), ne.bFactorList && (se.bFactorList = ve(ne.bFactorList, 100)), ne.atomIdList && (se.atomIdList = we(ne.atomIdList)), ne.altLocList && (se.altLocList = he(ne.altLocList)), ne.occupancyList && (se.occupancyList = ye(ne.occupancyList, 100)), se.groupIdList = we(ne.groupIdList), se.groupTypeList = fe(ne.groupTypeList), ne.secStructList && (se.secStructList = ee(ne.secStructList)), ne.insCodeList && (se.insCodeList = he(ne.insCodeList)), ne.sequenceIndexList && (se.sequenceIndexList = we(ne.sequenceIndexList)), se.chainIdList = me(ne.chainIdList, 4), ne.chainNameList && (se.chainNameList = me(ne.chainNameList, 4)), se;
              }
              function be(ne) {
                function se(xe) {
                  for (var Le = {}, He = 0; xe > He; He++) {
                    var Me = je();
                    Le[Me] = je();
                  }
                  return Le;
                }
                function ue(xe) {
                  var Le = ne.subarray(ze, ze + xe);
                  return ze += xe, Le;
                }
                function $e(xe) {
                  var Le = ne.subarray(ze, ze + xe);
                  ze += xe;
                  var He = 65535;
                  if (xe > He) {
                    for (var Me = [], Re = 0; Re < Le.length; Re += He) Me.push(String.fromCharCode.apply(null, Le.subarray(Re, Re + He)));
                    return Me.join("");
                  }
                  return String.fromCharCode.apply(null, Le);
                }
                function Ae(xe) {
                  for (var Le = new Array(xe), He = 0; xe > He; He++) Le[He] = je();
                  return Le;
                }
                function je() {
                  var xe, Le, He = ne[ze];
                  if (!(128 & He)) return ze++, He;
                  if ((240 & He) === 128) return Le = 15 & He, ze++, se(Le);
                  if ((240 & He) === 144) return Le = 15 & He, ze++, Ae(Le);
                  if ((224 & He) === 160) return Le = 31 & He, ze++, $e(Le);
                  if ((224 & He) === 224) return xe = re.getInt8(ze), ze++, xe;
                  switch (He) {
                    case 192:
                      return ze++, null;
                    case 194:
                      return ze++, !1;
                    case 195:
                      return ze++, !0;
                    case 196:
                      return Le = re.getUint8(ze + 1), ze += 2, ue(Le);
                    case 197:
                      return Le = re.getUint16(ze + 1), ze += 3, ue(Le);
                    case 198:
                      return Le = re.getUint32(ze + 1), ze += 5, ue(Le);
                    case 202:
                      return xe = re.getFloat32(ze + 1), ze += 5, xe;
                    case 203:
                      return xe = re.getFloat64(ze + 1), ze += 9, xe;
                    case 204:
                      return xe = ne[ze + 1], ze += 2, xe;
                    case 205:
                      return xe = re.getUint16(ze + 1), ze += 3, xe;
                    case 206:
                      return xe = re.getUint32(ze + 1), ze += 5, xe;
                    case 208:
                      return xe = re.getInt8(ze + 1), ze += 2, xe;
                    case 209:
                      return xe = re.getInt16(ze + 1), ze += 3, xe;
                    case 210:
                      return xe = re.getInt32(ze + 1), ze += 5, xe;
                    case 217:
                      return Le = re.getUint8(ze + 1), ze += 2, $e(Le);
                    case 218:
                      return Le = re.getUint16(ze + 1), ze += 3, $e(Le);
                    case 219:
                      return Le = re.getUint32(ze + 1), ze += 5, $e(Le);
                    case 220:
                      return Le = re.getUint16(ze + 1), ze += 3, Ae(Le);
                    case 221:
                      return Le = re.getUint32(ze + 1), ze += 5, Ae(Le);
                    case 222:
                      return Le = re.getUint16(ze + 1), ze += 3, se(Le);
                    case 223:
                      return Le = re.getUint32(ze + 1), ze += 5, se(Le);
                  }
                  throw new Error("Unknown type 0x" + He.toString(16));
                }
                var ze = 0, re = new DataView(ne.buffer);
                return je();
              }
              function le(ne, se, ue, $e) {
                switch (ne) {
                  case 1:
                    return w(se);
                  case 2:
                    return k(se);
                  case 3:
                    return L(se);
                  case 4:
                    return o(se);
                  case 5:
                    return x(se);
                  case 6:
                    return m(o(se), new Uint8Array(ue));
                  case 7:
                    return m(o(se));
                  case 8:
                    return P(o(se));
                  case 9:
                    return U(o(se), o($e)[0]);
                  case 10:
                    return j(L(se), o($e)[0]);
                  case 11:
                    return M(L(se), o($e)[0]);
                  case 12:
                    return H(L(se), o($e)[0]);
                  case 13:
                    return H(k(se), o($e)[0]);
                  case 14:
                    return R(L(se));
                  case 15:
                    return R(k(se));
                }
              }
              function Se(ne, se) {
                se = se || {};
                var ue = se.ignoreFields, $e = {};
                return Ge.forEach(function(Ae) {
                  var je = ue ? ue.indexOf(Ae) !== -1 : !1, ze = ne[Ae];
                  je || ze === void 0 || (ze instanceof Uint8Array ? $e[Ae] = le.apply(null, J(ze)) : $e[Ae] = ze);
                }), $e;
              }
              function ge(ne) {
                return String.fromCharCode.apply(null, ne).replace(/\0/g, "");
              }
              function de(ne, se, ue) {
                ue = ue || {};
                var $e, Ae, je, ze, re, xe, Le = ue.firstModelOnly, He = se.onModel, Me = se.onChain, Re = se.onGroup, ie = se.onAtom, We = se.onBond, Qe = 0, G = 0, Fe = 0, Te = 0, ae = 0, Ee = -1, Ie = ne.chainNameList, lt = ne.secStructList, st = ne.insCodeList, at = ne.sequenceIndexList, gt = ne.atomIdList, Ot = ne.bFactorList, vt = ne.altLocList, yt = ne.occupancyList, _t = ne.bondAtomList, Bt = ne.bondOrderList;
                for ($e = 0, Ae = ne.chainsPerModel.length; Ae > $e && !(Le && Qe > 0); ++$e) {
                  var Ct = ne.chainsPerModel[Qe];
                  for (He && He({ chainCount: Ct, modelIndex: Qe }), je = 0; Ct > je; ++je) {
                    var Gt = ne.groupsPerChain[G];
                    if (Me) {
                      var Zt = ge(ne.chainIdList.subarray(4 * G, 4 * G + 4)), zt = null;
                      Ie && (zt = ge(Ie.subarray(4 * G, 4 * G + 4))), Me({ groupCount: Gt, chainIndex: G, modelIndex: Qe, chainId: Zt, chainName: zt });
                    }
                    for (ze = 0; Gt > ze; ++ze) {
                      var It = ne.groupList[ne.groupTypeList[Fe]], Lt = It.atomNameList.length;
                      if (Re) {
                        var Kt = null;
                        lt && (Kt = lt[Fe]);
                        var ct = null;
                        ne.insCodeList && (ct = String.fromCharCode(st[Fe]));
                        var ke = null;
                        at && (ke = at[Fe]), Re({ atomCount: Lt, groupIndex: Fe, chainIndex: G, modelIndex: Qe, groupId: ne.groupIdList[Fe], groupType: ne.groupTypeList[Fe], groupName: It.groupName, singleLetterCode: It.singleLetterCode, chemCompType: It.chemCompType, secStruct: Kt, insCode: ct, sequenceIndex: ke });
                      }
                      for (re = 0; Lt > re; ++re) {
                        if (ie) {
                          var tt = null;
                          gt && (tt = gt[Te]);
                          var dt = null;
                          Ot && (dt = Ot[Te]);
                          var Tt = null;
                          vt && (Tt = String.fromCharCode(vt[Te]));
                          var Wt = null;
                          yt && (Wt = yt[Te]), ie({ atomIndex: Te, groupIndex: Fe, chainIndex: G, modelIndex: Qe, atomId: tt, element: It.elementList[re], atomName: It.atomNameList[re], formalCharge: It.formalChargeList[re], xCoord: ne.xCoordList[Te], yCoord: ne.yCoordList[Te], zCoord: ne.zCoordList[Te], bFactor: dt, altLoc: Tt, occupancy: Wt });
                        }
                        Te += 1;
                      }
                      if (We) {
                        var Ut = It.bondAtomList;
                        for (re = 0, xe = It.bondOrderList.length; xe > re; ++re) We({ atomIndex1: Te - Lt + Ut[2 * re], atomIndex2: Te - Lt + Ut[2 * re + 1], bondOrder: It.bondOrderList[re] });
                      }
                      Fe += 1;
                    }
                    G += 1;
                  }
                  if (ae = Ee + 1, Ee = Te - 1, We && _t) for (re = 0, xe = _t.length; xe > re; re += 2) {
                    var Ht = _t[re], Xt = _t[re + 1];
                    (Ht >= ae && Ee >= Ht || Xt >= ae && Ee >= Xt) && We({ atomIndex1: Ht, atomIndex2: Xt, bondOrder: Bt ? Bt[re / 2] : null });
                  }
                  Qe += 1;
                }
              }
              function De(ne) {
                return g(ce(ne));
              }
              function Be(ne, se) {
                ne instanceof ArrayBuffer && (ne = new Uint8Array(ne));
                var ue;
                return ue = ne instanceof Uint8Array ? be(ne) : ne, Se(ue, se);
              }
              function Ve(ne, se, ue, $e) {
                function Ae() {
                  try {
                    var ze = Be(je.response);
                    ue(ze);
                  } catch (re) {
                    $e(re);
                  }
                }
                var je = new XMLHttpRequest();
                je.addEventListener("load", Ae, !0), je.addEventListener("error", $e, !0), je.responseType = "arraybuffer", je.open("GET", se + ne.toUpperCase()), je.send();
              }
              function qe(ne, se, ue) {
                Ve(ne, it, se, ue);
              }
              function Ze(ne, se, ue) {
                Ve(ne, nt, se, ue);
              }
              var Ye = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], Xe = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], Ge = Ye.concat(Xe), Ke = "v1.0.1", Pe = "//mmtf.rcsb.org/v1.0/", it = Pe + "full/", nt = Pe + "reduced/";
              r.encode = De, r.decode = Be, r.traverse = de, r.fetch = qe, r.fetchReduced = Ze, r.version = Ke, r.fetchUrl = it, r.fetchReducedUrl = nt, r.encodeMsgpack = g, r.encodeMmtf = ce, r.decodeMsgpack = be, r.decodeMmtf = Se;
            });
          }
        ),
        /***/
        "./node_modules/pako/dist/pako.esm.mjs": (
          /*!*********************************************!*\
            !*** ./node_modules/pako/dist/pako.esm.mjs ***!
            \*********************************************/
          /***/
          (a, e, r) => {
            r.r(e), r.d(e, {
              /* harmony export */
              Deflate: () => (
                /* binding */
                ln
              ),
              /* harmony export */
              Inflate: () => (
                /* binding */
                un
              ),
              /* harmony export */
              constants: () => (
                /* binding */
                pn
              ),
              /* harmony export */
              default: () => (
                /* binding */
                ls
              ),
              /* harmony export */
              deflate: () => (
                /* binding */
                on
              ),
              /* harmony export */
              deflateRaw: () => (
                /* binding */
                cn
              ),
              /* harmony export */
              gzip: () => (
                /* binding */
                hn
              ),
              /* harmony export */
              inflate: () => (
                /* binding */
                dn
              ),
              /* harmony export */
              inflateRaw: () => (
                /* binding */
                fn
              ),
              /* harmony export */
              ungzip: () => (
                /* binding */
                mn
              )
              /* harmony export */
            });
            /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
            const n = 4, s = 0, h = 1, b = 2;
            function g(I) {
              let te = I.length;
              for (; --te >= 0; )
                I[te] = 0;
            }
            const _ = 0, A = 1, x = 2, k = 3, $ = 258, C = 29, L = 256, y = L + 1 + C, o = 30, v = 19, w = 2 * y + 1, M = 15, F = 16, m = 7, E = 256, z = 16, O = 17, R = 18, B = (
              /* extra bits for each length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
            ), P = (
              /* extra bits for each distance code */
              new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
            ), W = (
              /* extra bits for each bit length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
            ), U = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), V = 512, K = new Array((y + 2) * 2);
            g(K);
            const q = new Array(o * 2);
            g(q);
            const H = new Array(V);
            g(H);
            const j = new Array($ - k + 1);
            g(j);
            const Q = new Array(C);
            g(Q);
            const J = new Array(o);
            g(J);
            function Y(I, te, N, oe, _e) {
              this.static_tree = I, this.extra_bits = te, this.extra_base = N, this.elems = oe, this.max_length = _e, this.has_stree = I && I.length;
            }
            let ee, fe, me;
            function he(I, te) {
              this.dyn_tree = I, this.max_code = 0, this.stat_desc = te;
            }
            const we = (I) => I < 256 ? H[I] : H[256 + (I >>> 7)], ye = (I, te) => {
              I.pending_buf[I.pending++] = te & 255, I.pending_buf[I.pending++] = te >>> 8 & 255;
            }, ve = (I, te, N) => {
              I.bi_valid > F - N ? (I.bi_buf |= te << I.bi_valid & 65535, ye(I, I.bi_buf), I.bi_buf = te >> F - I.bi_valid, I.bi_valid += N - F) : (I.bi_buf |= te << I.bi_valid & 65535, I.bi_valid += N);
            }, ce = (I, te, N) => {
              ve(
                I,
                N[te * 2],
                N[te * 2 + 1]
                /*.Len*/
              );
            }, be = (I, te) => {
              let N = 0;
              do
                N |= I & 1, I >>>= 1, N <<= 1;
              while (--te > 0);
              return N >>> 1;
            }, le = (I) => {
              I.bi_valid === 16 ? (ye(I, I.bi_buf), I.bi_buf = 0, I.bi_valid = 0) : I.bi_valid >= 8 && (I.pending_buf[I.pending++] = I.bi_buf & 255, I.bi_buf >>= 8, I.bi_valid -= 8);
            }, Se = (I, te) => {
              const N = te.dyn_tree, oe = te.max_code, _e = te.stat_desc.static_tree, pe = te.stat_desc.has_stree, Ne = te.stat_desc.extra_bits, Oe = te.stat_desc.extra_base, ft = te.stat_desc.max_length;
              let Ce, Ue, Dt, ut, Je, mt, Nt = 0;
              for (ut = 0; ut <= M; ut++)
                I.bl_count[ut] = 0;
              for (N[I.heap[I.heap_max] * 2 + 1] = 0, Ce = I.heap_max + 1; Ce < w; Ce++)
                Ue = I.heap[Ce], ut = N[N[Ue * 2 + 1] * 2 + 1] + 1, ut > ft && (ut = ft, Nt++), N[Ue * 2 + 1] = ut, !(Ue > oe) && (I.bl_count[ut]++, Je = 0, Ue >= Oe && (Je = Ne[Ue - Oe]), mt = N[Ue * 2], I.opt_len += mt * (ut + Je), pe && (I.static_len += mt * (_e[Ue * 2 + 1] + Je)));
              if (Nt !== 0) {
                do {
                  for (ut = ft - 1; I.bl_count[ut] === 0; )
                    ut--;
                  I.bl_count[ut]--, I.bl_count[ut + 1] += 2, I.bl_count[ft]--, Nt -= 2;
                } while (Nt > 0);
                for (ut = ft; ut !== 0; ut--)
                  for (Ue = I.bl_count[ut]; Ue !== 0; )
                    Dt = I.heap[--Ce], !(Dt > oe) && (N[Dt * 2 + 1] !== ut && (I.opt_len += (ut - N[Dt * 2 + 1]) * N[Dt * 2], N[Dt * 2 + 1] = ut), Ue--);
              }
            }, ge = (I, te, N) => {
              const oe = new Array(M + 1);
              let _e = 0, pe, Ne;
              for (pe = 1; pe <= M; pe++)
                _e = _e + N[pe - 1] << 1, oe[pe] = _e;
              for (Ne = 0; Ne <= te; Ne++) {
                let Oe = I[Ne * 2 + 1];
                Oe !== 0 && (I[Ne * 2] = be(oe[Oe]++, Oe));
              }
            }, de = () => {
              let I, te, N, oe, _e;
              const pe = new Array(M + 1);
              for (N = 0, oe = 0; oe < C - 1; oe++)
                for (Q[oe] = N, I = 0; I < 1 << B[oe]; I++)
                  j[N++] = oe;
              for (j[N - 1] = oe, _e = 0, oe = 0; oe < 16; oe++)
                for (J[oe] = _e, I = 0; I < 1 << P[oe]; I++)
                  H[_e++] = oe;
              for (_e >>= 7; oe < o; oe++)
                for (J[oe] = _e << 7, I = 0; I < 1 << P[oe] - 7; I++)
                  H[256 + _e++] = oe;
              for (te = 0; te <= M; te++)
                pe[te] = 0;
              for (I = 0; I <= 143; )
                K[I * 2 + 1] = 8, I++, pe[8]++;
              for (; I <= 255; )
                K[I * 2 + 1] = 9, I++, pe[9]++;
              for (; I <= 279; )
                K[I * 2 + 1] = 7, I++, pe[7]++;
              for (; I <= 287; )
                K[I * 2 + 1] = 8, I++, pe[8]++;
              for (ge(K, y + 1, pe), I = 0; I < o; I++)
                q[I * 2 + 1] = 5, q[I * 2] = be(I, 5);
              ee = new Y(K, B, L + 1, y, M), fe = new Y(q, P, 0, o, M), me = new Y(new Array(0), W, 0, v, m);
            }, De = (I) => {
              let te;
              for (te = 0; te < y; te++)
                I.dyn_ltree[te * 2] = 0;
              for (te = 0; te < o; te++)
                I.dyn_dtree[te * 2] = 0;
              for (te = 0; te < v; te++)
                I.bl_tree[te * 2] = 0;
              I.dyn_ltree[E * 2] = 1, I.opt_len = I.static_len = 0, I.sym_next = I.matches = 0;
            }, Be = (I) => {
              I.bi_valid > 8 ? ye(I, I.bi_buf) : I.bi_valid > 0 && (I.pending_buf[I.pending++] = I.bi_buf), I.bi_buf = 0, I.bi_valid = 0;
            }, Ve = (I, te, N, oe) => {
              const _e = te * 2, pe = N * 2;
              return I[_e] < I[pe] || I[_e] === I[pe] && oe[te] <= oe[N];
            }, qe = (I, te, N) => {
              const oe = I.heap[N];
              let _e = N << 1;
              for (; _e <= I.heap_len && (_e < I.heap_len && Ve(te, I.heap[_e + 1], I.heap[_e], I.depth) && _e++, !Ve(te, oe, I.heap[_e], I.depth)); )
                I.heap[N] = I.heap[_e], N = _e, _e <<= 1;
              I.heap[N] = oe;
            }, Ze = (I, te, N) => {
              let oe, _e, pe = 0, Ne, Oe;
              if (I.sym_next !== 0)
                do
                  oe = I.pending_buf[I.sym_buf + pe++] & 255, oe += (I.pending_buf[I.sym_buf + pe++] & 255) << 8, _e = I.pending_buf[I.sym_buf + pe++], oe === 0 ? ce(I, _e, te) : (Ne = j[_e], ce(I, Ne + L + 1, te), Oe = B[Ne], Oe !== 0 && (_e -= Q[Ne], ve(I, _e, Oe)), oe--, Ne = we(oe), ce(I, Ne, N), Oe = P[Ne], Oe !== 0 && (oe -= J[Ne], ve(I, oe, Oe)));
                while (pe < I.sym_next);
              ce(I, E, te);
            }, Ye = (I, te) => {
              const N = te.dyn_tree, oe = te.stat_desc.static_tree, _e = te.stat_desc.has_stree, pe = te.stat_desc.elems;
              let Ne, Oe, ft = -1, Ce;
              for (I.heap_len = 0, I.heap_max = w, Ne = 0; Ne < pe; Ne++)
                N[Ne * 2] !== 0 ? (I.heap[++I.heap_len] = ft = Ne, I.depth[Ne] = 0) : N[Ne * 2 + 1] = 0;
              for (; I.heap_len < 2; )
                Ce = I.heap[++I.heap_len] = ft < 2 ? ++ft : 0, N[Ce * 2] = 1, I.depth[Ce] = 0, I.opt_len--, _e && (I.static_len -= oe[Ce * 2 + 1]);
              for (te.max_code = ft, Ne = I.heap_len >> 1; Ne >= 1; Ne--)
                qe(I, N, Ne);
              Ce = pe;
              do
                Ne = I.heap[
                  1
                  /*SMALLEST*/
                ], I.heap[
                  1
                  /*SMALLEST*/
                ] = I.heap[I.heap_len--], qe(
                  I,
                  N,
                  1
                  /*SMALLEST*/
                ), Oe = I.heap[
                  1
                  /*SMALLEST*/
                ], I.heap[--I.heap_max] = Ne, I.heap[--I.heap_max] = Oe, N[Ce * 2] = N[Ne * 2] + N[Oe * 2], I.depth[Ce] = (I.depth[Ne] >= I.depth[Oe] ? I.depth[Ne] : I.depth[Oe]) + 1, N[Ne * 2 + 1] = N[Oe * 2 + 1] = Ce, I.heap[
                  1
                  /*SMALLEST*/
                ] = Ce++, qe(
                  I,
                  N,
                  1
                  /*SMALLEST*/
                );
              while (I.heap_len >= 2);
              I.heap[--I.heap_max] = I.heap[
                1
                /*SMALLEST*/
              ], Se(I, te), ge(N, ft, I.bl_count);
            }, Xe = (I, te, N) => {
              let oe, _e = -1, pe, Ne = te[0 * 2 + 1], Oe = 0, ft = 7, Ce = 4;
              for (Ne === 0 && (ft = 138, Ce = 3), te[(N + 1) * 2 + 1] = 65535, oe = 0; oe <= N; oe++)
                pe = Ne, Ne = te[(oe + 1) * 2 + 1], !(++Oe < ft && pe === Ne) && (Oe < Ce ? I.bl_tree[pe * 2] += Oe : pe !== 0 ? (pe !== _e && I.bl_tree[pe * 2]++, I.bl_tree[z * 2]++) : Oe <= 10 ? I.bl_tree[O * 2]++ : I.bl_tree[R * 2]++, Oe = 0, _e = pe, Ne === 0 ? (ft = 138, Ce = 3) : pe === Ne ? (ft = 6, Ce = 3) : (ft = 7, Ce = 4));
            }, Ge = (I, te, N) => {
              let oe, _e = -1, pe, Ne = te[0 * 2 + 1], Oe = 0, ft = 7, Ce = 4;
              for (Ne === 0 && (ft = 138, Ce = 3), oe = 0; oe <= N; oe++)
                if (pe = Ne, Ne = te[(oe + 1) * 2 + 1], !(++Oe < ft && pe === Ne)) {
                  if (Oe < Ce)
                    do
                      ce(I, pe, I.bl_tree);
                    while (--Oe !== 0);
                  else pe !== 0 ? (pe !== _e && (ce(I, pe, I.bl_tree), Oe--), ce(I, z, I.bl_tree), ve(I, Oe - 3, 2)) : Oe <= 10 ? (ce(I, O, I.bl_tree), ve(I, Oe - 3, 3)) : (ce(I, R, I.bl_tree), ve(I, Oe - 11, 7));
                  Oe = 0, _e = pe, Ne === 0 ? (ft = 138, Ce = 3) : pe === Ne ? (ft = 6, Ce = 3) : (ft = 7, Ce = 4);
                }
            }, Ke = (I) => {
              let te;
              for (Xe(I, I.dyn_ltree, I.l_desc.max_code), Xe(I, I.dyn_dtree, I.d_desc.max_code), Ye(I, I.bl_desc), te = v - 1; te >= 3 && I.bl_tree[U[te] * 2 + 1] === 0; te--)
                ;
              return I.opt_len += 3 * (te + 1) + 5 + 5 + 4, te;
            }, Pe = (I, te, N, oe) => {
              let _e;
              for (ve(I, te - 257, 5), ve(I, N - 1, 5), ve(I, oe - 4, 4), _e = 0; _e < oe; _e++)
                ve(I, I.bl_tree[U[_e] * 2 + 1], 3);
              Ge(I, I.dyn_ltree, te - 1), Ge(I, I.dyn_dtree, N - 1);
            }, it = (I) => {
              let te = 4093624447, N;
              for (N = 0; N <= 31; N++, te >>>= 1)
                if (te & 1 && I.dyn_ltree[N * 2] !== 0)
                  return s;
              if (I.dyn_ltree[9 * 2] !== 0 || I.dyn_ltree[10 * 2] !== 0 || I.dyn_ltree[13 * 2] !== 0)
                return h;
              for (N = 32; N < L; N++)
                if (I.dyn_ltree[N * 2] !== 0)
                  return h;
              return s;
            };
            let nt = !1;
            const ne = (I) => {
              nt || (de(), nt = !0), I.l_desc = new he(I.dyn_ltree, ee), I.d_desc = new he(I.dyn_dtree, fe), I.bl_desc = new he(I.bl_tree, me), I.bi_buf = 0, I.bi_valid = 0, De(I);
            }, se = (I, te, N, oe) => {
              ve(I, (_ << 1) + (oe ? 1 : 0), 3), Be(I), ye(I, N), ye(I, ~N), N && I.pending_buf.set(I.window.subarray(te, te + N), I.pending), I.pending += N;
            }, ue = (I) => {
              ve(I, A << 1, 3), ce(I, E, K), le(I);
            }, $e = (I, te, N, oe) => {
              let _e, pe, Ne = 0;
              I.level > 0 ? (I.strm.data_type === b && (I.strm.data_type = it(I)), Ye(I, I.l_desc), Ye(I, I.d_desc), Ne = Ke(I), _e = I.opt_len + 3 + 7 >>> 3, pe = I.static_len + 3 + 7 >>> 3, pe <= _e && (_e = pe)) : _e = pe = N + 5, N + 4 <= _e && te !== -1 ? se(I, te, N, oe) : I.strategy === n || pe === _e ? (ve(I, (A << 1) + (oe ? 1 : 0), 3), Ze(I, K, q)) : (ve(I, (x << 1) + (oe ? 1 : 0), 3), Pe(I, I.l_desc.max_code + 1, I.d_desc.max_code + 1, Ne + 1), Ze(I, I.dyn_ltree, I.dyn_dtree)), De(I), oe && Be(I);
            }, Ae = (I, te, N) => (I.pending_buf[I.sym_buf + I.sym_next++] = te, I.pending_buf[I.sym_buf + I.sym_next++] = te >> 8, I.pending_buf[I.sym_buf + I.sym_next++] = N, te === 0 ? I.dyn_ltree[N * 2]++ : (I.matches++, te--, I.dyn_ltree[(j[N] + L + 1) * 2]++, I.dyn_dtree[we(te) * 2]++), I.sym_next === I.sym_end);
            var je = ne, ze = se, re = $e, xe = Ae, Le = ue, He = {
              _tr_init: je,
              _tr_stored_block: ze,
              _tr_flush_block: re,
              _tr_tally: xe,
              _tr_align: Le
            }, Re = (I, te, N, oe) => {
              let _e = I & 65535 | 0, pe = I >>> 16 & 65535 | 0, Ne = 0;
              for (; N !== 0; ) {
                Ne = N > 2e3 ? 2e3 : N, N -= Ne;
                do
                  _e = _e + te[oe++] | 0, pe = pe + _e | 0;
                while (--Ne);
                _e %= 65521, pe %= 65521;
              }
              return _e | pe << 16 | 0;
            };
            const ie = () => {
              let I, te = [];
              for (var N = 0; N < 256; N++) {
                I = N;
                for (var oe = 0; oe < 8; oe++)
                  I = I & 1 ? 3988292384 ^ I >>> 1 : I >>> 1;
                te[N] = I;
              }
              return te;
            }, We = new Uint32Array(ie());
            var G = (I, te, N, oe) => {
              const _e = We, pe = oe + N;
              I ^= -1;
              for (let Ne = oe; Ne < pe; Ne++)
                I = I >>> 8 ^ _e[(I ^ te[Ne]) & 255];
              return I ^ -1;
            }, Fe = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            }, Te = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              Z_MEM_ERROR: -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
            const { _tr_init: ae, _tr_stored_block: Ee, _tr_flush_block: Ie, _tr_tally: lt, _tr_align: st } = He, {
              Z_NO_FLUSH: at,
              Z_PARTIAL_FLUSH: gt,
              Z_FULL_FLUSH: Ot,
              Z_FINISH: vt,
              Z_BLOCK: yt,
              Z_OK: _t,
              Z_STREAM_END: Bt,
              Z_STREAM_ERROR: Ct,
              Z_DATA_ERROR: Gt,
              Z_BUF_ERROR: Zt,
              Z_DEFAULT_COMPRESSION: zt,
              Z_FILTERED: It,
              Z_HUFFMAN_ONLY: Lt,
              Z_RLE: Kt,
              Z_FIXED: ct,
              Z_DEFAULT_STRATEGY: ke,
              Z_UNKNOWN: tt,
              Z_DEFLATED: dt
            } = Te, Tt = 9, Wt = 15, Ut = 8, rr = 256 + 1 + 29, jt = 30, Fr = 19, Or = 2 * rr + 1, _n = 15, Et = 3, ar = 258, er = ar + Et + 1, vn = 32, pr = 42, Vr = 57, jr = 69, Kr = 73, Xr = 91, Yr = 103, or = 113, wr = 666, Yt = 1, gr = 2, cr = 3, _r = 4, bn = 3, ur = (I, te) => (I.msg = Fe[te], te), oi = (I) => I * 2 - (I > 4 ? 9 : 0), sr = (I) => {
              let te = I.length;
              for (; --te >= 0; )
                I[te] = 0;
            }, yn = (I) => {
              let te, N, oe, _e = I.w_size;
              te = I.hash_size, oe = te;
              do
                N = I.head[--oe], I.head[oe] = N >= _e ? N - _e : 0;
              while (--te);
              te = _e, oe = te;
              do
                N = I.prev[--oe], I.prev[oe] = N >= _e ? N - _e : 0;
              while (--te);
            };
            let lr = (I, te, N) => (te << I.hash_shift ^ N) & I.hash_mask;
            const qt = (I) => {
              const te = I.state;
              let N = te.pending;
              N > I.avail_out && (N = I.avail_out), N !== 0 && (I.output.set(te.pending_buf.subarray(te.pending_out, te.pending_out + N), I.next_out), I.next_out += N, te.pending_out += N, I.total_out += N, I.avail_out -= N, te.pending -= N, te.pending === 0 && (te.pending_out = 0));
            }, Qt = (I, te) => {
              Ie(I, I.block_start >= 0 ? I.block_start : -1, I.strstart - I.block_start, te), I.block_start = I.strstart, qt(I.strm);
            }, kt = (I, te) => {
              I.pending_buf[I.pending++] = te;
            }, Er = (I, te) => {
              I.pending_buf[I.pending++] = te >>> 8 & 255, I.pending_buf[I.pending++] = te & 255;
            }, Zr = (I, te, N, oe) => {
              let _e = I.avail_in;
              return _e > oe && (_e = oe), _e === 0 ? 0 : (I.avail_in -= _e, te.set(I.input.subarray(I.next_in, I.next_in + _e), N), I.state.wrap === 1 ? I.adler = Re(I.adler, te, _e, N) : I.state.wrap === 2 && (I.adler = G(I.adler, te, _e, N)), I.next_in += _e, I.total_in += _e, _e);
            }, ci = (I, te) => {
              let N = I.max_chain_length, oe = I.strstart, _e, pe, Ne = I.prev_length, Oe = I.nice_match;
              const ft = I.strstart > I.w_size - er ? I.strstart - (I.w_size - er) : 0, Ce = I.window, Ue = I.w_mask, Dt = I.prev, ut = I.strstart + ar;
              let Je = Ce[oe + Ne - 1], mt = Ce[oe + Ne];
              I.prev_length >= I.good_match && (N >>= 2), Oe > I.lookahead && (Oe = I.lookahead);
              do
                if (_e = te, !(Ce[_e + Ne] !== mt || Ce[_e + Ne - 1] !== Je || Ce[_e] !== Ce[oe] || Ce[++_e] !== Ce[oe + 1])) {
                  oe += 2, _e++;
                  do
                    ;
                  while (Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && Ce[++oe] === Ce[++_e] && oe < ut);
                  if (pe = ar - (ut - oe), oe = ut - ar, pe > Ne) {
                    if (I.match_start = te, Ne = pe, pe >= Oe)
                      break;
                    Je = Ce[oe + Ne - 1], mt = Ce[oe + Ne];
                  }
                }
              while ((te = Dt[te & Ue]) > ft && --N !== 0);
              return Ne <= I.lookahead ? Ne : I.lookahead;
            }, vr = (I) => {
              const te = I.w_size;
              let N, oe, _e;
              do {
                if (oe = I.window_size - I.lookahead - I.strstart, I.strstart >= te + (te - er) && (I.window.set(I.window.subarray(te, te + te - oe), 0), I.match_start -= te, I.strstart -= te, I.block_start -= te, I.insert > I.strstart && (I.insert = I.strstart), yn(I), oe += te), I.strm.avail_in === 0)
                  break;
                if (N = Zr(I.strm, I.window, I.strstart + I.lookahead, oe), I.lookahead += N, I.lookahead + I.insert >= Et)
                  for (_e = I.strstart - I.insert, I.ins_h = I.window[_e], I.ins_h = lr(I, I.ins_h, I.window[_e + 1]); I.insert && (I.ins_h = lr(I, I.ins_h, I.window[_e + Et - 1]), I.prev[_e & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = _e, _e++, I.insert--, !(I.lookahead + I.insert < Et)); )
                    ;
              } while (I.lookahead < er && I.strm.avail_in !== 0);
            }, hi = (I, te) => {
              let N = I.pending_buf_size - 5 > I.w_size ? I.w_size : I.pending_buf_size - 5, oe, _e, pe, Ne = 0, Oe = I.strm.avail_in;
              do {
                if (oe = 65535, pe = I.bi_valid + 42 >> 3, I.strm.avail_out < pe || (pe = I.strm.avail_out - pe, _e = I.strstart - I.block_start, oe > _e + I.strm.avail_in && (oe = _e + I.strm.avail_in), oe > pe && (oe = pe), oe < N && (oe === 0 && te !== vt || te === at || oe !== _e + I.strm.avail_in)))
                  break;
                Ne = te === vt && oe === _e + I.strm.avail_in ? 1 : 0, Ee(I, 0, 0, Ne), I.pending_buf[I.pending - 4] = oe, I.pending_buf[I.pending - 3] = oe >> 8, I.pending_buf[I.pending - 2] = ~oe, I.pending_buf[I.pending - 1] = ~oe >> 8, qt(I.strm), _e && (_e > oe && (_e = oe), I.strm.output.set(I.window.subarray(I.block_start, I.block_start + _e), I.strm.next_out), I.strm.next_out += _e, I.strm.avail_out -= _e, I.strm.total_out += _e, I.block_start += _e, oe -= _e), oe && (Zr(I.strm, I.strm.output, I.strm.next_out, oe), I.strm.next_out += oe, I.strm.avail_out -= oe, I.strm.total_out += oe);
              } while (Ne === 0);
              return Oe -= I.strm.avail_in, Oe && (Oe >= I.w_size ? (I.matches = 2, I.window.set(I.strm.input.subarray(I.strm.next_in - I.w_size, I.strm.next_in), 0), I.strstart = I.w_size, I.insert = I.strstart) : (I.window_size - I.strstart <= Oe && (I.strstart -= I.w_size, I.window.set(I.window.subarray(I.w_size, I.w_size + I.strstart), 0), I.matches < 2 && I.matches++, I.insert > I.strstart && (I.insert = I.strstart)), I.window.set(I.strm.input.subarray(I.strm.next_in - Oe, I.strm.next_in), I.strstart), I.strstart += Oe, I.insert += Oe > I.w_size - I.insert ? I.w_size - I.insert : Oe), I.block_start = I.strstart), I.high_water < I.strstart && (I.high_water = I.strstart), Ne ? _r : te !== at && te !== vt && I.strm.avail_in === 0 && I.strstart === I.block_start ? gr : (pe = I.window_size - I.strstart, I.strm.avail_in > pe && I.block_start >= I.w_size && (I.block_start -= I.w_size, I.strstart -= I.w_size, I.window.set(I.window.subarray(I.w_size, I.w_size + I.strstart), 0), I.matches < 2 && I.matches++, pe += I.w_size, I.insert > I.strstart && (I.insert = I.strstart)), pe > I.strm.avail_in && (pe = I.strm.avail_in), pe && (Zr(I.strm, I.window, I.strstart, pe), I.strstart += pe, I.insert += pe > I.w_size - I.insert ? I.w_size - I.insert : pe), I.high_water < I.strstart && (I.high_water = I.strstart), pe = I.bi_valid + 42 >> 3, pe = I.pending_buf_size - pe > 65535 ? 65535 : I.pending_buf_size - pe, N = pe > I.w_size ? I.w_size : pe, _e = I.strstart - I.block_start, (_e >= N || (_e || te === vt) && te !== at && I.strm.avail_in === 0 && _e <= pe) && (oe = _e > pe ? pe : _e, Ne = te === vt && I.strm.avail_in === 0 && oe === _e ? 1 : 0, Ee(I, I.block_start, oe, Ne), I.block_start += oe, qt(I.strm)), Ne ? cr : Yt);
            }, qr = (I, te) => {
              let N, oe;
              for (; ; ) {
                if (I.lookahead < er) {
                  if (vr(I), I.lookahead < er && te === at)
                    return Yt;
                  if (I.lookahead === 0)
                    break;
                }
                if (N = 0, I.lookahead >= Et && (I.ins_h = lr(I, I.ins_h, I.window[I.strstart + Et - 1]), N = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), N !== 0 && I.strstart - N <= I.w_size - er && (I.match_length = ci(I, N)), I.match_length >= Et)
                  if (oe = lt(I, I.strstart - I.match_start, I.match_length - Et), I.lookahead -= I.match_length, I.match_length <= I.max_lazy_match && I.lookahead >= Et) {
                    I.match_length--;
                    do
                      I.strstart++, I.ins_h = lr(I, I.ins_h, I.window[I.strstart + Et - 1]), N = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart;
                    while (--I.match_length !== 0);
                    I.strstart++;
                  } else
                    I.strstart += I.match_length, I.match_length = 0, I.ins_h = I.window[I.strstart], I.ins_h = lr(I, I.ins_h, I.window[I.strstart + 1]);
                else
                  oe = lt(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++;
                if (oe && (Qt(I, !1), I.strm.avail_out === 0))
                  return Yt;
              }
              return I.insert = I.strstart < Et - 1 ? I.strstart : Et - 1, te === vt ? (Qt(I, !0), I.strm.avail_out === 0 ? cr : _r) : I.sym_next && (Qt(I, !1), I.strm.avail_out === 0) ? Yt : gr;
            }, yr = (I, te) => {
              let N, oe, _e;
              for (; ; ) {
                if (I.lookahead < er) {
                  if (vr(I), I.lookahead < er && te === at)
                    return Yt;
                  if (I.lookahead === 0)
                    break;
                }
                if (N = 0, I.lookahead >= Et && (I.ins_h = lr(I, I.ins_h, I.window[I.strstart + Et - 1]), N = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), I.prev_length = I.match_length, I.prev_match = I.match_start, I.match_length = Et - 1, N !== 0 && I.prev_length < I.max_lazy_match && I.strstart - N <= I.w_size - er && (I.match_length = ci(I, N), I.match_length <= 5 && (I.strategy === It || I.match_length === Et && I.strstart - I.match_start > 4096) && (I.match_length = Et - 1)), I.prev_length >= Et && I.match_length <= I.prev_length) {
                  _e = I.strstart + I.lookahead - Et, oe = lt(I, I.strstart - 1 - I.prev_match, I.prev_length - Et), I.lookahead -= I.prev_length - 1, I.prev_length -= 2;
                  do
                    ++I.strstart <= _e && (I.ins_h = lr(I, I.ins_h, I.window[I.strstart + Et - 1]), N = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart);
                  while (--I.prev_length !== 0);
                  if (I.match_available = 0, I.match_length = Et - 1, I.strstart++, oe && (Qt(I, !1), I.strm.avail_out === 0))
                    return Yt;
                } else if (I.match_available) {
                  if (oe = lt(I, 0, I.window[I.strstart - 1]), oe && Qt(I, !1), I.strstart++, I.lookahead--, I.strm.avail_out === 0)
                    return Yt;
                } else
                  I.match_available = 1, I.strstart++, I.lookahead--;
              }
              return I.match_available && (oe = lt(I, 0, I.window[I.strstart - 1]), I.match_available = 0), I.insert = I.strstart < Et - 1 ? I.strstart : Et - 1, te === vt ? (Qt(I, !0), I.strm.avail_out === 0 ? cr : _r) : I.sym_next && (Qt(I, !1), I.strm.avail_out === 0) ? Yt : gr;
            }, xn = (I, te) => {
              let N, oe, _e, pe;
              const Ne = I.window;
              for (; ; ) {
                if (I.lookahead <= ar) {
                  if (vr(I), I.lookahead <= ar && te === at)
                    return Yt;
                  if (I.lookahead === 0)
                    break;
                }
                if (I.match_length = 0, I.lookahead >= Et && I.strstart > 0 && (_e = I.strstart - 1, oe = Ne[_e], oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e])) {
                  pe = I.strstart + ar;
                  do
                    ;
                  while (oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && oe === Ne[++_e] && _e < pe);
                  I.match_length = ar - (pe - _e), I.match_length > I.lookahead && (I.match_length = I.lookahead);
                }
                if (I.match_length >= Et ? (N = lt(I, 1, I.match_length - Et), I.lookahead -= I.match_length, I.strstart += I.match_length, I.match_length = 0) : (N = lt(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++), N && (Qt(I, !1), I.strm.avail_out === 0))
                  return Yt;
              }
              return I.insert = 0, te === vt ? (Qt(I, !0), I.strm.avail_out === 0 ? cr : _r) : I.sym_next && (Qt(I, !1), I.strm.avail_out === 0) ? Yt : gr;
            }, wn = (I, te) => {
              let N;
              for (; ; ) {
                if (I.lookahead === 0 && (vr(I), I.lookahead === 0)) {
                  if (te === at)
                    return Yt;
                  break;
                }
                if (I.match_length = 0, N = lt(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++, N && (Qt(I, !1), I.strm.avail_out === 0))
                  return Yt;
              }
              return I.insert = 0, te === vt ? (Qt(I, !0), I.strm.avail_out === 0 ? cr : _r) : I.sym_next && (Qt(I, !1), I.strm.avail_out === 0) ? Yt : gr;
            };
            function tr(I, te, N, oe, _e) {
              this.good_length = I, this.max_lazy = te, this.nice_length = N, this.max_chain = oe, this.func = _e;
            }
            const Sr = [
              /*      good lazy nice chain */
              new tr(0, 0, 0, 0, hi),
              /* 0 store only */
              new tr(4, 4, 8, 4, qr),
              /* 1 max speed, no lazy matches */
              new tr(4, 5, 16, 8, qr),
              /* 2 */
              new tr(4, 6, 32, 32, qr),
              /* 3 */
              new tr(4, 4, 16, 16, yr),
              /* 4 lazy matches */
              new tr(8, 16, 32, 32, yr),
              /* 5 */
              new tr(8, 16, 128, 128, yr),
              /* 6 */
              new tr(8, 32, 128, 256, yr),
              /* 7 */
              new tr(32, 128, 258, 1024, yr),
              /* 8 */
              new tr(32, 258, 258, 4096, yr)
              /* 9 max compression */
            ], En = (I) => {
              I.window_size = 2 * I.w_size, sr(I.head), I.max_lazy_match = Sr[I.level].max_lazy, I.good_match = Sr[I.level].good_length, I.nice_match = Sr[I.level].nice_length, I.max_chain_length = Sr[I.level].max_chain, I.strstart = 0, I.block_start = 0, I.lookahead = 0, I.insert = 0, I.match_length = I.prev_length = Et - 1, I.match_available = 0, I.ins_h = 0;
            };
            function Sn() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = dt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Or * 2), this.dyn_dtree = new Uint16Array((2 * jt + 1) * 2), this.bl_tree = new Uint16Array((2 * Fr + 1) * 2), sr(this.dyn_ltree), sr(this.dyn_dtree), sr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(_n + 1), this.heap = new Uint16Array(2 * rr + 1), sr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * rr + 1), sr(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            const Ar = (I) => {
              if (!I)
                return 1;
              const te = I.state;
              return !te || te.strm !== I || te.status !== pr && //#ifdef GZIP
              te.status !== Vr && //#endif
              te.status !== jr && te.status !== Kr && te.status !== Xr && te.status !== Yr && te.status !== or && te.status !== wr ? 1 : 0;
            }, ui = (I) => {
              if (Ar(I))
                return ur(I, Ct);
              I.total_in = I.total_out = 0, I.data_type = tt;
              const te = I.state;
              return te.pending = 0, te.pending_out = 0, te.wrap < 0 && (te.wrap = -te.wrap), te.status = //#ifdef GZIP
              te.wrap === 2 ? Vr : (
                //#endif
                te.wrap ? pr : or
              ), I.adler = te.wrap === 2 ? 0 : 1, te.last_flush = -2, ae(te), _t;
            }, di = (I) => {
              const te = ui(I);
              return te === _t && En(I.state), te;
            }, An = (I, te) => Ar(I) || I.state.wrap !== 2 ? Ct : (I.state.gzhead = te, _t), fi = (I, te, N, oe, _e, pe) => {
              if (!I)
                return Ct;
              let Ne = 1;
              if (te === zt && (te = 6), oe < 0 ? (Ne = 0, oe = -oe) : oe > 15 && (Ne = 2, oe -= 16), _e < 1 || _e > Tt || N !== dt || oe < 8 || oe > 15 || te < 0 || te > 9 || pe < 0 || pe > ct || oe === 8 && Ne !== 1)
                return ur(I, Ct);
              oe === 8 && (oe = 9);
              const Oe = new Sn();
              return I.state = Oe, Oe.strm = I, Oe.status = pr, Oe.wrap = Ne, Oe.gzhead = null, Oe.w_bits = oe, Oe.w_size = 1 << Oe.w_bits, Oe.w_mask = Oe.w_size - 1, Oe.hash_bits = _e + 7, Oe.hash_size = 1 << Oe.hash_bits, Oe.hash_mask = Oe.hash_size - 1, Oe.hash_shift = ~~((Oe.hash_bits + Et - 1) / Et), Oe.window = new Uint8Array(Oe.w_size * 2), Oe.head = new Uint16Array(Oe.hash_size), Oe.prev = new Uint16Array(Oe.w_size), Oe.lit_bufsize = 1 << _e + 6, Oe.pending_buf_size = Oe.lit_bufsize * 4, Oe.pending_buf = new Uint8Array(Oe.pending_buf_size), Oe.sym_buf = Oe.lit_bufsize, Oe.sym_end = (Oe.lit_bufsize - 1) * 3, Oe.level = te, Oe.strategy = pe, Oe.method = N, di(I);
            }, Mn = (I, te) => fi(I, te, dt, Wt, Ut, ke), Dn = (I, te) => {
              if (Ar(I) || te > yt || te < 0)
                return I ? ur(I, Ct) : Ct;
              const N = I.state;
              if (!I.output || I.avail_in !== 0 && !I.input || N.status === wr && te !== vt)
                return ur(I, I.avail_out === 0 ? Zt : Ct);
              const oe = N.last_flush;
              if (N.last_flush = te, N.pending !== 0) {
                if (qt(I), I.avail_out === 0)
                  return N.last_flush = -1, _t;
              } else if (I.avail_in === 0 && oi(te) <= oi(oe) && te !== vt)
                return ur(I, Zt);
              if (N.status === wr && I.avail_in !== 0)
                return ur(I, Zt);
              if (N.status === pr && N.wrap === 0 && (N.status = or), N.status === pr) {
                let _e = dt + (N.w_bits - 8 << 4) << 8, pe = -1;
                if (N.strategy >= Lt || N.level < 2 ? pe = 0 : N.level < 6 ? pe = 1 : N.level === 6 ? pe = 2 : pe = 3, _e |= pe << 6, N.strstart !== 0 && (_e |= vn), _e += 31 - _e % 31, Er(N, _e), N.strstart !== 0 && (Er(N, I.adler >>> 16), Er(N, I.adler & 65535)), I.adler = 1, N.status = or, qt(I), N.pending !== 0)
                  return N.last_flush = -1, _t;
              }
              if (N.status === Vr) {
                if (I.adler = 0, kt(N, 31), kt(N, 139), kt(N, 8), N.gzhead)
                  kt(
                    N,
                    (N.gzhead.text ? 1 : 0) + (N.gzhead.hcrc ? 2 : 0) + (N.gzhead.extra ? 4 : 0) + (N.gzhead.name ? 8 : 0) + (N.gzhead.comment ? 16 : 0)
                  ), kt(N, N.gzhead.time & 255), kt(N, N.gzhead.time >> 8 & 255), kt(N, N.gzhead.time >> 16 & 255), kt(N, N.gzhead.time >> 24 & 255), kt(N, N.level === 9 ? 2 : N.strategy >= Lt || N.level < 2 ? 4 : 0), kt(N, N.gzhead.os & 255), N.gzhead.extra && N.gzhead.extra.length && (kt(N, N.gzhead.extra.length & 255), kt(N, N.gzhead.extra.length >> 8 & 255)), N.gzhead.hcrc && (I.adler = G(I.adler, N.pending_buf, N.pending, 0)), N.gzindex = 0, N.status = jr;
                else if (kt(N, 0), kt(N, 0), kt(N, 0), kt(N, 0), kt(N, 0), kt(N, N.level === 9 ? 2 : N.strategy >= Lt || N.level < 2 ? 4 : 0), kt(N, bn), N.status = or, qt(I), N.pending !== 0)
                  return N.last_flush = -1, _t;
              }
              if (N.status === jr) {
                if (N.gzhead.extra) {
                  let _e = N.pending, pe = (N.gzhead.extra.length & 65535) - N.gzindex;
                  for (; N.pending + pe > N.pending_buf_size; ) {
                    let Oe = N.pending_buf_size - N.pending;
                    if (N.pending_buf.set(N.gzhead.extra.subarray(N.gzindex, N.gzindex + Oe), N.pending), N.pending = N.pending_buf_size, N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e)), N.gzindex += Oe, qt(I), N.pending !== 0)
                      return N.last_flush = -1, _t;
                    _e = 0, pe -= Oe;
                  }
                  let Ne = new Uint8Array(N.gzhead.extra);
                  N.pending_buf.set(Ne.subarray(N.gzindex, N.gzindex + pe), N.pending), N.pending += pe, N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e)), N.gzindex = 0;
                }
                N.status = Kr;
              }
              if (N.status === Kr) {
                if (N.gzhead.name) {
                  let _e = N.pending, pe;
                  do {
                    if (N.pending === N.pending_buf_size) {
                      if (N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e)), qt(I), N.pending !== 0)
                        return N.last_flush = -1, _t;
                      _e = 0;
                    }
                    N.gzindex < N.gzhead.name.length ? pe = N.gzhead.name.charCodeAt(N.gzindex++) & 255 : pe = 0, kt(N, pe);
                  } while (pe !== 0);
                  N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e)), N.gzindex = 0;
                }
                N.status = Xr;
              }
              if (N.status === Xr) {
                if (N.gzhead.comment) {
                  let _e = N.pending, pe;
                  do {
                    if (N.pending === N.pending_buf_size) {
                      if (N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e)), qt(I), N.pending !== 0)
                        return N.last_flush = -1, _t;
                      _e = 0;
                    }
                    N.gzindex < N.gzhead.comment.length ? pe = N.gzhead.comment.charCodeAt(N.gzindex++) & 255 : pe = 0, kt(N, pe);
                  } while (pe !== 0);
                  N.gzhead.hcrc && N.pending > _e && (I.adler = G(I.adler, N.pending_buf, N.pending - _e, _e));
                }
                N.status = Yr;
              }
              if (N.status === Yr) {
                if (N.gzhead.hcrc) {
                  if (N.pending + 2 > N.pending_buf_size && (qt(I), N.pending !== 0))
                    return N.last_flush = -1, _t;
                  kt(N, I.adler & 255), kt(N, I.adler >> 8 & 255), I.adler = 0;
                }
                if (N.status = or, qt(I), N.pending !== 0)
                  return N.last_flush = -1, _t;
              }
              if (I.avail_in !== 0 || N.lookahead !== 0 || te !== at && N.status !== wr) {
                let _e = N.level === 0 ? hi(N, te) : N.strategy === Lt ? wn(N, te) : N.strategy === Kt ? xn(N, te) : Sr[N.level].func(N, te);
                if ((_e === cr || _e === _r) && (N.status = wr), _e === Yt || _e === cr)
                  return I.avail_out === 0 && (N.last_flush = -1), _t;
                if (_e === gr && (te === gt ? st(N) : te !== yt && (Ee(N, 0, 0, !1), te === Ot && (sr(N.head), N.lookahead === 0 && (N.strstart = 0, N.block_start = 0, N.insert = 0))), qt(I), I.avail_out === 0))
                  return N.last_flush = -1, _t;
              }
              return te !== vt ? _t : N.wrap <= 0 ? Bt : (N.wrap === 2 ? (kt(N, I.adler & 255), kt(N, I.adler >> 8 & 255), kt(N, I.adler >> 16 & 255), kt(N, I.adler >> 24 & 255), kt(N, I.total_in & 255), kt(N, I.total_in >> 8 & 255), kt(N, I.total_in >> 16 & 255), kt(N, I.total_in >> 24 & 255)) : (Er(N, I.adler >>> 16), Er(N, I.adler & 65535)), qt(I), N.wrap > 0 && (N.wrap = -N.wrap), N.pending !== 0 ? _t : Bt);
            }, Cn = (I) => {
              if (Ar(I))
                return Ct;
              const te = I.state.status;
              return I.state = null, te === or ? ur(I, Gt) : _t;
            }, Tn = (I, te) => {
              let N = te.length;
              if (Ar(I))
                return Ct;
              const oe = I.state, _e = oe.wrap;
              if (_e === 2 || _e === 1 && oe.status !== pr || oe.lookahead)
                return Ct;
              if (_e === 1 && (I.adler = Re(I.adler, te, N, 0)), oe.wrap = 0, N >= oe.w_size) {
                _e === 0 && (sr(oe.head), oe.strstart = 0, oe.block_start = 0, oe.insert = 0);
                let ft = new Uint8Array(oe.w_size);
                ft.set(te.subarray(N - oe.w_size, N), 0), te = ft, N = oe.w_size;
              }
              const pe = I.avail_in, Ne = I.next_in, Oe = I.input;
              for (I.avail_in = N, I.next_in = 0, I.input = te, vr(oe); oe.lookahead >= Et; ) {
                let ft = oe.strstart, Ce = oe.lookahead - (Et - 1);
                do
                  oe.ins_h = lr(oe, oe.ins_h, oe.window[ft + Et - 1]), oe.prev[ft & oe.w_mask] = oe.head[oe.ins_h], oe.head[oe.ins_h] = ft, ft++;
                while (--Ce);
                oe.strstart = ft, oe.lookahead = Et - 1, vr(oe);
              }
              return oe.strstart += oe.lookahead, oe.block_start = oe.strstart, oe.insert = oe.lookahead, oe.lookahead = 0, oe.match_length = oe.prev_length = Et - 1, oe.match_available = 0, I.next_in = Ne, I.input = Oe, I.avail_in = pe, oe.wrap = _e, _t;
            };
            var kn = Mn, $n = fi, Ln = di, Fn = ui, On = An, zn = Dn, In = Cn, Rn = Tn, Bn = "pako deflate (from Nodeca project)", Mr = {
              deflateInit: kn,
              deflateInit2: $n,
              deflateReset: Ln,
              deflateResetKeep: Fn,
              deflateSetHeader: On,
              deflate: zn,
              deflateEnd: In,
              deflateSetDictionary: Rn,
              deflateInfo: Bn
            };
            const Pn = (I, te) => Object.prototype.hasOwnProperty.call(I, te);
            var Nn = function(I) {
              const te = Array.prototype.slice.call(arguments, 1);
              for (; te.length; ) {
                const N = te.shift();
                if (N) {
                  if (typeof N != "object")
                    throw new TypeError(N + "must be non-object");
                  for (const oe in N)
                    Pn(N, oe) && (I[oe] = N[oe]);
                }
              }
              return I;
            }, Un = (I) => {
              let te = 0;
              for (let oe = 0, _e = I.length; oe < _e; oe++)
                te += I[oe].length;
              const N = new Uint8Array(te);
              for (let oe = 0, _e = 0, pe = I.length; oe < pe; oe++) {
                let Ne = I[oe];
                N.set(Ne, _e), _e += Ne.length;
              }
              return N;
            }, zr = {
              assign: Nn,
              flattenChunks: Un
            };
            let mi = !0;
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              mi = !1;
            }
            const Dr = new Uint8Array(256);
            for (let I = 0; I < 256; I++)
              Dr[I] = I >= 252 ? 6 : I >= 248 ? 5 : I >= 240 ? 4 : I >= 224 ? 3 : I >= 192 ? 2 : 1;
            Dr[254] = Dr[254] = 1;
            var Wn = (I) => {
              if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
                return new TextEncoder().encode(I);
              let te, N, oe, _e, pe, Ne = I.length, Oe = 0;
              for (_e = 0; _e < Ne; _e++)
                N = I.charCodeAt(_e), (N & 64512) === 55296 && _e + 1 < Ne && (oe = I.charCodeAt(_e + 1), (oe & 64512) === 56320 && (N = 65536 + (N - 55296 << 10) + (oe - 56320), _e++)), Oe += N < 128 ? 1 : N < 2048 ? 2 : N < 65536 ? 3 : 4;
              for (te = new Uint8Array(Oe), pe = 0, _e = 0; pe < Oe; _e++)
                N = I.charCodeAt(_e), (N & 64512) === 55296 && _e + 1 < Ne && (oe = I.charCodeAt(_e + 1), (oe & 64512) === 56320 && (N = 65536 + (N - 55296 << 10) + (oe - 56320), _e++)), N < 128 ? te[pe++] = N : N < 2048 ? (te[pe++] = 192 | N >>> 6, te[pe++] = 128 | N & 63) : N < 65536 ? (te[pe++] = 224 | N >>> 12, te[pe++] = 128 | N >>> 6 & 63, te[pe++] = 128 | N & 63) : (te[pe++] = 240 | N >>> 18, te[pe++] = 128 | N >>> 12 & 63, te[pe++] = 128 | N >>> 6 & 63, te[pe++] = 128 | N & 63);
              return te;
            };
            const Gn = (I, te) => {
              if (te < 65534 && I.subarray && mi)
                return String.fromCharCode.apply(null, I.length === te ? I : I.subarray(0, te));
              let N = "";
              for (let oe = 0; oe < te; oe++)
                N += String.fromCharCode(I[oe]);
              return N;
            };
            var Hn = (I, te) => {
              const N = te || I.length;
              if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
                return new TextDecoder().decode(I.subarray(0, te));
              let oe, _e;
              const pe = new Array(N * 2);
              for (_e = 0, oe = 0; oe < N; ) {
                let Ne = I[oe++];
                if (Ne < 128) {
                  pe[_e++] = Ne;
                  continue;
                }
                let Oe = Dr[Ne];
                if (Oe > 4) {
                  pe[_e++] = 65533, oe += Oe - 1;
                  continue;
                }
                for (Ne &= Oe === 2 ? 31 : Oe === 3 ? 15 : 7; Oe > 1 && oe < N; )
                  Ne = Ne << 6 | I[oe++] & 63, Oe--;
                if (Oe > 1) {
                  pe[_e++] = 65533;
                  continue;
                }
                Ne < 65536 ? pe[_e++] = Ne : (Ne -= 65536, pe[_e++] = 55296 | Ne >> 10 & 1023, pe[_e++] = 56320 | Ne & 1023);
              }
              return Gn(pe, _e);
            }, Vn = (I, te) => {
              te = te || I.length, te > I.length && (te = I.length);
              let N = te - 1;
              for (; N >= 0 && (I[N] & 192) === 128; )
                N--;
              return N < 0 || N === 0 ? te : N + Dr[I[N]] > te ? N : te;
            }, Cr = {
              string2buf: Wn,
              buf2string: Hn,
              utf8border: Vn
            };
            function jn() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            var pi = jn;
            const gi = Object.prototype.toString, {
              Z_NO_FLUSH: Kn,
              Z_SYNC_FLUSH: Xn,
              Z_FULL_FLUSH: Yn,
              Z_FINISH: Zn,
              Z_OK: Ir,
              Z_STREAM_END: qn,
              Z_DEFAULT_COMPRESSION: Qn,
              Z_DEFAULT_STRATEGY: Jn,
              Z_DEFLATED: ea
            } = Te;
            function Tr(I) {
              this.options = zr.assign({
                level: Qn,
                method: ea,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Jn
              }, I || {});
              let te = this.options;
              te.raw && te.windowBits > 0 ? te.windowBits = -te.windowBits : te.gzip && te.windowBits > 0 && te.windowBits < 16 && (te.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new pi(), this.strm.avail_out = 0;
              let N = Mr.deflateInit2(
                this.strm,
                te.level,
                te.method,
                te.windowBits,
                te.memLevel,
                te.strategy
              );
              if (N !== Ir)
                throw new Error(Fe[N]);
              if (te.header && Mr.deflateSetHeader(this.strm, te.header), te.dictionary) {
                let oe;
                if (typeof te.dictionary == "string" ? oe = Cr.string2buf(te.dictionary) : gi.call(te.dictionary) === "[object ArrayBuffer]" ? oe = new Uint8Array(te.dictionary) : oe = te.dictionary, N = Mr.deflateSetDictionary(this.strm, oe), N !== Ir)
                  throw new Error(Fe[N]);
                this._dict_set = !0;
              }
            }
            Tr.prototype.push = function(I, te) {
              const N = this.strm, oe = this.options.chunkSize;
              let _e, pe;
              if (this.ended)
                return !1;
              for (te === ~~te ? pe = te : pe = te === !0 ? Zn : Kn, typeof I == "string" ? N.input = Cr.string2buf(I) : gi.call(I) === "[object ArrayBuffer]" ? N.input = new Uint8Array(I) : N.input = I, N.next_in = 0, N.avail_in = N.input.length; ; ) {
                if (N.avail_out === 0 && (N.output = new Uint8Array(oe), N.next_out = 0, N.avail_out = oe), (pe === Xn || pe === Yn) && N.avail_out <= 6) {
                  this.onData(N.output.subarray(0, N.next_out)), N.avail_out = 0;
                  continue;
                }
                if (_e = Mr.deflate(N, pe), _e === qn)
                  return N.next_out > 0 && this.onData(N.output.subarray(0, N.next_out)), _e = Mr.deflateEnd(this.strm), this.onEnd(_e), this.ended = !0, _e === Ir;
                if (N.avail_out === 0) {
                  this.onData(N.output);
                  continue;
                }
                if (pe > 0 && N.next_out > 0) {
                  this.onData(N.output.subarray(0, N.next_out)), N.avail_out = 0;
                  continue;
                }
                if (N.avail_in === 0) break;
              }
              return !0;
            }, Tr.prototype.onData = function(I) {
              this.chunks.push(I);
            }, Tr.prototype.onEnd = function(I) {
              I === Ir && (this.result = zr.flattenChunks(this.chunks)), this.chunks = [], this.err = I, this.msg = this.strm.msg;
            };
            function Qr(I, te) {
              const N = new Tr(te);
              if (N.push(I, !0), N.err)
                throw N.msg || Fe[N.err];
              return N.result;
            }
            function ta(I, te) {
              return te = te || {}, te.raw = !0, Qr(I, te);
            }
            function ra(I, te) {
              return te = te || {}, te.gzip = !0, Qr(I, te);
            }
            var ia = Tr, na = Qr, aa = ta, sa = ra, la = Te, oa = {
              Deflate: ia,
              deflate: na,
              deflateRaw: aa,
              gzip: sa,
              constants: la
            };
            const Rr = 16209, ca = 16191;
            var ha = function(te, N) {
              let oe, _e, pe, Ne, Oe, ft, Ce, Ue, Dt, ut, Je, mt, Nt, At, xt, Ft, wt, ht, $t, Vt, pt, Rt, Mt, bt;
              const St = te.state;
              oe = te.next_in, Mt = te.input, _e = oe + (te.avail_in - 5), pe = te.next_out, bt = te.output, Ne = pe - (N - te.avail_out), Oe = pe + (te.avail_out - 257), ft = St.dmax, Ce = St.wsize, Ue = St.whave, Dt = St.wnext, ut = St.window, Je = St.hold, mt = St.bits, Nt = St.lencode, At = St.distcode, xt = (1 << St.lenbits) - 1, Ft = (1 << St.distbits) - 1;
              e:
                do {
                  mt < 15 && (Je += Mt[oe++] << mt, mt += 8, Je += Mt[oe++] << mt, mt += 8), wt = Nt[Je & xt];
                  t:
                    for (; ; ) {
                      if (ht = wt >>> 24, Je >>>= ht, mt -= ht, ht = wt >>> 16 & 255, ht === 0)
                        bt[pe++] = wt & 65535;
                      else if (ht & 16) {
                        $t = wt & 65535, ht &= 15, ht && (mt < ht && (Je += Mt[oe++] << mt, mt += 8), $t += Je & (1 << ht) - 1, Je >>>= ht, mt -= ht), mt < 15 && (Je += Mt[oe++] << mt, mt += 8, Je += Mt[oe++] << mt, mt += 8), wt = At[Je & Ft];
                        r:
                          for (; ; ) {
                            if (ht = wt >>> 24, Je >>>= ht, mt -= ht, ht = wt >>> 16 & 255, ht & 16) {
                              if (Vt = wt & 65535, ht &= 15, mt < ht && (Je += Mt[oe++] << mt, mt += 8, mt < ht && (Je += Mt[oe++] << mt, mt += 8)), Vt += Je & (1 << ht) - 1, Vt > ft) {
                                te.msg = "invalid distance too far back", St.mode = Rr;
                                break e;
                              }
                              if (Je >>>= ht, mt -= ht, ht = pe - Ne, Vt > ht) {
                                if (ht = Vt - ht, ht > Ue && St.sane) {
                                  te.msg = "invalid distance too far back", St.mode = Rr;
                                  break e;
                                }
                                if (pt = 0, Rt = ut, Dt === 0) {
                                  if (pt += Ce - ht, ht < $t) {
                                    $t -= ht;
                                    do
                                      bt[pe++] = ut[pt++];
                                    while (--ht);
                                    pt = pe - Vt, Rt = bt;
                                  }
                                } else if (Dt < ht) {
                                  if (pt += Ce + Dt - ht, ht -= Dt, ht < $t) {
                                    $t -= ht;
                                    do
                                      bt[pe++] = ut[pt++];
                                    while (--ht);
                                    if (pt = 0, Dt < $t) {
                                      ht = Dt, $t -= ht;
                                      do
                                        bt[pe++] = ut[pt++];
                                      while (--ht);
                                      pt = pe - Vt, Rt = bt;
                                    }
                                  }
                                } else if (pt += Dt - ht, ht < $t) {
                                  $t -= ht;
                                  do
                                    bt[pe++] = ut[pt++];
                                  while (--ht);
                                  pt = pe - Vt, Rt = bt;
                                }
                                for (; $t > 2; )
                                  bt[pe++] = Rt[pt++], bt[pe++] = Rt[pt++], bt[pe++] = Rt[pt++], $t -= 3;
                                $t && (bt[pe++] = Rt[pt++], $t > 1 && (bt[pe++] = Rt[pt++]));
                              } else {
                                pt = pe - Vt;
                                do
                                  bt[pe++] = bt[pt++], bt[pe++] = bt[pt++], bt[pe++] = bt[pt++], $t -= 3;
                                while ($t > 2);
                                $t && (bt[pe++] = bt[pt++], $t > 1 && (bt[pe++] = bt[pt++]));
                              }
                            } else if (ht & 64) {
                              te.msg = "invalid distance code", St.mode = Rr;
                              break e;
                            } else {
                              wt = At[(wt & 65535) + (Je & (1 << ht) - 1)];
                              continue r;
                            }
                            break;
                          }
                      } else if (ht & 64)
                        if (ht & 32) {
                          St.mode = ca;
                          break e;
                        } else {
                          te.msg = "invalid literal/length code", St.mode = Rr;
                          break e;
                        }
                      else {
                        wt = Nt[(wt & 65535) + (Je & (1 << ht) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (oe < _e && pe < Oe);
              $t = mt >> 3, oe -= $t, mt -= $t << 3, Je &= (1 << mt) - 1, te.next_in = oe, te.next_out = pe, te.avail_in = oe < _e ? 5 + (_e - oe) : 5 - (oe - _e), te.avail_out = pe < Oe ? 257 + (Oe - pe) : 257 - (pe - Oe), St.hold = Je, St.bits = mt;
            };
            const xr = 15, vi = 852, bi = 592, yi = 0, Jr = 1, xi = 2, ua = new Uint16Array([
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ]), da = new Uint8Array([
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ]), fa = new Uint16Array([
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ]), ma = new Uint8Array([
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ]);
            var kr = (I, te, N, oe, _e, pe, Ne, Oe) => {
              const ft = Oe.bits;
              let Ce = 0, Ue = 0, Dt = 0, ut = 0, Je = 0, mt = 0, Nt = 0, At = 0, xt = 0, Ft = 0, wt, ht, $t, Vt, pt, Rt = null, Mt;
              const bt = new Uint16Array(xr + 1), St = new Uint16Array(xr + 1);
              let mr = null, gn, Gr, Hr;
              for (Ce = 0; Ce <= xr; Ce++)
                bt[Ce] = 0;
              for (Ue = 0; Ue < oe; Ue++)
                bt[te[N + Ue]]++;
              for (Je = ft, ut = xr; ut >= 1 && bt[ut] === 0; ut--)
                ;
              if (Je > ut && (Je = ut), ut === 0)
                return _e[pe++] = 1 << 24 | 64 << 16 | 0, _e[pe++] = 1 << 24 | 64 << 16 | 0, Oe.bits = 1, 0;
              for (Dt = 1; Dt < ut && bt[Dt] === 0; Dt++)
                ;
              for (Je < Dt && (Je = Dt), At = 1, Ce = 1; Ce <= xr; Ce++)
                if (At <<= 1, At -= bt[Ce], At < 0)
                  return -1;
              if (At > 0 && (I === yi || ut !== 1))
                return -1;
              for (St[1] = 0, Ce = 1; Ce < xr; Ce++)
                St[Ce + 1] = St[Ce] + bt[Ce];
              for (Ue = 0; Ue < oe; Ue++)
                te[N + Ue] !== 0 && (Ne[St[te[N + Ue]]++] = Ue);
              if (I === yi ? (Rt = mr = Ne, Mt = 20) : I === Jr ? (Rt = ua, mr = da, Mt = 257) : (Rt = fa, mr = ma, Mt = 0), Ft = 0, Ue = 0, Ce = Dt, pt = pe, mt = Je, Nt = 0, $t = -1, xt = 1 << Je, Vt = xt - 1, I === Jr && xt > vi || I === xi && xt > bi)
                return 1;
              for (; ; ) {
                gn = Ce - Nt, Ne[Ue] + 1 < Mt ? (Gr = 0, Hr = Ne[Ue]) : Ne[Ue] >= Mt ? (Gr = mr[Ne[Ue] - Mt], Hr = Rt[Ne[Ue] - Mt]) : (Gr = 96, Hr = 0), wt = 1 << Ce - Nt, ht = 1 << mt, Dt = ht;
                do
                  ht -= wt, _e[pt + (Ft >> Nt) + ht] = gn << 24 | Gr << 16 | Hr | 0;
                while (ht !== 0);
                for (wt = 1 << Ce - 1; Ft & wt; )
                  wt >>= 1;
                if (wt !== 0 ? (Ft &= wt - 1, Ft += wt) : Ft = 0, Ue++, --bt[Ce] === 0) {
                  if (Ce === ut)
                    break;
                  Ce = te[N + Ne[Ue]];
                }
                if (Ce > Je && (Ft & Vt) !== $t) {
                  for (Nt === 0 && (Nt = Je), pt += Dt, mt = Ce - Nt, At = 1 << mt; mt + Nt < ut && (At -= bt[mt + Nt], !(At <= 0)); )
                    mt++, At <<= 1;
                  if (xt += 1 << mt, I === Jr && xt > vi || I === xi && xt > bi)
                    return 1;
                  $t = Ft & Vt, _e[$t] = Je << 24 | mt << 16 | pt - pe | 0;
                }
              }
              return Ft !== 0 && (_e[pt + Ft] = Ce - Nt << 24 | 64 << 16 | 0), Oe.bits = Je, 0;
            };
            const pa = 0, wi = 1, Ei = 2, {
              Z_FINISH: Si,
              Z_BLOCK: ga,
              Z_TREES: Br,
              Z_OK: dr,
              Z_STREAM_END: _a,
              Z_NEED_DICT: va,
              Z_STREAM_ERROR: Jt,
              Z_DATA_ERROR: Ai,
              Z_MEM_ERROR: Mi,
              Z_BUF_ERROR: ba,
              Z_DEFLATED: Di
            } = Te, Pr = 16180, Ci = 16181, Ti = 16182, ki = 16183, $i = 16184, Li = 16185, Fi = 16186, Oi = 16187, zi = 16188, Ii = 16189, Nr = 16190, ir = 16191, ei = 16192, Ri = 16193, ti = 16194, Bi = 16195, Pi = 16196, Ni = 16197, Ui = 16198, Ur = 16199, Wr = 16200, Wi = 16201, Gi = 16202, Hi = 16203, Vi = 16204, ji = 16205, ri = 16206, Ki = 16207, Xi = 16208, Pt = 16209, Yi = 16210, Zi = 16211, ya = 852, xa = 592, wa = 15, qi = (I) => (I >>> 24 & 255) + (I >>> 8 & 65280) + ((I & 65280) << 8) + ((I & 255) << 24);
            function Ea() {
              this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            const fr = (I) => {
              if (!I)
                return 1;
              const te = I.state;
              return !te || te.strm !== I || te.mode < Pr || te.mode > Zi ? 1 : 0;
            }, Qi = (I) => {
              if (fr(I))
                return Jt;
              const te = I.state;
              return I.total_in = I.total_out = te.total = 0, I.msg = "", te.wrap && (I.adler = te.wrap & 1), te.mode = Pr, te.last = 0, te.havedict = 0, te.flags = -1, te.dmax = 32768, te.head = null, te.hold = 0, te.bits = 0, te.lencode = te.lendyn = new Int32Array(ya), te.distcode = te.distdyn = new Int32Array(xa), te.sane = 1, te.back = -1, dr;
            }, Ji = (I) => {
              if (fr(I))
                return Jt;
              const te = I.state;
              return te.wsize = 0, te.whave = 0, te.wnext = 0, Qi(I);
            }, en = (I, te) => {
              let N;
              if (fr(I))
                return Jt;
              const oe = I.state;
              return te < 0 ? (N = 0, te = -te) : (N = (te >> 4) + 5, te < 48 && (te &= 15)), te && (te < 8 || te > 15) ? Jt : (oe.window !== null && oe.wbits !== te && (oe.window = null), oe.wrap = N, oe.wbits = te, Ji(I));
            }, tn = (I, te) => {
              if (!I)
                return Jt;
              const N = new Ea();
              I.state = N, N.strm = I, N.window = null, N.mode = Pr;
              const oe = en(I, te);
              return oe !== dr && (I.state = null), oe;
            }, Sa = (I) => tn(I, wa);
            let rn = !0, ii, ni;
            const Aa = (I) => {
              if (rn) {
                ii = new Int32Array(512), ni = new Int32Array(32);
                let te = 0;
                for (; te < 144; )
                  I.lens[te++] = 8;
                for (; te < 256; )
                  I.lens[te++] = 9;
                for (; te < 280; )
                  I.lens[te++] = 7;
                for (; te < 288; )
                  I.lens[te++] = 8;
                for (kr(wi, I.lens, 0, 288, ii, 0, I.work, { bits: 9 }), te = 0; te < 32; )
                  I.lens[te++] = 5;
                kr(Ei, I.lens, 0, 32, ni, 0, I.work, { bits: 5 }), rn = !1;
              }
              I.lencode = ii, I.lenbits = 9, I.distcode = ni, I.distbits = 5;
            }, nn = (I, te, N, oe) => {
              let _e;
              const pe = I.state;
              return pe.window === null && (pe.wsize = 1 << pe.wbits, pe.wnext = 0, pe.whave = 0, pe.window = new Uint8Array(pe.wsize)), oe >= pe.wsize ? (pe.window.set(te.subarray(N - pe.wsize, N), 0), pe.wnext = 0, pe.whave = pe.wsize) : (_e = pe.wsize - pe.wnext, _e > oe && (_e = oe), pe.window.set(te.subarray(N - oe, N - oe + _e), pe.wnext), oe -= _e, oe ? (pe.window.set(te.subarray(N - oe, N), 0), pe.wnext = oe, pe.whave = pe.wsize) : (pe.wnext += _e, pe.wnext === pe.wsize && (pe.wnext = 0), pe.whave < pe.wsize && (pe.whave += _e))), 0;
            }, Ma = (I, te) => {
              let N, oe, _e, pe, Ne, Oe, ft, Ce, Ue, Dt, ut, Je, mt, Nt, At = 0, xt, Ft, wt, ht, $t, Vt, pt, Rt;
              const Mt = new Uint8Array(4);
              let bt, St;
              const mr = (
                /* permutation of code lengths */
                new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              );
              if (fr(I) || !I.output || !I.input && I.avail_in !== 0)
                return Jt;
              N = I.state, N.mode === ir && (N.mode = ei), Ne = I.next_out, _e = I.output, ft = I.avail_out, pe = I.next_in, oe = I.input, Oe = I.avail_in, Ce = N.hold, Ue = N.bits, Dt = Oe, ut = ft, Rt = dr;
              e:
                for (; ; )
                  switch (N.mode) {
                    case Pr:
                      if (N.wrap === 0) {
                        N.mode = ei;
                        break;
                      }
                      for (; Ue < 16; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if (N.wrap & 2 && Ce === 35615) {
                        N.wbits === 0 && (N.wbits = 15), N.check = 0, Mt[0] = Ce & 255, Mt[1] = Ce >>> 8 & 255, N.check = G(N.check, Mt, 2, 0), Ce = 0, Ue = 0, N.mode = Ci;
                        break;
                      }
                      if (N.head && (N.head.done = !1), !(N.wrap & 1) || /* check if zlib header allowed */
                      (((Ce & 255) << 8) + (Ce >> 8)) % 31) {
                        I.msg = "incorrect header check", N.mode = Pt;
                        break;
                      }
                      if ((Ce & 15) !== Di) {
                        I.msg = "unknown compression method", N.mode = Pt;
                        break;
                      }
                      if (Ce >>>= 4, Ue -= 4, pt = (Ce & 15) + 8, N.wbits === 0 && (N.wbits = pt), pt > 15 || pt > N.wbits) {
                        I.msg = "invalid window size", N.mode = Pt;
                        break;
                      }
                      N.dmax = 1 << N.wbits, N.flags = 0, I.adler = N.check = 1, N.mode = Ce & 512 ? Ii : ir, Ce = 0, Ue = 0;
                      break;
                    case Ci:
                      for (; Ue < 16; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if (N.flags = Ce, (N.flags & 255) !== Di) {
                        I.msg = "unknown compression method", N.mode = Pt;
                        break;
                      }
                      if (N.flags & 57344) {
                        I.msg = "unknown header flags set", N.mode = Pt;
                        break;
                      }
                      N.head && (N.head.text = Ce >> 8 & 1), N.flags & 512 && N.wrap & 4 && (Mt[0] = Ce & 255, Mt[1] = Ce >>> 8 & 255, N.check = G(N.check, Mt, 2, 0)), Ce = 0, Ue = 0, N.mode = Ti;
                    case Ti:
                      for (; Ue < 32; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      N.head && (N.head.time = Ce), N.flags & 512 && N.wrap & 4 && (Mt[0] = Ce & 255, Mt[1] = Ce >>> 8 & 255, Mt[2] = Ce >>> 16 & 255, Mt[3] = Ce >>> 24 & 255, N.check = G(N.check, Mt, 4, 0)), Ce = 0, Ue = 0, N.mode = ki;
                    case ki:
                      for (; Ue < 16; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      N.head && (N.head.xflags = Ce & 255, N.head.os = Ce >> 8), N.flags & 512 && N.wrap & 4 && (Mt[0] = Ce & 255, Mt[1] = Ce >>> 8 & 255, N.check = G(N.check, Mt, 2, 0)), Ce = 0, Ue = 0, N.mode = $i;
                    case $i:
                      if (N.flags & 1024) {
                        for (; Ue < 16; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        N.length = Ce, N.head && (N.head.extra_len = Ce), N.flags & 512 && N.wrap & 4 && (Mt[0] = Ce & 255, Mt[1] = Ce >>> 8 & 255, N.check = G(N.check, Mt, 2, 0)), Ce = 0, Ue = 0;
                      } else N.head && (N.head.extra = null);
                      N.mode = Li;
                    case Li:
                      if (N.flags & 1024 && (Je = N.length, Je > Oe && (Je = Oe), Je && (N.head && (pt = N.head.extra_len - N.length, N.head.extra || (N.head.extra = new Uint8Array(N.head.extra_len)), N.head.extra.set(
                        oe.subarray(
                          pe,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          pe + Je
                        ),
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        pt
                      )), N.flags & 512 && N.wrap & 4 && (N.check = G(N.check, oe, Je, pe)), Oe -= Je, pe += Je, N.length -= Je), N.length))
                        break e;
                      N.length = 0, N.mode = Fi;
                    case Fi:
                      if (N.flags & 2048) {
                        if (Oe === 0)
                          break e;
                        Je = 0;
                        do
                          pt = oe[pe + Je++], N.head && pt && N.length < 65536 && (N.head.name += String.fromCharCode(pt));
                        while (pt && Je < Oe);
                        if (N.flags & 512 && N.wrap & 4 && (N.check = G(N.check, oe, Je, pe)), Oe -= Je, pe += Je, pt)
                          break e;
                      } else N.head && (N.head.name = null);
                      N.length = 0, N.mode = Oi;
                    case Oi:
                      if (N.flags & 4096) {
                        if (Oe === 0)
                          break e;
                        Je = 0;
                        do
                          pt = oe[pe + Je++], N.head && pt && N.length < 65536 && (N.head.comment += String.fromCharCode(pt));
                        while (pt && Je < Oe);
                        if (N.flags & 512 && N.wrap & 4 && (N.check = G(N.check, oe, Je, pe)), Oe -= Je, pe += Je, pt)
                          break e;
                      } else N.head && (N.head.comment = null);
                      N.mode = zi;
                    case zi:
                      if (N.flags & 512) {
                        for (; Ue < 16; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        if (N.wrap & 4 && Ce !== (N.check & 65535)) {
                          I.msg = "header crc mismatch", N.mode = Pt;
                          break;
                        }
                        Ce = 0, Ue = 0;
                      }
                      N.head && (N.head.hcrc = N.flags >> 9 & 1, N.head.done = !0), I.adler = N.check = 0, N.mode = ir;
                      break;
                    case Ii:
                      for (; Ue < 32; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      I.adler = N.check = qi(Ce), Ce = 0, Ue = 0, N.mode = Nr;
                    case Nr:
                      if (N.havedict === 0)
                        return I.next_out = Ne, I.avail_out = ft, I.next_in = pe, I.avail_in = Oe, N.hold = Ce, N.bits = Ue, va;
                      I.adler = N.check = 1, N.mode = ir;
                    case ir:
                      if (te === ga || te === Br)
                        break e;
                    case ei:
                      if (N.last) {
                        Ce >>>= Ue & 7, Ue -= Ue & 7, N.mode = ri;
                        break;
                      }
                      for (; Ue < 3; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      switch (N.last = Ce & 1, Ce >>>= 1, Ue -= 1, Ce & 3) {
                        case 0:
                          N.mode = Ri;
                          break;
                        case 1:
                          if (Aa(N), N.mode = Ur, te === Br) {
                            Ce >>>= 2, Ue -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          N.mode = Pi;
                          break;
                        case 3:
                          I.msg = "invalid block type", N.mode = Pt;
                      }
                      Ce >>>= 2, Ue -= 2;
                      break;
                    case Ri:
                      for (Ce >>>= Ue & 7, Ue -= Ue & 7; Ue < 32; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if ((Ce & 65535) !== (Ce >>> 16 ^ 65535)) {
                        I.msg = "invalid stored block lengths", N.mode = Pt;
                        break;
                      }
                      if (N.length = Ce & 65535, Ce = 0, Ue = 0, N.mode = ti, te === Br)
                        break e;
                    case ti:
                      N.mode = Bi;
                    case Bi:
                      if (Je = N.length, Je) {
                        if (Je > Oe && (Je = Oe), Je > ft && (Je = ft), Je === 0)
                          break e;
                        _e.set(oe.subarray(pe, pe + Je), Ne), Oe -= Je, pe += Je, ft -= Je, Ne += Je, N.length -= Je;
                        break;
                      }
                      N.mode = ir;
                      break;
                    case Pi:
                      for (; Ue < 14; ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if (N.nlen = (Ce & 31) + 257, Ce >>>= 5, Ue -= 5, N.ndist = (Ce & 31) + 1, Ce >>>= 5, Ue -= 5, N.ncode = (Ce & 15) + 4, Ce >>>= 4, Ue -= 4, N.nlen > 286 || N.ndist > 30) {
                        I.msg = "too many length or distance symbols", N.mode = Pt;
                        break;
                      }
                      N.have = 0, N.mode = Ni;
                    case Ni:
                      for (; N.have < N.ncode; ) {
                        for (; Ue < 3; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        N.lens[mr[N.have++]] = Ce & 7, Ce >>>= 3, Ue -= 3;
                      }
                      for (; N.have < 19; )
                        N.lens[mr[N.have++]] = 0;
                      if (N.lencode = N.lendyn, N.lenbits = 7, bt = { bits: N.lenbits }, Rt = kr(pa, N.lens, 0, 19, N.lencode, 0, N.work, bt), N.lenbits = bt.bits, Rt) {
                        I.msg = "invalid code lengths set", N.mode = Pt;
                        break;
                      }
                      N.have = 0, N.mode = Ui;
                    case Ui:
                      for (; N.have < N.nlen + N.ndist; ) {
                        for (; At = N.lencode[Ce & (1 << N.lenbits) - 1], xt = At >>> 24, Ft = At >>> 16 & 255, wt = At & 65535, !(xt <= Ue); ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        if (wt < 16)
                          Ce >>>= xt, Ue -= xt, N.lens[N.have++] = wt;
                        else {
                          if (wt === 16) {
                            for (St = xt + 2; Ue < St; ) {
                              if (Oe === 0)
                                break e;
                              Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                            }
                            if (Ce >>>= xt, Ue -= xt, N.have === 0) {
                              I.msg = "invalid bit length repeat", N.mode = Pt;
                              break;
                            }
                            pt = N.lens[N.have - 1], Je = 3 + (Ce & 3), Ce >>>= 2, Ue -= 2;
                          } else if (wt === 17) {
                            for (St = xt + 3; Ue < St; ) {
                              if (Oe === 0)
                                break e;
                              Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                            }
                            Ce >>>= xt, Ue -= xt, pt = 0, Je = 3 + (Ce & 7), Ce >>>= 3, Ue -= 3;
                          } else {
                            for (St = xt + 7; Ue < St; ) {
                              if (Oe === 0)
                                break e;
                              Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                            }
                            Ce >>>= xt, Ue -= xt, pt = 0, Je = 11 + (Ce & 127), Ce >>>= 7, Ue -= 7;
                          }
                          if (N.have + Je > N.nlen + N.ndist) {
                            I.msg = "invalid bit length repeat", N.mode = Pt;
                            break;
                          }
                          for (; Je--; )
                            N.lens[N.have++] = pt;
                        }
                      }
                      if (N.mode === Pt)
                        break;
                      if (N.lens[256] === 0) {
                        I.msg = "invalid code -- missing end-of-block", N.mode = Pt;
                        break;
                      }
                      if (N.lenbits = 9, bt = { bits: N.lenbits }, Rt = kr(wi, N.lens, 0, N.nlen, N.lencode, 0, N.work, bt), N.lenbits = bt.bits, Rt) {
                        I.msg = "invalid literal/lengths set", N.mode = Pt;
                        break;
                      }
                      if (N.distbits = 6, N.distcode = N.distdyn, bt = { bits: N.distbits }, Rt = kr(Ei, N.lens, N.nlen, N.ndist, N.distcode, 0, N.work, bt), N.distbits = bt.bits, Rt) {
                        I.msg = "invalid distances set", N.mode = Pt;
                        break;
                      }
                      if (N.mode = Ur, te === Br)
                        break e;
                    case Ur:
                      N.mode = Wr;
                    case Wr:
                      if (Oe >= 6 && ft >= 258) {
                        I.next_out = Ne, I.avail_out = ft, I.next_in = pe, I.avail_in = Oe, N.hold = Ce, N.bits = Ue, ha(I, ut), Ne = I.next_out, _e = I.output, ft = I.avail_out, pe = I.next_in, oe = I.input, Oe = I.avail_in, Ce = N.hold, Ue = N.bits, N.mode === ir && (N.back = -1);
                        break;
                      }
                      for (N.back = 0; At = N.lencode[Ce & (1 << N.lenbits) - 1], xt = At >>> 24, Ft = At >>> 16 & 255, wt = At & 65535, !(xt <= Ue); ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if (Ft && !(Ft & 240)) {
                        for (ht = xt, $t = Ft, Vt = wt; At = N.lencode[Vt + ((Ce & (1 << ht + $t) - 1) >> ht)], xt = At >>> 24, Ft = At >>> 16 & 255, wt = At & 65535, !(ht + xt <= Ue); ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        Ce >>>= ht, Ue -= ht, N.back += ht;
                      }
                      if (Ce >>>= xt, Ue -= xt, N.back += xt, N.length = wt, Ft === 0) {
                        N.mode = ji;
                        break;
                      }
                      if (Ft & 32) {
                        N.back = -1, N.mode = ir;
                        break;
                      }
                      if (Ft & 64) {
                        I.msg = "invalid literal/length code", N.mode = Pt;
                        break;
                      }
                      N.extra = Ft & 15, N.mode = Wi;
                    case Wi:
                      if (N.extra) {
                        for (St = N.extra; Ue < St; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        N.length += Ce & (1 << N.extra) - 1, Ce >>>= N.extra, Ue -= N.extra, N.back += N.extra;
                      }
                      N.was = N.length, N.mode = Gi;
                    case Gi:
                      for (; At = N.distcode[Ce & (1 << N.distbits) - 1], xt = At >>> 24, Ft = At >>> 16 & 255, wt = At & 65535, !(xt <= Ue); ) {
                        if (Oe === 0)
                          break e;
                        Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                      }
                      if (!(Ft & 240)) {
                        for (ht = xt, $t = Ft, Vt = wt; At = N.distcode[Vt + ((Ce & (1 << ht + $t) - 1) >> ht)], xt = At >>> 24, Ft = At >>> 16 & 255, wt = At & 65535, !(ht + xt <= Ue); ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        Ce >>>= ht, Ue -= ht, N.back += ht;
                      }
                      if (Ce >>>= xt, Ue -= xt, N.back += xt, Ft & 64) {
                        I.msg = "invalid distance code", N.mode = Pt;
                        break;
                      }
                      N.offset = wt, N.extra = Ft & 15, N.mode = Hi;
                    case Hi:
                      if (N.extra) {
                        for (St = N.extra; Ue < St; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        N.offset += Ce & (1 << N.extra) - 1, Ce >>>= N.extra, Ue -= N.extra, N.back += N.extra;
                      }
                      if (N.offset > N.dmax) {
                        I.msg = "invalid distance too far back", N.mode = Pt;
                        break;
                      }
                      N.mode = Vi;
                    case Vi:
                      if (ft === 0)
                        break e;
                      if (Je = ut - ft, N.offset > Je) {
                        if (Je = N.offset - Je, Je > N.whave && N.sane) {
                          I.msg = "invalid distance too far back", N.mode = Pt;
                          break;
                        }
                        Je > N.wnext ? (Je -= N.wnext, mt = N.wsize - Je) : mt = N.wnext - Je, Je > N.length && (Je = N.length), Nt = N.window;
                      } else
                        Nt = _e, mt = Ne - N.offset, Je = N.length;
                      Je > ft && (Je = ft), ft -= Je, N.length -= Je;
                      do
                        _e[Ne++] = Nt[mt++];
                      while (--Je);
                      N.length === 0 && (N.mode = Wr);
                      break;
                    case ji:
                      if (ft === 0)
                        break e;
                      _e[Ne++] = N.length, ft--, N.mode = Wr;
                      break;
                    case ri:
                      if (N.wrap) {
                        for (; Ue < 32; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce |= oe[pe++] << Ue, Ue += 8;
                        }
                        if (ut -= ft, I.total_out += ut, N.total += ut, N.wrap & 4 && ut && (I.adler = N.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                        N.flags ? G(N.check, _e, ut, Ne - ut) : Re(N.check, _e, ut, Ne - ut)), ut = ft, N.wrap & 4 && (N.flags ? Ce : qi(Ce)) !== N.check) {
                          I.msg = "incorrect data check", N.mode = Pt;
                          break;
                        }
                        Ce = 0, Ue = 0;
                      }
                      N.mode = Ki;
                    case Ki:
                      if (N.wrap && N.flags) {
                        for (; Ue < 32; ) {
                          if (Oe === 0)
                            break e;
                          Oe--, Ce += oe[pe++] << Ue, Ue += 8;
                        }
                        if (N.wrap & 4 && Ce !== (N.total & 4294967295)) {
                          I.msg = "incorrect length check", N.mode = Pt;
                          break;
                        }
                        Ce = 0, Ue = 0;
                      }
                      N.mode = Xi;
                    case Xi:
                      Rt = _a;
                      break e;
                    case Pt:
                      Rt = Ai;
                      break e;
                    case Yi:
                      return Mi;
                    case Zi:
                    default:
                      return Jt;
                  }
              return I.next_out = Ne, I.avail_out = ft, I.next_in = pe, I.avail_in = Oe, N.hold = Ce, N.bits = Ue, (N.wsize || ut !== I.avail_out && N.mode < Pt && (N.mode < ri || te !== Si)) && nn(I, I.output, I.next_out, ut - I.avail_out), Dt -= I.avail_in, ut -= I.avail_out, I.total_in += Dt, I.total_out += ut, N.total += ut, N.wrap & 4 && ut && (I.adler = N.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
              N.flags ? G(N.check, _e, ut, I.next_out - ut) : Re(N.check, _e, ut, I.next_out - ut)), I.data_type = N.bits + (N.last ? 64 : 0) + (N.mode === ir ? 128 : 0) + (N.mode === Ur || N.mode === ti ? 256 : 0), (Dt === 0 && ut === 0 || te === Si) && Rt === dr && (Rt = ba), Rt;
            }, Da = (I) => {
              if (fr(I))
                return Jt;
              let te = I.state;
              return te.window && (te.window = null), I.state = null, dr;
            }, Ca = (I, te) => {
              if (fr(I))
                return Jt;
              const N = I.state;
              return N.wrap & 2 ? (N.head = te, te.done = !1, dr) : Jt;
            }, Ta = (I, te) => {
              const N = te.length;
              let oe, _e, pe;
              return fr(I) || (oe = I.state, oe.wrap !== 0 && oe.mode !== Nr) ? Jt : oe.mode === Nr && (_e = 1, _e = Re(_e, te, N, 0), _e !== oe.check) ? Ai : (pe = nn(I, te, N, N), pe ? (oe.mode = Yi, Mi) : (oe.havedict = 1, dr));
            };
            var ka = Ji, $a = en, La = Qi, Fa = Sa, Oa = tn, za = Ma, Ia = Da, Ra = Ca, Ba = Ta, Pa = "pako inflate (from Nodeca project)", nr = {
              inflateReset: ka,
              inflateReset2: $a,
              inflateResetKeep: La,
              inflateInit: Fa,
              inflateInit2: Oa,
              inflate: za,
              inflateEnd: Ia,
              inflateGetHeader: Ra,
              inflateSetDictionary: Ba,
              inflateInfo: Pa
            };
            function Na() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            var Ua = Na;
            const an = Object.prototype.toString, {
              Z_NO_FLUSH: Wa,
              Z_FINISH: Ga,
              Z_OK: $r,
              Z_STREAM_END: ai,
              Z_NEED_DICT: si,
              Z_STREAM_ERROR: Ha,
              Z_DATA_ERROR: sn,
              Z_MEM_ERROR: Va
            } = Te;
            function Lr(I) {
              this.options = zr.assign({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
              }, I || {});
              const te = this.options;
              te.raw && te.windowBits >= 0 && te.windowBits < 16 && (te.windowBits = -te.windowBits, te.windowBits === 0 && (te.windowBits = -15)), te.windowBits >= 0 && te.windowBits < 16 && !(I && I.windowBits) && (te.windowBits += 32), te.windowBits > 15 && te.windowBits < 48 && (te.windowBits & 15 || (te.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new pi(), this.strm.avail_out = 0;
              let N = nr.inflateInit2(
                this.strm,
                te.windowBits
              );
              if (N !== $r)
                throw new Error(Fe[N]);
              if (this.header = new Ua(), nr.inflateGetHeader(this.strm, this.header), te.dictionary && (typeof te.dictionary == "string" ? te.dictionary = Cr.string2buf(te.dictionary) : an.call(te.dictionary) === "[object ArrayBuffer]" && (te.dictionary = new Uint8Array(te.dictionary)), te.raw && (N = nr.inflateSetDictionary(this.strm, te.dictionary), N !== $r)))
                throw new Error(Fe[N]);
            }
            Lr.prototype.push = function(I, te) {
              const N = this.strm, oe = this.options.chunkSize, _e = this.options.dictionary;
              let pe, Ne, Oe;
              if (this.ended) return !1;
              for (te === ~~te ? Ne = te : Ne = te === !0 ? Ga : Wa, an.call(I) === "[object ArrayBuffer]" ? N.input = new Uint8Array(I) : N.input = I, N.next_in = 0, N.avail_in = N.input.length; ; ) {
                for (N.avail_out === 0 && (N.output = new Uint8Array(oe), N.next_out = 0, N.avail_out = oe), pe = nr.inflate(N, Ne), pe === si && _e && (pe = nr.inflateSetDictionary(N, _e), pe === $r ? pe = nr.inflate(N, Ne) : pe === sn && (pe = si)); N.avail_in > 0 && pe === ai && N.state.wrap > 0 && I[N.next_in] !== 0; )
                  nr.inflateReset(N), pe = nr.inflate(N, Ne);
                switch (pe) {
                  case Ha:
                  case sn:
                  case si:
                  case Va:
                    return this.onEnd(pe), this.ended = !0, !1;
                }
                if (Oe = N.avail_out, N.next_out && (N.avail_out === 0 || pe === ai))
                  if (this.options.to === "string") {
                    let ft = Cr.utf8border(N.output, N.next_out), Ce = N.next_out - ft, Ue = Cr.buf2string(N.output, ft);
                    N.next_out = Ce, N.avail_out = oe - Ce, Ce && N.output.set(N.output.subarray(ft, ft + Ce), 0), this.onData(Ue);
                  } else
                    this.onData(N.output.length === N.next_out ? N.output : N.output.subarray(0, N.next_out));
                if (!(pe === $r && Oe === 0)) {
                  if (pe === ai)
                    return pe = nr.inflateEnd(this.strm), this.onEnd(pe), this.ended = !0, !0;
                  if (N.avail_in === 0) break;
                }
              }
              return !0;
            }, Lr.prototype.onData = function(I) {
              this.chunks.push(I);
            }, Lr.prototype.onEnd = function(I) {
              I === $r && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = zr.flattenChunks(this.chunks)), this.chunks = [], this.err = I, this.msg = this.strm.msg;
            };
            function li(I, te) {
              const N = new Lr(te);
              if (N.push(I), N.err) throw N.msg || Fe[N.err];
              return N.result;
            }
            function ja(I, te) {
              return te = te || {}, te.raw = !0, li(I, te);
            }
            var Ka = Lr, Xa = li, Ya = ja, Za = li, qa = Te, Qa = {
              Inflate: Ka,
              inflate: Xa,
              inflateRaw: Ya,
              ungzip: Za,
              constants: qa
            };
            const { Deflate: Ja, deflate: es, deflateRaw: ts, gzip: rs } = oa, { Inflate: is, inflate: ns, inflateRaw: as, ungzip: ss } = Qa;
            var ln = Ja, on = es, cn = ts, hn = rs, un = is, dn = ns, fn = as, mn = ss, pn = Te, ls = {
              Deflate: ln,
              deflate: on,
              deflateRaw: cn,
              gzip: hn,
              Inflate: un,
              inflate: dn,
              inflateRaw: fn,
              ungzip: mn,
              constants: pn
            };
          }
        )
        /******/
      }, __webpack_module_cache__ = {};
      function __webpack_require__(a) {
        var e = __webpack_module_cache__[a];
        if (e !== void 0)
          return e.exports;
        var r = __webpack_module_cache__[a] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[a].call(r.exports, r, r.exports, __webpack_require__), r.exports;
      }
      __webpack_require__.n = (a) => {
        var e = a && a.__esModule ? (
          /******/
          () => a.default
        ) : (
          /******/
          () => a
        );
        return __webpack_require__.d(e, { a: e }), e;
      }, __webpack_require__.d = (a, e) => {
        for (var r in e)
          __webpack_require__.o(e, r) && !__webpack_require__.o(a, r) && Object.defineProperty(a, r, { enumerable: !0, get: e[r] });
      }, __webpack_require__.o = (a, e) => Object.prototype.hasOwnProperty.call(a, e), __webpack_require__.r = (a) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
      }, __webpack_require__("./src/index.ts"), __webpack_require__("./src/SurfaceWorker.js");
      var __webpack_exports__ = __webpack_require__("./src/exporter.js");
      return __webpack_exports__;
    })()
  ));
})(_3Dmol$1);
var _3DmolExports = _3Dmol$1.exports;
const _3Dmol = /* @__PURE__ */ getDefaultExportFromCjs(_3DmolExports), mol = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: _3Dmol
}, [_3DmolExports]), {
  SvelteComponent: SvelteComponent$c,
  add_render_callback,
  append_hydration: append_hydration$7,
  attr: attr$7,
  binding_callbacks: binding_callbacks$3,
  children: children$8,
  claim_element: claim_element$8,
  claim_space: claim_space$8,
  claim_svg_element: claim_svg_element$2,
  claim_text: claim_text$5,
  create_in_transition,
  destroy_each: destroy_each$2,
  detach: detach$b,
  element: element$8,
  ensure_array_like: ensure_array_like$3,
  get_svelte_dataset: get_svelte_dataset$2,
  init: init$c,
  insert_hydration: insert_hydration$b,
  listen: listen$3,
  noop: noop$6,
  null_to_empty,
  run_all: run_all$2,
  safe_not_equal: safe_not_equal$c,
  select_option,
  select_value,
  set_data: set_data$4,
  set_input_value,
  space: space$8,
  svg_element: svg_element$2,
  text: text$5,
  toggle_class: toggle_class$7,
  transition_in: transition_in$8
} = window.__gradio__svelte__internal, { onMount: onMount$2, beforeUpdate } = window.__gradio__svelte__internal;
function get_each_context$3(a, e, r) {
  const n = a.slice();
  return n[43] = e[r], n[44] = e, n[45] = r, n;
}
function get_each_context_1$1(a, e, r) {
  const n = a.slice();
  return n[46] = e[r], n[48] = r, n;
}
function get_each_context_2(a, e, r) {
  const n = a.slice();
  return n[49] = e[r], n[50] = e, n[51] = r, n;
}
function get_each_context_3(a, e, r) {
  const n = a.slice();
  return n[52] = e[r], n;
}
function create_if_block_9$1(a) {
  let e, r = '<div class="flex text-xs items-center space-x-1 justify-center flex-wrap svelte-1skivl7"><div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #0000FF;"> </span><span class="legendlabel svelte-1skivl7">0.0-0.1</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #1E90FF;"> </span><span class="legendlabel svelte-1skivl7">0.1-0.2</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #00CED1;"> </span><span class="legendlabel svelte-1skivl7">0.2-0.3</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #7CFC00;"> </span><span class="legendlabel svelte-1skivl7">0.3-0.4</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #ADFF2F;"> </span><span class="legendlabel svelte-1skivl7">0.4-0.5</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #FFFF00;"> </span><span class="legendlabel svelte-1skivl7">0.5-0.6</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #FFD700;"> </span><span class="legendlabel svelte-1skivl7">0.6-0.7</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #FFA500;"> </span><span class="legendlabel svelte-1skivl7">0.7-0.8</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #FF4500;"> </span><span class="legendlabel svelte-1skivl7">0.8-0.9</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-3 h-3 svelte-1skivl7" style="background-color: #FF0000;"> </span><span class="legendlabel svelte-1skivl7">0.9-1.0</span></div></div>';
  return {
    c() {
      e = element$8("div"), e.innerHTML = r, this.h();
    },
    l(n) {
      e = claim_element$8(n, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(e) !== "svelte-1t40i04" && (e.innerHTML = r), this.h();
    },
    h() {
      attr$7(e, "class", "absolute bottom-0 left-0 z-50 p-2 -mb-2 w-full bg-white svelte-1skivl7");
    },
    m(n, s) {
      insert_hydration$b(n, e, s);
    },
    d(n) {
      n && detach$b(e);
    }
  };
}
function create_if_block_8$1(a) {
  let e, r = '<div class="flex text-sm items-center space-x-2 justify-center svelte-1skivl7"><div class="flex space-x-1 py-1 items-center svelte-1skivl7"><a class="cursor-pointer svelte-1skivl7" href="https://pubmed.ncbi.nlm.nih.gov/7108955/">Kyte &amp; Doolittle hydrophobicity scale:</a></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-4 h-4 svelte-1skivl7" style="background-color: #B8860B;"> </span><span class="legendlabel svelte-1skivl7">Hydrophobic</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-4 h-4 border border-gray-300 svelte-1skivl7" style="background-color: white"> </span><span class="legendlabel svelte-1skivl7">Neutral</span></div> <div class="flex space-x-1 py-1 items-center svelte-1skivl7"><span class="w-4 h-4 svelte-1skivl7" style="background-color: darkcyan;"> </span><span class="legendlabel svelte-1skivl7">Hydrophilic</span></div></div>';
  return {
    c() {
      e = element$8("div"), e.innerHTML = r, this.h();
    },
    l(n) {
      e = claim_element$8(n, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(e) !== "svelte-n84ddp" && (e.innerHTML = r), this.h();
    },
    h() {
      attr$7(e, "class", "absolute bottom-0 left-0 z-50 p-2 mb-2 w-full bg-white svelte-1skivl7");
    },
    m(n, s) {
      insert_hydration$b(n, e, s);
    },
    d(n) {
      n && detach$b(e);
    }
  };
}
function create_if_block_6$1(a) {
  let e;
  function r(h, b) {
    return (
      /*isAnimated*/
      h[8] ? create_else_block$7 : create_if_block_7$1
    );
  }
  let n = r(a), s = n(a);
  return {
    c() {
      e = element$8("div"), s.c(), this.h();
    },
    l(h) {
      e = claim_element$8(h, "DIV", { class: !0 });
      var b = children$8(e);
      s.l(b), b.forEach(detach$b), this.h();
    },
    h() {
      attr$7(e, "class", "absolute z-50 bottom-0 right-0 mr-2 flex divide-x border border-gray-200 mb-2 rounded items-center justify-center svelte-1skivl7");
    },
    m(h, b) {
      insert_hydration$b(h, e, b), s.m(e, null);
    },
    p(h, b) {
      n === (n = r(h)) && s ? s.p(h, b) : (s.d(1), s = n(h), s && (s.c(), s.m(e, null)));
    },
    d(h) {
      h && detach$b(e), s.d();
    }
  };
}
function create_else_block$7(a) {
  let e, r = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z" class="svelte-1skivl7"></path></svg>', n, s;
  return {
    c() {
      e = element$8("button"), e.innerHTML = r, this.h();
    },
    l(h) {
      e = claim_element$8(h, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(e) !== "svelte-jyx1zx" && (e.innerHTML = r), this.h();
    },
    h() {
      attr$7(e, "class", "p-2 svelte-1skivl7"), attr$7(e, "title", "Pause");
    },
    m(h, b) {
      insert_hydration$b(h, e, b), n || (s = listen$3(
        e,
        "click",
        /*toggleAnimation*/
        a[18]
      ), n = !0);
    },
    p: noop$6,
    d(h) {
      h && detach$b(e), n = !1, s();
    }
  };
}
function create_if_block_7$1(a) {
  let e, r = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" class="svelte-1skivl7"></path></svg>', n, s;
  return {
    c() {
      e = element$8("button"), e.innerHTML = r, this.h();
    },
    l(h) {
      e = claim_element$8(h, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(e) !== "svelte-y25go4" && (e.innerHTML = r), this.h();
    },
    h() {
      attr$7(e, "class", "p-2 svelte-1skivl7"), attr$7(e, "title", "Play");
    },
    m(h, b) {
      insert_hydration$b(h, e, b), n || (s = listen$3(
        e,
        "click",
        /*toggleAnimation*/
        a[18]
      ), n = !0);
    },
    p: noop$6,
    d(h) {
      h && detach$b(e), n = !1, s();
    }
  };
}
function create_if_block_2$3(a) {
  let e, r, n, s = "Settings", h, b, g = '<svg aria-hidden="true" class="w-5 h-5 svelte-1skivl7" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" class="svelte-1skivl7"></path></svg> <span class="sr-only svelte-1skivl7">Close menu</span>', _, A, x, k, $, C = "Label atoms on hover", L, y, o, v, w, M, F, m = ensure_array_like$3(Object.keys(
    /*config*/
    a[0]
  )), E = [];
  for (let z = 0; z < m.length; z += 1)
    E[z] = create_each_block_2(get_each_context_2(a, m, z));
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("h5"), n.textContent = s, h = space$8(), b = element$8("button"), b.innerHTML = g, _ = space$8();
      for (let z = 0; z < E.length; z += 1)
        E[z].c();
      A = space$8(), x = element$8("div"), k = element$8("div"), $ = element$8("label"), $.textContent = C, L = space$8(), y = element$8("label"), o = element$8("input"), v = space$8(), w = element$8("div"), this.h();
    },
    l(z) {
      e = claim_element$8(z, "DIV", {
        id: !0,
        class: !0,
        tabindex: !0,
        "aria-labelledby": !0
      });
      var O = children$8(e);
      r = claim_element$8(O, "DIV", { class: !0 });
      var R = children$8(r);
      n = claim_element$8(R, "H5", {
        id: !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(n) !== "svelte-17gte" && (n.textContent = s), h = claim_space$8(R), b = claim_element$8(R, "BUTTON", {
        type: !0,
        "data-drawer-hide": !0,
        "aria-controls": !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(b) !== "svelte-1qzp5va" && (b.innerHTML = g), R.forEach(detach$b), _ = claim_space$8(O);
      for (let U = 0; U < E.length; U += 1)
        E[U].l(O);
      A = claim_space$8(O), x = claim_element$8(O, "DIV", { class: !0 });
      var B = children$8(x);
      k = claim_element$8(B, "DIV", { class: !0 });
      var P = children$8(k);
      $ = claim_element$8(P, "LABEL", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2($) !== "svelte-1l09ghj" && ($.textContent = C), L = claim_space$8(P), y = claim_element$8(P, "LABEL", { class: !0 });
      var W = children$8(y);
      o = claim_element$8(W, "INPUT", { type: !0, class: !0 }), v = claim_space$8(W), w = claim_element$8(W, "DIV", { class: !0 }), children$8(w).forEach(detach$b), W.forEach(detach$b), P.forEach(detach$b), B.forEach(detach$b), O.forEach(detach$b), this.h();
    },
    h() {
      attr$7(n, "id", "settings-drawer-label"), attr$7(n, "class", "inline-flex items-center mb-4 text-base font-semibold text-gray-500 dark:text-gray-400 svelte-1skivl7"), attr$7(b, "type", "button"), attr$7(b, "data-drawer-hide", "drawer-example"), attr$7(b, "aria-controls", "drawer-example"), attr$7(b, "class", "text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 absolute top-2.5 right-2.5 inline-flex items-center dark:hover:bg-gray-600 dark:hover:text-white svelte-1skivl7"), attr$7(r, "class", "p-4 svelte-1skivl7"), attr$7($, "class", "text-sm font-medium text-gray-600 dark:text-gray-400 w-1/2 svelte-1skivl7"), attr$7(o, "type", "checkbox"), attr$7(o, "class", "sr-only peer svelte-1skivl7"), attr$7(w, "class", "w-11 h-6 bg-gray-200 rounded-full peer dark:bg-gray-700 peer-focus:ring-4 peer-focus:ring-orange-300 dark:peer-focus:ring-orange-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-orange-400 svelte-1skivl7"), attr$7(y, "class", "relative inline-flex items-center mr-5 cursor-pointer text-center justify-center svelte-1skivl7"), attr$7(k, "class", "flex items-center border-t border-b border-gray-200 bg-white px-4 py-2 space-x-2 svelte-1skivl7"), attr$7(x, "class", "bg-white svelte-1skivl7"), attr$7(e, "id", "settings-drawer"), attr$7(e, "class", "absolute top-0 right-0 z-50 h-full overflow-y-auto transition-transform bg-gray-100 w-80 dark:bg-gray-800 svelte-1skivl7"), attr$7(e, "tabindex", "-1"), attr$7(e, "aria-labelledby", "settings-drawer-label");
    },
    m(z, O) {
      insert_hydration$b(z, e, O), append_hydration$7(e, r), append_hydration$7(r, n), append_hydration$7(r, h), append_hydration$7(r, b), append_hydration$7(e, _);
      for (let R = 0; R < E.length; R += 1)
        E[R] && E[R].m(e, null);
      append_hydration$7(e, A), append_hydration$7(e, x), append_hydration$7(x, k), append_hydration$7(k, $), append_hydration$7(k, L), append_hydration$7(k, y), append_hydration$7(y, o), set_input_value(
        o,
        /*labelHover*/
        a[4]
      ), append_hydration$7(y, v), append_hydration$7(y, w), M || (F = [
        listen$3(
          b,
          "click",
          /*toggleOffCanvas*/
          a[13]
        ),
        listen$3(
          o,
          "change",
          /*input_change_handler_1*/
          a[25]
        )
      ], M = !0);
    },
    p(z, O) {
      if (O[0] & /*config, settings*/
      2049) {
        m = ensure_array_like$3(Object.keys(
          /*config*/
          z[0]
        ));
        let R;
        for (R = 0; R < m.length; R += 1) {
          const B = get_each_context_2(z, m, R);
          E[R] ? E[R].p(B, O) : (E[R] = create_each_block_2(B), E[R].c(), E[R].m(e, A));
        }
        for (; R < E.length; R += 1)
          E[R].d(1);
        E.length = m.length;
      }
      O[0] & /*labelHover*/
      16 && set_input_value(
        o,
        /*labelHover*/
        z[4]
      );
    },
    d(z) {
      z && detach$b(e), destroy_each$2(E, z), M = !1, run_all$2(F);
    }
  };
}
function create_if_block_5$1(a) {
  let e, r, n, s, h, b;
  function g() {
    a[22].call(
      r,
      /*setting*/
      a[49]
    );
  }
  return {
    c() {
      e = element$8("label"), r = element$8("input"), n = space$8(), s = element$8("div"), this.h();
    },
    l(_) {
      e = claim_element$8(_, "LABEL", { class: !0 });
      var A = children$8(e);
      r = claim_element$8(A, "INPUT", { type: !0, class: !0 }), n = claim_space$8(A), s = claim_element$8(A, "DIV", { class: !0 }), children$8(s).forEach(detach$b), A.forEach(detach$b), this.h();
    },
    h() {
      attr$7(r, "type", "checkbox"), r.__value = "", set_input_value(r, r.__value), attr$7(r, "class", "sr-only peer svelte-1skivl7"), attr$7(s, "class", "w-11 h-6 bg-gray-200 rounded-full peer dark:bg-gray-700 peer-focus:ring-4 peer-focus:ring-orange-300 dark:peer-focus:ring-orange-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-orange-400 svelte-1skivl7"), attr$7(e, "class", "relative inline-flex items-center mr-5 cursor-pointer text-center justify-center svelte-1skivl7");
    },
    m(_, A) {
      insert_hydration$b(_, e, A), append_hydration$7(e, r), r.checked = /*config*/
      a[0][
        /*setting*/
        a[49]
      ], append_hydration$7(e, n), append_hydration$7(e, s), h || (b = listen$3(r, "change", g), h = !0);
    },
    p(_, A) {
      a = _, A[0] & /*config, settings*/
      2049 && (r.checked = /*config*/
      a[0][
        /*setting*/
        a[49]
      ]);
    },
    d(_) {
      _ && detach$b(e), h = !1, b();
    }
  };
}
function create_if_block_4$1(a) {
  let e, r, n, s, h, b, g, _, A = (
    /*config*/
    a[0][
      /*setting*/
      a[49]
    ] + ""
  ), x, k, $;
  function C() {
    return (
      /*change_handler*/
      a[23](
        /*setting*/
        a[49]
      )
    );
  }
  return {
    c() {
      e = element$8("div"), r = element$8("input"), g = space$8(), _ = element$8("span"), x = text$5(A), this.h();
    },
    l(L) {
      e = claim_element$8(L, "DIV", { class: !0 });
      var y = children$8(e);
      r = claim_element$8(y, "INPUT", {
        id: !0,
        type: !0,
        min: !0,
        max: !0,
        step: !0,
        class: !0
      }), g = claim_space$8(y), _ = claim_element$8(y, "SPAN", { class: !0 });
      var o = children$8(_);
      x = claim_text$5(o, A), o.forEach(detach$b), y.forEach(detach$b), this.h();
    },
    h() {
      attr$7(r, "id", "medium-range"), attr$7(r, "type", "range"), r.value = n = /*config*/
      a[0][
        /*setting*/
        a[49]
      ], attr$7(r, "min", s = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].min), attr$7(r, "max", h = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].max), attr$7(r, "step", b = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].step), attr$7(r, "class", "w-2/3 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 svelte-1skivl7"), attr$7(_, "class", "w-1/3 text-center text-sm font-medium text-gray-600 dark:text-gray-400 svelte-1skivl7"), attr$7(e, "class", "flex items-center svelte-1skivl7");
    },
    m(L, y) {
      insert_hydration$b(L, e, y), append_hydration$7(e, r), append_hydration$7(e, g), append_hydration$7(e, _), append_hydration$7(_, x), k || ($ = listen$3(r, "change", C), k = !0);
    },
    p(L, y) {
      a = L, y[0] & /*config, settings*/
      2049 && n !== (n = /*config*/
      a[0][
        /*setting*/
        a[49]
      ]) && (r.value = n), y[0] & /*config, settings*/
      2049 && s !== (s = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].min) && attr$7(r, "min", s), y[0] & /*config, settings*/
      2049 && h !== (h = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].max) && attr$7(r, "max", h), y[0] & /*config, settings*/
      2049 && b !== (b = /*settings*/
      a[11][
        /*setting*/
        a[49]
      ].step) && attr$7(r, "step", b), y[0] & /*config*/
      1 && A !== (A = /*config*/
      a[0][
        /*setting*/
        a[49]
      ] + "") && set_data$4(x, A);
    },
    d(L) {
      L && detach$b(e), k = !1, $();
    }
  };
}
function create_if_block_3$1(a) {
  let e, r, n, s, h, b, g, _, A = ensure_array_like$3(
    /*settings*/
    a[11][
      /*setting*/
      a[49]
    ].options
  ), x = [];
  for (let $ = 0; $ < A.length; $ += 1)
    x[$] = create_each_block_3(get_each_context_3(a, A, $));
  function k() {
    a[24].call(
      h,
      /*setting*/
      a[49]
    );
  }
  return {
    c() {
      e = element$8("label"), r = text$5("Select style"), s = space$8(), h = element$8("select");
      for (let $ = 0; $ < x.length; $ += 1)
        x[$].c();
      this.h();
    },
    l($) {
      e = claim_element$8($, "LABEL", { for: !0, class: !0 });
      var C = children$8(e);
      r = claim_text$5(C, "Select style"), C.forEach(detach$b), s = claim_space$8($), h = claim_element$8($, "SELECT", { id: !0, class: !0 });
      var L = children$8(h);
      for (let y = 0; y < x.length; y += 1)
        x[y].l(L);
      L.forEach(detach$b), this.h();
    },
    h() {
      attr$7(e, "for", n = /*setting*/
      a[49]), attr$7(e, "class", "sr-only svelte-1skivl7"), attr$7(h, "id", b = /*setting*/
      a[49]), attr$7(h, "class", "bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 svelte-1skivl7"), /*config*/
      a[0][
        /*setting*/
        a[49]
      ] === void 0 && add_render_callback(k);
    },
    m($, C) {
      insert_hydration$b($, e, C), append_hydration$7(e, r), insert_hydration$b($, s, C), insert_hydration$b($, h, C);
      for (let L = 0; L < x.length; L += 1)
        x[L] && x[L].m(h, null);
      select_option(
        h,
        /*config*/
        a[0][
          /*setting*/
          a[49]
        ],
        !0
      ), g || (_ = listen$3(h, "change", k), g = !0);
    },
    p($, C) {
      if (a = $, C[0] & /*config, settings*/
      2049 && n !== (n = /*setting*/
      a[49]) && attr$7(e, "for", n), C[0] & /*settings, config*/
      2049) {
        A = ensure_array_like$3(
          /*settings*/
          a[11][
            /*setting*/
            a[49]
          ].options
        );
        let L;
        for (L = 0; L < A.length; L += 1) {
          const y = get_each_context_3(a, A, L);
          x[L] ? x[L].p(y, C) : (x[L] = create_each_block_3(y), x[L].c(), x[L].m(h, null));
        }
        for (; L < x.length; L += 1)
          x[L].d(1);
        x.length = A.length;
      }
      C[0] & /*config, settings*/
      2049 && b !== (b = /*setting*/
      a[49]) && attr$7(h, "id", b), C[0] & /*config, settings*/
      2049 && select_option(
        h,
        /*config*/
        a[0][
          /*setting*/
          a[49]
        ]
      );
    },
    d($) {
      $ && (detach$b(e), detach$b(s), detach$b(h)), destroy_each$2(x, $), g = !1, _();
    }
  };
}
function create_each_block_3(a) {
  let e, r = (
    /*option*/
    a[52] + ""
  ), n, s, h;
  return {
    c() {
      e = element$8("option"), n = text$5(r), this.h();
    },
    l(b) {
      e = claim_element$8(b, "OPTION", { class: !0 });
      var g = children$8(e);
      n = claim_text$5(g, r), g.forEach(detach$b), this.h();
    },
    h() {
      e.__value = s = /*option*/
      a[52], set_input_value(e, e.__value), e.selected = h = /*option*/
      a[52] == /*config*/
      a[0][
        /*setting*/
        a[49]
      ], attr$7(e, "class", "svelte-1skivl7");
    },
    m(b, g) {
      insert_hydration$b(b, e, g), append_hydration$7(e, n);
    },
    p(b, g) {
      g[0] & /*config*/
      1 && r !== (r = /*option*/
      b[52] + "") && set_data$4(n, r), g[0] & /*config, settings*/
      2049 && s !== (s = /*option*/
      b[52]) && (e.__value = s, set_input_value(e, e.__value)), g[0] & /*config, settings*/
      2049 && h !== (h = /*option*/
      b[52] == /*config*/
      b[0][
        /*setting*/
        b[49]
      ]) && (e.selected = h);
    },
    d(b) {
      b && detach$b(e);
    }
  };
}
function create_each_block_2(a) {
  let e, r, n, s = (
    /*setting*/
    a[49] + ""
  ), h, b, g, _, A, x = (
    /*settings*/
    a[11][
      /*setting*/
      a[49]
    ].type == "toggle" && create_if_block_5$1(a)
  ), k = (
    /*settings*/
    a[11][
      /*setting*/
      a[49]
    ].type == "range" && create_if_block_4$1(a)
  ), $ = (
    /*settings*/
    a[11][
      /*setting*/
      a[49]
    ].type == "select" && create_if_block_3$1(a)
  );
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("label"), h = text$5(s), g = space$8(), x && x.c(), _ = space$8(), k && k.c(), A = space$8(), $ && $.c(), this.h();
    },
    l(C) {
      e = claim_element$8(C, "DIV", { class: !0 });
      var L = children$8(e);
      r = claim_element$8(L, "DIV", { class: !0 });
      var y = children$8(r);
      n = claim_element$8(y, "LABEL", { for: !0, class: !0 });
      var o = children$8(n);
      h = claim_text$5(o, s), o.forEach(detach$b), g = claim_space$8(y), x && x.l(y), _ = claim_space$8(y), k && k.l(y), A = claim_space$8(y), $ && $.l(y), y.forEach(detach$b), L.forEach(detach$b), this.h();
    },
    h() {
      attr$7(n, "for", b = /*setting*/
      a[49]), attr$7(n, "class", "text-sm font-medium text-gray-600 dark:text-gray-400 w-1/2 svelte-1skivl7"), attr$7(r, "class", "flex items-center border-t border-b border-gray-200 bg-white px-4 py-2 space-x-2 svelte-1skivl7"), attr$7(e, "class", "flex flex-col mb-4 divide-y svelte-1skivl7");
    },
    m(C, L) {
      insert_hydration$b(C, e, L), append_hydration$7(e, r), append_hydration$7(r, n), append_hydration$7(n, h), append_hydration$7(r, g), x && x.m(r, null), append_hydration$7(r, _), k && k.m(r, null), append_hydration$7(r, A), $ && $.m(r, null);
    },
    p(C, L) {
      L[0] & /*config*/
      1 && s !== (s = /*setting*/
      C[49] + "") && set_data$4(h, s), L[0] & /*config, settings*/
      2049 && b !== (b = /*setting*/
      C[49]) && attr$7(n, "for", b), /*settings*/
      C[11][
        /*setting*/
        C[49]
      ].type == "toggle" ? x ? x.p(C, L) : (x = create_if_block_5$1(C), x.c(), x.m(r, _)) : x && (x.d(1), x = null), /*settings*/
      C[11][
        /*setting*/
        C[49]
      ].type == "range" ? k ? k.p(C, L) : (k = create_if_block_4$1(C), k.c(), k.m(r, A)) : k && (k.d(1), k = null), /*settings*/
      C[11][
        /*setting*/
        C[49]
      ].type == "select" ? $ ? $.p(C, L) : ($ = create_if_block_3$1(C), $.c(), $.m(r, null)) : $ && ($.d(1), $ = null);
    },
    d(C) {
      C && detach$b(e), x && x.d(), k && k.d(), $ && $.d();
    }
  };
}
function create_if_block$9(a) {
  let e, r, n, s = "Representations", h, b, g = '<svg aria-hidden="true" class="w-5 h-5 svelte-1skivl7" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" class="svelte-1skivl7"></path></svg> <span class="sr-only svelte-1skivl7">Close menu</span>', _, A, x, k = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4 svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v6m3-3H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z" class="svelte-1skivl7"></path></svg> <div class="svelte-1skivl7">Add representation</div>', $, C, L = ensure_array_like$3(
    /*representations*/
    a[1]
  ), y = [];
  for (let o = 0; o < L.length; o += 1)
    y[o] = create_each_block$3(get_each_context$3(a, L, o));
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("h5"), n.textContent = s, h = space$8(), b = element$8("button"), b.innerHTML = g, _ = space$8();
      for (let o = 0; o < y.length; o += 1)
        y[o].c();
      A = space$8(), x = element$8("button"), x.innerHTML = k, this.h();
    },
    l(o) {
      e = claim_element$8(o, "DIV", {
        id: !0,
        class: !0,
        tabindex: !0,
        "aria-labelledby": !0
      });
      var v = children$8(e);
      r = claim_element$8(v, "DIV", { class: !0 });
      var w = children$8(r);
      n = claim_element$8(w, "H5", {
        id: !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(n) !== "svelte-1o7jz4z" && (n.textContent = s), h = claim_space$8(w), b = claim_element$8(w, "BUTTON", {
        type: !0,
        "data-drawer-hide": !0,
        "aria-controls": !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(b) !== "svelte-1nfxhie" && (b.innerHTML = g), w.forEach(detach$b), _ = claim_space$8(v);
      for (let M = 0; M < y.length; M += 1)
        y[M].l(v);
      A = claim_space$8(v), x = claim_element$8(v, "BUTTON", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(x) !== "svelte-dc168v" && (x.innerHTML = k), v.forEach(detach$b), this.h();
    },
    h() {
      attr$7(n, "id", "drawer-label"), attr$7(n, "class", "inline-flex items-center mb-4 text-base font-semibold text-gray-500 dark:text-gray-400 svelte-1skivl7"), attr$7(b, "type", "button"), attr$7(b, "data-drawer-hide", "drawer-example"), attr$7(b, "aria-controls", "drawer-example"), attr$7(b, "class", "text-gray-400 bg-transparent hover:bg-gray-200 hover:text-gray-900 rounded-lg text-sm p-1.5 absolute top-2.5 right-2.5 inline-flex items-center dark:hover:bg-gray-600 dark:hover:text-white svelte-1skivl7"), attr$7(r, "class", "p-4 svelte-1skivl7"), attr$7(x, "class", "w-full flex text-orange-600 justify-center my-2 text-sm space-x-2 items-center hover:text-gray-600 cursor-pointer svelte-1skivl7"), attr$7(e, "id", "drawer-example"), attr$7(e, "class", "absolute top-0 right-0 z-50 h-full overflow-y-auto transition-transform bg-gray-100 w-80 dark:bg-gray-800 border-l border-gray-200 svelte-1skivl7"), attr$7(e, "tabindex", "-1"), attr$7(e, "aria-labelledby", "drawer-label");
    },
    m(o, v) {
      insert_hydration$b(o, e, v), append_hydration$7(e, r), append_hydration$7(r, n), append_hydration$7(r, h), append_hydration$7(r, b), append_hydration$7(e, _);
      for (let w = 0; w < y.length; w += 1)
        y[w] && y[w].m(e, null);
      append_hydration$7(e, A), append_hydration$7(e, x), $ || (C = [
        listen$3(
          b,
          "click",
          /*toggleOffCanvasReps*/
          a[14]
        ),
        listen$3(
          x,
          "click",
          /*insertRep*/
          a[16]
        )
      ], $ = !0);
    },
    p(o, v) {
      if (v[0] & /*representations, moldata, resetZoom, deleteRep*/
      163846) {
        L = ensure_array_like$3(
          /*representations*/
          o[1]
        );
        let w;
        for (w = 0; w < L.length; w += 1) {
          const M = get_each_context$3(o, L, w);
          y[w] ? y[w].p(M, v) : (y[w] = create_each_block$3(M), y[w].c(), y[w].m(e, A));
        }
        for (; w < y.length; w += 1)
          y[w].d(1);
        y.length = L.length;
      }
    },
    d(o) {
      o && detach$b(e), destroy_each$2(y, o), $ = !1, run_all$2(C);
    }
  };
}
function create_if_block_1$8(a) {
  let e, r, n, s, h, b, g, _, A, x, k, $ = "Select style", C, L, y, o = "Stick", v, w = "Cartoon", M, F = "Surface", m, E, z = "Sphere", O, R, B, P = "Opacity", W, U, V, K, q, H, j, Q, J = "Scale", Y, ee, fe, me, he, we, ye, ve, ce = "Expand selection", be, le, Se, ge, de, De, Be, Ve = "Å", qe, Ze, Ye, Xe = ensure_array_like$3(
    /*moldata*/
    a[2]
  ), Ge = [];
  for (let ze = 0; ze < Xe.length; ze += 1)
    Ge[ze] = create_each_block_1$1(get_each_context_1$1(a, Xe, ze));
  function Ke() {
    a[29].call(
      n,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function Pe() {
    a[30].call(
      b,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function it() {
    a[31].call(
      _,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function nt() {
    a[32].call(
      L,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function ne(...ze) {
    return (
      /*change_handler_1*/
      a[33](
        /*rep*/
        a[43],
        /*each_value*/
        a[44],
        /*index*/
        a[45],
        ...ze
      )
    );
  }
  function se() {
    a[34].call(
      q,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function ue(...ze) {
    return (
      /*change_handler_2*/
      a[35](
        /*rep*/
        a[43],
        /*each_value*/
        a[44],
        /*index*/
        a[45],
        ...ze
      )
    );
  }
  function $e() {
    a[36].call(
      he,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  function Ae(...ze) {
    return (
      /*change_handler_3*/
      a[37](
        /*rep*/
        a[43],
        /*each_value*/
        a[44],
        /*index*/
        a[45],
        ...ze
      )
    );
  }
  function je() {
    a[38].call(
      de,
      /*each_value*/
      a[44],
      /*index*/
      a[45]
    );
  }
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("select");
      for (let ze = 0; ze < Ge.length; ze += 1)
        Ge[ze].c();
      s = space$8(), h = element$8("div"), b = element$8("input"), g = space$8(), _ = element$8("input"), A = space$8(), x = element$8("div"), k = element$8("label"), k.textContent = $, C = space$8(), L = element$8("select"), y = element$8("option"), y.textContent = o, v = element$8("option"), v.textContent = w, M = element$8("option"), M.textContent = F, m = text$5(`$
                        `), E = element$8("option"), E.textContent = z, O = space$8(), R = element$8("div"), B = element$8("div"), B.textContent = P, W = space$8(), U = element$8("input"), K = space$8(), q = element$8("input"), H = space$8(), j = element$8("div"), Q = element$8("div"), Q.textContent = J, Y = space$8(), ee = element$8("input"), me = space$8(), he = element$8("input"), we = space$8(), ye = element$8("div"), ve = element$8("div"), ve.textContent = ce, be = space$8(), le = element$8("input"), ge = space$8(), de = element$8("input"), De = space$8(), Be = element$8("div"), Be.textContent = Ve, this.h();
    },
    l(ze) {
      e = claim_element$8(ze, "DIV", { class: !0 });
      var re = children$8(e);
      r = claim_element$8(re, "DIV", { class: !0 });
      var xe = children$8(r);
      n = claim_element$8(xe, "SELECT", { id: !0, class: !0 });
      var Le = children$8(n);
      for (let G = 0; G < Ge.length; G += 1)
        Ge[G].l(Le);
      Le.forEach(detach$b), xe.forEach(detach$b), s = claim_space$8(re), h = claim_element$8(re, "DIV", { class: !0 });
      var He = children$8(h);
      b = claim_element$8(He, "INPUT", {
        type: !0,
        id: !0,
        class: !0,
        placeholder: !0
      }), g = claim_space$8(He), _ = claim_element$8(He, "INPUT", {
        type: !0,
        id: !0,
        class: !0,
        placeholder: !0
      }), He.forEach(detach$b), A = claim_space$8(re), x = claim_element$8(re, "DIV", { class: !0 });
      var Me = children$8(x);
      k = claim_element$8(Me, "LABEL", {
        for: !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(k) !== "svelte-wallp4" && (k.textContent = $), C = claim_space$8(Me), L = claim_element$8(Me, "SELECT", { id: !0, class: !0 });
      var Re = children$8(L);
      y = claim_element$8(Re, "OPTION", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(y) !== "svelte-sfou62" && (y.textContent = o), v = claim_element$8(Re, "OPTION", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(v) !== "svelte-e05dfq" && (v.textContent = w), M = claim_element$8(Re, "OPTION", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(M) !== "svelte-1nnagnw" && (M.textContent = F), m = claim_text$5(Re, `$
                        `), E = claim_element$8(Re, "OPTION", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(E) !== "svelte-eymsc2" && (E.textContent = z), Re.forEach(detach$b), Me.forEach(detach$b), O = claim_space$8(re), R = claim_element$8(re, "DIV", { class: !0 });
      var ie = children$8(R);
      B = claim_element$8(ie, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(B) !== "svelte-17zx4ra" && (B.textContent = P), W = claim_space$8(ie), U = claim_element$8(ie, "INPUT", {
        id: !0,
        type: !0,
        min: !0,
        max: !0,
        step: !0,
        class: !0
      }), K = claim_space$8(ie), q = claim_element$8(ie, "INPUT", { type: !0, class: !0 }), ie.forEach(detach$b), H = claim_space$8(re), j = claim_element$8(re, "DIV", { class: !0 });
      var We = children$8(j);
      Q = claim_element$8(We, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(Q) !== "svelte-1n8cxvb" && (Q.textContent = J), Y = claim_space$8(We), ee = claim_element$8(We, "INPUT", {
        id: !0,
        type: !0,
        min: !0,
        max: !0,
        step: !0,
        class: !0
      }), me = claim_space$8(We), he = claim_element$8(We, "INPUT", { type: !0, class: !0 }), We.forEach(detach$b), we = claim_space$8(re), ye = claim_element$8(re, "DIV", { class: !0 });
      var Qe = children$8(ye);
      ve = claim_element$8(Qe, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(ve) !== "svelte-1i4r04x" && (ve.textContent = ce), be = claim_space$8(Qe), le = claim_element$8(Qe, "INPUT", {
        id: !0,
        type: !0,
        min: !0,
        max: !0,
        step: !0,
        class: !0
      }), ge = claim_space$8(Qe), de = claim_element$8(Qe, "INPUT", { type: !0, class: !0 }), De = claim_space$8(Qe), Be = claim_element$8(Qe, "DIV", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(Be) !== "svelte-n73cw5" && (Be.textContent = Ve), Qe.forEach(detach$b), re.forEach(detach$b), this.h();
    },
    h() {
      attr$7(n, "id", "style"), attr$7(n, "class", "bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 svelte-1skivl7"), /*rep*/
      a[43].model === void 0 && add_render_callback(Ke), attr$7(r, "class", "p-1 flex space-x-1 svelte-1skivl7"), attr$7(b, "type", "text"), attr$7(b, "id", "chain"), attr$7(b, "class", "w-1/2 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 svelte-1skivl7"), attr$7(b, "placeholder", "Resname"), attr$7(_, "type", "text"), attr$7(_, "id", "residue_range"), attr$7(_, "class", "w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 svelte-1skivl7"), attr$7(_, "placeholder", "Residue range"), attr$7(h, "class", "p-1 flex space-x-1 svelte-1skivl7"), attr$7(k, "for", "countries"), attr$7(k, "class", "block mb-2 text-sm w-1/3 font-medium text-gray-600 dark:text-white svelte-1skivl7"), y.__value = "stick", set_input_value(y, y.__value), attr$7(y, "class", "svelte-1skivl7"), v.__value = "cartoon", set_input_value(v, v.__value), attr$7(v, "class", "svelte-1skivl7"), M.__value = "surface", set_input_value(M, M.__value), attr$7(M, "class", "svelte-1skivl7"), E.__value = "sphere", set_input_value(E, E.__value), attr$7(E, "class", "svelte-1skivl7"), attr$7(L, "id", "style"), attr$7(L, "class", "bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500 svelte-1skivl7"), /*rep*/
      a[43].style === void 0 && add_render_callback(nt), attr$7(x, "class", "p-1 flex space-x-1 items-center svelte-1skivl7"), attr$7(B, "class", " svelte-1skivl7"), attr$7(U, "id", "around"), attr$7(U, "type", "range"), U.value = V = /*rep*/
      a[43].opacity, attr$7(U, "min", "0"), attr$7(U, "max", "1"), attr$7(U, "step", "0.1"), attr$7(U, "class", "h-2 w-full bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 svelte-1skivl7"), attr$7(q, "type", "text"), attr$7(q, "class", "w-8 svelte-1skivl7"), attr$7(R, "class", "flex p-1 items-center text-gray-700 space-x-1 text-sm svelte-1skivl7"), attr$7(Q, "class", " svelte-1skivl7"), attr$7(ee, "id", "around"), attr$7(ee, "type", "range"), ee.value = fe = /*rep*/
      a[43].scale, attr$7(ee, "min", "0"), attr$7(ee, "max", "1"), attr$7(ee, "step", "0.1"), attr$7(ee, "class", "h-2 w-full bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 svelte-1skivl7"), attr$7(he, "type", "text"), attr$7(he, "class", "w-8 svelte-1skivl7"), attr$7(j, "class", "flex p-1 items-center text-gray-700 space-x-1 text-sm svelte-1skivl7"), attr$7(ve, "class", " svelte-1skivl7"), attr$7(le, "id", "around"), attr$7(le, "type", "range"), le.value = Se = /*rep*/
      a[43].around, attr$7(le, "min", "0"), attr$7(le, "max", "10"), attr$7(le, "step", "0.5"), attr$7(le, "class", "h-2 w-1/3 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 svelte-1skivl7"), attr$7(de, "type", "text"), attr$7(de, "class", "w-8 svelte-1skivl7"), attr$7(Be, "class", "svelte-1skivl7"), attr$7(ye, "class", "flex p-1 items-center text-gray-700 space-x-1 text-sm svelte-1skivl7"), attr$7(e, "class", "svelte-1skivl7");
    },
    m(ze, re) {
      insert_hydration$b(ze, e, re), append_hydration$7(e, r), append_hydration$7(r, n);
      for (let xe = 0; xe < Ge.length; xe += 1)
        Ge[xe] && Ge[xe].m(n, null);
      select_option(
        n,
        /*rep*/
        a[43].model,
        !0
      ), append_hydration$7(e, s), append_hydration$7(e, h), append_hydration$7(h, b), set_input_value(
        b,
        /*rep*/
        a[43].resname
      ), append_hydration$7(h, g), append_hydration$7(h, _), set_input_value(
        _,
        /*rep*/
        a[43].residue_range
      ), append_hydration$7(e, A), append_hydration$7(e, x), append_hydration$7(x, k), append_hydration$7(x, C), append_hydration$7(x, L), append_hydration$7(L, y), append_hydration$7(L, v), append_hydration$7(L, M), append_hydration$7(L, m), append_hydration$7(L, E), select_option(
        L,
        /*rep*/
        a[43].style,
        !0
      ), append_hydration$7(e, O), append_hydration$7(e, R), append_hydration$7(R, B), append_hydration$7(R, W), append_hydration$7(R, U), append_hydration$7(R, K), append_hydration$7(R, q), set_input_value(
        q,
        /*rep*/
        a[43].opacity
      ), append_hydration$7(e, H), append_hydration$7(e, j), append_hydration$7(j, Q), append_hydration$7(j, Y), append_hydration$7(j, ee), append_hydration$7(j, me), append_hydration$7(j, he), set_input_value(
        he,
        /*rep*/
        a[43].scale
      ), append_hydration$7(e, we), append_hydration$7(e, ye), append_hydration$7(ye, ve), append_hydration$7(ye, be), append_hydration$7(ye, le), append_hydration$7(ye, ge), append_hydration$7(ye, de), set_input_value(
        de,
        /*rep*/
        a[43].around
      ), append_hydration$7(ye, De), append_hydration$7(ye, Be), Ze || (Ye = [
        listen$3(n, "change", Ke),
        listen$3(b, "input", Pe),
        listen$3(_, "input", it),
        listen$3(L, "change", nt),
        listen$3(U, "change", ne),
        listen$3(q, "input", se),
        listen$3(ee, "change", ue),
        listen$3(he, "input", $e),
        listen$3(le, "change", Ae),
        listen$3(de, "input", je)
      ], Ze = !0);
    },
    p(ze, re) {
      if (a = ze, re[0] & /*moldata*/
      4) {
        Xe = ensure_array_like$3(
          /*moldata*/
          a[2]
        );
        let xe;
        for (xe = 0; xe < Xe.length; xe += 1) {
          const Le = get_each_context_1$1(a, Xe, xe);
          Ge[xe] ? Ge[xe].p(Le, re) : (Ge[xe] = create_each_block_1$1(Le), Ge[xe].c(), Ge[xe].m(n, null));
        }
        for (; xe < Ge.length; xe += 1)
          Ge[xe].d(1);
        Ge.length = Xe.length;
      }
      re[0] & /*representations*/
      2 && select_option(
        n,
        /*rep*/
        a[43].model
      ), re[0] & /*representations*/
      2 && b.value !== /*rep*/
      a[43].resname && set_input_value(
        b,
        /*rep*/
        a[43].resname
      ), re[0] & /*representations*/
      2 && _.value !== /*rep*/
      a[43].residue_range && set_input_value(
        _,
        /*rep*/
        a[43].residue_range
      ), re[0] & /*representations*/
      2 && select_option(
        L,
        /*rep*/
        a[43].style
      ), re[0] & /*representations*/
      2 && V !== (V = /*rep*/
      a[43].opacity) && (U.value = V), re[0] & /*representations*/
      2 && q.value !== /*rep*/
      a[43].opacity && set_input_value(
        q,
        /*rep*/
        a[43].opacity
      ), re[0] & /*representations*/
      2 && fe !== (fe = /*rep*/
      a[43].scale) && (ee.value = fe), re[0] & /*representations*/
      2 && he.value !== /*rep*/
      a[43].scale && set_input_value(
        he,
        /*rep*/
        a[43].scale
      ), re[0] & /*representations*/
      2 && Se !== (Se = /*rep*/
      a[43].around) && (le.value = Se), re[0] & /*representations*/
      2 && de.value !== /*rep*/
      a[43].around && set_input_value(
        de,
        /*rep*/
        a[43].around
      );
    },
    i(ze) {
      ze && (qe || add_render_callback(() => {
        qe = create_in_transition(e, fade, {}), qe.start();
      }));
    },
    o: noop$6,
    d(ze) {
      ze && detach$b(e), destroy_each$2(Ge, ze), Ze = !1, run_all$2(Ye);
    }
  };
}
function create_each_block_1$1(a) {
  let e, r = (
    /*mol*/
    a[46].name + ""
  ), n, s, h;
  return {
    c() {
      e = element$8("option"), n = text$5(r), s = text$5(" #"), h = text$5(
        /*i*/
        a[48]
      ), this.h();
    },
    l(b) {
      e = claim_element$8(b, "OPTION", { class: !0 });
      var g = children$8(e);
      n = claim_text$5(g, r), s = claim_text$5(g, " #"), h = claim_text$5(
        g,
        /*i*/
        a[48]
      ), g.forEach(detach$b), this.h();
    },
    h() {
      e.__value = /*i*/
      a[48], set_input_value(e, e.__value), attr$7(e, "class", "svelte-1skivl7");
    },
    m(b, g) {
      insert_hydration$b(b, e, g), append_hydration$7(e, n), append_hydration$7(e, s), append_hydration$7(e, h);
    },
    p(b, g) {
      g[0] & /*moldata*/
      4 && r !== (r = /*mol*/
      b[46].name + "") && set_data$4(n, r);
    },
    d(b) {
      b && detach$b(e);
    }
  };
}
function create_each_block$3(a) {
  let e, r, n, s, h, b, g, _, A, x, k, $, C, L = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" class="svelte-1skivl7"></path></svg>', y, o, v = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" class="svelte-1skivl7"></path></svg>', w, M, F;
  function m() {
    return (
      /*click_handler*/
      a[26](
        /*rep*/
        a[43],
        /*each_value*/
        a[44],
        /*index*/
        a[45]
      )
    );
  }
  function E() {
    return (
      /*click_handler_1*/
      a[27](
        /*index*/
        a[45]
      )
    );
  }
  function z() {
    return (
      /*click_handler_2*/
      a[28](
        /*rep*/
        a[43]
      )
    );
  }
  let O = (
    /*rep*/
    a[43].visible && create_if_block_1$8(a)
  );
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("div"), s = element$8("button"), h = svg_element$2("svg"), b = svg_element$2("path"), _ = space$8(), A = element$8("span"), x = text$5("Representation #"), k = text$5(
        /*index*/
        a[45]
      ), $ = space$8(), C = element$8("button"), C.innerHTML = L, y = space$8(), o = element$8("button"), o.innerHTML = v, w = space$8(), O && O.c(), this.h();
    },
    l(R) {
      e = claim_element$8(R, "DIV", { class: !0 });
      var B = children$8(e);
      r = claim_element$8(B, "DIV", { class: !0 });
      var P = children$8(r);
      n = claim_element$8(P, "DIV", { class: !0 });
      var W = children$8(n);
      s = claim_element$8(W, "BUTTON", { class: !0 });
      var U = children$8(s);
      h = claim_svg_element$2(U, "svg", {
        xmlns: !0,
        fill: !0,
        viewBox: !0,
        "stroke-width": !0,
        stroke: !0,
        class: !0
      });
      var V = children$8(h);
      b = claim_svg_element$2(V, "path", {
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        d: !0,
        class: !0
      }), children$8(b).forEach(detach$b), V.forEach(detach$b), _ = claim_space$8(U), A = claim_element$8(U, "SPAN", { class: !0 });
      var K = children$8(A);
      x = claim_text$5(K, "Representation #"), k = claim_text$5(
        K,
        /*index*/
        a[45]
      ), K.forEach(detach$b), U.forEach(detach$b), $ = claim_space$8(W), C = claim_element$8(W, "BUTTON", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(C) !== "svelte-1b0ur8n" && (C.innerHTML = L), y = claim_space$8(W), o = claim_element$8(W, "BUTTON", {
        title: !0,
        class: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(o) !== "svelte-jpslxx" && (o.innerHTML = v), W.forEach(detach$b), w = claim_space$8(P), O && O.l(P), P.forEach(detach$b), B.forEach(detach$b), this.h();
    },
    h() {
      attr$7(b, "stroke-linecap", "round"), attr$7(b, "stroke-linejoin", "round"), attr$7(b, "d", "M8.25 4.5l7.5 7.5-7.5 7.5"), attr$7(b, "class", "svelte-1skivl7"), attr$7(h, "xmlns", "http://www.w3.org/2000/svg"), attr$7(h, "fill", "none"), attr$7(h, "viewBox", "0 0 24 24"), attr$7(h, "stroke-width", "1.5"), attr$7(h, "stroke", "currentColor"), attr$7(h, "class", g = null_to_empty(
        /*rep*/
        a[43].visible ? "transform rotate-90 w-5 h-5 " : "w-5 h-5 "
      ) + " svelte-1skivl7"), attr$7(A, "class", "svelte-1skivl7"), attr$7(s, "class", "flex items-center space-x-2 svelte-1skivl7"), attr$7(C, "class", "svelte-1skivl7"), attr$7(o, "title", "zoom to selection"), attr$7(o, "class", "svelte-1skivl7"), attr$7(n, "class", "flex space-x-2 items-center cursor-pointer p-1 svelte-1skivl7"), attr$7(r, "class", " svelte-1skivl7"), attr$7(e, "class", "bg-white border-b border-t border-gray-200 py-4 px-2 svelte-1skivl7");
    },
    m(R, B) {
      insert_hydration$b(R, e, B), append_hydration$7(e, r), append_hydration$7(r, n), append_hydration$7(n, s), append_hydration$7(s, h), append_hydration$7(h, b), append_hydration$7(s, _), append_hydration$7(s, A), append_hydration$7(A, x), append_hydration$7(A, k), append_hydration$7(n, $), append_hydration$7(n, C), append_hydration$7(n, y), append_hydration$7(n, o), append_hydration$7(r, w), O && O.m(r, null), M || (F = [
        listen$3(s, "click", m),
        listen$3(C, "click", E),
        listen$3(o, "click", z)
      ], M = !0);
    },
    p(R, B) {
      a = R, B[0] & /*representations*/
      2 && g !== (g = null_to_empty(
        /*rep*/
        a[43].visible ? "transform rotate-90 w-5 h-5 " : "w-5 h-5 "
      ) + " svelte-1skivl7") && attr$7(h, "class", g), /*rep*/
      a[43].visible ? O ? (O.p(a, B), B[0] & /*representations*/
      2 && transition_in$8(O, 1)) : (O = create_if_block_1$8(a), O.c(), transition_in$8(O, 1), O.m(r, null)) : O && (O.d(1), O = null);
    },
    d(R) {
      R && detach$b(e), O && O.d(), M = !1, run_all$2(F);
    }
  };
}
function create_fragment$b(a) {
  let e, r, n, s, h, b = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25" class="svelte-1skivl7"></path></svg>', g, _, A = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 6a1.5 1.5 0 11-3 0m3 0a1.5 1.5 0 10-3 0M3.75 6H7.5m3 12h9.75m-9.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-3.75 0H7.5m9-6h3.75m-3.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-9.75 0h9.75" class="svelte-1skivl7"></path></svg>', x, k, $ = '<svg class="w-5 h-5 text-gray-500 hover:text-orange-600 cursor-pointer svelte-1skivl7" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.0281146,15 L12.5,15 C13.3284271,15 14,15.6715729 14,16.5 L14,20.5 C14,21.3284271 13.3284271,22 12.5,22 L10.5,22 C9.67157288,22 9,21.3284271 9,20.5 L9,16.5 C9,15.6715729 9.67157288,15 10.5,15 L11.0167145,15 C11.1492163,13.8570393 12.0552513,12.9352285 13.2239212,12.8053762 L18.6656473,12.20074 C19.4252963,12.1163346 20,11.4742382 20,10.7099144 L20,8.5 C20,7.67157288 19.3284271,7 18.5,7 C18.2238576,7 18,6.77614237 18,6.5 C18,6.22385763 18.2238576,6 18.5,6 C19.8807119,6 21,7.11928813 21,8.5 L21,10.7099144 C21,11.9837875 20.0421605,13.053948 18.7760788,13.1946238 L13.3343527,13.79926 C12.6731623,13.8727256 12.1520824,14.3686853 12.0281146,15 Z M10.5,16 C10.2238576,16 10,16.2238576 10,16.5 L10,20.5 C10,20.7761424 10.2238576,21 10.5,21 L12.5,21 C12.7761424,21 13,20.7761424 13,20.5 L13,16.5 C13,16.2238576 12.7761424,16 12.5,16 L10.5,16 Z M5.49996942,2.99995128 L16.5,2.99995128 C17.8807119,2.99995128 19,4.11923941 19,5.49995128 L19,7.5 C19,8.88071187 17.8807119,10 16.5,10 L5.49996942,10 C4.11925755,10 2.99996942,8.88071187 2.99996942,7.5 L2.99996942,5.49995128 C2.99996942,4.11923941 4.11925755,2.99995128 5.49996942,2.99995128 Z M5.49996942,3.99995128 C4.6715423,3.99995128 3.99996942,4.67152416 3.99996942,5.49995128 L3.99996942,7.5 C3.99996942,8.32842712 4.6715423,9 5.49996942,9 L16.5,9 C17.3284271,9 18,8.32842712 18,7.5 L18,5.49995128 C18,4.67152416 17.3284271,3.99995128 16.5,3.99995128 L5.49996942,3.99995128 Z" class="svelte-1skivl7"></path></svg>', C, L, y, o, v, w, M = '<svg class="w-4 h-4 text-gray-500 hover:text-orange-600 cursor-pointer fill-current svelte-1skivl7" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0" class="svelte-1skivl7"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" class="svelte-1skivl7"></g><g id="SVGRepo_iconCarrier" class="svelte-1skivl7"><path d="M12.6 7.6v3.9h-1.1v4.6h-3v-4.6H7.4V7.6c0-.3.3-.6.6-.6h4c.3 0 .6.3.6.6zM10 6.5c.7 0 1.3-.6 1.3-1.3 0-.7-.6-1.3-1.3-1.3-.7 0-1.3.6-1.3 1.3 0 .7.6 1.3 1.3 1.3zm9.6 3.5c0 2.7-.9 4.9-2.7 6.7-1.9 1.9-4.2 2.9-6.9 2.9-2.6 0-4.9-.9-6.8-2.8C1.3 14.9.4 12.7.4 10c0-2.6.9-4.9 2.8-6.8C5.1 1.3 7.3.4 10 .4s5 .9 6.8 2.8c1.9 1.8 2.8 4.1 2.8 6.8zm-1.7 0c0-2.2-.8-4-2.3-5.6C14 2.9 12.2 2.1 10 2.1c-2.2 0-4 .8-5.5 2.3C2.9 6 2.1 7.9 2.1 10c0 2.1.8 4 2.3 5.5s3.4 2.3 5.6 2.3c2.1 0 4-.8 5.6-2.4 1.5-1.4 2.3-3.2 2.3-5.4z" class="svelte-1skivl7"></path></g></svg>', F, m, E = "Cite 3dmol.js as Rego & Koes, doi:10/gb5g5n", z, O, R, B, P, W, U = (
    /*anyColorAlphaFold*/
    a[9] && create_if_block_9$1()
  ), V = (
    /*anyColorHydrophobic*/
    a[10] && create_if_block_8$1()
  ), K = create_if_block_6$1(a), q = (
    /*showOffCanvas*/
    a[6] && create_if_block_2$3(a)
  ), H = (
    /*showOffCanvasReps*/
    a[7] && create_if_block$9(a)
  );
  return {
    c() {
      e = element$8("div"), r = element$8("div"), n = element$8("div"), s = element$8("div"), h = element$8("button"), h.innerHTML = b, g = space$8(), _ = element$8("button"), _.innerHTML = A, x = space$8(), k = element$8("button"), k.innerHTML = $, C = space$8(), U && U.c(), L = space$8(), V && V.c(), y = space$8(), K && K.c(), o = space$8(), v = element$8("div"), w = element$8("button"), w.innerHTML = M, F = space$8(), m = element$8("span"), m.textContent = E, z = space$8(), O = element$8("div"), R = space$8(), q && q.c(), B = space$8(), H && H.c(), this.h();
    },
    l(j) {
      e = claim_element$8(j, "DIV", { class: !0 });
      var Q = children$8(e);
      r = claim_element$8(Q, "DIV", { class: !0 });
      var J = children$8(r);
      n = claim_element$8(J, "DIV", { class: !0 });
      var Y = children$8(n);
      s = claim_element$8(Y, "DIV", { class: !0 });
      var ee = children$8(s);
      h = claim_element$8(ee, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(h) !== "svelte-1awoxzz" && (h.innerHTML = b), g = claim_space$8(ee), _ = claim_element$8(ee, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(_) !== "svelte-18a3afg" && (_.innerHTML = A), x = claim_space$8(ee), k = claim_element$8(ee, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(k) !== "svelte-osiom6" && (k.innerHTML = $), ee.forEach(detach$b), C = claim_space$8(Y), U && U.l(Y), L = claim_space$8(Y), V && V.l(Y), y = claim_space$8(Y), K && K.l(Y), o = claim_space$8(Y), v = claim_element$8(Y, "DIV", { class: !0 });
      var fe = children$8(v);
      w = claim_element$8(fe, "BUTTON", {
        class: !0,
        title: !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$2(w) !== "svelte-1yqhmsc" && (w.innerHTML = M), F = claim_space$8(fe), m = claim_element$8(fe, "SPAN", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset$2(m) !== "svelte-yennc4" && (m.textContent = E), fe.forEach(detach$b), z = claim_space$8(Y), O = claim_element$8(Y, "DIV", { class: !0 }), children$8(O).forEach(detach$b), R = claim_space$8(Y), q && q.l(Y), B = claim_space$8(Y), H && H.l(Y), Y.forEach(detach$b), J.forEach(detach$b), Q.forEach(detach$b), this.h();
    },
    h() {
      attr$7(h, "class", "p-2 svelte-1skivl7"), attr$7(h, "title", "Reset View"), attr$7(_, "class", "p-2 svelte-1skivl7"), attr$7(_, "title", "Settings"), attr$7(k, "class", "p-2 svelte-1skivl7"), attr$7(k, "title", "Representations"), attr$7(s, "class", "absolute z-50 top-0 right-0 mr-2 flex flex-col divide-y border border-gray-200 mt-2 rounded items-center justify-center bg-white dark:bg-gray-800 svelte-1skivl7"), attr$7(w, "class", "p-1 svelte-1skivl7"), attr$7(w, "title", "How to cite 3Dmol.js"), attr$7(m, "class", "absolute -top-1 left-6 w-max rounded bg-gray-900 px-2 py-1 text-sm font-medium text-gray-50 opacity-0 shadow transition-opacity svelte-1skivl7"), toggle_class$7(
        m,
        "opacity-100",
        /*showCiteTooltip*/
        a[5]
      ), attr$7(v, "class", "absolute z-50 bottom-0 left-0 ml-2 flex divide-x mb-2 rounded items-center justify-center svelte-1skivl7"), attr$7(O, "class", "viewer w-full h-full z-10 svelte-1skivl7"), attr$7(n, "class", "gr-block gr-box relative w-full overflow-hidden svelte-1skivl7"), attr$7(r, "class", "overflow-hidden flex gap-px w-full h-full flex-wrap svelte-1skivl7"), attr$7(e, "class", "bg-white w-full minh svelte-1skivl7");
    },
    m(j, Q) {
      insert_hydration$b(j, e, Q), append_hydration$7(e, r), append_hydration$7(r, n), append_hydration$7(n, s), append_hydration$7(s, h), append_hydration$7(s, g), append_hydration$7(s, _), append_hydration$7(s, x), append_hydration$7(s, k), append_hydration$7(n, C), U && U.m(n, null), append_hydration$7(n, L), V && V.m(n, null), append_hydration$7(n, y), K && K.m(n, null), append_hydration$7(n, o), append_hydration$7(n, v), append_hydration$7(v, w), append_hydration$7(v, F), append_hydration$7(v, m), append_hydration$7(n, z), append_hydration$7(n, O), a[21](O), append_hydration$7(n, R), q && q.m(n, null), append_hydration$7(n, B), H && H.m(n, null), P || (W = [
        listen$3(
          h,
          "click",
          /*resetZoom*/
          a[17]
        ),
        listen$3(
          _,
          "click",
          /*toggleOffCanvas*/
          a[13]
        ),
        listen$3(
          k,
          "click",
          /*toggleOffCanvasReps*/
          a[14]
        ),
        listen$3(
          w,
          "click",
          /*toggleCiteTooltip*/
          a[12]
        )
      ], P = !0);
    },
    p(j, Q) {
      /*anyColorAlphaFold*/
      j[9] ? U || (U = create_if_block_9$1(), U.c(), U.m(n, L)) : U && (U.d(1), U = null), /*anyColorHydrophobic*/
      j[10] ? V || (V = create_if_block_8$1(), V.c(), V.m(n, y)) : V && (V.d(1), V = null), K.p(j, Q), Q[0] & /*showCiteTooltip*/
      32 && toggle_class$7(
        m,
        "opacity-100",
        /*showCiteTooltip*/
        j[5]
      ), /*showOffCanvas*/
      j[6] ? q ? q.p(j, Q) : (q = create_if_block_2$3(j), q.c(), q.m(n, B)) : q && (q.d(1), q = null), /*showOffCanvasReps*/
      j[7] ? H ? H.p(j, Q) : (H = create_if_block$9(j), H.c(), H.m(n, null)) : H && (H.d(1), H = null);
    },
    i: noop$6,
    o: noop$6,
    d(j) {
      j && detach$b(e), U && U.d(), V && V.d(), K && K.d(), a[21](null), q && q.d(), H && H.d(), P = !1, run_all$2(W);
    }
  };
}
function fade(a, { delay: e = 0, duration: r = 50 }) {
  const n = +getComputedStyle(a).opacity;
  return {
    delay: e,
    duration: r,
    css: (s) => `opacity: ${s * n}`
  };
}
function instance$c(a, e, r) {
  let n = mol, s, { confidenceLabel: h = null } = e, { moldata: b = null } = e, g = {
    backgroundColor: {
      type: "select",
      options: ["white", "black", "gray", "lightgray", "beige", "orange"]
    },
    orthographic: { type: "toggle" },
    disableFog: { type: "toggle" }
  }, { config: _ = {
    backgroundColor: "white",
    orthographic: !1,
    disableFog: !1
  } } = e, A = !0, x = !1;
  function k() {
    r(5, x = !x);
  }
  let { representations: $ = [] } = e, C = !1, L = !1;
  function y() {
    r(6, C = !C);
  }
  function o() {
    r(7, L = !L);
  }
  function v(be) {
    $.splice(be, 1), r(1, $);
  }
  function w() {
    $.push({
      model: 0,
      chain: "",
      resname: "",
      style: "cartoon",
      color: "grayCarbon",
      residue_range: "",
      around: 0,
      byres: !1,
      visible: !0,
      opacity: 1,
      scale: 1
    }), r(1, $);
  }
  let M = function(be) {
    return be.b < 0.1 ? "#0000FF" : be.b < 0.2 ? "#1E90FF" : be.b < 0.3 ? "#00CED1" : be.b < 0.4 ? "#7CFC00" : be.b < 0.5 ? "#ADFF2F" : be.b < 0.6 ? "#FFFF00" : be.b < 0.7 ? "#FFD700" : be.b < 0.8 ? "#FFA500" : be.b < 0.9 ? "#FF4500" : "#FF0000";
  }, F = function(be) {
    let le = {
      ILE: 4.5,
      VAL: 4.2,
      LEU: 3.8,
      PHE: 2.8,
      CYS: 2.5,
      MET: 1.9,
      ALA: 1.8,
      GLY: -0.4,
      THR: -0.7,
      SER: -0.8,
      TRP: -0.9,
      TYR: -1.3,
      PRO: -1.6,
      HIS: -3.2,
      GLU: -3.5,
      GLN: -3.5,
      ASP: -3.5,
      ASN: -3.5,
      LYS: -3.9,
      ARG: -4.5
    };
    if (be.resn in le) {
      const Se = le[be.resn], ge = -4.5, De = (Se - ge) / (4.5 - ge), Be = (Ve, qe, Ze) => {
        const Ye = parseInt(Ve.slice(1), 16), Xe = parseInt(qe.slice(1), 16), Ge = Math.round(((Xe >> 16) - (Ye >> 16)) * Ze + (Ye >> 16)), Ke = Math.round(((Xe >> 8 & 255) - (Ye >> 8 & 255)) * Ze + (Ye >> 8 & 255)), Pe = Math.round(((Xe & 255) - (Ye & 255)) * Ze + (Ye & 255));
        return `#${((1 << 24) + (Ge << 16) + (Ke << 8) + Pe).toString(16).slice(1)}`;
      };
      return De <= 0.5 ? Be("#008B8B", "#FFFFFF", De * 2) : Be("#FFFFFF", "#B8860B", (De - 0.5) * 2);
    } else
      return "#FFFFFF";
  }, m;
  function E(be) {
    if (be.type != null)
      m.zoomTo();
    else {
      let le = { model: be.model };
      be.chain !== "" && (le.chain = be.chain), be.residue_range !== "" && (le.resi = be.residue_range), be.resname !== "" && (le.resn = be.resname), m.zoomTo(le);
    }
  }
  function z(be) {
    m !== void 0 && (m.setStyle(), m.removeAllSurfaces(), be.forEach((le) => {
      let Se;
      le.color === "alphafold" ? Se = { colorfunc: M } : le.color === "hydrophobicity" ? Se = { colorfunc: F } : le.color == "spectrum" ? Se = { color: "spectrum" } : Se = { colorscheme: le.color }, Se.opacity = le.opacity;
      let ge = { model: le.model };
      if (le.chain !== "" && (ge.chain = le.chain), le.residue_range !== "" && (ge.resi = le.residue_range), le.resname !== "" && (ge.resn = le.resname), ge.byres = le.byres, le.around !== 0 && (ge.expand = le.around), le.sidechain && (ge = {
        and: [ge, { atom: ["N", "C", "O"], invert: !0 }]
      }), (le.style == "sphere" || le.style == "stick") && (Se.scale = le.scale), le.style === "surface")
        m.addSurface(n.SurfaceType.VDW, Se, ge);
      else
        try {
          m.getModel(ge.model) != null && m.addStyle(ge, { [le.style]: Se });
        } catch (de) {
          console.log(de);
        }
    }), m.render());
  }
  onMount$2(() => {
    console.log("MolecularViewer Mounted");
    let be = Object.assign(Object.assign({}, _), { cartoonQuality: 7 });
    r(20, m = n.createViewer(s, be));
    let le = [];
    $.forEach((Se) => {
      le.some((ge) => ge.model === Se.model && ge.chain === Se.chain && ge.resname === Se.resname && ge.style === Se.style && ge.color === Se.color && ge.residue_range === Se.residue_range && ge.around === Se.around && ge.byres === Se.byres && ge.sidechain === Se.sidechain && ge.scale == Se.scale) || le.push(Se);
    }), r(1, $ = le), b.length > 0 && b.forEach((Se) => {
      m.addModelsAsFrames(Se.data, Se.format, { keepH: !0, multiModel: !0 });
    }), m.addUnitCell(m.getModel(), {
      box: {
        color: "black",
        // Set color to black
        linewidth: 2,
        // Set line width
        hidden: !1
      }
    }), z($), m.zoomTo(), m.render(), m.zoom(0.9, 100), $.forEach((Se) => {
      Se.color === "alphafold" && r(9, R = !0), Se.color === "hydrophobicity" && r(10, B = !0);
    }), A && m.setHoverable(
      {},
      !0,
      function(Se, ge, de, De) {
        if (!Se.label) {
          let Be;
          R ? Be = Se.resn + ":" + Se.resi + ":" + Se.atom + " (" + h + " " + Se.b + ")" : Be = Se.resn + ":" + Se.resi + ":" + Se.atom, Se.label = ge.addLabel(Be, {
            position: Se,
            backgroundColor: "#ffffff",
            borderColor: "#dddddd",
            fontColor: "black"
          });
        }
      },
      function(Se, ge) {
        Se.label && (ge.removeLabel(Se.label), delete Se.label);
      }
    ), m.getNumFrames() > 1 && P();
  }), beforeUpdate(() => {
  });
  let O = !1, R = !1, B = !1;
  function P() {
    console.log(m.isAnimated()), O ? m.stopAnimate() : m.animate({ loop: "forward", reps: 0 }), r(8, O = !O);
  }
  function W(be) {
    binding_callbacks$3[be ? "unshift" : "push"](() => {
      s = be, r(3, s);
    });
  }
  function U(be) {
    _[be] = this.checked, r(0, _), r(11, g);
  }
  const V = (be) => {
    r(0, _[be] = event.target.value, _);
  };
  function K(be) {
    _[be] = select_value(this), r(0, _), r(11, g);
  }
  function q() {
    A = this.value, r(4, A);
  }
  const H = (be, le, Se) => r(1, le[Se].visible = !be.visible, $), j = (be) => v(be), Q = (be) => E(be);
  function J(be, le) {
    be[le].model = select_value(this), r(1, $);
  }
  function Y(be, le) {
    be[le].resname = this.value, r(1, $);
  }
  function ee(be, le) {
    be[le].residue_range = this.value, r(1, $);
  }
  function fe(be, le) {
    be[le].style = select_value(this), r(1, $);
  }
  const me = (be, le, Se, ge) => {
    r(1, le[Se].opacity = ge.target.value, $);
  };
  function he(be, le) {
    be[le].opacity = this.value, r(1, $);
  }
  const we = (be, le, Se, ge) => {
    r(1, le[Se].scale = ge.target.value, $);
  };
  function ye(be, le) {
    be[le].scale = this.value, r(1, $);
  }
  const ve = (be, le, Se, ge) => {
    r(1, le[Se].around = ge.target.value, $);
  };
  function ce(be, le) {
    be[le].around = this.value, r(1, $);
  }
  return a.$$set = (be) => {
    "confidenceLabel" in be && r(19, h = be.confidenceLabel), "moldata" in be && r(2, b = be.moldata), "config" in be && r(0, _ = be.config), "representations" in be && r(1, $ = be.representations);
  }, a.$$.update = () => {
    a.$$.dirty[0] & /*view, config*/
    1048577 && m != null && (m.setBackgroundColor(_.backgroundColor), m.enableFog(!_.disableFog), m.setCameraParameters({ orthographic: _.orthographic })), a.$$.dirty[0] & /*representations*/
    2 && z($), a.$$.dirty[0] & /*representations*/
    2 && (r(9, R = !1), $.forEach((be) => {
      be.color === "alphafold" && r(9, R = !0);
    })), a.$$.dirty[0] & /*representations*/
    2 && (r(10, B = !1), $.forEach((be) => {
      be.color === "hydrophobicity" && r(10, B = !0);
    }));
  }, [
    _,
    $,
    b,
    s,
    A,
    x,
    C,
    L,
    O,
    R,
    B,
    g,
    k,
    y,
    o,
    v,
    w,
    E,
    P,
    h,
    m,
    W,
    U,
    V,
    K,
    q,
    H,
    j,
    Q,
    J,
    Y,
    ee,
    fe,
    me,
    he,
    we,
    ye,
    ve,
    ce
  ];
}
class MolecularViewer extends SvelteComponent$c {
  constructor(e) {
    super(), init$c(
      this,
      e,
      instance$c,
      create_fragment$b,
      safe_not_equal$c,
      {
        confidenceLabel: 19,
        moldata: 2,
        config: 0,
        representations: 1
      },
      null,
      [-1, -1]
    );
  }
}
const {
  SvelteComponent: SvelteComponent$b,
  check_outros: check_outros$7,
  claim_component: claim_component$6,
  claim_space: claim_space$7,
  create_component: create_component$6,
  destroy_component: destroy_component$6,
  detach: detach$a,
  empty: empty$5,
  group_outros: group_outros$7,
  init: init$b,
  insert_hydration: insert_hydration$a,
  mount_component: mount_component$6,
  safe_not_equal: safe_not_equal$b,
  space: space$7,
  transition_in: transition_in$7,
  transition_out: transition_out$7
} = window.__gradio__svelte__internal;
function create_else_block$6(a) {
  let e, r;
  return e = new Empty({
    props: {
      unpadded_box: !0,
      size: "large",
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx: a }
    }
  }), {
    c() {
      create_component$6(e.$$.fragment);
    },
    l(n) {
      claim_component$6(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$6(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*$$scope*/
      2048 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in$7(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$7(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$6(e, n);
    }
  };
}
function create_if_block$8(a) {
  let e, r, n = (
    /*moldata*/
    a[6] != null && /*molviewer*/
    a[7] && create_if_block_1$7(a)
  );
  return {
    c() {
      n && n.c(), e = empty$5();
    },
    l(s) {
      n && n.l(s), e = empty$5();
    },
    m(s, h) {
      n && n.m(s, h), insert_hydration$a(s, e, h), r = !0;
    },
    p(s, h) {
      /*moldata*/
      s[6] != null && /*molviewer*/
      s[7] ? n ? (n.p(s, h), h & /*moldata, molviewer*/
      192 && transition_in$7(n, 1)) : (n = create_if_block_1$7(s), n.c(), transition_in$7(n, 1), n.m(e.parentNode, e)) : n && (group_outros$7(), transition_out$7(n, 1, 1, () => {
        n = null;
      }), check_outros$7());
    },
    i(s) {
      r || (transition_in$7(n), r = !0);
    },
    o(s) {
      transition_out$7(n), r = !1;
    },
    d(s) {
      s && detach$a(e), n && n.d(s);
    }
  };
}
function create_default_slot$4(a) {
  let e, r;
  return e = new File$1({}), {
    c() {
      create_component$6(e.$$.fragment);
    },
    l(n) {
      claim_component$6(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$6(e, n, s), r = !0;
    },
    i(n) {
      r || (transition_in$7(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$7(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$6(e, n);
    }
  };
}
function create_if_block_1$7(a) {
  let e, r;
  return e = new MolecularViewer({
    props: {
      moldata: (
        /*moldata*/
        a[6]
      ),
      config: (
        /*config*/
        a[3]
      ),
      confidenceLabel: (
        /*confidenceLabel*/
        a[4]
      ),
      representations: (
        /*representations*/
        a[5]
      )
    }
  }), {
    c() {
      create_component$6(e.$$.fragment);
    },
    l(n) {
      claim_component$6(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$6(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*moldata*/
      64 && (h.moldata = /*moldata*/
      n[6]), s & /*config*/
      8 && (h.config = /*config*/
      n[3]), s & /*confidenceLabel*/
      16 && (h.confidenceLabel = /*confidenceLabel*/
      n[4]), s & /*representations*/
      32 && (h.representations = /*representations*/
      n[5]), e.$set(h);
    },
    i(n) {
      r || (transition_in$7(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$7(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$6(e, n);
    }
  };
}
function create_fragment$a(a) {
  let e, r, n, s, h, b, g;
  e = new BlockLabel({
    props: {
      show_label: (
        /*show_label*/
        a[2]
      ),
      float: (
        /*value*/
        a[0] === null
      ),
      Icon: File$1,
      label: (
        /*label*/
        a[1] || "File"
      )
    }
  });
  const _ = [create_if_block$8, create_else_block$6], A = [];
  function x(k, $) {
    return $ & /*value*/
    1 && (n = null), n == null && (n = !!/*value*/
    (k[0] && (!Array.isArray(
      /*value*/
      k[0]
    ) || /*value*/
    k[0].length > 0))), n ? 0 : 1;
  }
  return s = x(a, -1), h = A[s] = _[s](a), {
    c() {
      create_component$6(e.$$.fragment), r = space$7(), h.c(), b = empty$5();
    },
    l(k) {
      claim_component$6(e.$$.fragment, k), r = claim_space$7(k), h.l(k), b = empty$5();
    },
    m(k, $) {
      mount_component$6(e, k, $), insert_hydration$a(k, r, $), A[s].m(k, $), insert_hydration$a(k, b, $), g = !0;
    },
    p(k, [$]) {
      const C = {};
      $ & /*show_label*/
      4 && (C.show_label = /*show_label*/
      k[2]), $ & /*value*/
      1 && (C.float = /*value*/
      k[0] === null), $ & /*label*/
      2 && (C.label = /*label*/
      k[1] || "File"), e.$set(C);
      let L = s;
      s = x(k, $), s === L ? A[s].p(k, $) : (group_outros$7(), transition_out$7(A[L], 1, 1, () => {
        A[L] = null;
      }), check_outros$7(), h = A[s], h ? h.p(k, $) : (h = A[s] = _[s](k), h.c()), transition_in$7(h, 1), h.m(b.parentNode, b));
    },
    i(k) {
      g || (transition_in$7(e.$$.fragment, k), transition_in$7(h), g = !0);
    },
    o(k) {
      transition_out$7(e.$$.fragment, k), transition_out$7(h), g = !1;
    },
    d(k) {
      k && (detach$a(r), detach$a(b)), destroy_component$6(e, k), A[s].d(k);
    }
  };
}
function instance$b(a, e, r) {
  let { value: n = null } = e, { label: s } = e, { show_label: h = !0 } = e, { selectable: b = !1 } = e, { height: g = void 0 } = e, { i18n: _ } = e, { config: A = {} } = e, { confidenceLabel: x = "" } = e, { representations: k = [] } = e, { moldata: $ = null } = e, { molviewer: C = !1 } = e;
  return a.$$set = (L) => {
    "value" in L && r(0, n = L.value), "label" in L && r(1, s = L.label), "show_label" in L && r(2, h = L.show_label), "selectable" in L && r(8, b = L.selectable), "height" in L && r(9, g = L.height), "i18n" in L && r(10, _ = L.i18n), "config" in L && r(3, A = L.config), "confidenceLabel" in L && r(4, x = L.confidenceLabel), "representations" in L && r(5, k = L.representations), "moldata" in L && r(6, $ = L.moldata), "molviewer" in L && r(7, C = L.molviewer);
  }, [
    n,
    s,
    h,
    A,
    x,
    k,
    $,
    C,
    b,
    g,
    _
  ];
}
class File_1 extends SvelteComponent$b {
  constructor(e) {
    super(), init$b(this, e, instance$b, create_fragment$a, safe_not_equal$b, {
      value: 0,
      label: 1,
      show_label: 2,
      selectable: 8,
      height: 9,
      i18n: 10,
      config: 3,
      confidenceLabel: 4,
      representations: 5,
      moldata: 6,
      molviewer: 7
    });
  }
}
new Intl.Collator(0, { numeric: 1 }).compare;
async function prepare_files(a, e) {
  return a.map(
    (r) => new FileData({
      path: r.name,
      orig_name: r.name,
      blob: r,
      size: r.size,
      mime_type: r.type,
      is_stream: e
    })
  );
}
class FileData {
  constructor({
    path: e,
    url: r,
    orig_name: n,
    size: s,
    blob: h,
    is_stream: b,
    mime_type: g,
    alt_text: _,
    b64: A
  }) {
    this.meta = { _type: "gradio.FileData" }, this.path = e, this.url = r, this.orig_name = n, this.size = s, this.blob = r ? void 0 : h, this.is_stream = b, this.mime_type = g, this.alt_text = _, this.b64 = A;
  }
}
typeof process < "u" && process.versions && process.versions.node;
class TextLineStream extends TransformStream {
  #e = "";
  /** Constructs a new instance. */
  constructor(e = { allowCR: !1 }) {
    super({
      transform: (r, n) => {
        for (r = this.#e + r; ; ) {
          const s = r.indexOf(`
`), h = e.allowCR ? r.indexOf("\r") : -1;
          if (h !== -1 && h !== r.length - 1 && (s === -1 || s - 1 > h)) {
            n.enqueue(r.slice(0, h)), r = r.slice(h + 1);
            continue;
          }
          if (s === -1)
            break;
          const b = r[s - 1] === "\r" ? s - 1 : s;
          n.enqueue(r.slice(0, b)), r = r.slice(s + 1);
        }
        this.#e = r;
      },
      flush: (r) => {
        if (this.#e === "")
          return;
        const n = e.allowCR && this.#e.endsWith("\r") ? this.#e.slice(0, -1) : this.#e;
        r.enqueue(n);
      }
    });
  }
}
const {
  SvelteComponent: SvelteComponent$a,
  append_hydration: append_hydration$6,
  attr: attr$6,
  children: children$7,
  claim_element: claim_element$7,
  claim_space: claim_space$6,
  claim_text: claim_text$4,
  detach: detach$9,
  element: element$7,
  init: init$a,
  insert_hydration: insert_hydration$9,
  noop: noop$5,
  safe_not_equal: safe_not_equal$a,
  set_data: set_data$3,
  set_style: set_style$5,
  space: space$6,
  text: text$4,
  toggle_class: toggle_class$6
} = window.__gradio__svelte__internal, { onMount: onMount$1, createEventDispatcher: createEventDispatcher$7, onDestroy: onDestroy$1 } = window.__gradio__svelte__internal;
function create_if_block$7(a) {
  let e, r, n, s, h = getProgress(
    /*file_to_display*/
    a[2]
  ) + "", b, g, _, A, x = (
    /*file_to_display*/
    a[2].orig_name + ""
  ), k;
  return {
    c() {
      e = element$7("div"), r = element$7("span"), n = element$7("div"), s = element$7("progress"), b = text$4(h), _ = space$6(), A = element$7("span"), k = text$4(x), this.h();
    },
    l($) {
      e = claim_element$7($, "DIV", { class: !0 });
      var C = children$7(e);
      r = claim_element$7(C, "SPAN", {});
      var L = children$7(r);
      n = claim_element$7(L, "DIV", { class: !0 });
      var y = children$7(n);
      s = claim_element$7(y, "PROGRESS", { style: !0, max: !0, class: !0 });
      var o = children$7(s);
      b = claim_text$4(o, h), o.forEach(detach$9), y.forEach(detach$9), L.forEach(detach$9), _ = claim_space$6(C), A = claim_element$7(C, "SPAN", { class: !0 });
      var v = children$7(A);
      k = claim_text$4(v, x), v.forEach(detach$9), C.forEach(detach$9), this.h();
    },
    h() {
      set_style$5(s, "visibility", "hidden"), set_style$5(s, "height", "0"), set_style$5(s, "width", "0"), s.value = g = getProgress(
        /*file_to_display*/
        a[2]
      ), attr$6(s, "max", "100"), attr$6(s, "class", "svelte-cr2edf"), attr$6(n, "class", "progress-bar svelte-cr2edf"), attr$6(A, "class", "file-name svelte-cr2edf"), attr$6(e, "class", "file svelte-cr2edf");
    },
    m($, C) {
      insert_hydration$9($, e, C), append_hydration$6(e, r), append_hydration$6(r, n), append_hydration$6(n, s), append_hydration$6(s, b), append_hydration$6(e, _), append_hydration$6(e, A), append_hydration$6(A, k);
    },
    p($, C) {
      C & /*file_to_display*/
      4 && h !== (h = getProgress(
        /*file_to_display*/
        $[2]
      ) + "") && set_data$3(b, h), C & /*file_to_display*/
      4 && g !== (g = getProgress(
        /*file_to_display*/
        $[2]
      )) && (s.value = g), C & /*file_to_display*/
      4 && x !== (x = /*file_to_display*/
      $[2].orig_name + "") && set_data$3(k, x);
    },
    d($) {
      $ && detach$9(e);
    }
  };
}
function create_fragment$9(a) {
  let e, r, n, s = (
    /*files_with_progress*/
    a[0].length + ""
  ), h, b, g = (
    /*files_with_progress*/
    a[0].length > 1 ? "files" : "file"
  ), _, A, x, k = (
    /*file_to_display*/
    a[2] && create_if_block$7(a)
  );
  return {
    c() {
      e = element$7("div"), r = element$7("span"), n = text$4("Uploading "), h = text$4(s), b = space$6(), _ = text$4(g), A = text$4("..."), x = space$6(), k && k.c(), this.h();
    },
    l($) {
      e = claim_element$7($, "DIV", { class: !0 });
      var C = children$7(e);
      r = claim_element$7(C, "SPAN", { class: !0 });
      var L = children$7(r);
      n = claim_text$4(L, "Uploading "), h = claim_text$4(L, s), b = claim_space$6(L), _ = claim_text$4(L, g), A = claim_text$4(L, "..."), L.forEach(detach$9), x = claim_space$6(C), k && k.l(C), C.forEach(detach$9), this.h();
    },
    h() {
      attr$6(r, "class", "uploading svelte-cr2edf"), attr$6(e, "class", "wrap svelte-cr2edf"), toggle_class$6(
        e,
        "progress",
        /*progress*/
        a[1]
      );
    },
    m($, C) {
      insert_hydration$9($, e, C), append_hydration$6(e, r), append_hydration$6(r, n), append_hydration$6(r, h), append_hydration$6(r, b), append_hydration$6(r, _), append_hydration$6(r, A), append_hydration$6(e, x), k && k.m(e, null);
    },
    p($, [C]) {
      C & /*files_with_progress*/
      1 && s !== (s = /*files_with_progress*/
      $[0].length + "") && set_data$3(h, s), C & /*files_with_progress*/
      1 && g !== (g = /*files_with_progress*/
      $[0].length > 1 ? "files" : "file") && set_data$3(_, g), /*file_to_display*/
      $[2] ? k ? k.p($, C) : (k = create_if_block$7($), k.c(), k.m(e, null)) : k && (k.d(1), k = null), C & /*progress*/
      2 && toggle_class$6(
        e,
        "progress",
        /*progress*/
        $[1]
      );
    },
    i: noop$5,
    o: noop$5,
    d($) {
      $ && detach$9(e), k && k.d();
    }
  };
}
function getProgress(a) {
  return a.progress * 100 / (a.size || 0) || 0;
}
function calculateTotalProgress(a) {
  let e = 0;
  return a.forEach((r) => {
    e += getProgress(r);
  }), document.documentElement.style.setProperty("--upload-progress-width", (e / a.length).toFixed(2) + "%"), e / a.length;
}
function instance$a(a, e, r) {
  var n = this && this.__awaiter || function(y, o, v, w) {
    function M(F) {
      return F instanceof v ? F : new v(function(m) {
        m(F);
      });
    }
    return new (v || (v = Promise))(function(F, m) {
      function E(R) {
        try {
          O(w.next(R));
        } catch (B) {
          m(B);
        }
      }
      function z(R) {
        try {
          O(w.throw(R));
        } catch (B) {
          m(B);
        }
      }
      function O(R) {
        R.done ? F(R.value) : M(R.value).then(E, z);
      }
      O((w = w.apply(y, o || [])).next());
    });
  };
  let { upload_id: s } = e, { root: h } = e, { files: b } = e, { stream_handler: g } = e, _, A = !1, x, k, $ = b.map((y) => Object.assign(Object.assign({}, y), { progress: 0 }));
  const C = createEventDispatcher$7();
  function L(y, o) {
    r(0, $ = $.map((v) => (v.orig_name === y && (v.progress += o), v)));
  }
  return onMount$1(() => n(void 0, void 0, void 0, function* () {
    if (_ = yield g(new URL(`${h}/gradio_api/upload_progress?upload_id=${s}`)), _ == null)
      throw new Error("Event source is not defined");
    _.onmessage = function(y) {
      return n(this, void 0, void 0, function* () {
        const o = JSON.parse(y.data);
        A || r(1, A = !0), o.msg === "done" ? (_?.close(), C("done")) : (r(7, x = o), L(o.orig_name, o.chunk_size));
      });
    };
  })), onDestroy$1(() => {
    (_ != null || _ != null) && _.close();
  }), a.$$set = (y) => {
    "upload_id" in y && r(3, s = y.upload_id), "root" in y && r(4, h = y.root), "files" in y && r(5, b = y.files), "stream_handler" in y && r(6, g = y.stream_handler);
  }, a.$$.update = () => {
    a.$$.dirty & /*files_with_progress*/
    1 && calculateTotalProgress($), a.$$.dirty & /*current_file_upload, files_with_progress*/
    129 && r(2, k = x || $[0]);
  }, [
    $,
    A,
    k,
    s,
    h,
    b,
    g,
    x
  ];
}
class UploadProgress extends SvelteComponent$a {
  constructor(e) {
    super(), init$a(this, e, instance$a, create_fragment$9, safe_not_equal$a, {
      upload_id: 3,
      root: 4,
      files: 5,
      stream_handler: 6
    });
  }
}
const {
  SvelteComponent: SvelteComponent$9,
  append_hydration: append_hydration$5,
  attr: attr$5,
  binding_callbacks: binding_callbacks$2,
  bubble: bubble$1,
  check_outros: check_outros$6,
  children: children$6,
  claim_component: claim_component$5,
  claim_element: claim_element$6,
  claim_space: claim_space$5,
  create_component: create_component$5,
  create_slot: create_slot$4,
  destroy_component: destroy_component$5,
  detach: detach$8,
  element: element$6,
  empty: empty$4,
  get_all_dirty_from_scope: get_all_dirty_from_scope$4,
  get_slot_changes: get_slot_changes$4,
  group_outros: group_outros$6,
  init: init$9,
  insert_hydration: insert_hydration$8,
  listen: listen$2,
  mount_component: mount_component$5,
  prevent_default: prevent_default$1,
  run_all: run_all$1,
  safe_not_equal: safe_not_equal$9,
  set_style: set_style$4,
  space: space$5,
  stop_propagation,
  toggle_class: toggle_class$5,
  transition_in: transition_in$6,
  transition_out: transition_out$6,
  update_slot_base: update_slot_base$4
} = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$6, tick: tick$3 } = window.__gradio__svelte__internal;
function create_else_block$5(a) {
  let e, r, n, s, h, b, g, _, A, x, k;
  const $ = (
    /*#slots*/
    a[27].default
  ), C = create_slot$4(
    $,
    a,
    /*$$scope*/
    a[26],
    null
  );
  return {
    c() {
      e = element$6("button"), C && C.c(), r = space$5(), n = element$6("input"), this.h();
    },
    l(L) {
      e = claim_element$6(L, "BUTTON", { tabindex: !0, class: !0 });
      var y = children$6(e);
      C && C.l(y), r = claim_space$5(y), n = claim_element$6(y, "INPUT", {
        "aria-label": !0,
        "data-testid": !0,
        type: !0,
        accept: !0,
        webkitdirectory: !0,
        mozdirectory: !0,
        class: !0
      }), y.forEach(detach$8), this.h();
    },
    h() {
      attr$5(n, "aria-label", "file upload"), attr$5(n, "data-testid", "file-upload"), attr$5(n, "type", "file"), attr$5(n, "accept", s = /*accept_file_types*/
      a[16] || void 0), n.multiple = h = /*file_count*/
      a[6] === "multiple" || void 0, attr$5(n, "webkitdirectory", b = /*file_count*/
      a[6] === "directory" || void 0), attr$5(n, "mozdirectory", g = /*file_count*/
      a[6] === "directory" || void 0), attr$5(n, "class", "svelte-1mceliw"), attr$5(e, "tabindex", _ = /*hidden*/
      a[9] ? -1 : 0), attr$5(e, "class", "svelte-1mceliw"), toggle_class$5(
        e,
        "hidden",
        /*hidden*/
        a[9]
      ), toggle_class$5(
        e,
        "center",
        /*center*/
        a[4]
      ), toggle_class$5(
        e,
        "boundedheight",
        /*boundedheight*/
        a[3]
      ), toggle_class$5(
        e,
        "flex",
        /*flex*/
        a[5]
      ), toggle_class$5(
        e,
        "disable_click",
        /*disable_click*/
        a[7]
      ), set_style$4(e, "height", "100%");
    },
    m(L, y) {
      insert_hydration$8(L, e, y), C && C.m(e, null), append_hydration$5(e, r), append_hydration$5(e, n), a[35](n), A = !0, x || (k = [
        listen$2(
          n,
          "change",
          /*load_files_from_upload*/
          a[18]
        ),
        listen$2(e, "drag", stop_propagation(prevent_default$1(
          /*drag_handler*/
          a[28]
        ))),
        listen$2(e, "dragstart", stop_propagation(prevent_default$1(
          /*dragstart_handler*/
          a[29]
        ))),
        listen$2(e, "dragend", stop_propagation(prevent_default$1(
          /*dragend_handler*/
          a[30]
        ))),
        listen$2(e, "dragover", stop_propagation(prevent_default$1(
          /*dragover_handler*/
          a[31]
        ))),
        listen$2(e, "dragenter", stop_propagation(prevent_default$1(
          /*dragenter_handler*/
          a[32]
        ))),
        listen$2(e, "dragleave", stop_propagation(prevent_default$1(
          /*dragleave_handler*/
          a[33]
        ))),
        listen$2(e, "drop", stop_propagation(prevent_default$1(
          /*drop_handler*/
          a[34]
        ))),
        listen$2(
          e,
          "click",
          /*open_file_upload*/
          a[13]
        ),
        listen$2(
          e,
          "drop",
          /*loadFilesFromDrop*/
          a[19]
        ),
        listen$2(
          e,
          "dragenter",
          /*updateDragging*/
          a[17]
        ),
        listen$2(
          e,
          "dragleave",
          /*updateDragging*/
          a[17]
        )
      ], x = !0);
    },
    p(L, y) {
      C && C.p && (!A || y[0] & /*$$scope*/
      67108864) && update_slot_base$4(
        C,
        $,
        L,
        /*$$scope*/
        L[26],
        A ? get_slot_changes$4(
          $,
          /*$$scope*/
          L[26],
          y,
          null
        ) : get_all_dirty_from_scope$4(
          /*$$scope*/
          L[26]
        ),
        null
      ), (!A || y[0] & /*accept_file_types*/
      65536 && s !== (s = /*accept_file_types*/
      L[16] || void 0)) && attr$5(n, "accept", s), (!A || y[0] & /*file_count*/
      64 && h !== (h = /*file_count*/
      L[6] === "multiple" || void 0)) && (n.multiple = h), (!A || y[0] & /*file_count*/
      64 && b !== (b = /*file_count*/
      L[6] === "directory" || void 0)) && attr$5(n, "webkitdirectory", b), (!A || y[0] & /*file_count*/
      64 && g !== (g = /*file_count*/
      L[6] === "directory" || void 0)) && attr$5(n, "mozdirectory", g), (!A || y[0] & /*hidden*/
      512 && _ !== (_ = /*hidden*/
      L[9] ? -1 : 0)) && attr$5(e, "tabindex", _), (!A || y[0] & /*hidden*/
      512) && toggle_class$5(
        e,
        "hidden",
        /*hidden*/
        L[9]
      ), (!A || y[0] & /*center*/
      16) && toggle_class$5(
        e,
        "center",
        /*center*/
        L[4]
      ), (!A || y[0] & /*boundedheight*/
      8) && toggle_class$5(
        e,
        "boundedheight",
        /*boundedheight*/
        L[3]
      ), (!A || y[0] & /*flex*/
      32) && toggle_class$5(
        e,
        "flex",
        /*flex*/
        L[5]
      ), (!A || y[0] & /*disable_click*/
      128) && toggle_class$5(
        e,
        "disable_click",
        /*disable_click*/
        L[7]
      );
    },
    i(L) {
      A || (transition_in$6(C, L), A = !0);
    },
    o(L) {
      transition_out$6(C, L), A = !1;
    },
    d(L) {
      L && detach$8(e), C && C.d(L), a[35](null), x = !1, run_all$1(k);
    }
  };
}
function create_if_block_1$6(a) {
  let e, r, n = !/*hidden*/
  a[9] && create_if_block_2$2(a);
  return {
    c() {
      n && n.c(), e = empty$4();
    },
    l(s) {
      n && n.l(s), e = empty$4();
    },
    m(s, h) {
      n && n.m(s, h), insert_hydration$8(s, e, h), r = !0;
    },
    p(s, h) {
      /*hidden*/
      s[9] ? n && (group_outros$6(), transition_out$6(n, 1, 1, () => {
        n = null;
      }), check_outros$6()) : n ? (n.p(s, h), h[0] & /*hidden*/
      512 && transition_in$6(n, 1)) : (n = create_if_block_2$2(s), n.c(), transition_in$6(n, 1), n.m(e.parentNode, e));
    },
    i(s) {
      r || (transition_in$6(n), r = !0);
    },
    o(s) {
      transition_out$6(n), r = !1;
    },
    d(s) {
      s && detach$8(e), n && n.d(s);
    }
  };
}
function create_if_block$6(a) {
  let e, r, n, s, h;
  const b = (
    /*#slots*/
    a[27].default
  ), g = create_slot$4(
    b,
    a,
    /*$$scope*/
    a[26],
    null
  );
  return {
    c() {
      e = element$6("button"), g && g.c(), this.h();
    },
    l(_) {
      e = claim_element$6(_, "BUTTON", { tabindex: !0, class: !0 });
      var A = children$6(e);
      g && g.l(A), A.forEach(detach$8), this.h();
    },
    h() {
      attr$5(e, "tabindex", r = /*hidden*/
      a[9] ? -1 : 0), attr$5(e, "class", "svelte-1mceliw"), toggle_class$5(
        e,
        "hidden",
        /*hidden*/
        a[9]
      ), toggle_class$5(
        e,
        "center",
        /*center*/
        a[4]
      ), toggle_class$5(
        e,
        "boundedheight",
        /*boundedheight*/
        a[3]
      ), toggle_class$5(
        e,
        "flex",
        /*flex*/
        a[5]
      ), set_style$4(e, "height", "100%");
    },
    m(_, A) {
      insert_hydration$8(_, e, A), g && g.m(e, null), n = !0, s || (h = listen$2(
        e,
        "click",
        /*paste_clipboard*/
        a[12]
      ), s = !0);
    },
    p(_, A) {
      g && g.p && (!n || A[0] & /*$$scope*/
      67108864) && update_slot_base$4(
        g,
        b,
        _,
        /*$$scope*/
        _[26],
        n ? get_slot_changes$4(
          b,
          /*$$scope*/
          _[26],
          A,
          null
        ) : get_all_dirty_from_scope$4(
          /*$$scope*/
          _[26]
        ),
        null
      ), (!n || A[0] & /*hidden*/
      512 && r !== (r = /*hidden*/
      _[9] ? -1 : 0)) && attr$5(e, "tabindex", r), (!n || A[0] & /*hidden*/
      512) && toggle_class$5(
        e,
        "hidden",
        /*hidden*/
        _[9]
      ), (!n || A[0] & /*center*/
      16) && toggle_class$5(
        e,
        "center",
        /*center*/
        _[4]
      ), (!n || A[0] & /*boundedheight*/
      8) && toggle_class$5(
        e,
        "boundedheight",
        /*boundedheight*/
        _[3]
      ), (!n || A[0] & /*flex*/
      32) && toggle_class$5(
        e,
        "flex",
        /*flex*/
        _[5]
      );
    },
    i(_) {
      n || (transition_in$6(g, _), n = !0);
    },
    o(_) {
      transition_out$6(g, _), n = !1;
    },
    d(_) {
      _ && detach$8(e), g && g.d(_), s = !1, h();
    }
  };
}
function create_if_block_2$2(a) {
  let e, r;
  return e = new UploadProgress({
    props: {
      root: (
        /*root*/
        a[8]
      ),
      upload_id: (
        /*upload_id*/
        a[14]
      ),
      files: (
        /*file_data*/
        a[15]
      ),
      stream_handler: (
        /*stream_handler*/
        a[11]
      )
    }
  }), {
    c() {
      create_component$5(e.$$.fragment);
    },
    l(n) {
      claim_component$5(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$5(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*root*/
      256 && (h.root = /*root*/
      n[8]), s[0] & /*upload_id*/
      16384 && (h.upload_id = /*upload_id*/
      n[14]), s[0] & /*file_data*/
      32768 && (h.files = /*file_data*/
      n[15]), s[0] & /*stream_handler*/
      2048 && (h.stream_handler = /*stream_handler*/
      n[11]), e.$set(h);
    },
    i(n) {
      r || (transition_in$6(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$6(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$5(e, n);
    }
  };
}
function create_fragment$8(a) {
  let e, r, n, s;
  const h = [create_if_block$6, create_if_block_1$6, create_else_block$5], b = [];
  function g(_, A) {
    return (
      /*filetype*/
      _[0] === "clipboard" ? 0 : (
        /*uploading*/
        _[1] && /*show_progress*/
        _[10] ? 1 : 2
      )
    );
  }
  return e = g(a), r = b[e] = h[e](a), {
    c() {
      r.c(), n = empty$4();
    },
    l(_) {
      r.l(_), n = empty$4();
    },
    m(_, A) {
      b[e].m(_, A), insert_hydration$8(_, n, A), s = !0;
    },
    p(_, A) {
      let x = e;
      e = g(_), e === x ? b[e].p(_, A) : (group_outros$6(), transition_out$6(b[x], 1, 1, () => {
        b[x] = null;
      }), check_outros$6(), r = b[e], r ? r.p(_, A) : (r = b[e] = h[e](_), r.c()), transition_in$6(r, 1), r.m(n.parentNode, n));
    },
    i(_) {
      s || (transition_in$6(r), s = !0);
    },
    o(_) {
      transition_out$6(r), s = !1;
    },
    d(_) {
      _ && detach$8(n), b[e].d(_);
    }
  };
}
function is_valid_mimetype(a, e, r) {
  if (!a || a === "*" || a === "file/*" || Array.isArray(a) && a.some((s) => s === "*" || s === "file/*"))
    return !0;
  let n;
  if (typeof a == "string")
    n = a.split(",").map((s) => s.trim());
  else if (Array.isArray(a))
    n = a;
  else
    return !1;
  return n.includes(e) || n.some((s) => {
    const [h] = s.split("/").map((b) => b.trim());
    return s.endsWith("/*") && r.startsWith(h + "/");
  });
}
function instance$9(a, e, r) {
  let n, { $$slots: s = {}, $$scope: h } = e;
  var b = this && this.__awaiter || function(le, Se, ge, de) {
    function De(Be) {
      return Be instanceof ge ? Be : new ge(function(Ve) {
        Ve(Be);
      });
    }
    return new (ge || (ge = Promise))(function(Be, Ve) {
      function qe(Xe) {
        try {
          Ye(de.next(Xe));
        } catch (Ge) {
          Ve(Ge);
        }
      }
      function Ze(Xe) {
        try {
          Ye(de.throw(Xe));
        } catch (Ge) {
          Ve(Ge);
        }
      }
      function Ye(Xe) {
        Xe.done ? Be(Xe.value) : De(Xe.value).then(qe, Ze);
      }
      Ye((de = de.apply(le, Se || [])).next());
    });
  };
  let { filetype: g = null } = e, { dragging: _ = !1 } = e, { boundedheight: A = !0 } = e, { center: x = !0 } = e, { flex: k = !0 } = e, { file_count: $ = "single" } = e, { disable_click: C = !1 } = e, { root: L } = e, { hidden: y = !1 } = e, { format: o = "file" } = e, { uploading: v = !1 } = e, { hidden_upload: w = null } = e, { show_progress: M = !0 } = e, { max_file_size: F = null } = e, { upload: m } = e, { stream_handler: E } = e, z, O, R, B = null;
  const P = () => {
    if (typeof navigator < "u") {
      const le = navigator.userAgent.toLowerCase();
      return le.indexOf("iphone") > -1 || le.indexOf("ipad") > -1;
    }
    return !1;
  }, W = createEventDispatcher$6(), U = ["image", "video", "audio", "text", "file"], V = (le) => n && le.startsWith(".") ? (B = !0, le) : n && le.includes("file/*") ? "*" : le.startsWith(".") || le.endsWith("/*") ? le : U.includes(le) ? le + "/*" : "." + le;
  function K() {
    r(20, _ = !_);
  }
  function q() {
    navigator.clipboard.read().then((le) => b(this, void 0, void 0, function* () {
      for (let Se = 0; Se < le.length; Se++) {
        const ge = le[Se].types.find((de) => de.startsWith("image/"));
        if (ge) {
          le[Se].getType(ge).then((de) => b(this, void 0, void 0, function* () {
            const De = new File([de], `clipboard.${ge.replace("image/", "")}`);
            yield Q([De]);
          }));
          break;
        }
      }
    }));
  }
  function H() {
    C || w && (r(2, w.value = "", w), w.click());
  }
  function j(le) {
    return b(this, void 0, void 0, function* () {
      yield tick$3(), r(14, z = Math.random().toString(36).substring(2, 15)), r(1, v = !0);
      try {
        const Se = yield m(le, L, z, F ?? 1 / 0);
        return W("load", $ === "single" ? Se?.[0] : Se), r(1, v = !1), Se || [];
      } catch (Se) {
        return W("error", Se.message), r(1, v = !1), [];
      }
    });
  }
  function Q(le) {
    return b(this, void 0, void 0, function* () {
      if (!le.length)
        return;
      let Se = le.map((ge) => new File([ge], ge instanceof File ? ge.name : "file", { type: ge.type }));
      return n && B && (Se = Se.filter((ge) => J(ge) ? !0 : (W("error", `Invalid file type: ${ge.name}. Only ${g} allowed.`), !1)), Se.length === 0) ? [] : (r(15, O = yield prepare_files(Se)), yield j(O));
    });
  }
  function J(le) {
    return g ? (Array.isArray(g) ? g : [g]).some((ge) => {
      const de = V(ge);
      if (de.startsWith("."))
        return le.name.toLowerCase().endsWith(de.toLowerCase());
      if (de === "*")
        return !0;
      if (de.endsWith("/*")) {
        const [De] = de.split("/");
        return le.type.startsWith(De + "/");
      }
      return le.type === de;
    }) : !0;
  }
  function Y(le) {
    return b(this, void 0, void 0, function* () {
      const Se = le.target;
      if (Se.files)
        if (o != "blob")
          yield Q(Array.from(Se.files));
        else {
          if ($ === "single") {
            W("load", Se.files[0]);
            return;
          }
          W("load", Se.files);
        }
    });
  }
  function ee(le) {
    return b(this, void 0, void 0, function* () {
      var Se;
      if (r(20, _ = !1), !(!((Se = le.dataTransfer) === null || Se === void 0) && Se.files)) return;
      const ge = Array.from(le.dataTransfer.files).filter((de) => {
        const De = "." + de.name.split(".").pop();
        return De && is_valid_mimetype(R, De, de.type) || (De && Array.isArray(g) ? g.includes(De) : De === g) ? !0 : (W("error", `Invalid file type only ${g} allowed.`), !1);
      });
      if (o != "blob")
        yield Q(ge);
      else {
        if ($ === "single") {
          W("load", ge[0]);
          return;
        }
        W("load", ge);
      }
    });
  }
  function fe(le) {
    bubble$1.call(this, a, le);
  }
  function me(le) {
    bubble$1.call(this, a, le);
  }
  function he(le) {
    bubble$1.call(this, a, le);
  }
  function we(le) {
    bubble$1.call(this, a, le);
  }
  function ye(le) {
    bubble$1.call(this, a, le);
  }
  function ve(le) {
    bubble$1.call(this, a, le);
  }
  function ce(le) {
    bubble$1.call(this, a, le);
  }
  function be(le) {
    binding_callbacks$2[le ? "unshift" : "push"](() => {
      w = le, r(2, w);
    });
  }
  return a.$$set = (le) => {
    "filetype" in le && r(0, g = le.filetype), "dragging" in le && r(20, _ = le.dragging), "boundedheight" in le && r(3, A = le.boundedheight), "center" in le && r(4, x = le.center), "flex" in le && r(5, k = le.flex), "file_count" in le && r(6, $ = le.file_count), "disable_click" in le && r(7, C = le.disable_click), "root" in le && r(8, L = le.root), "hidden" in le && r(9, y = le.hidden), "format" in le && r(21, o = le.format), "uploading" in le && r(1, v = le.uploading), "hidden_upload" in le && r(2, w = le.hidden_upload), "show_progress" in le && r(10, M = le.show_progress), "max_file_size" in le && r(22, F = le.max_file_size), "upload" in le && r(23, m = le.upload), "stream_handler" in le && r(11, E = le.stream_handler), "$$scope" in le && r(26, h = le.$$scope);
  }, a.$$.update = () => {
    a.$$.dirty[0] & /*filetype, ios*/
    33554433 && (g == null ? r(16, R = null) : typeof g == "string" ? r(16, R = V(g)) : n && g.includes("file/*") ? r(16, R = "*") : (r(0, g = g.map(V)), r(16, R = g.join(", "))));
  }, r(25, n = P()), [
    g,
    v,
    w,
    A,
    x,
    k,
    $,
    C,
    L,
    y,
    M,
    E,
    q,
    H,
    z,
    O,
    R,
    K,
    Y,
    ee,
    _,
    o,
    F,
    m,
    Q,
    n,
    h,
    s,
    fe,
    me,
    he,
    we,
    ye,
    ve,
    ce,
    be
  ];
}
class Upload extends SvelteComponent$9 {
  constructor(e) {
    super(), init$9(
      this,
      e,
      instance$9,
      create_fragment$8,
      safe_not_equal$9,
      {
        filetype: 0,
        dragging: 20,
        boundedheight: 3,
        center: 4,
        flex: 5,
        file_count: 6,
        disable_click: 7,
        root: 8,
        hidden: 9,
        format: 21,
        uploading: 1,
        hidden_upload: 2,
        show_progress: 10,
        max_file_size: 22,
        upload: 23,
        stream_handler: 11,
        paste_clipboard: 12,
        open_file_upload: 13,
        load_files: 24
      },
      null,
      [-1, -1]
    );
  }
  get paste_clipboard() {
    return this.$$.ctx[12];
  }
  get open_file_upload() {
    return this.$$.ctx[13];
  }
  get load_files() {
    return this.$$.ctx[24];
  }
}
const { setContext, getContext } = window.__gradio__svelte__internal, WORKER_PROXY_CONTEXT_KEY = "WORKER_PROXY_CONTEXT_KEY";
function getWorkerProxyContext() {
  return getContext(WORKER_PROXY_CONTEXT_KEY);
}
const FAKE_LITE_HOST = "lite.local";
function is_self_host(a) {
  return a.host === window.location.host || a.host === "localhost:7860" || a.host === "127.0.0.1:7860" || // Ref: https://github.com/gradio-app/gradio/blob/v3.32.0/js/app/src/Index.svelte#L194
  a.host === FAKE_LITE_HOST;
}
function getHeaderValue(a, e) {
  const r = e.toLowerCase();
  for (const [n, s] of Object.entries(a))
    if (n.toLowerCase() === r)
      return s;
}
function should_proxy_wasm_src(a) {
  const e = typeof window < "u";
  if (a == null || !e)
    return !1;
  const r = new URL(a, window.location.href);
  return !(!is_self_host(r) || r.protocol !== "http:" && r.protocol !== "https:");
}
const {
  SvelteComponent: SvelteComponent$8,
  assign: assign$1,
  check_outros: check_outros$5,
  children: children$5,
  claim_element: claim_element$5,
  compute_rest_props,
  create_slot: create_slot$3,
  detach: detach$7,
  element: element$5,
  empty: empty$3,
  exclude_internal_props,
  get_all_dirty_from_scope: get_all_dirty_from_scope$3,
  get_slot_changes: get_slot_changes$3,
  get_spread_update: get_spread_update$1,
  group_outros: group_outros$5,
  init: init$8,
  insert_hydration: insert_hydration$7,
  listen: listen$1,
  prevent_default,
  safe_not_equal: safe_not_equal$8,
  set_attributes,
  set_style: set_style$3,
  toggle_class: toggle_class$4,
  transition_in: transition_in$5,
  transition_out: transition_out$5,
  update_slot_base: update_slot_base$3
} = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$5 } = window.__gradio__svelte__internal;
function create_else_block_1(a) {
  let e, r, n, s, h;
  const b = (
    /*#slots*/
    a[8].default
  ), g = create_slot$3(
    b,
    a,
    /*$$scope*/
    a[7],
    null
  );
  let _ = [
    { class: "download-link" },
    { href: (
      /*href*/
      a[0]
    ) },
    {
      target: r = typeof window < "u" && window.__is_colab__ ? "_blank" : null
    },
    { rel: "noopener noreferrer" },
    { download: (
      /*download*/
      a[1]
    ) },
    /*$$restProps*/
    a[6]
  ], A = {};
  for (let x = 0; x < _.length; x += 1)
    A = assign$1(A, _[x]);
  return {
    c() {
      e = element$5("a"), g && g.c(), this.h();
    },
    l(x) {
      e = claim_element$5(x, "A", {
        class: !0,
        href: !0,
        target: !0,
        rel: !0,
        download: !0
      });
      var k = children$5(e);
      g && g.l(k), k.forEach(detach$7), this.h();
    },
    h() {
      set_attributes(e, A), set_style$3(e, "position", "relative"), toggle_class$4(e, "svelte-151nsdd", !0);
    },
    m(x, k) {
      insert_hydration$7(x, e, k), g && g.m(e, null), n = !0, s || (h = listen$1(
        e,
        "click",
        /*dispatch*/
        a[3].bind(null, "click")
      ), s = !0);
    },
    p(x, k) {
      g && g.p && (!n || k & /*$$scope*/
      128) && update_slot_base$3(
        g,
        b,
        x,
        /*$$scope*/
        x[7],
        n ? get_slot_changes$3(
          b,
          /*$$scope*/
          x[7],
          k,
          null
        ) : get_all_dirty_from_scope$3(
          /*$$scope*/
          x[7]
        ),
        null
      ), set_attributes(e, A = get_spread_update$1(_, [
        { class: "download-link" },
        (!n || k & /*href*/
        1) && { href: (
          /*href*/
          x[0]
        ) },
        { target: r },
        { rel: "noopener noreferrer" },
        (!n || k & /*download*/
        2) && { download: (
          /*download*/
          x[1]
        ) },
        k & /*$$restProps*/
        64 && /*$$restProps*/
        x[6]
      ])), set_style$3(e, "position", "relative"), toggle_class$4(e, "svelte-151nsdd", !0);
    },
    i(x) {
      n || (transition_in$5(g, x), n = !0);
    },
    o(x) {
      transition_out$5(g, x), n = !1;
    },
    d(x) {
      x && detach$7(e), g && g.d(x), s = !1, h();
    }
  };
}
function create_if_block$5(a) {
  let e, r, n, s;
  const h = [create_if_block_1$5, create_else_block$4], b = [];
  function g(_, A) {
    return (
      /*is_downloading*/
      _[2] ? 0 : 1
    );
  }
  return e = g(a), r = b[e] = h[e](a), {
    c() {
      r.c(), n = empty$3();
    },
    l(_) {
      r.l(_), n = empty$3();
    },
    m(_, A) {
      b[e].m(_, A), insert_hydration$7(_, n, A), s = !0;
    },
    p(_, A) {
      let x = e;
      e = g(_), e === x ? b[e].p(_, A) : (group_outros$5(), transition_out$5(b[x], 1, 1, () => {
        b[x] = null;
      }), check_outros$5(), r = b[e], r ? r.p(_, A) : (r = b[e] = h[e](_), r.c()), transition_in$5(r, 1), r.m(n.parentNode, n));
    },
    i(_) {
      s || (transition_in$5(r), s = !0);
    },
    o(_) {
      transition_out$5(r), s = !1;
    },
    d(_) {
      _ && detach$7(n), b[e].d(_);
    }
  };
}
function create_else_block$4(a) {
  let e, r, n, s;
  const h = (
    /*#slots*/
    a[8].default
  ), b = create_slot$3(
    h,
    a,
    /*$$scope*/
    a[7],
    null
  );
  let g = [
    /*$$restProps*/
    a[6],
    { href: (
      /*href*/
      a[0]
    ) }
  ], _ = {};
  for (let A = 0; A < g.length; A += 1)
    _ = assign$1(_, g[A]);
  return {
    c() {
      e = element$5("a"), b && b.c(), this.h();
    },
    l(A) {
      e = claim_element$5(A, "A", { href: !0 });
      var x = children$5(e);
      b && b.l(x), x.forEach(detach$7), this.h();
    },
    h() {
      set_attributes(e, _), toggle_class$4(e, "svelte-151nsdd", !0);
    },
    m(A, x) {
      insert_hydration$7(A, e, x), b && b.m(e, null), r = !0, n || (s = listen$1(e, "click", prevent_default(
        /*wasm_click_handler*/
        a[5]
      )), n = !0);
    },
    p(A, x) {
      b && b.p && (!r || x & /*$$scope*/
      128) && update_slot_base$3(
        b,
        h,
        A,
        /*$$scope*/
        A[7],
        r ? get_slot_changes$3(
          h,
          /*$$scope*/
          A[7],
          x,
          null
        ) : get_all_dirty_from_scope$3(
          /*$$scope*/
          A[7]
        ),
        null
      ), set_attributes(e, _ = get_spread_update$1(g, [
        x & /*$$restProps*/
        64 && /*$$restProps*/
        A[6],
        (!r || x & /*href*/
        1) && { href: (
          /*href*/
          A[0]
        ) }
      ])), toggle_class$4(e, "svelte-151nsdd", !0);
    },
    i(A) {
      r || (transition_in$5(b, A), r = !0);
    },
    o(A) {
      transition_out$5(b, A), r = !1;
    },
    d(A) {
      A && detach$7(e), b && b.d(A), n = !1, s();
    }
  };
}
function create_if_block_1$5(a) {
  let e;
  const r = (
    /*#slots*/
    a[8].default
  ), n = create_slot$3(
    r,
    a,
    /*$$scope*/
    a[7],
    null
  );
  return {
    c() {
      n && n.c();
    },
    l(s) {
      n && n.l(s);
    },
    m(s, h) {
      n && n.m(s, h), e = !0;
    },
    p(s, h) {
      n && n.p && (!e || h & /*$$scope*/
      128) && update_slot_base$3(
        n,
        r,
        s,
        /*$$scope*/
        s[7],
        e ? get_slot_changes$3(
          r,
          /*$$scope*/
          s[7],
          h,
          null
        ) : get_all_dirty_from_scope$3(
          /*$$scope*/
          s[7]
        ),
        null
      );
    },
    i(s) {
      e || (transition_in$5(n, s), e = !0);
    },
    o(s) {
      transition_out$5(n, s), e = !1;
    },
    d(s) {
      n && n.d(s);
    }
  };
}
function create_fragment$7(a) {
  let e, r, n, s, h;
  const b = [create_if_block$5, create_else_block_1], g = [];
  function _(A, x) {
    return x & /*href*/
    1 && (e = null), e == null && (e = !!/*worker_proxy*/
    (A[4] && should_proxy_wasm_src(
      /*href*/
      A[0]
    ))), e ? 0 : 1;
  }
  return r = _(a, -1), n = g[r] = b[r](a), {
    c() {
      n.c(), s = empty$3();
    },
    l(A) {
      n.l(A), s = empty$3();
    },
    m(A, x) {
      g[r].m(A, x), insert_hydration$7(A, s, x), h = !0;
    },
    p(A, [x]) {
      let k = r;
      r = _(A, x), r === k ? g[r].p(A, x) : (group_outros$5(), transition_out$5(g[k], 1, 1, () => {
        g[k] = null;
      }), check_outros$5(), n = g[r], n ? n.p(A, x) : (n = g[r] = b[r](A), n.c()), transition_in$5(n, 1), n.m(s.parentNode, s));
    },
    i(A) {
      h || (transition_in$5(n), h = !0);
    },
    o(A) {
      transition_out$5(n), h = !1;
    },
    d(A) {
      A && detach$7(s), g[r].d(A);
    }
  };
}
function instance$8(a, e, r) {
  const n = ["href", "download"];
  let s = compute_rest_props(e, n), { $$slots: h = {}, $$scope: b } = e;
  var g = this && this.__awaiter || function(L, y, o, v) {
    function w(M) {
      return M instanceof o ? M : new o(function(F) {
        F(M);
      });
    }
    return new (o || (o = Promise))(function(M, F) {
      function m(O) {
        try {
          z(v.next(O));
        } catch (R) {
          F(R);
        }
      }
      function E(O) {
        try {
          z(v.throw(O));
        } catch (R) {
          F(R);
        }
      }
      function z(O) {
        O.done ? M(O.value) : w(O.value).then(m, E);
      }
      z((v = v.apply(L, y || [])).next());
    });
  };
  let { href: _ = void 0 } = e, { download: A } = e;
  const x = createEventDispatcher$5();
  let k = !1;
  const $ = getWorkerProxyContext();
  function C() {
    return g(this, void 0, void 0, function* () {
      if (k)
        return;
      if (x("click"), _ == null)
        throw new Error("href is not defined.");
      if ($ == null)
        throw new Error("Wasm worker proxy is not available.");
      const y = new URL(_, window.location.href).pathname;
      r(2, k = !0), $.httpRequest({
        method: "GET",
        path: y,
        headers: {},
        query_string: ""
      }).then((o) => {
        if (o.status !== 200)
          throw new Error(`Failed to get file ${y} from the Wasm worker.`);
        const v = new Blob(
          [o.body],
          {
            type: getHeaderValue(o.headers, "content-type")
          }
        ), w = URL.createObjectURL(v), M = document.createElement("a");
        M.href = w, M.download = A, M.click(), URL.revokeObjectURL(w);
      }).finally(() => {
        r(2, k = !1);
      });
    });
  }
  return a.$$set = (L) => {
    e = assign$1(assign$1({}, e), exclude_internal_props(L)), r(6, s = compute_rest_props(e, n)), "href" in L && r(0, _ = L.href), "download" in L && r(1, A = L.download), "$$scope" in L && r(7, b = L.$$scope);
  }, [
    _,
    A,
    k,
    x,
    $,
    C,
    s,
    b,
    h
  ];
}
class DownloadLink extends SvelteComponent$8 {
  constructor(e) {
    super(), init$8(this, e, instance$8, create_fragment$7, safe_not_equal$8, { href: 0, download: 1 });
  }
}
const {
  SvelteComponent: SvelteComponent$7,
  check_outros: check_outros$4,
  claim_component: claim_component$4,
  claim_space: claim_space$4,
  create_component: create_component$4,
  create_slot: create_slot$2,
  destroy_component: destroy_component$4,
  detach: detach$6,
  get_all_dirty_from_scope: get_all_dirty_from_scope$2,
  get_slot_changes: get_slot_changes$2,
  group_outros: group_outros$4,
  init: init$7,
  insert_hydration: insert_hydration$6,
  mount_component: mount_component$4,
  safe_not_equal: safe_not_equal$7,
  space: space$4,
  transition_in: transition_in$4,
  transition_out: transition_out$4,
  update_slot_base: update_slot_base$2
} = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$4 } = window.__gradio__svelte__internal;
function create_if_block_2$1(a) {
  let e, r;
  return e = new IconButton({
    props: {
      Icon: Edit,
      label: (
        /*i18n*/
        a[3]("common.edit")
      )
    }
  }), e.$on(
    "click",
    /*click_handler*/
    a[6]
  ), {
    c() {
      create_component$4(e.$$.fragment);
    },
    l(n) {
      claim_component$4(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$4(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*i18n*/
      8 && (h.label = /*i18n*/
      n[3]("common.edit")), e.$set(h);
    },
    i(n) {
      r || (transition_in$4(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$4(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$4(e, n);
    }
  };
}
function create_if_block_1$4(a) {
  let e, r;
  return e = new IconButton({
    props: {
      Icon: Undo,
      label: (
        /*i18n*/
        a[3]("common.undo")
      )
    }
  }), e.$on(
    "click",
    /*click_handler_1*/
    a[7]
  ), {
    c() {
      create_component$4(e.$$.fragment);
    },
    l(n) {
      claim_component$4(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$4(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*i18n*/
      8 && (h.label = /*i18n*/
      n[3]("common.undo")), e.$set(h);
    },
    i(n) {
      r || (transition_in$4(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$4(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$4(e, n);
    }
  };
}
function create_if_block$4(a) {
  let e, r;
  return e = new DownloadLink({
    props: {
      href: (
        /*download*/
        a[2]
      ),
      download: !0,
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx: a }
    }
  }), {
    c() {
      create_component$4(e.$$.fragment);
    },
    l(n) {
      claim_component$4(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$4(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*download*/
      4 && (h.href = /*download*/
      n[2]), s & /*$$scope, i18n*/
      520 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in$4(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$4(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$4(e, n);
    }
  };
}
function create_default_slot_1$1(a) {
  let e, r;
  return e = new IconButton({
    props: {
      Icon: Download,
      label: (
        /*i18n*/
        a[3]("common.download")
      )
    }
  }), {
    c() {
      create_component$4(e.$$.fragment);
    },
    l(n) {
      claim_component$4(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$4(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*i18n*/
      8 && (h.label = /*i18n*/
      n[3]("common.download")), e.$set(h);
    },
    i(n) {
      r || (transition_in$4(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$4(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$4(e, n);
    }
  };
}
function create_default_slot$3(a) {
  let e, r, n, s, h, b, g = (
    /*editable*/
    a[0] && create_if_block_2$1(a)
  ), _ = (
    /*undoable*/
    a[1] && create_if_block_1$4(a)
  ), A = (
    /*download*/
    a[2] && create_if_block$4(a)
  );
  const x = (
    /*#slots*/
    a[5].default
  ), k = create_slot$2(
    x,
    a,
    /*$$scope*/
    a[9],
    null
  );
  return h = new IconButton({
    props: {
      Icon: Clear,
      label: (
        /*i18n*/
        a[3]("common.clear")
      )
    }
  }), h.$on(
    "click",
    /*click_handler_2*/
    a[8]
  ), {
    c() {
      g && g.c(), e = space$4(), _ && _.c(), r = space$4(), A && A.c(), n = space$4(), k && k.c(), s = space$4(), create_component$4(h.$$.fragment);
    },
    l($) {
      g && g.l($), e = claim_space$4($), _ && _.l($), r = claim_space$4($), A && A.l($), n = claim_space$4($), k && k.l($), s = claim_space$4($), claim_component$4(h.$$.fragment, $);
    },
    m($, C) {
      g && g.m($, C), insert_hydration$6($, e, C), _ && _.m($, C), insert_hydration$6($, r, C), A && A.m($, C), insert_hydration$6($, n, C), k && k.m($, C), insert_hydration$6($, s, C), mount_component$4(h, $, C), b = !0;
    },
    p($, C) {
      /*editable*/
      $[0] ? g ? (g.p($, C), C & /*editable*/
      1 && transition_in$4(g, 1)) : (g = create_if_block_2$1($), g.c(), transition_in$4(g, 1), g.m(e.parentNode, e)) : g && (group_outros$4(), transition_out$4(g, 1, 1, () => {
        g = null;
      }), check_outros$4()), /*undoable*/
      $[1] ? _ ? (_.p($, C), C & /*undoable*/
      2 && transition_in$4(_, 1)) : (_ = create_if_block_1$4($), _.c(), transition_in$4(_, 1), _.m(r.parentNode, r)) : _ && (group_outros$4(), transition_out$4(_, 1, 1, () => {
        _ = null;
      }), check_outros$4()), /*download*/
      $[2] ? A ? (A.p($, C), C & /*download*/
      4 && transition_in$4(A, 1)) : (A = create_if_block$4($), A.c(), transition_in$4(A, 1), A.m(n.parentNode, n)) : A && (group_outros$4(), transition_out$4(A, 1, 1, () => {
        A = null;
      }), check_outros$4()), k && k.p && (!b || C & /*$$scope*/
      512) && update_slot_base$2(
        k,
        x,
        $,
        /*$$scope*/
        $[9],
        b ? get_slot_changes$2(
          x,
          /*$$scope*/
          $[9],
          C,
          null
        ) : get_all_dirty_from_scope$2(
          /*$$scope*/
          $[9]
        ),
        null
      );
      const L = {};
      C & /*i18n*/
      8 && (L.label = /*i18n*/
      $[3]("common.clear")), h.$set(L);
    },
    i($) {
      b || (transition_in$4(g), transition_in$4(_), transition_in$4(A), transition_in$4(k, $), transition_in$4(h.$$.fragment, $), b = !0);
    },
    o($) {
      transition_out$4(g), transition_out$4(_), transition_out$4(A), transition_out$4(k, $), transition_out$4(h.$$.fragment, $), b = !1;
    },
    d($) {
      $ && (detach$6(e), detach$6(r), detach$6(n), detach$6(s)), g && g.d($), _ && _.d($), A && A.d($), k && k.d($), destroy_component$4(h, $);
    }
  };
}
function create_fragment$6(a) {
  let e, r;
  return e = new IconButtonWrapper({
    props: {
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx: a }
    }
  }), {
    c() {
      create_component$4(e.$$.fragment);
    },
    l(n) {
      claim_component$4(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$4(e, n, s), r = !0;
    },
    p(n, [s]) {
      const h = {};
      s & /*$$scope, i18n, download, undoable, editable*/
      527 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in$4(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$4(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$4(e, n);
    }
  };
}
function instance$7(a, e, r) {
  let { $$slots: n = {}, $$scope: s } = e, { editable: h = !1 } = e, { undoable: b = !1 } = e, { download: g = null } = e, { i18n: _ } = e;
  const A = createEventDispatcher$4(), x = () => A("edit"), k = () => A("undo"), $ = (C) => {
    A("clear"), C.stopPropagation();
  };
  return a.$$set = (C) => {
    "editable" in C && r(0, h = C.editable), "undoable" in C && r(1, b = C.undoable), "download" in C && r(2, g = C.download), "i18n" in C && r(3, _ = C.i18n), "$$scope" in C && r(9, s = C.$$scope);
  }, [
    h,
    b,
    g,
    _,
    A,
    n,
    x,
    k,
    $,
    s
  ];
}
class ModifyUpload extends SvelteComponent$7 {
  constructor(e) {
    super(), init$7(this, e, instance$7, create_fragment$6, safe_not_equal$7, {
      editable: 0,
      undoable: 1,
      download: 2,
      i18n: 3
    });
  }
}
const { SvelteComponent: SvelteComponent$6, init: init$6, safe_not_equal: safe_not_equal$6 } = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$3, tick: tick$2 } = window.__gradio__svelte__internal;
function instance$6(a, e, r) {
  this && this.__awaiter, createEventDispatcher$3();
  let { upload: n } = e, { root: s } = e, h = "pdb_assym";
  return a.$$set = (b) => {
    "upload" in b && r(0, n = b.upload), "root" in b && r(1, s = b.root);
  }, a.$$.update = () => {
    a.$$.dirty & /*selectedValue*/
    4;
  }, [n, s, h];
}
class FileRetrieval extends SvelteComponent$6 {
  constructor(e) {
    super(), init$6(this, e, instance$6, null, safe_not_equal$6, { upload: 0, root: 1 });
  }
}
const prettyBytes = (a) => {
  let e = ["B", "KB", "MB", "GB", "PB"], r = 0;
  for (; a > 1024; )
    a /= 1024, r++;
  let n = e[r];
  return a.toFixed(1) + "&nbsp;" + n;
}, {
  HtmlTagHydration,
  SvelteComponent: SvelteComponent$5,
  append_hydration: append_hydration$4,
  attr: attr$4,
  check_outros: check_outros$3,
  children: children$4,
  claim_component: claim_component$3,
  claim_element: claim_element$4,
  claim_html_tag,
  claim_space: claim_space$3,
  claim_text: claim_text$3,
  create_component: create_component$3,
  destroy_component: destroy_component$3,
  detach: detach$5,
  element: element$4,
  ensure_array_like: ensure_array_like$2,
  get_svelte_dataset: get_svelte_dataset$1,
  group_outros: group_outros$3,
  init: init$5,
  insert_hydration: insert_hydration$5,
  listen,
  mount_component: mount_component$3,
  noop: noop$4,
  outro_and_destroy_block,
  run_all,
  safe_not_equal: safe_not_equal$5,
  set_data: set_data$2,
  set_style: set_style$2,
  space: space$3,
  text: text$3,
  toggle_class: toggle_class$3,
  transition_in: transition_in$3,
  transition_out: transition_out$3,
  update_keyed_each
} = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$2 } = window.__gradio__svelte__internal;
function get_each_context$2(a, e, r) {
  const n = a.slice();
  return n[11] = e[r], n[13] = r, n;
}
function create_else_block$3(a) {
  let e = (
    /*i18n*/
    a[2]("file.uploading") + ""
  ), r;
  return {
    c() {
      r = text$3(e);
    },
    l(n) {
      r = claim_text$3(n, e);
    },
    m(n, s) {
      insert_hydration$5(n, r, s);
    },
    p(n, s) {
      s & /*i18n*/
      4 && e !== (e = /*i18n*/
      n[2]("file.uploading") + "") && set_data$2(r, e);
    },
    i: noop$4,
    o: noop$4,
    d(n) {
      n && detach$5(r);
    }
  };
}
function create_if_block_1$3(a) {
  let e, r;
  return e = new DownloadLink({
    props: {
      href: (
        /*file*/
        a[11].url
      ),
      download: window.__is_colab__ ? null : (
        /*file*/
        a[11].orig_name
      ),
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx: a }
    }
  }), {
    c() {
      create_component$3(e.$$.fragment);
    },
    l(n) {
      claim_component$3(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$3(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*normalized_files*/
      8 && (h.href = /*file*/
      n[11].url), s & /*normalized_files*/
      8 && (h.download = window.__is_colab__ ? null : (
        /*file*/
        n[11].orig_name
      )), s & /*$$scope, normalized_files*/
      16392 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in$3(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$3(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$3(e, n);
    }
  };
}
function create_default_slot$2(a) {
  let e, r = (
    /*file*/
    (a[11].size != null ? prettyBytes(
      /*file*/
      a[11].size
    ) : "(size unknown)") + ""
  ), n;
  return {
    c() {
      e = new HtmlTagHydration(!1), n = text$3(" ⇣"), this.h();
    },
    l(s) {
      e = claim_html_tag(s, !1), n = claim_text$3(s, " ⇣"), this.h();
    },
    h() {
      e.a = n;
    },
    m(s, h) {
      e.m(r, s, h), insert_hydration$5(s, n, h);
    },
    p(s, h) {
      h & /*normalized_files*/
      8 && r !== (r = /*file*/
      (s[11].size != null ? prettyBytes(
        /*file*/
        s[11].size
      ) : "(size unknown)") + "") && e.p(r);
    },
    d(s) {
      s && (e.d(), detach$5(n));
    }
  };
}
function create_if_block$3(a) {
  let e, r, n = "×", s, h;
  function b() {
    return (
      /*click_handler*/
      a[7](
        /*i*/
        a[13]
      )
    );
  }
  function g(..._) {
    return (
      /*keydown_handler*/
      a[8](
        /*i*/
        a[13],
        ..._
      )
    );
  }
  return {
    c() {
      e = element$4("td"), r = element$4("button"), r.textContent = n, this.h();
    },
    l(_) {
      e = claim_element$4(_, "TD", { class: !0 });
      var A = children$4(e);
      r = claim_element$4(A, "BUTTON", {
        class: !0,
        "aria-label": !0,
        "data-svelte-h": !0
      }), get_svelte_dataset$1(r) !== "svelte-nhtord" && (r.textContent = n), A.forEach(detach$5), this.h();
    },
    h() {
      attr$4(r, "class", "label-clear-button svelte-1g4vug2"), attr$4(r, "aria-label", "Remove this file"), attr$4(e, "class", "svelte-1g4vug2");
    },
    m(_, A) {
      insert_hydration$5(_, e, A), append_hydration$4(e, r), s || (h = [
        listen(r, "click", b),
        listen(r, "keydown", g)
      ], s = !0);
    },
    p(_, A) {
      a = _;
    },
    d(_) {
      _ && detach$5(e), s = !1, run_all(h);
    }
  };
}
function create_each_block$2(a, e) {
  let r, n, s, h = (
    /*file*/
    e[11].filename_stem + ""
  ), b, g, _, A = (
    /*file*/
    e[11].filename_ext + ""
  ), x, k, $, C, L, y, o, v, w, M, F;
  const m = [create_if_block_1$3, create_else_block$3], E = [];
  function z(B, P) {
    return (
      /*file*/
      B[11].url ? 0 : 1
    );
  }
  L = z(e), y = E[L] = m[L](e);
  let O = (
    /*normalized_files*/
    e[3].length > 1 && create_if_block$3(e)
  );
  function R(...B) {
    return (
      /*click_handler_1*/
      e[9](
        /*i*/
        e[13],
        ...B
      )
    );
  }
  return {
    key: a,
    first: null,
    c() {
      r = element$4("tr"), n = element$4("td"), s = element$4("span"), b = text$3(h), g = space$3(), _ = element$4("span"), x = text$3(A), $ = space$3(), C = element$4("td"), y.c(), o = space$3(), O && O.c(), v = space$3(), this.h();
    },
    l(B) {
      r = claim_element$4(B, "TR", { class: !0 });
      var P = children$4(r);
      n = claim_element$4(P, "TD", { class: !0, "aria-label": !0 });
      var W = children$4(n);
      s = claim_element$4(W, "SPAN", { class: !0 });
      var U = children$4(s);
      b = claim_text$3(U, h), U.forEach(detach$5), g = claim_space$3(W), _ = claim_element$4(W, "SPAN", { class: !0 });
      var V = children$4(_);
      x = claim_text$3(V, A), V.forEach(detach$5), W.forEach(detach$5), $ = claim_space$3(P), C = claim_element$4(P, "TD", { class: !0 });
      var K = children$4(C);
      y.l(K), K.forEach(detach$5), o = claim_space$3(P), O && O.l(P), v = claim_space$3(P), P.forEach(detach$5), this.h();
    },
    h() {
      attr$4(s, "class", "stem svelte-1g4vug2"), attr$4(_, "class", "ext svelte-1g4vug2"), attr$4(n, "class", "filename svelte-1g4vug2"), attr$4(n, "aria-label", k = /*file*/
      e[11].orig_name), attr$4(C, "class", "download svelte-1g4vug2"), attr$4(r, "class", "file svelte-1g4vug2"), toggle_class$3(
        r,
        "selectable",
        /*selectable*/
        e[0]
      ), this.first = r;
    },
    m(B, P) {
      insert_hydration$5(B, r, P), append_hydration$4(r, n), append_hydration$4(n, s), append_hydration$4(s, b), append_hydration$4(n, g), append_hydration$4(n, _), append_hydration$4(_, x), append_hydration$4(r, $), append_hydration$4(r, C), E[L].m(C, null), append_hydration$4(r, o), O && O.m(r, null), append_hydration$4(r, v), w = !0, M || (F = listen(r, "click", R), M = !0);
    },
    p(B, P) {
      e = B, (!w || P & /*normalized_files*/
      8) && h !== (h = /*file*/
      e[11].filename_stem + "") && set_data$2(b, h), (!w || P & /*normalized_files*/
      8) && A !== (A = /*file*/
      e[11].filename_ext + "") && set_data$2(x, A), (!w || P & /*normalized_files*/
      8 && k !== (k = /*file*/
      e[11].orig_name)) && attr$4(n, "aria-label", k);
      let W = L;
      L = z(e), L === W ? E[L].p(e, P) : (group_outros$3(), transition_out$3(E[W], 1, 1, () => {
        E[W] = null;
      }), check_outros$3(), y = E[L], y ? y.p(e, P) : (y = E[L] = m[L](e), y.c()), transition_in$3(y, 1), y.m(C, null)), /*normalized_files*/
      e[3].length > 1 ? O ? O.p(e, P) : (O = create_if_block$3(e), O.c(), O.m(r, v)) : O && (O.d(1), O = null), (!w || P & /*selectable*/
      1) && toggle_class$3(
        r,
        "selectable",
        /*selectable*/
        e[0]
      );
    },
    i(B) {
      w || (transition_in$3(y), w = !0);
    },
    o(B) {
      transition_out$3(y), w = !1;
    },
    d(B) {
      B && detach$5(r), E[L].d(), O && O.d(), M = !1, F();
    }
  };
}
function create_fragment$5(a) {
  let e, r, n, s = [], h = /* @__PURE__ */ new Map(), b, g = ensure_array_like$2(
    /*normalized_files*/
    a[3]
  );
  const _ = (A) => (
    /*file*/
    A[11]
  );
  for (let A = 0; A < g.length; A += 1) {
    let x = get_each_context$2(a, g, A), k = _(x);
    h.set(k, s[A] = create_each_block$2(k, x));
  }
  return {
    c() {
      e = element$4("div"), r = element$4("table"), n = element$4("tbody");
      for (let A = 0; A < s.length; A += 1)
        s[A].c();
      this.h();
    },
    l(A) {
      e = claim_element$4(A, "DIV", { class: !0, style: !0 });
      var x = children$4(e);
      r = claim_element$4(x, "TABLE", { class: !0 });
      var k = children$4(r);
      n = claim_element$4(k, "TBODY", { class: !0 });
      var $ = children$4(n);
      for (let C = 0; C < s.length; C += 1)
        s[C].l($);
      $.forEach(detach$5), k.forEach(detach$5), x.forEach(detach$5), this.h();
    },
    h() {
      attr$4(n, "class", "svelte-1g4vug2"), attr$4(r, "class", "file-preview svelte-1g4vug2"), attr$4(e, "class", "file-preview-holder svelte-1g4vug2"), set_style$2(e, "max-height", typeof /*height*/
      a[1] === void 0 ? "auto" : (
        /*height*/
        a[1] + "px"
      ));
    },
    m(A, x) {
      insert_hydration$5(A, e, x), append_hydration$4(e, r), append_hydration$4(r, n);
      for (let k = 0; k < s.length; k += 1)
        s[k] && s[k].m(n, null);
      b = !0;
    },
    p(A, [x]) {
      x & /*selectable, handle_row_click, normalized_files, remove_file, window, i18n*/
      61 && (g = ensure_array_like$2(
        /*normalized_files*/
        A[3]
      ), group_outros$3(), s = update_keyed_each(s, x, _, 1, A, g, h, n, outro_and_destroy_block, create_each_block$2, null, get_each_context$2), check_outros$3()), (!b || x & /*height*/
      2) && set_style$2(e, "max-height", typeof /*height*/
      A[1] === void 0 ? "auto" : (
        /*height*/
        A[1] + "px"
      ));
    },
    i(A) {
      if (!b) {
        for (let x = 0; x < g.length; x += 1)
          transition_in$3(s[x]);
        b = !0;
      }
    },
    o(A) {
      for (let x = 0; x < s.length; x += 1)
        transition_out$3(s[x]);
      b = !1;
    },
    d(A) {
      A && detach$5(e);
      for (let x = 0; x < s.length; x += 1)
        s[x].d();
    }
  };
}
function split_filename(a) {
  const e = a.lastIndexOf(".");
  return e === -1 ? [a, ""] : [a.slice(0, e), a.slice(e)];
}
function instance$5(a, e, r) {
  let n;
  const s = createEventDispatcher$2();
  let { value: h } = e, { selectable: b = !1 } = e, { height: g = void 0 } = e, { i18n: _ } = e;
  function A(L, y) {
    const o = L.currentTarget;
    (L.target === o || // Only select if the click is on the row itself
    o && o.firstElementChild && L.composedPath().includes(o.firstElementChild)) && s("select", {
      value: n[y].orig_name,
      index: y
    });
  }
  function x(L) {
    const y = n.splice(L, 1);
    r(3, n = [...n]), r(6, h = n), s("delete", y[0]), s("change", n);
  }
  const k = (L) => {
    x(L);
  }, $ = (L, y) => {
    y.key === "Enter" && x(L);
  }, C = (L, y) => {
    A(y, L);
  };
  return a.$$set = (L) => {
    "value" in L && r(6, h = L.value), "selectable" in L && r(0, b = L.selectable), "height" in L && r(1, g = L.height), "i18n" in L && r(2, _ = L.i18n);
  }, a.$$.update = () => {
    a.$$.dirty & /*value*/
    64 && r(3, n = (Array.isArray(h) ? h : [h]).map((L) => {
      var y;
      const [o, v] = split_filename((y = L.orig_name) !== null && y !== void 0 ? y : "");
      return Object.assign(Object.assign({}, L), { filename_stem: o, filename_ext: v });
    }));
  }, [
    b,
    g,
    _,
    n,
    A,
    x,
    h,
    k,
    $,
    C
  ];
}
class FilePreview extends SvelteComponent$5 {
  constructor(e) {
    super(), init$5(this, e, instance$5, create_fragment$5, safe_not_equal$5, {
      value: 6,
      selectable: 0,
      height: 1,
      i18n: 2
    });
  }
}
const {
  SvelteComponent: SvelteComponent$4,
  add_flush_callback,
  bind,
  binding_callbacks: binding_callbacks$1,
  bubble,
  check_outros: check_outros$2,
  claim_component: claim_component$2,
  claim_space: claim_space$2,
  create_component: create_component$2,
  create_slot: create_slot$1,
  destroy_component: destroy_component$2,
  detach: detach$4,
  empty: empty$2,
  get_all_dirty_from_scope: get_all_dirty_from_scope$1,
  get_slot_changes: get_slot_changes$1,
  group_outros: group_outros$2,
  init: init$4,
  insert_hydration: insert_hydration$4,
  mount_component: mount_component$2,
  safe_not_equal: safe_not_equal$4,
  space: space$2,
  transition_in: transition_in$2,
  transition_out: transition_out$2,
  update_slot_base: update_slot_base$1
} = window.__gradio__svelte__internal, { createEventDispatcher: createEventDispatcher$1, tick: tick$1 } = window.__gradio__svelte__internal;
function create_else_block$2(a) {
  let e, r, n, s, h;
  e = new FileRetrieval({
    props: {
      root: (
        /*root*/
        a[6]
      ),
      upload: (
        /*upload*/
        a[10]
      )
    }
  }), e.$on(
    "load",
    /*handle_upload*/
    a[18]
  ), e.$on(
    "notfound",
    /*notfound_handler*/
    a[25]
  );
  function b(_) {
    a[26](_);
  }
  let g = {
    filetype: (
      /*file_types*/
      a[4]
    ),
    file_count: (
      /*file_count*/
      a[3]
    ),
    max_file_size: (
      /*max_file_size*/
      a[9]
    ),
    root: (
      /*root*/
      a[6]
    ),
    stream_handler: (
      /*stream_handler*/
      a[11]
    ),
    upload: (
      /*upload*/
      a[10]
    ),
    $$slots: { default: [create_default_slot$1] },
    $$scope: { ctx: a }
  };
  return (
    /*dragging*/
    a[17] !== void 0 && (g.dragging = /*dragging*/
    a[17]), n = new Upload({ props: g }), binding_callbacks$1.push(() => bind(n, "dragging", b)), n.$on(
      "load",
      /*handle_upload*/
      a[18]
    ), n.$on(
      "error",
      /*error_handler*/
      a[27]
    ), {
      c() {
        create_component$2(e.$$.fragment), r = space$2(), create_component$2(n.$$.fragment);
      },
      l(_) {
        claim_component$2(e.$$.fragment, _), r = claim_space$2(_), claim_component$2(n.$$.fragment, _);
      },
      m(_, A) {
        mount_component$2(e, _, A), insert_hydration$4(_, r, A), mount_component$2(n, _, A), h = !0;
      },
      p(_, A) {
        const x = {};
        A & /*root*/
        64 && (x.root = /*root*/
        _[6]), A & /*upload*/
        1024 && (x.upload = /*upload*/
        _[10]), e.$set(x);
        const k = {};
        A & /*file_types*/
        16 && (k.filetype = /*file_types*/
        _[4]), A & /*file_count*/
        8 && (k.file_count = /*file_count*/
        _[3]), A & /*max_file_size*/
        512 && (k.max_file_size = /*max_file_size*/
        _[9]), A & /*root*/
        64 && (k.root = /*root*/
        _[6]), A & /*stream_handler*/
        2048 && (k.stream_handler = /*stream_handler*/
        _[11]), A & /*upload*/
        1024 && (k.upload = /*upload*/
        _[10]), A & /*$$scope*/
        268435456 && (k.$$scope = { dirty: A, ctx: _ }), !s && A & /*dragging*/
        131072 && (s = !0, k.dragging = /*dragging*/
        _[17], add_flush_callback(() => s = !1)), n.$set(k);
      },
      i(_) {
        h || (transition_in$2(e.$$.fragment, _), transition_in$2(n.$$.fragment, _), h = !0);
      },
      o(_) {
        transition_out$2(e.$$.fragment, _), transition_out$2(n.$$.fragment, _), h = !1;
      },
      d(_) {
        _ && detach$4(r), destroy_component$2(e, _), destroy_component$2(n, _);
      }
    }
  );
}
function create_if_block$2(a) {
  let e, r, n, s, h, b;
  e = new ModifyUpload({
    props: { i18n: (
      /*i18n*/
      a[8]
    ), absolute: !0 }
  }), e.$on(
    "clear",
    /*handle_clear*/
    a[19]
  ), n = new FilePreview({
    props: {
      i18n: (
        /*i18n*/
        a[8]
      ),
      selectable: (
        /*selectable*/
        a[5]
      ),
      value: (
        /*value*/
        a[0]
      ),
      height: (
        /*height*/
        a[7]
      )
    }
  }), n.$on(
    "select",
    /*select_handler*/
    a[22]
  ), n.$on(
    "change",
    /*change_handler*/
    a[23]
  ), n.$on(
    "delete",
    /*delete_handler*/
    a[24]
  );
  let g = (
    /*moldata*/
    a[15] != null && /*molviewer*/
    a[16] && create_if_block_1$2(a)
  );
  return {
    c() {
      create_component$2(e.$$.fragment), r = space$2(), create_component$2(n.$$.fragment), s = space$2(), g && g.c(), h = empty$2();
    },
    l(_) {
      claim_component$2(e.$$.fragment, _), r = claim_space$2(_), claim_component$2(n.$$.fragment, _), s = claim_space$2(_), g && g.l(_), h = empty$2();
    },
    m(_, A) {
      mount_component$2(e, _, A), insert_hydration$4(_, r, A), mount_component$2(n, _, A), insert_hydration$4(_, s, A), g && g.m(_, A), insert_hydration$4(_, h, A), b = !0;
    },
    p(_, A) {
      const x = {};
      A & /*i18n*/
      256 && (x.i18n = /*i18n*/
      _[8]), e.$set(x);
      const k = {};
      A & /*i18n*/
      256 && (k.i18n = /*i18n*/
      _[8]), A & /*selectable*/
      32 && (k.selectable = /*selectable*/
      _[5]), A & /*value*/
      1 && (k.value = /*value*/
      _[0]), A & /*height*/
      128 && (k.height = /*height*/
      _[7]), n.$set(k), /*moldata*/
      _[15] != null && /*molviewer*/
      _[16] ? g ? (g.p(_, A), A & /*moldata, molviewer*/
      98304 && transition_in$2(g, 1)) : (g = create_if_block_1$2(_), g.c(), transition_in$2(g, 1), g.m(h.parentNode, h)) : g && (group_outros$2(), transition_out$2(g, 1, 1, () => {
        g = null;
      }), check_outros$2());
    },
    i(_) {
      b || (transition_in$2(e.$$.fragment, _), transition_in$2(n.$$.fragment, _), transition_in$2(g), b = !0);
    },
    o(_) {
      transition_out$2(e.$$.fragment, _), transition_out$2(n.$$.fragment, _), transition_out$2(g), b = !1;
    },
    d(_) {
      _ && (detach$4(r), detach$4(s), detach$4(h)), destroy_component$2(e, _), destroy_component$2(n, _), g && g.d(_);
    }
  };
}
function create_default_slot$1(a) {
  let e;
  const r = (
    /*#slots*/
    a[21].default
  ), n = create_slot$1(
    r,
    a,
    /*$$scope*/
    a[28],
    null
  );
  return {
    c() {
      n && n.c();
    },
    l(s) {
      n && n.l(s);
    },
    m(s, h) {
      n && n.m(s, h), e = !0;
    },
    p(s, h) {
      n && n.p && (!e || h & /*$$scope*/
      268435456) && update_slot_base$1(
        n,
        r,
        s,
        /*$$scope*/
        s[28],
        e ? get_slot_changes$1(
          r,
          /*$$scope*/
          s[28],
          h,
          null
        ) : get_all_dirty_from_scope$1(
          /*$$scope*/
          s[28]
        ),
        null
      );
    },
    i(s) {
      e || (transition_in$2(n, s), e = !0);
    },
    o(s) {
      transition_out$2(n, s), e = !1;
    },
    d(s) {
      n && n.d(s);
    }
  };
}
function create_if_block_1$2(a) {
  let e, r;
  return e = new MolecularViewer({
    props: {
      moldata: (
        /*moldata*/
        a[15]
      ),
      config: (
        /*config*/
        a[12]
      ),
      confidenceLabel: (
        /*confidenceLabel*/
        a[13]
      ),
      representations: (
        /*representations*/
        a[14]
      )
    }
  }), {
    c() {
      create_component$2(e.$$.fragment);
    },
    l(n) {
      claim_component$2(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$2(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s & /*moldata*/
      32768 && (h.moldata = /*moldata*/
      n[15]), s & /*config*/
      4096 && (h.config = /*config*/
      n[12]), s & /*confidenceLabel*/
      8192 && (h.confidenceLabel = /*confidenceLabel*/
      n[13]), s & /*representations*/
      16384 && (h.representations = /*representations*/
      n[14]), e.$set(h);
    },
    i(n) {
      r || (transition_in$2(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$2(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$2(e, n);
    }
  };
}
function create_fragment$4(a) {
  let e, r, n, s, h, b, g;
  e = new BlockLabel({
    props: {
      show_label: (
        /*show_label*/
        a[2]
      ),
      Icon: File$1,
      float: !/*value*/
      a[0],
      label: (
        /*label*/
        a[1] || "File"
      )
    }
  });
  const _ = [create_if_block$2, create_else_block$2], A = [];
  function x(k, $) {
    return $ & /*value*/
    1 && (n = null), n == null && (n = !!/*value*/
    (k[0] && (!Array.isArray(
      /*value*/
      k[0]
    ) || /*value*/
    k[0].length > 0))), n ? 0 : 1;
  }
  return s = x(a, -1), h = A[s] = _[s](a), {
    c() {
      create_component$2(e.$$.fragment), r = space$2(), h.c(), b = empty$2();
    },
    l(k) {
      claim_component$2(e.$$.fragment, k), r = claim_space$2(k), h.l(k), b = empty$2();
    },
    m(k, $) {
      mount_component$2(e, k, $), insert_hydration$4(k, r, $), A[s].m(k, $), insert_hydration$4(k, b, $), g = !0;
    },
    p(k, [$]) {
      const C = {};
      $ & /*show_label*/
      4 && (C.show_label = /*show_label*/
      k[2]), $ & /*value*/
      1 && (C.float = !/*value*/
      k[0]), $ & /*label*/
      2 && (C.label = /*label*/
      k[1] || "File"), e.$set(C);
      let L = s;
      s = x(k, $), s === L ? A[s].p(k, $) : (group_outros$2(), transition_out$2(A[L], 1, 1, () => {
        A[L] = null;
      }), check_outros$2(), h = A[s], h ? h.p(k, $) : (h = A[s] = _[s](k), h.c()), transition_in$2(h, 1), h.m(b.parentNode, b));
    },
    i(k) {
      g || (transition_in$2(e.$$.fragment, k), transition_in$2(h), g = !0);
    },
    o(k) {
      transition_out$2(e.$$.fragment, k), transition_out$2(h), g = !1;
    },
    d(k) {
      k && (detach$4(r), detach$4(b)), destroy_component$2(e, k), A[s].d(k);
    }
  };
}
function instance$4(a, e, r) {
  let { $$slots: n = {}, $$scope: s } = e;
  var h = this && this.__awaiter || function(H, j, Q, J) {
    function Y(ee) {
      return ee instanceof Q ? ee : new Q(function(fe) {
        fe(ee);
      });
    }
    return new (Q || (Q = Promise))(function(ee, fe) {
      function me(ye) {
        try {
          we(J.next(ye));
        } catch (ve) {
          fe(ve);
        }
      }
      function he(ye) {
        try {
          we(J.throw(ye));
        } catch (ve) {
          fe(ve);
        }
      }
      function we(ye) {
        ye.done ? ee(ye.value) : Y(ye.value).then(me, he);
      }
      we((J = J.apply(H, j || [])).next());
    });
  };
  let { value: b } = e, { label: g } = e, { show_label: _ = !0 } = e, { file_count: A = "single" } = e, { file_types: x = null } = e, { selectable: k = !1 } = e, { root: $ } = e, { height: C = void 0 } = e, { i18n: L } = e, { max_file_size: y = null } = e, { upload: o } = e, { stream_handler: v } = e, { config: w = {} } = e, { confidenceLabel: M = "" } = e, { representations: F = [] } = e, { moldata: m = null } = e, { molviewer: E = !1 } = e;
  function z(H) {
    return h(this, arguments, void 0, function* ({ detail: j }) {
      r(0, b = j), console.log("upload", j), yield tick$1(), R("change", b), R("upload", j);
    });
  }
  function O() {
    r(0, b = null), oldata = null, R("change", null), R("clear");
  }
  const R = createEventDispatcher$1();
  let B = !1;
  function P(H) {
    bubble.call(this, a, H);
  }
  function W(H) {
    bubble.call(this, a, H);
  }
  function U(H) {
    bubble.call(this, a, H);
  }
  const V = () => R("notfound");
  function K(H) {
    B = H, r(17, B);
  }
  function q(H) {
    bubble.call(this, a, H);
  }
  return a.$$set = (H) => {
    "value" in H && r(0, b = H.value), "label" in H && r(1, g = H.label), "show_label" in H && r(2, _ = H.show_label), "file_count" in H && r(3, A = H.file_count), "file_types" in H && r(4, x = H.file_types), "selectable" in H && r(5, k = H.selectable), "root" in H && r(6, $ = H.root), "height" in H && r(7, C = H.height), "i18n" in H && r(8, L = H.i18n), "max_file_size" in H && r(9, y = H.max_file_size), "upload" in H && r(10, o = H.upload), "stream_handler" in H && r(11, v = H.stream_handler), "config" in H && r(12, w = H.config), "confidenceLabel" in H && r(13, M = H.confidenceLabel), "representations" in H && r(14, F = H.representations), "moldata" in H && r(15, m = H.moldata), "molviewer" in H && r(16, E = H.molviewer), "$$scope" in H && r(28, s = H.$$scope);
  }, a.$$.update = () => {
    a.$$.dirty & /*dragging*/
    131072 && R("drag", B);
  }, [
    b,
    g,
    _,
    A,
    x,
    k,
    $,
    C,
    L,
    y,
    o,
    v,
    w,
    M,
    F,
    m,
    E,
    B,
    z,
    O,
    R,
    n,
    P,
    W,
    U,
    V,
    K,
    q,
    s
  ];
}
class FileUpload extends SvelteComponent$4 {
  constructor(e) {
    super(), init$4(this, e, instance$4, create_fragment$4, safe_not_equal$4, {
      value: 0,
      label: 1,
      show_label: 2,
      file_count: 3,
      file_types: 4,
      selectable: 5,
      root: 6,
      height: 7,
      i18n: 8,
      max_file_size: 9,
      upload: 10,
      stream_handler: 11,
      config: 12,
      confidenceLabel: 13,
      representations: 14,
      moldata: 15,
      molviewer: 16
    });
  }
}
function pretty_si(a) {
  let e = ["", "k", "M", "G", "T", "P", "E", "Z"], r = 0;
  for (; a > 1e3 && r < e.length - 1; )
    a /= 1e3, r++;
  let n = e[r];
  return (Number.isInteger(a) ? a : a.toFixed(1)) + n;
}
const {
  SvelteComponent: SvelteComponent$3,
  append_hydration: append_hydration$3,
  attr: attr$3,
  children: children$3,
  claim_element: claim_element$3,
  claim_svg_element: claim_svg_element$1,
  component_subscribe,
  detach: detach$3,
  element: element$3,
  init: init$3,
  insert_hydration: insert_hydration$3,
  noop: noop$3,
  safe_not_equal: safe_not_equal$3,
  set_style: set_style$1,
  svg_element: svg_element$1,
  toggle_class: toggle_class$2
} = window.__gradio__svelte__internal, { onMount } = window.__gradio__svelte__internal;
function create_fragment$3(a) {
  let e, r, n, s, h, b, g, _, A, x, k, $;
  return {
    c() {
      e = element$3("div"), r = svg_element$1("svg"), n = svg_element$1("g"), s = svg_element$1("path"), h = svg_element$1("path"), b = svg_element$1("path"), g = svg_element$1("path"), _ = svg_element$1("g"), A = svg_element$1("path"), x = svg_element$1("path"), k = svg_element$1("path"), $ = svg_element$1("path"), this.h();
    },
    l(C) {
      e = claim_element$3(C, "DIV", { class: !0 });
      var L = children$3(e);
      r = claim_svg_element$1(L, "svg", {
        viewBox: !0,
        fill: !0,
        xmlns: !0,
        class: !0
      });
      var y = children$3(r);
      n = claim_svg_element$1(y, "g", { style: !0 });
      var o = children$3(n);
      s = claim_svg_element$1(o, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$3(s).forEach(detach$3), h = claim_svg_element$1(o, "path", { d: !0, fill: !0, class: !0 }), children$3(h).forEach(detach$3), b = claim_svg_element$1(o, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$3(b).forEach(detach$3), g = claim_svg_element$1(o, "path", { d: !0, fill: !0, class: !0 }), children$3(g).forEach(detach$3), o.forEach(detach$3), _ = claim_svg_element$1(y, "g", { style: !0 });
      var v = children$3(_);
      A = claim_svg_element$1(v, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$3(A).forEach(detach$3), x = claim_svg_element$1(v, "path", { d: !0, fill: !0, class: !0 }), children$3(x).forEach(detach$3), k = claim_svg_element$1(v, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$3(k).forEach(detach$3), $ = claim_svg_element$1(v, "path", { d: !0, fill: !0, class: !0 }), children$3($).forEach(detach$3), v.forEach(detach$3), y.forEach(detach$3), L.forEach(detach$3), this.h();
    },
    h() {
      attr$3(s, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$3(s, "fill", "#FF7C00"), attr$3(s, "fill-opacity", "0.4"), attr$3(s, "class", "svelte-43sxxs"), attr$3(h, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$3(h, "fill", "#FF7C00"), attr$3(h, "class", "svelte-43sxxs"), attr$3(b, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$3(b, "fill", "#FF7C00"), attr$3(b, "fill-opacity", "0.4"), attr$3(b, "class", "svelte-43sxxs"), attr$3(g, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$3(g, "fill", "#FF7C00"), attr$3(g, "class", "svelte-43sxxs"), set_style$1(n, "transform", "translate(" + /*$top*/
      a[1][0] + "px, " + /*$top*/
      a[1][1] + "px)"), attr$3(A, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$3(A, "fill", "#FF7C00"), attr$3(A, "fill-opacity", "0.4"), attr$3(A, "class", "svelte-43sxxs"), attr$3(x, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$3(x, "fill", "#FF7C00"), attr$3(x, "class", "svelte-43sxxs"), attr$3(k, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$3(k, "fill", "#FF7C00"), attr$3(k, "fill-opacity", "0.4"), attr$3(k, "class", "svelte-43sxxs"), attr$3($, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$3($, "fill", "#FF7C00"), attr$3($, "class", "svelte-43sxxs"), set_style$1(_, "transform", "translate(" + /*$bottom*/
      a[2][0] + "px, " + /*$bottom*/
      a[2][1] + "px)"), attr$3(r, "viewBox", "-1200 -1200 3000 3000"), attr$3(r, "fill", "none"), attr$3(r, "xmlns", "http://www.w3.org/2000/svg"), attr$3(r, "class", "svelte-43sxxs"), attr$3(e, "class", "svelte-43sxxs"), toggle_class$2(
        e,
        "margin",
        /*margin*/
        a[0]
      );
    },
    m(C, L) {
      insert_hydration$3(C, e, L), append_hydration$3(e, r), append_hydration$3(r, n), append_hydration$3(n, s), append_hydration$3(n, h), append_hydration$3(n, b), append_hydration$3(n, g), append_hydration$3(r, _), append_hydration$3(_, A), append_hydration$3(_, x), append_hydration$3(_, k), append_hydration$3(_, $);
    },
    p(C, [L]) {
      L & /*$top*/
      2 && set_style$1(n, "transform", "translate(" + /*$top*/
      C[1][0] + "px, " + /*$top*/
      C[1][1] + "px)"), L & /*$bottom*/
      4 && set_style$1(_, "transform", "translate(" + /*$bottom*/
      C[2][0] + "px, " + /*$bottom*/
      C[2][1] + "px)"), L & /*margin*/
      1 && toggle_class$2(
        e,
        "margin",
        /*margin*/
        C[0]
      );
    },
    i: noop$3,
    o: noop$3,
    d(C) {
      C && detach$3(e);
    }
  };
}
function instance$3(a, e, r) {
  let n, s;
  var h = this && this.__awaiter || function(C, L, y, o) {
    function v(w) {
      return w instanceof y ? w : new y(function(M) {
        M(w);
      });
    }
    return new (y || (y = Promise))(function(w, M) {
      function F(z) {
        try {
          E(o.next(z));
        } catch (O) {
          M(O);
        }
      }
      function m(z) {
        try {
          E(o.throw(z));
        } catch (O) {
          M(O);
        }
      }
      function E(z) {
        z.done ? w(z.value) : v(z.value).then(F, m);
      }
      E((o = o.apply(C, L || [])).next());
    });
  };
  let { margin: b = !0 } = e;
  const g = ot([0, 0]);
  component_subscribe(a, g, (C) => r(1, n = C));
  const _ = ot([0, 0]);
  component_subscribe(a, _, (C) => r(2, s = C));
  let A;
  function x() {
    return h(this, void 0, void 0, function* () {
      yield Promise.all([g.set([125, 140]), _.set([-125, -140])]), yield Promise.all([g.set([-125, 140]), _.set([125, -140])]), yield Promise.all([g.set([-125, 0]), _.set([125, -0])]), yield Promise.all([g.set([125, 0]), _.set([-125, 0])]);
    });
  }
  function k() {
    return h(this, void 0, void 0, function* () {
      yield x(), A || k();
    });
  }
  function $() {
    return h(this, void 0, void 0, function* () {
      yield Promise.all([g.set([125, 0]), _.set([-125, 0])]), k();
    });
  }
  return onMount(() => ($(), () => A = !0)), a.$$set = (C) => {
    "margin" in C && r(0, b = C.margin);
  }, [b, n, s, g, _];
}
class Loader extends SvelteComponent$3 {
  constructor(e) {
    super(), init$3(this, e, instance$3, create_fragment$3, safe_not_equal$3, { margin: 0 });
  }
}
const {
  SvelteComponent: SvelteComponent$2,
  append_hydration: append_hydration$2,
  attr: attr$2,
  binding_callbacks,
  check_outros: check_outros$1,
  children: children$2,
  claim_component: claim_component$1,
  claim_element: claim_element$2,
  claim_space: claim_space$1,
  claim_text: claim_text$2,
  create_component: create_component$1,
  create_slot,
  destroy_component: destroy_component$1,
  destroy_each: destroy_each$1,
  detach: detach$2,
  element: element$2,
  empty: empty$1,
  ensure_array_like: ensure_array_like$1,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros: group_outros$1,
  init: init$2,
  insert_hydration: insert_hydration$2,
  mount_component: mount_component$1,
  noop: noop$2,
  safe_not_equal: safe_not_equal$2,
  set_data: set_data$1,
  set_style,
  space: space$1,
  text: text$2,
  toggle_class: toggle_class$1,
  transition_in: transition_in$1,
  transition_out: transition_out$1,
  update_slot_base
} = window.__gradio__svelte__internal, { tick } = window.__gradio__svelte__internal, { onDestroy } = window.__gradio__svelte__internal, { createEventDispatcher } = window.__gradio__svelte__internal, get_error_slot_changes = (a) => ({}), get_error_slot_context = (a) => ({}), get_additional_loading_text_slot_changes = (a) => ({}), get_additional_loading_text_slot_context = (a) => ({});
function get_each_context$1(a, e, r) {
  const n = a.slice();
  return n[41] = e[r], n[43] = r, n;
}
function get_each_context_1(a, e, r) {
  const n = a.slice();
  return n[41] = e[r], n;
}
function create_if_block_17(a) {
  let e, r, n, s, h = (
    /*i18n*/
    a[1]("common.error") + ""
  ), b, g, _;
  r = new IconButton({
    props: {
      Icon: Clear,
      label: (
        /*i18n*/
        a[1]("common.clear")
      ),
      disabled: !1
    }
  }), r.$on(
    "click",
    /*click_handler*/
    a[32]
  );
  const A = (
    /*#slots*/
    a[30].error
  ), x = create_slot(
    A,
    a,
    /*$$scope*/
    a[29],
    get_error_slot_context
  );
  return {
    c() {
      e = element$2("div"), create_component$1(r.$$.fragment), n = space$1(), s = element$2("span"), b = text$2(h), g = space$1(), x && x.c(), this.h();
    },
    l(k) {
      e = claim_element$2(k, "DIV", { class: !0 });
      var $ = children$2(e);
      claim_component$1(r.$$.fragment, $), $.forEach(detach$2), n = claim_space$1(k), s = claim_element$2(k, "SPAN", { class: !0 });
      var C = children$2(s);
      b = claim_text$2(C, h), C.forEach(detach$2), g = claim_space$1(k), x && x.l(k), this.h();
    },
    h() {
      attr$2(e, "class", "clear-status svelte-17v219f"), attr$2(s, "class", "error svelte-17v219f");
    },
    m(k, $) {
      insert_hydration$2(k, e, $), mount_component$1(r, e, null), insert_hydration$2(k, n, $), insert_hydration$2(k, s, $), append_hydration$2(s, b), insert_hydration$2(k, g, $), x && x.m(k, $), _ = !0;
    },
    p(k, $) {
      const C = {};
      $[0] & /*i18n*/
      2 && (C.label = /*i18n*/
      k[1]("common.clear")), r.$set(C), (!_ || $[0] & /*i18n*/
      2) && h !== (h = /*i18n*/
      k[1]("common.error") + "") && set_data$1(b, h), x && x.p && (!_ || $[0] & /*$$scope*/
      536870912) && update_slot_base(
        x,
        A,
        k,
        /*$$scope*/
        k[29],
        _ ? get_slot_changes(
          A,
          /*$$scope*/
          k[29],
          $,
          get_error_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          k[29]
        ),
        get_error_slot_context
      );
    },
    i(k) {
      _ || (transition_in$1(r.$$.fragment, k), transition_in$1(x, k), _ = !0);
    },
    o(k) {
      transition_out$1(r.$$.fragment, k), transition_out$1(x, k), _ = !1;
    },
    d(k) {
      k && (detach$2(e), detach$2(n), detach$2(s), detach$2(g)), destroy_component$1(r), x && x.d(k);
    }
  };
}
function create_if_block$1(a) {
  let e, r, n, s, h, b, g, _, A, x = (
    /*variant*/
    a[8] === "default" && /*show_eta_bar*/
    a[18] && /*show_progress*/
    a[6] === "full" && create_if_block_16(a)
  );
  function k(M, F) {
    if (
      /*progress*/
      M[7]
    ) return create_if_block_11;
    if (
      /*queue_position*/
      M[2] !== null && /*queue_size*/
      M[3] !== void 0 && /*queue_position*/
      M[2] >= 0
    ) return create_if_block_14;
    if (
      /*queue_position*/
      M[2] === 0
    ) return create_if_block_15;
  }
  let $ = k(a), C = $ && $(a), L = (
    /*timer*/
    a[5] && create_if_block_10(a)
  );
  const y = [create_if_block_2, create_if_block_9], o = [];
  function v(M, F) {
    return (
      /*last_progress_level*/
      M[15] != null ? 0 : (
        /*show_progress*/
        M[6] === "full" ? 1 : -1
      )
    );
  }
  ~(h = v(a)) && (b = o[h] = y[h](a));
  let w = !/*timer*/
  a[5] && create_if_block_1$1(a);
  return {
    c() {
      x && x.c(), e = space$1(), r = element$2("div"), C && C.c(), n = space$1(), L && L.c(), s = space$1(), b && b.c(), g = space$1(), w && w.c(), _ = empty$1(), this.h();
    },
    l(M) {
      x && x.l(M), e = claim_space$1(M), r = claim_element$2(M, "DIV", { class: !0 });
      var F = children$2(r);
      C && C.l(F), n = claim_space$1(F), L && L.l(F), F.forEach(detach$2), s = claim_space$1(M), b && b.l(M), g = claim_space$1(M), w && w.l(M), _ = empty$1(), this.h();
    },
    h() {
      attr$2(r, "class", "progress-text svelte-17v219f"), toggle_class$1(
        r,
        "meta-text-center",
        /*variant*/
        a[8] === "center"
      ), toggle_class$1(
        r,
        "meta-text",
        /*variant*/
        a[8] === "default"
      );
    },
    m(M, F) {
      x && x.m(M, F), insert_hydration$2(M, e, F), insert_hydration$2(M, r, F), C && C.m(r, null), append_hydration$2(r, n), L && L.m(r, null), insert_hydration$2(M, s, F), ~h && o[h].m(M, F), insert_hydration$2(M, g, F), w && w.m(M, F), insert_hydration$2(M, _, F), A = !0;
    },
    p(M, F) {
      /*variant*/
      M[8] === "default" && /*show_eta_bar*/
      M[18] && /*show_progress*/
      M[6] === "full" ? x ? x.p(M, F) : (x = create_if_block_16(M), x.c(), x.m(e.parentNode, e)) : x && (x.d(1), x = null), $ === ($ = k(M)) && C ? C.p(M, F) : (C && C.d(1), C = $ && $(M), C && (C.c(), C.m(r, n))), /*timer*/
      M[5] ? L ? L.p(M, F) : (L = create_if_block_10(M), L.c(), L.m(r, null)) : L && (L.d(1), L = null), (!A || F[0] & /*variant*/
      256) && toggle_class$1(
        r,
        "meta-text-center",
        /*variant*/
        M[8] === "center"
      ), (!A || F[0] & /*variant*/
      256) && toggle_class$1(
        r,
        "meta-text",
        /*variant*/
        M[8] === "default"
      );
      let m = h;
      h = v(M), h === m ? ~h && o[h].p(M, F) : (b && (group_outros$1(), transition_out$1(o[m], 1, 1, () => {
        o[m] = null;
      }), check_outros$1()), ~h ? (b = o[h], b ? b.p(M, F) : (b = o[h] = y[h](M), b.c()), transition_in$1(b, 1), b.m(g.parentNode, g)) : b = null), /*timer*/
      M[5] ? w && (group_outros$1(), transition_out$1(w, 1, 1, () => {
        w = null;
      }), check_outros$1()) : w ? (w.p(M, F), F[0] & /*timer*/
      32 && transition_in$1(w, 1)) : (w = create_if_block_1$1(M), w.c(), transition_in$1(w, 1), w.m(_.parentNode, _));
    },
    i(M) {
      A || (transition_in$1(b), transition_in$1(w), A = !0);
    },
    o(M) {
      transition_out$1(b), transition_out$1(w), A = !1;
    },
    d(M) {
      M && (detach$2(e), detach$2(r), detach$2(s), detach$2(g), detach$2(_)), x && x.d(M), C && C.d(), L && L.d(), ~h && o[h].d(M), w && w.d(M);
    }
  };
}
function create_if_block_16(a) {
  let e, r = `translateX(${/*eta_level*/
  (a[17] || 0) * 100 - 100}%)`;
  return {
    c() {
      e = element$2("div"), this.h();
    },
    l(n) {
      e = claim_element$2(n, "DIV", { class: !0 }), children$2(e).forEach(detach$2), this.h();
    },
    h() {
      attr$2(e, "class", "eta-bar svelte-17v219f"), set_style(e, "transform", r);
    },
    m(n, s) {
      insert_hydration$2(n, e, s);
    },
    p(n, s) {
      s[0] & /*eta_level*/
      131072 && r !== (r = `translateX(${/*eta_level*/
      (n[17] || 0) * 100 - 100}%)`) && set_style(e, "transform", r);
    },
    d(n) {
      n && detach$2(e);
    }
  };
}
function create_if_block_15(a) {
  let e;
  return {
    c() {
      e = text$2("processing |");
    },
    l(r) {
      e = claim_text$2(r, "processing |");
    },
    m(r, n) {
      insert_hydration$2(r, e, n);
    },
    p: noop$2,
    d(r) {
      r && detach$2(e);
    }
  };
}
function create_if_block_14(a) {
  let e, r = (
    /*queue_position*/
    a[2] + 1 + ""
  ), n, s, h, b;
  return {
    c() {
      e = text$2("queue: "), n = text$2(r), s = text$2("/"), h = text$2(
        /*queue_size*/
        a[3]
      ), b = text$2(" |");
    },
    l(g) {
      e = claim_text$2(g, "queue: "), n = claim_text$2(g, r), s = claim_text$2(g, "/"), h = claim_text$2(
        g,
        /*queue_size*/
        a[3]
      ), b = claim_text$2(g, " |");
    },
    m(g, _) {
      insert_hydration$2(g, e, _), insert_hydration$2(g, n, _), insert_hydration$2(g, s, _), insert_hydration$2(g, h, _), insert_hydration$2(g, b, _);
    },
    p(g, _) {
      _[0] & /*queue_position*/
      4 && r !== (r = /*queue_position*/
      g[2] + 1 + "") && set_data$1(n, r), _[0] & /*queue_size*/
      8 && set_data$1(
        h,
        /*queue_size*/
        g[3]
      );
    },
    d(g) {
      g && (detach$2(e), detach$2(n), detach$2(s), detach$2(h), detach$2(b));
    }
  };
}
function create_if_block_11(a) {
  let e, r = ensure_array_like$1(
    /*progress*/
    a[7]
  ), n = [];
  for (let s = 0; s < r.length; s += 1)
    n[s] = create_each_block_1(get_each_context_1(a, r, s));
  return {
    c() {
      for (let s = 0; s < n.length; s += 1)
        n[s].c();
      e = empty$1();
    },
    l(s) {
      for (let h = 0; h < n.length; h += 1)
        n[h].l(s);
      e = empty$1();
    },
    m(s, h) {
      for (let b = 0; b < n.length; b += 1)
        n[b] && n[b].m(s, h);
      insert_hydration$2(s, e, h);
    },
    p(s, h) {
      if (h[0] & /*progress*/
      128) {
        r = ensure_array_like$1(
          /*progress*/
          s[7]
        );
        let b;
        for (b = 0; b < r.length; b += 1) {
          const g = get_each_context_1(s, r, b);
          n[b] ? n[b].p(g, h) : (n[b] = create_each_block_1(g), n[b].c(), n[b].m(e.parentNode, e));
        }
        for (; b < n.length; b += 1)
          n[b].d(1);
        n.length = r.length;
      }
    },
    d(s) {
      s && detach$2(e), destroy_each$1(n, s);
    }
  };
}
function create_if_block_12(a) {
  let e, r = (
    /*p*/
    a[41].unit + ""
  ), n, s, h = " ", b;
  function g(x, k) {
    return (
      /*p*/
      x[41].length != null ? create_if_block_13 : create_else_block$1
    );
  }
  let _ = g(a), A = _(a);
  return {
    c() {
      A.c(), e = space$1(), n = text$2(r), s = text$2(" | "), b = text$2(h);
    },
    l(x) {
      A.l(x), e = claim_space$1(x), n = claim_text$2(x, r), s = claim_text$2(x, " | "), b = claim_text$2(x, h);
    },
    m(x, k) {
      A.m(x, k), insert_hydration$2(x, e, k), insert_hydration$2(x, n, k), insert_hydration$2(x, s, k), insert_hydration$2(x, b, k);
    },
    p(x, k) {
      _ === (_ = g(x)) && A ? A.p(x, k) : (A.d(1), A = _(x), A && (A.c(), A.m(e.parentNode, e))), k[0] & /*progress*/
      128 && r !== (r = /*p*/
      x[41].unit + "") && set_data$1(n, r);
    },
    d(x) {
      x && (detach$2(e), detach$2(n), detach$2(s), detach$2(b)), A.d(x);
    }
  };
}
function create_else_block$1(a) {
  let e = pretty_si(
    /*p*/
    a[41].index || 0
  ) + "", r;
  return {
    c() {
      r = text$2(e);
    },
    l(n) {
      r = claim_text$2(n, e);
    },
    m(n, s) {
      insert_hydration$2(n, r, s);
    },
    p(n, s) {
      s[0] & /*progress*/
      128 && e !== (e = pretty_si(
        /*p*/
        n[41].index || 0
      ) + "") && set_data$1(r, e);
    },
    d(n) {
      n && detach$2(r);
    }
  };
}
function create_if_block_13(a) {
  let e = pretty_si(
    /*p*/
    a[41].index || 0
  ) + "", r, n, s = pretty_si(
    /*p*/
    a[41].length
  ) + "", h;
  return {
    c() {
      r = text$2(e), n = text$2("/"), h = text$2(s);
    },
    l(b) {
      r = claim_text$2(b, e), n = claim_text$2(b, "/"), h = claim_text$2(b, s);
    },
    m(b, g) {
      insert_hydration$2(b, r, g), insert_hydration$2(b, n, g), insert_hydration$2(b, h, g);
    },
    p(b, g) {
      g[0] & /*progress*/
      128 && e !== (e = pretty_si(
        /*p*/
        b[41].index || 0
      ) + "") && set_data$1(r, e), g[0] & /*progress*/
      128 && s !== (s = pretty_si(
        /*p*/
        b[41].length
      ) + "") && set_data$1(h, s);
    },
    d(b) {
      b && (detach$2(r), detach$2(n), detach$2(h));
    }
  };
}
function create_each_block_1(a) {
  let e, r = (
    /*p*/
    a[41].index != null && create_if_block_12(a)
  );
  return {
    c() {
      r && r.c(), e = empty$1();
    },
    l(n) {
      r && r.l(n), e = empty$1();
    },
    m(n, s) {
      r && r.m(n, s), insert_hydration$2(n, e, s);
    },
    p(n, s) {
      /*p*/
      n[41].index != null ? r ? r.p(n, s) : (r = create_if_block_12(n), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null);
    },
    d(n) {
      n && detach$2(e), r && r.d(n);
    }
  };
}
function create_if_block_10(a) {
  let e, r = (
    /*eta*/
    a[0] ? `/${/*formatted_eta*/
    a[19]}` : ""
  ), n, s;
  return {
    c() {
      e = text$2(
        /*formatted_timer*/
        a[20]
      ), n = text$2(r), s = text$2("s");
    },
    l(h) {
      e = claim_text$2(
        h,
        /*formatted_timer*/
        a[20]
      ), n = claim_text$2(h, r), s = claim_text$2(h, "s");
    },
    m(h, b) {
      insert_hydration$2(h, e, b), insert_hydration$2(h, n, b), insert_hydration$2(h, s, b);
    },
    p(h, b) {
      b[0] & /*formatted_timer*/
      1048576 && set_data$1(
        e,
        /*formatted_timer*/
        h[20]
      ), b[0] & /*eta, formatted_eta*/
      524289 && r !== (r = /*eta*/
      h[0] ? `/${/*formatted_eta*/
      h[19]}` : "") && set_data$1(n, r);
    },
    d(h) {
      h && (detach$2(e), detach$2(n), detach$2(s));
    }
  };
}
function create_if_block_9(a) {
  let e, r;
  return e = new Loader({
    props: { margin: (
      /*variant*/
      a[8] === "default"
    ) }
  }), {
    c() {
      create_component$1(e.$$.fragment);
    },
    l(n) {
      claim_component$1(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component$1(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*variant*/
      256 && (h.margin = /*variant*/
      n[8] === "default"), e.$set(h);
    },
    i(n) {
      r || (transition_in$1(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out$1(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component$1(e, n);
    }
  };
}
function create_if_block_2(a) {
  let e, r, n, s, h, b = `${/*last_progress_level*/
  a[15] * 100}%`, g = (
    /*progress*/
    a[7] != null && create_if_block_3(a)
  );
  return {
    c() {
      e = element$2("div"), r = element$2("div"), g && g.c(), n = space$1(), s = element$2("div"), h = element$2("div"), this.h();
    },
    l(_) {
      e = claim_element$2(_, "DIV", { class: !0 });
      var A = children$2(e);
      r = claim_element$2(A, "DIV", { class: !0 });
      var x = children$2(r);
      g && g.l(x), x.forEach(detach$2), n = claim_space$1(A), s = claim_element$2(A, "DIV", { class: !0 });
      var k = children$2(s);
      h = claim_element$2(k, "DIV", { class: !0 }), children$2(h).forEach(detach$2), k.forEach(detach$2), A.forEach(detach$2), this.h();
    },
    h() {
      attr$2(r, "class", "progress-level-inner svelte-17v219f"), attr$2(h, "class", "progress-bar svelte-17v219f"), set_style(h, "width", b), attr$2(s, "class", "progress-bar-wrap svelte-17v219f"), attr$2(e, "class", "progress-level svelte-17v219f");
    },
    m(_, A) {
      insert_hydration$2(_, e, A), append_hydration$2(e, r), g && g.m(r, null), append_hydration$2(e, n), append_hydration$2(e, s), append_hydration$2(s, h), a[31](h);
    },
    p(_, A) {
      /*progress*/
      _[7] != null ? g ? g.p(_, A) : (g = create_if_block_3(_), g.c(), g.m(r, null)) : g && (g.d(1), g = null), A[0] & /*last_progress_level*/
      32768 && b !== (b = `${/*last_progress_level*/
      _[15] * 100}%`) && set_style(h, "width", b);
    },
    i: noop$2,
    o: noop$2,
    d(_) {
      _ && detach$2(e), g && g.d(), a[31](null);
    }
  };
}
function create_if_block_3(a) {
  let e, r = ensure_array_like$1(
    /*progress*/
    a[7]
  ), n = [];
  for (let s = 0; s < r.length; s += 1)
    n[s] = create_each_block$1(get_each_context$1(a, r, s));
  return {
    c() {
      for (let s = 0; s < n.length; s += 1)
        n[s].c();
      e = empty$1();
    },
    l(s) {
      for (let h = 0; h < n.length; h += 1)
        n[h].l(s);
      e = empty$1();
    },
    m(s, h) {
      for (let b = 0; b < n.length; b += 1)
        n[b] && n[b].m(s, h);
      insert_hydration$2(s, e, h);
    },
    p(s, h) {
      if (h[0] & /*progress_level, progress*/
      16512) {
        r = ensure_array_like$1(
          /*progress*/
          s[7]
        );
        let b;
        for (b = 0; b < r.length; b += 1) {
          const g = get_each_context$1(s, r, b);
          n[b] ? n[b].p(g, h) : (n[b] = create_each_block$1(g), n[b].c(), n[b].m(e.parentNode, e));
        }
        for (; b < n.length; b += 1)
          n[b].d(1);
        n.length = r.length;
      }
    },
    d(s) {
      s && detach$2(e), destroy_each$1(n, s);
    }
  };
}
function create_if_block_4(a) {
  let e, r, n, s, h = (
    /*i*/
    a[43] !== 0 && create_if_block_8()
  ), b = (
    /*p*/
    a[41].desc != null && create_if_block_7(a)
  ), g = (
    /*p*/
    a[41].desc != null && /*progress_level*/
    a[14] && /*progress_level*/
    a[14][
      /*i*/
      a[43]
    ] != null && create_if_block_6()
  ), _ = (
    /*progress_level*/
    a[14] != null && create_if_block_5(a)
  );
  return {
    c() {
      h && h.c(), e = space$1(), b && b.c(), r = space$1(), g && g.c(), n = space$1(), _ && _.c(), s = empty$1();
    },
    l(A) {
      h && h.l(A), e = claim_space$1(A), b && b.l(A), r = claim_space$1(A), g && g.l(A), n = claim_space$1(A), _ && _.l(A), s = empty$1();
    },
    m(A, x) {
      h && h.m(A, x), insert_hydration$2(A, e, x), b && b.m(A, x), insert_hydration$2(A, r, x), g && g.m(A, x), insert_hydration$2(A, n, x), _ && _.m(A, x), insert_hydration$2(A, s, x);
    },
    p(A, x) {
      /*p*/
      A[41].desc != null ? b ? b.p(A, x) : (b = create_if_block_7(A), b.c(), b.m(r.parentNode, r)) : b && (b.d(1), b = null), /*p*/
      A[41].desc != null && /*progress_level*/
      A[14] && /*progress_level*/
      A[14][
        /*i*/
        A[43]
      ] != null ? g || (g = create_if_block_6(), g.c(), g.m(n.parentNode, n)) : g && (g.d(1), g = null), /*progress_level*/
      A[14] != null ? _ ? _.p(A, x) : (_ = create_if_block_5(A), _.c(), _.m(s.parentNode, s)) : _ && (_.d(1), _ = null);
    },
    d(A) {
      A && (detach$2(e), detach$2(r), detach$2(n), detach$2(s)), h && h.d(A), b && b.d(A), g && g.d(A), _ && _.d(A);
    }
  };
}
function create_if_block_8(a) {
  let e;
  return {
    c() {
      e = text$2(" /");
    },
    l(r) {
      e = claim_text$2(r, " /");
    },
    m(r, n) {
      insert_hydration$2(r, e, n);
    },
    d(r) {
      r && detach$2(e);
    }
  };
}
function create_if_block_7(a) {
  let e = (
    /*p*/
    a[41].desc + ""
  ), r;
  return {
    c() {
      r = text$2(e);
    },
    l(n) {
      r = claim_text$2(n, e);
    },
    m(n, s) {
      insert_hydration$2(n, r, s);
    },
    p(n, s) {
      s[0] & /*progress*/
      128 && e !== (e = /*p*/
      n[41].desc + "") && set_data$1(r, e);
    },
    d(n) {
      n && detach$2(r);
    }
  };
}
function create_if_block_6(a) {
  let e;
  return {
    c() {
      e = text$2("-");
    },
    l(r) {
      e = claim_text$2(r, "-");
    },
    m(r, n) {
      insert_hydration$2(r, e, n);
    },
    d(r) {
      r && detach$2(e);
    }
  };
}
function create_if_block_5(a) {
  let e = (100 * /*progress_level*/
  (a[14][
    /*i*/
    a[43]
  ] || 0)).toFixed(1) + "", r, n;
  return {
    c() {
      r = text$2(e), n = text$2("%");
    },
    l(s) {
      r = claim_text$2(s, e), n = claim_text$2(s, "%");
    },
    m(s, h) {
      insert_hydration$2(s, r, h), insert_hydration$2(s, n, h);
    },
    p(s, h) {
      h[0] & /*progress_level*/
      16384 && e !== (e = (100 * /*progress_level*/
      (s[14][
        /*i*/
        s[43]
      ] || 0)).toFixed(1) + "") && set_data$1(r, e);
    },
    d(s) {
      s && (detach$2(r), detach$2(n));
    }
  };
}
function create_each_block$1(a) {
  let e, r = (
    /*p*/
    (a[41].desc != null || /*progress_level*/
    a[14] && /*progress_level*/
    a[14][
      /*i*/
      a[43]
    ] != null) && create_if_block_4(a)
  );
  return {
    c() {
      r && r.c(), e = empty$1();
    },
    l(n) {
      r && r.l(n), e = empty$1();
    },
    m(n, s) {
      r && r.m(n, s), insert_hydration$2(n, e, s);
    },
    p(n, s) {
      /*p*/
      n[41].desc != null || /*progress_level*/
      n[14] && /*progress_level*/
      n[14][
        /*i*/
        n[43]
      ] != null ? r ? r.p(n, s) : (r = create_if_block_4(n), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null);
    },
    d(n) {
      n && detach$2(e), r && r.d(n);
    }
  };
}
function create_if_block_1$1(a) {
  let e, r, n, s;
  const h = (
    /*#slots*/
    a[30]["additional-loading-text"]
  ), b = create_slot(
    h,
    a,
    /*$$scope*/
    a[29],
    get_additional_loading_text_slot_context
  );
  return {
    c() {
      e = element$2("p"), r = text$2(
        /*loading_text*/
        a[9]
      ), n = space$1(), b && b.c(), this.h();
    },
    l(g) {
      e = claim_element$2(g, "P", { class: !0 });
      var _ = children$2(e);
      r = claim_text$2(
        _,
        /*loading_text*/
        a[9]
      ), _.forEach(detach$2), n = claim_space$1(g), b && b.l(g), this.h();
    },
    h() {
      attr$2(e, "class", "loading svelte-17v219f");
    },
    m(g, _) {
      insert_hydration$2(g, e, _), append_hydration$2(e, r), insert_hydration$2(g, n, _), b && b.m(g, _), s = !0;
    },
    p(g, _) {
      (!s || _[0] & /*loading_text*/
      512) && set_data$1(
        r,
        /*loading_text*/
        g[9]
      ), b && b.p && (!s || _[0] & /*$$scope*/
      536870912) && update_slot_base(
        b,
        h,
        g,
        /*$$scope*/
        g[29],
        s ? get_slot_changes(
          h,
          /*$$scope*/
          g[29],
          _,
          get_additional_loading_text_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          g[29]
        ),
        get_additional_loading_text_slot_context
      );
    },
    i(g) {
      s || (transition_in$1(b, g), s = !0);
    },
    o(g) {
      transition_out$1(b, g), s = !1;
    },
    d(g) {
      g && (detach$2(e), detach$2(n)), b && b.d(g);
    }
  };
}
function create_fragment$2(a) {
  let e, r, n, s, h;
  const b = [create_if_block$1, create_if_block_17], g = [];
  function _(A, x) {
    return (
      /*status*/
      A[4] === "pending" ? 0 : (
        /*status*/
        A[4] === "error" ? 1 : -1
      )
    );
  }
  return ~(r = _(a)) && (n = g[r] = b[r](a)), {
    c() {
      e = element$2("div"), n && n.c(), this.h();
    },
    l(A) {
      e = claim_element$2(A, "DIV", { class: !0 });
      var x = children$2(e);
      n && n.l(x), x.forEach(detach$2), this.h();
    },
    h() {
      attr$2(e, "class", s = "wrap " + /*variant*/
      a[8] + " " + /*show_progress*/
      a[6] + " svelte-17v219f"), toggle_class$1(e, "hide", !/*status*/
      a[4] || /*status*/
      a[4] === "complete" || /*show_progress*/
      a[6] === "hidden" || /*status*/
      a[4] == "streaming"), toggle_class$1(
        e,
        "translucent",
        /*variant*/
        a[8] === "center" && /*status*/
        (a[4] === "pending" || /*status*/
        a[4] === "error") || /*translucent*/
        a[11] || /*show_progress*/
        a[6] === "minimal"
      ), toggle_class$1(
        e,
        "generating",
        /*status*/
        a[4] === "generating" && /*show_progress*/
        a[6] === "full"
      ), toggle_class$1(
        e,
        "border",
        /*border*/
        a[12]
      ), set_style(
        e,
        "position",
        /*absolute*/
        a[10] ? "absolute" : "static"
      ), set_style(
        e,
        "padding",
        /*absolute*/
        a[10] ? "0" : "var(--size-8) 0"
      );
    },
    m(A, x) {
      insert_hydration$2(A, e, x), ~r && g[r].m(e, null), a[33](e), h = !0;
    },
    p(A, x) {
      let k = r;
      r = _(A), r === k ? ~r && g[r].p(A, x) : (n && (group_outros$1(), transition_out$1(g[k], 1, 1, () => {
        g[k] = null;
      }), check_outros$1()), ~r ? (n = g[r], n ? n.p(A, x) : (n = g[r] = b[r](A), n.c()), transition_in$1(n, 1), n.m(e, null)) : n = null), (!h || x[0] & /*variant, show_progress*/
      320 && s !== (s = "wrap " + /*variant*/
      A[8] + " " + /*show_progress*/
      A[6] + " svelte-17v219f")) && attr$2(e, "class", s), (!h || x[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$1(e, "hide", !/*status*/
      A[4] || /*status*/
      A[4] === "complete" || /*show_progress*/
      A[6] === "hidden" || /*status*/
      A[4] == "streaming"), (!h || x[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
      2384) && toggle_class$1(
        e,
        "translucent",
        /*variant*/
        A[8] === "center" && /*status*/
        (A[4] === "pending" || /*status*/
        A[4] === "error") || /*translucent*/
        A[11] || /*show_progress*/
        A[6] === "minimal"
      ), (!h || x[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$1(
        e,
        "generating",
        /*status*/
        A[4] === "generating" && /*show_progress*/
        A[6] === "full"
      ), (!h || x[0] & /*variant, show_progress, border*/
      4416) && toggle_class$1(
        e,
        "border",
        /*border*/
        A[12]
      ), x[0] & /*absolute*/
      1024 && set_style(
        e,
        "position",
        /*absolute*/
        A[10] ? "absolute" : "static"
      ), x[0] & /*absolute*/
      1024 && set_style(
        e,
        "padding",
        /*absolute*/
        A[10] ? "0" : "var(--size-8) 0"
      );
    },
    i(A) {
      h || (transition_in$1(n), h = !0);
    },
    o(A) {
      transition_out$1(n), h = !1;
    },
    d(A) {
      A && detach$2(e), ~r && g[r].d(), a[33](null);
    }
  };
}
var __awaiter = function(a, e, r, n) {
  function s(h) {
    return h instanceof r ? h : new r(function(b) {
      b(h);
    });
  }
  return new (r || (r = Promise))(function(h, b) {
    function g(x) {
      try {
        A(n.next(x));
      } catch (k) {
        b(k);
      }
    }
    function _(x) {
      try {
        A(n.throw(x));
      } catch (k) {
        b(k);
      }
    }
    function A(x) {
      x.done ? h(x.value) : s(x.value).then(g, _);
    }
    A((n = n.apply(a, e || [])).next());
  });
};
let items = [], called = !1;
const is_browser = typeof window < "u", raf = is_browser ? window.requestAnimationFrame : (a) => {
};
function scroll_into_view(a) {
  return __awaiter(this, arguments, void 0, function* (e, r = !0) {
    if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && r !== !0)) {
      if (items.push(e), !called) called = !0;
      else return;
      yield tick(), raf(() => {
        let n = [0, 0];
        for (let s = 0; s < items.length; s++) {
          const b = items[s].getBoundingClientRect();
          (s === 0 || b.top + window.scrollY <= n[0]) && (n[0] = b.top + window.scrollY, n[1] = s);
        }
        window.scrollTo({ top: n[0] - 20, behavior: "smooth" }), called = !1, items = [];
      });
    }
  });
}
function instance$2(a, e, r) {
  let n, { $$slots: s = {}, $$scope: h } = e;
  this && this.__awaiter;
  const b = createEventDispatcher();
  let { i18n: g } = e, { eta: _ = null } = e, { queue_position: A } = e, { queue_size: x } = e, { status: k } = e, { scroll_to_output: $ = !1 } = e, { timer: C = !0 } = e, { show_progress: L = "full" } = e, { message: y = null } = e, { progress: o = null } = e, { variant: v = "default" } = e, { loading_text: w = "Loading..." } = e, { absolute: M = !0 } = e, { translucent: F = !1 } = e, { border: m = !1 } = e, { autoscroll: E } = e, z, O = !1, R = 0, B = 0, P = null, W = null, U = 0, V = null, K, q = null, H = !0;
  const j = () => {
    r(0, _ = r(27, P = r(19, Y = null))), r(25, R = performance.now()), r(26, B = 0), O = !0, Q();
  };
  function Q() {
    raf(() => {
      r(26, B = (performance.now() - R) / 1e3), O && Q();
    });
  }
  function J() {
    r(26, B = 0), r(0, _ = r(27, P = r(19, Y = null))), O && (O = !1);
  }
  onDestroy(() => {
    O && J();
  });
  let Y = null;
  function ee(he) {
    binding_callbacks[he ? "unshift" : "push"](() => {
      q = he, r(16, q), r(7, o), r(14, V), r(15, K);
    });
  }
  const fe = () => {
    b("clear_status");
  };
  function me(he) {
    binding_callbacks[he ? "unshift" : "push"](() => {
      z = he, r(13, z);
    });
  }
  return a.$$set = (he) => {
    "i18n" in he && r(1, g = he.i18n), "eta" in he && r(0, _ = he.eta), "queue_position" in he && r(2, A = he.queue_position), "queue_size" in he && r(3, x = he.queue_size), "status" in he && r(4, k = he.status), "scroll_to_output" in he && r(22, $ = he.scroll_to_output), "timer" in he && r(5, C = he.timer), "show_progress" in he && r(6, L = he.show_progress), "message" in he && r(23, y = he.message), "progress" in he && r(7, o = he.progress), "variant" in he && r(8, v = he.variant), "loading_text" in he && r(9, w = he.loading_text), "absolute" in he && r(10, M = he.absolute), "translucent" in he && r(11, F = he.translucent), "border" in he && r(12, m = he.border), "autoscroll" in he && r(24, E = he.autoscroll), "$$scope" in he && r(29, h = he.$$scope);
  }, a.$$.update = () => {
    a.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
    436207617 && (_ === null && r(0, _ = P), _ != null && P !== _ && (r(28, W = (performance.now() - R) / 1e3 + _), r(19, Y = W.toFixed(1)), r(27, P = _))), a.$$.dirty[0] & /*eta_from_start, timer_diff*/
    335544320 && r(17, U = W === null || W <= 0 || !B ? null : Math.min(B / W, 1)), a.$$.dirty[0] & /*progress*/
    128 && o != null && r(18, H = !1), a.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
    114816 && (o != null ? r(14, V = o.map((he) => {
      if (he.index != null && he.length != null)
        return he.index / he.length;
      if (he.progress != null)
        return he.progress;
    })) : r(14, V = null), V ? (r(15, K = V[V.length - 1]), q && (K === 0 ? r(16, q.style.transition = "0", q) : r(16, q.style.transition = "150ms", q))) : r(15, K = void 0)), a.$$.dirty[0] & /*status*/
    16 && (k === "pending" ? j() : J()), a.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
    20979728 && z && $ && (k === "pending" || k === "complete") && scroll_into_view(z, E), a.$$.dirty[0] & /*status, message*/
    8388624, a.$$.dirty[0] & /*timer_diff*/
    67108864 && r(20, n = B.toFixed(1));
  }, [
    _,
    g,
    A,
    x,
    k,
    C,
    L,
    o,
    v,
    w,
    M,
    F,
    m,
    z,
    V,
    K,
    q,
    U,
    H,
    Y,
    n,
    b,
    $,
    y,
    E,
    R,
    B,
    P,
    W,
    h,
    s,
    ee,
    fe,
    me
  ];
}
class Static extends SvelteComponent$2 {
  constructor(e) {
    super(), init$2(
      this,
      e,
      instance$2,
      create_fragment$2,
      safe_not_equal$2,
      {
        i18n: 1,
        eta: 0,
        queue_position: 2,
        queue_size: 3,
        status: 4,
        scroll_to_output: 22,
        timer: 5,
        show_progress: 6,
        message: 23,
        progress: 7,
        variant: 8,
        loading_text: 9,
        absolute: 10,
        translucent: 11,
        border: 12,
        autoscroll: 24
      },
      null,
      [-1, -1]
    );
  }
}
const {
  SvelteComponent: SvelteComponent$1,
  append_hydration: append_hydration$1,
  attr: attr$1,
  children: children$1,
  claim_element: claim_element$1,
  claim_text: claim_text$1,
  detach: detach$1,
  element: element$1,
  init: init$1,
  insert_hydration: insert_hydration$1,
  noop: noop$1,
  safe_not_equal: safe_not_equal$1,
  set_data,
  text: text$1,
  toggle_class
} = window.__gradio__svelte__internal;
function create_fragment$1(a) {
  let e, r = (
    /*value*/
    (a[0] ? Array.isArray(
      /*value*/
      a[0]
    ) ? (
      /*value*/
      a[0].join(", ")
    ) : (
      /*value*/
      a[0]
    ) : "") + ""
  ), n;
  return {
    c() {
      e = element$1("div"), n = text$1(r), this.h();
    },
    l(s) {
      e = claim_element$1(s, "DIV", { class: !0 });
      var h = children$1(e);
      n = claim_text$1(h, r), h.forEach(detach$1), this.h();
    },
    h() {
      attr$1(e, "class", "svelte-1hgn91n"), toggle_class(
        e,
        "table",
        /*type*/
        a[1] === "table"
      ), toggle_class(
        e,
        "gallery",
        /*type*/
        a[1] === "gallery"
      ), toggle_class(
        e,
        "selected",
        /*selected*/
        a[2]
      );
    },
    m(s, h) {
      insert_hydration$1(s, e, h), append_hydration$1(e, n);
    },
    p(s, [h]) {
      h & /*value*/
      1 && r !== (r = /*value*/
      (s[0] ? Array.isArray(
        /*value*/
        s[0]
      ) ? (
        /*value*/
        s[0].join(", ")
      ) : (
        /*value*/
        s[0]
      ) : "") + "") && set_data(n, r), h & /*type*/
      2 && toggle_class(
        e,
        "table",
        /*type*/
        s[1] === "table"
      ), h & /*type*/
      2 && toggle_class(
        e,
        "gallery",
        /*type*/
        s[1] === "gallery"
      ), h & /*selected*/
      4 && toggle_class(
        e,
        "selected",
        /*selected*/
        s[2]
      );
    },
    i: noop$1,
    o: noop$1,
    d(s) {
      s && detach$1(e);
    }
  };
}
function instance$1(a, e, r) {
  let { value: n } = e, { type: s } = e, { selected: h = !1 } = e;
  return a.$$set = (b) => {
    "value" in b && r(0, n = b.value), "type" in b && r(1, s = b.type), "selected" in b && r(2, h = b.selected);
  }, [n, s, h];
}
class Example extends SvelteComponent$1 {
  constructor(e) {
    super(), init$1(this, e, instance$1, create_fragment$1, safe_not_equal$1, { value: 0, type: 1, selected: 2 });
  }
}
const {
  SvelteComponent,
  append_hydration,
  assign,
  attr,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  create_component,
  destroy_component,
  destroy_each,
  detach,
  element,
  empty,
  ensure_array_like,
  flush,
  get_spread_object,
  get_spread_update,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration,
  mount_component,
  noop,
  safe_not_equal,
  space,
  svg_element,
  text,
  transition_in,
  transition_out
} = window.__gradio__svelte__internal;
function get_each_context(a, e, r) {
  const n = a.slice();
  return n[43] = e[r], n;
}
function create_else_block(a) {
  let e, r;
  return e = new FileUpload({
    props: {
      upload: (
        /*gradio*/
        a[17].client.upload
      ),
      stream_handler: (
        /*gradio*/
        a[17].client.stream
      ),
      label: (
        /*label*/
        a[7]
      ),
      show_label: (
        /*show_label*/
        a[8]
      ),
      value: (
        /*value*/
        a[0]
      ),
      file_count: (
        /*file_count*/
        a[18]
      ),
      file_types: (
        /*file_types*/
        a[19]
      ),
      selectable: (
        /*_selectable*/
        a[13]
      ),
      root: (
        /*root*/
        a[6]
      ),
      height: (
        /*height*/
        a[9]
      ),
      representations: (
        /*representations*/
        a[23]
      ),
      config: (
        /*config*/
        a[10]
      ),
      confidenceLabel: (
        /*confidenceLabel*/
        a[11]
      ),
      moldata: (
        /*moldata*/
        a[20]
      ),
      molviewer: (
        /*showviewer*/
        a[12]
      ),
      max_file_size: (
        /*gradio*/
        a[17].max_file_size
      ),
      i18n: (
        /*gradio*/
        a[17].i18n
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx: a }
    }
  }), e.$on(
    "change",
    /*change_handler*/
    a[29]
  ), e.$on(
    "drag",
    /*drag_handler*/
    a[30]
  ), e.$on(
    "clear",
    /*clear_handler*/
    a[31]
  ), e.$on(
    "select",
    /*select_handler_1*/
    a[32]
  ), e.$on(
    "notfound",
    /*notfound_handler*/
    a[33]
  ), e.$on(
    "upload",
    /*upload_handler*/
    a[34]
  ), e.$on(
    "error",
    /*error_handler*/
    a[35]
  ), e.$on(
    "delete",
    /*delete_handler*/
    a[36]
  ), {
    c() {
      create_component(e.$$.fragment);
    },
    l(n) {
      claim_component(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*gradio*/
      131072 && (h.upload = /*gradio*/
      n[17].client.upload), s[0] & /*gradio*/
      131072 && (h.stream_handler = /*gradio*/
      n[17].client.stream), s[0] & /*label*/
      128 && (h.label = /*label*/
      n[7]), s[0] & /*show_label*/
      256 && (h.show_label = /*show_label*/
      n[8]), s[0] & /*value*/
      1 && (h.value = /*value*/
      n[0]), s[0] & /*file_count*/
      262144 && (h.file_count = /*file_count*/
      n[18]), s[0] & /*file_types*/
      524288 && (h.file_types = /*file_types*/
      n[19]), s[0] & /*_selectable*/
      8192 && (h.selectable = /*_selectable*/
      n[13]), s[0] & /*root*/
      64 && (h.root = /*root*/
      n[6]), s[0] & /*height*/
      512 && (h.height = /*height*/
      n[9]), s[0] & /*config*/
      1024 && (h.config = /*config*/
      n[10]), s[0] & /*confidenceLabel*/
      2048 && (h.confidenceLabel = /*confidenceLabel*/
      n[11]), s[0] & /*moldata*/
      1048576 && (h.moldata = /*moldata*/
      n[20]), s[0] & /*showviewer*/
      4096 && (h.molviewer = /*showviewer*/
      n[12]), s[0] & /*gradio*/
      131072 && (h.max_file_size = /*gradio*/
      n[17].max_file_size), s[0] & /*gradio*/
      131072 && (h.i18n = /*gradio*/
      n[17].i18n), s[0] & /*gradio*/
      131072 | s[1] & /*$$scope*/
      32768 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component(e, n);
    }
  };
}
function create_if_block_1(a) {
  let e, r;
  return e = new File_1({
    props: {
      selectable: (
        /*_selectable*/
        a[13]
      ),
      value: (
        /*value*/
        a[0]
      ),
      label: (
        /*label*/
        a[7]
      ),
      show_label: (
        /*show_label*/
        a[8]
      ),
      height: (
        /*height*/
        a[9]
      ),
      representations: (
        /*representations*/
        a[23]
      ),
      config: (
        /*config*/
        a[10]
      ),
      confidenceLabel: (
        /*confidenceLabel*/
        a[11]
      ),
      moldata: (
        /*moldata*/
        a[20]
      ),
      errors: (
        /*errors*/
        a[22]
      ),
      i18n: (
        /*gradio*/
        a[17].i18n
      ),
      molviewer: (
        /*showviewer*/
        a[12]
      )
    }
  }), e.$on(
    "select",
    /*select_handler*/
    a[28]
  ), {
    c() {
      create_component(e.$$.fragment);
    },
    l(n) {
      claim_component(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*_selectable*/
      8192 && (h.selectable = /*_selectable*/
      n[13]), s[0] & /*value*/
      1 && (h.value = /*value*/
      n[0]), s[0] & /*label*/
      128 && (h.label = /*label*/
      n[7]), s[0] & /*show_label*/
      256 && (h.show_label = /*show_label*/
      n[8]), s[0] & /*height*/
      512 && (h.height = /*height*/
      n[9]), s[0] & /*config*/
      1024 && (h.config = /*config*/
      n[10]), s[0] & /*confidenceLabel*/
      2048 && (h.confidenceLabel = /*confidenceLabel*/
      n[11]), s[0] & /*moldata*/
      1048576 && (h.moldata = /*moldata*/
      n[20]), s[0] & /*gradio*/
      131072 && (h.i18n = /*gradio*/
      n[17].i18n), s[0] & /*showviewer*/
      4096 && (h.molviewer = /*showviewer*/
      n[12]), e.$set(h);
    },
    i(n) {
      r || (transition_in(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component(e, n);
    }
  };
}
function create_default_slot_1(a) {
  let e, r;
  return e = new UploadText({
    props: {
      i18n: (
        /*gradio*/
        a[17].i18n
      ),
      type: "file"
    }
  }), {
    c() {
      create_component(e.$$.fragment);
    },
    l(n) {
      claim_component(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*gradio*/
      131072 && (h.i18n = /*gradio*/
      n[17].i18n), e.$set(h);
    },
    i(n) {
      r || (transition_in(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component(e, n);
    }
  };
}
function create_if_block(a) {
  let e, r, n, s, h, b = "Error in the representations", g, _, A, x = "Couldn't display Molecule. Fix the following problems:", k, $, C = ensure_array_like(
    /*errors*/
    a[22]
  ), L = [];
  for (let y = 0; y < C.length; y += 1)
    L[y] = create_each_block(get_each_context(a, C, y));
  return {
    c() {
      e = element("div"), r = svg_element("svg"), n = svg_element("path"), s = space(), h = element("span"), h.textContent = b, g = space(), _ = element("div"), A = element("span"), A.textContent = x, k = space(), $ = element("ul");
      for (let y = 0; y < L.length; y += 1)
        L[y].c();
      this.h();
    },
    l(y) {
      e = claim_element(y, "DIV", { class: !0, role: !0 });
      var o = children(e);
      r = claim_svg_element(o, "svg", {
        class: !0,
        xmlns: !0,
        fill: !0,
        viewBox: !0,
        "stroke-width": !0,
        stroke: !0
      });
      var v = children(r);
      n = claim_svg_element(v, "path", {
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        d: !0
      }), children(n).forEach(detach), v.forEach(detach), s = claim_space(o), h = claim_element(o, "SPAN", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset(h) !== "svelte-jj7i23" && (h.textContent = b), g = claim_space(o), _ = claim_element(o, "DIV", {});
      var w = children(_);
      A = claim_element(w, "SPAN", { class: !0, "data-svelte-h": !0 }), get_svelte_dataset(A) !== "svelte-6hdql9" && (A.textContent = x), k = claim_space(w), $ = claim_element(w, "UL", { class: !0 });
      var M = children($);
      for (let F = 0; F < L.length; F += 1)
        L[F].l(M);
      M.forEach(detach), w.forEach(detach), o.forEach(detach), this.h();
    },
    h() {
      attr(n, "stroke-linecap", "round"), attr(n, "stroke-linejoin", "round"), attr(n, "d", "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"), attr(r, "class", "flex-shrink-0 inline w-4 h-4 mr-3 mt-[2px]"), attr(r, "xmlns", "http://www.w3.org/2000/svg"), attr(r, "fill", "none"), attr(r, "viewBox", "0 0 24 24"), attr(r, "stroke-width", "1.5"), attr(r, "stroke", "currentColor"), attr(h, "class", "sr-only"), attr(A, "class", "font-medium"), attr($, "class", "mt-1.5 ml-4 list-disc list-inside"), attr(e, "class", "flex m-2 p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50 dark:bg-gray-800 dark:text-red-400"), attr(e, "role", "alert");
    },
    m(y, o) {
      insert_hydration(y, e, o), append_hydration(e, r), append_hydration(r, n), append_hydration(e, s), append_hydration(e, h), append_hydration(e, g), append_hydration(e, _), append_hydration(_, A), append_hydration(_, k), append_hydration(_, $);
      for (let v = 0; v < L.length; v += 1)
        L[v] && L[v].m($, null);
    },
    p(y, o) {
      if (o[0] & /*errors*/
      4194304) {
        C = ensure_array_like(
          /*errors*/
          y[22]
        );
        let v;
        for (v = 0; v < C.length; v += 1) {
          const w = get_each_context(y, C, v);
          L[v] ? L[v].p(w, o) : (L[v] = create_each_block(w), L[v].c(), L[v].m($, null));
        }
        for (; v < L.length; v += 1)
          L[v].d(1);
        L.length = C.length;
      }
    },
    d(y) {
      y && detach(e), destroy_each(L, y);
    }
  };
}
function create_each_block(a) {
  let e, r = (
    /*error*/
    a[43] + ""
  ), n;
  return {
    c() {
      e = element("li"), n = text(r);
    },
    l(s) {
      e = claim_element(s, "LI", {});
      var h = children(e);
      n = claim_text(h, r), h.forEach(detach);
    },
    m(s, h) {
      insert_hydration(s, e, h), append_hydration(e, n);
    },
    p: noop,
    d(s) {
      s && detach(e);
    }
  };
}
function create_default_slot(a) {
  let e, r, n, s, h, b, g;
  const _ = [
    {
      autoscroll: (
        /*gradio*/
        a[17].autoscroll
      )
    },
    { i18n: (
      /*gradio*/
      a[17].i18n
    ) },
    /*loading_status*/
    a[1],
    {
      status: (
        /*loading_status*/
        a[1]?.status || "complete"
      )
    }
  ];
  let A = {};
  for (let L = 0; L < _.length; L += 1)
    A = assign(A, _[L]);
  e = new Static({ props: A }), e.$on(
    "clear_status",
    /*clear_status_handler*/
    a[27]
  );
  const x = [create_if_block_1, create_else_block], k = [];
  function $(L, y) {
    return (
      /*interactive*/
      L[5] ? 1 : 0
    );
  }
  n = $(a), s = k[n] = x[n](a);
  let C = (
    /*errors*/
    a[22].length > 0 && /*value*/
    a[0] !== null && create_if_block(a)
  );
  return {
    c() {
      create_component(e.$$.fragment), r = space(), s.c(), h = space(), C && C.c(), b = empty();
    },
    l(L) {
      claim_component(e.$$.fragment, L), r = claim_space(L), s.l(L), h = claim_space(L), C && C.l(L), b = empty();
    },
    m(L, y) {
      mount_component(e, L, y), insert_hydration(L, r, y), k[n].m(L, y), insert_hydration(L, h, y), C && C.m(L, y), insert_hydration(L, b, y), g = !0;
    },
    p(L, y) {
      const o = y[0] & /*gradio, loading_status*/
      131074 ? get_spread_update(_, [
        y[0] & /*gradio*/
        131072 && {
          autoscroll: (
            /*gradio*/
            L[17].autoscroll
          )
        },
        y[0] & /*gradio*/
        131072 && { i18n: (
          /*gradio*/
          L[17].i18n
        ) },
        y[0] & /*loading_status*/
        2 && get_spread_object(
          /*loading_status*/
          L[1]
        ),
        y[0] & /*loading_status*/
        2 && {
          status: (
            /*loading_status*/
            L[1]?.status || "complete"
          )
        }
      ]) : {};
      e.$set(o);
      let v = n;
      n = $(L), n === v ? k[n].p(L, y) : (group_outros(), transition_out(k[v], 1, 1, () => {
        k[v] = null;
      }), check_outros(), s = k[n], s ? s.p(L, y) : (s = k[n] = x[n](L), s.c()), transition_in(s, 1), s.m(h.parentNode, h)), /*errors*/
      L[22].length > 0 && /*value*/
      L[0] !== null ? C ? C.p(L, y) : (C = create_if_block(L), C.c(), C.m(b.parentNode, b)) : C && (C.d(1), C = null);
    },
    i(L) {
      g || (transition_in(e.$$.fragment, L), transition_in(s), g = !0);
    },
    o(L) {
      transition_out(e.$$.fragment, L), transition_out(s), g = !1;
    },
    d(L) {
      L && (detach(r), detach(h), detach(b)), destroy_component(e, L), k[n].d(L), C && C.d(L);
    }
  };
}
function create_fragment(a) {
  let e, r;
  return e = new Block({
    props: {
      visible: (
        /*visible*/
        a[4]
      ),
      variant: (
        /*value*/
        a[0] ? "solid" : "dashed"
      ),
      border_mode: (
        /*dragging*/
        a[21] ? "focus" : "base"
      ),
      padding: !1,
      elem_id: (
        /*elem_id*/
        a[2]
      ),
      elem_classes: (
        /*elem_classes*/
        a[3]
      ),
      container: (
        /*container*/
        a[14]
      ),
      scale: (
        /*scale*/
        a[15]
      ),
      min_width: (
        /*min_width*/
        a[16]
      ),
      allow_overflow: !1,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: a }
    }
  }), {
    c() {
      create_component(e.$$.fragment);
    },
    l(n) {
      claim_component(e.$$.fragment, n);
    },
    m(n, s) {
      mount_component(e, n, s), r = !0;
    },
    p(n, s) {
      const h = {};
      s[0] & /*visible*/
      16 && (h.visible = /*visible*/
      n[4]), s[0] & /*value*/
      1 && (h.variant = /*value*/
      n[0] ? "solid" : "dashed"), s[0] & /*dragging*/
      2097152 && (h.border_mode = /*dragging*/
      n[21] ? "focus" : "base"), s[0] & /*elem_id*/
      4 && (h.elem_id = /*elem_id*/
      n[2]), s[0] & /*elem_classes*/
      8 && (h.elem_classes = /*elem_classes*/
      n[3]), s[0] & /*container*/
      16384 && (h.container = /*container*/
      n[14]), s[0] & /*scale*/
      32768 && (h.scale = /*scale*/
      n[15]), s[0] & /*min_width*/
      65536 && (h.min_width = /*min_width*/
      n[16]), s[0] & /*value, _selectable, label, show_label, height, config, confidenceLabel, moldata, gradio, showviewer, interactive, file_count, file_types, root, dragging, loading_status*/
      4079587 | s[1] & /*$$scope*/
      32768 && (h.$$scope = { dirty: s, ctx: n }), e.$set(h);
    },
    i(n) {
      r || (transition_in(e.$$.fragment, n), r = !0);
    },
    o(n) {
      transition_out(e.$$.fragment, n), r = !1;
    },
    d(n) {
      destroy_component(e, n);
    }
  };
}
function instance(a, e, r) {
  var n = this && this.__awaiter || function(ce, be, le, Se) {
    function ge(de) {
      return de instanceof le ? de : new le(function(De) {
        De(de);
      });
    }
    return new (le || (le = Promise))(function(de, De) {
      function Be(Ze) {
        try {
          qe(Se.next(Ze));
        } catch (Ye) {
          De(Ye);
        }
      }
      function Ve(Ze) {
        try {
          qe(Se.throw(Ze));
        } catch (Ye) {
          De(Ye);
        }
      }
      function qe(Ze) {
        Ze.done ? de(Ze.value) : ge(Ze.value).then(Be, Ve);
      }
      qe((Se = Se.apply(ce, be || [])).next());
    });
  };
  let { elem_id: s = "" } = e, { elem_classes: h = [] } = e, { visible: b = !0 } = e, { value: g } = e, { interactive: _ } = e, { root: A } = e, { label: x } = e, { show_label: k } = e, { height: $ = void 0 } = e, { reps: C = [] } = e, { config: L = {} } = e, { confidenceLabel: y = "" } = e, { showviewer: o = !0 } = e, { _selectable: v = !1 } = e, { loading_status: w } = e, { container: M = !0 } = e, { scale: F = null } = e, { min_width: m = void 0 } = e, { gradio: E } = e, { file_count: z } = e, { file_types: O = ["file"] } = e, R = g, B = !1, P = {
    model: { type: Number, default: 0 },
    chain: { type: String, default: "" },
    resname: { type: String, default: "" },
    style: {
      type: String,
      default: "cartoon",
      choices: ["cartoon", "stick", "sphere", "surface"]
    },
    color: {
      type: String,
      default: "whiteCarbon",
      choices: [
        "whiteCarbon",
        "orangeCarbon",
        "redCarbon",
        "blackCarbon",
        "blueCarbon",
        "grayCarbon",
        "greenCarbon",
        "cyanCarbon",
        "alphafold",
        "default",
        "Jmol",
        "chain",
        "spectrum"
      ]
    },
    opacity: { type: Number, default: 1 },
    residue_range: { type: String, default: "" },
    around: { type: Number, default: 0 },
    byres: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !0 }
  }, W = null, U = ["pdb", "sdf", "mol2", "pdb1", "cif", "traj", "xyz"];
  function V(ce) {
    return n(this, void 0, void 0, function* () {
      return yield (yield fetch(ce)).text();
    });
  }
  let K = [];
  function q(ce) {
    return n(this, void 0, void 0, function* () {
      if (ce == null)
        return [];
      if (Array.isArray(ce)) {
        let be = [];
        for (const le of ce) {
          let Se = le.orig_name.split(".").pop();
          if (!U.includes(Se)) {
            K.push(`Invalid file extension for ${le.orig_name}. Expected one of ${U.join(", ")}, got ${Se}`), r(20, W = null);
            continue;
          }
          be.push({
            data: yield V(le.url),
            name: le.orig_name,
            format: Se,
            asFrames: !1
          });
        }
        r(20, W = be);
      } else if (typeof ce == "object" && ce !== null) {
        let be = ce.orig_name.split(".").pop();
        if (!U.includes(be))
          K.push(`Invalid file extension for ${ce.orig_name}. Expected one of ${U.join(", ")}, got ${be}`), r(20, W = null);
        else {
          let le = yield V(ce.url), Se = ce.orig_name.split(".").pop();
          Se === "pdb1" && (Se = "pdb"), r(20, W = [
            {
              data: le,
              name: ce.orig_name,
              format: Se,
              asFrames: !1
            }
          ]);
        }
      } else
        r(20, W = null);
    });
  }
  let H = 0, j = [];
  const Q = () => E.dispatch("clear_status", w), J = ({ detail: ce }) => E.dispatch("select", ce), Y = ({ detail: ce }) => {
    r(0, g = ce);
  }, ee = ({ detail: ce }) => r(21, B = ce), fe = () => E.dispatch("clear"), me = ({ detail: ce }) => E.dispatch("select", ce), he = () => E.dispatch("error", "identifier not found in database, check spelling"), we = () => E.dispatch("upload"), ye = ({ detail: ce }) => {
    r(1, w = w || {}), r(1, w.status = "error", w), E.dispatch("error", ce);
  }, ve = ({ detail: ce }) => {
    E.dispatch("delete", ce);
  };
  return a.$$set = (ce) => {
    "elem_id" in ce && r(2, s = ce.elem_id), "elem_classes" in ce && r(3, h = ce.elem_classes), "visible" in ce && r(4, b = ce.visible), "value" in ce && r(0, g = ce.value), "interactive" in ce && r(5, _ = ce.interactive), "root" in ce && r(6, A = ce.root), "label" in ce && r(7, x = ce.label), "show_label" in ce && r(8, k = ce.show_label), "height" in ce && r(9, $ = ce.height), "reps" in ce && r(24, C = ce.reps), "config" in ce && r(10, L = ce.config), "confidenceLabel" in ce && r(11, y = ce.confidenceLabel), "showviewer" in ce && r(12, o = ce.showviewer), "_selectable" in ce && r(13, v = ce._selectable), "loading_status" in ce && r(1, w = ce.loading_status), "container" in ce && r(14, M = ce.container), "scale" in ce && r(15, F = ce.scale), "min_width" in ce && r(16, m = ce.min_width), "gradio" in ce && r(17, E = ce.gradio), "file_count" in ce && r(18, z = ce.file_count), "file_types" in ce && r(19, O = ce.file_types);
  }, a.$$.update = () => {
    a.$$.dirty[0] & /*old_value, value, gradio*/
    33685505 && JSON.stringify(R) !== JSON.stringify(g) && (E.dispatch("change"), r(25, R = g), r(20, W = null), q(g)), a.$$.dirty[0] & /*reps, gradio, value*/
    16908289 && JSON.stringify(C) !== JSON.stringify(C) && (E.dispatch("change"), r(25, R = g), r(20, W = null), q(g)), a.$$.dirty[0] & /*moldata*/
    1048576 && r(26, H = W ? W.length : 0), a.$$.dirty[0] & /*reps, lenMoldata*/
    83886080 && (C.forEach((ce) => {
      for (const [be, le] of Object.entries(P))
        ce[be] === void 0 && (ce[be] = le.default), ce[be].constructor != le.type && K.push(`Invalid type for ${be} in reps. Expected ${le.type}, got ${typeof ce[be]}`);
    }), C.forEach((ce) => {
      ce.model <= H && j.push(ce);
    })), a.$$.dirty[0] & /*value*/
    1 && q(g);
  }, [
    g,
    w,
    s,
    h,
    b,
    _,
    A,
    x,
    k,
    $,
    L,
    y,
    o,
    v,
    M,
    F,
    m,
    E,
    z,
    O,
    W,
    B,
    K,
    j,
    C,
    R,
    H,
    Q,
    J,
    Y,
    ee,
    fe,
    me,
    he,
    we,
    ye,
    ve
  ];
}
class Index extends SvelteComponent {
  constructor(e) {
    super(), init(
      this,
      e,
      instance,
      create_fragment,
      safe_not_equal,
      {
        elem_id: 2,
        elem_classes: 3,
        visible: 4,
        value: 0,
        interactive: 5,
        root: 6,
        label: 7,
        show_label: 8,
        height: 9,
        reps: 24,
        config: 10,
        confidenceLabel: 11,
        showviewer: 12,
        _selectable: 13,
        loading_status: 1,
        container: 14,
        scale: 15,
        min_width: 16,
        gradio: 17,
        file_count: 18,
        file_types: 19
      },
      null,
      [-1, -1]
    );
  }
  get elem_id() {
    return this.$$.ctx[2];
  }
  set elem_id(e) {
    this.$$set({ elem_id: e }), flush();
  }
  get elem_classes() {
    return this.$$.ctx[3];
  }
  set elem_classes(e) {
    this.$$set({ elem_classes: e }), flush();
  }
  get visible() {
    return this.$$.ctx[4];
  }
  set visible(e) {
    this.$$set({ visible: e }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(e) {
    this.$$set({ value: e }), flush();
  }
  get interactive() {
    return this.$$.ctx[5];
  }
  set interactive(e) {
    this.$$set({ interactive: e }), flush();
  }
  get root() {
    return this.$$.ctx[6];
  }
  set root(e) {
    this.$$set({ root: e }), flush();
  }
  get label() {
    return this.$$.ctx[7];
  }
  set label(e) {
    this.$$set({ label: e }), flush();
  }
  get show_label() {
    return this.$$.ctx[8];
  }
  set show_label(e) {
    this.$$set({ show_label: e }), flush();
  }
  get height() {
    return this.$$.ctx[9];
  }
  set height(e) {
    this.$$set({ height: e }), flush();
  }
  get reps() {
    return this.$$.ctx[24];
  }
  set reps(e) {
    this.$$set({ reps: e }), flush();
  }
  get config() {
    return this.$$.ctx[10];
  }
  set config(e) {
    this.$$set({ config: e }), flush();
  }
  get confidenceLabel() {
    return this.$$.ctx[11];
  }
  set confidenceLabel(e) {
    this.$$set({ confidenceLabel: e }), flush();
  }
  get showviewer() {
    return this.$$.ctx[12];
  }
  set showviewer(e) {
    this.$$set({ showviewer: e }), flush();
  }
  get _selectable() {
    return this.$$.ctx[13];
  }
  set _selectable(e) {
    this.$$set({ _selectable: e }), flush();
  }
  get loading_status() {
    return this.$$.ctx[1];
  }
  set loading_status(e) {
    this.$$set({ loading_status: e }), flush();
  }
  get container() {
    return this.$$.ctx[14];
  }
  set container(e) {
    this.$$set({ container: e }), flush();
  }
  get scale() {
    return this.$$.ctx[15];
  }
  set scale(e) {
    this.$$set({ scale: e }), flush();
  }
  get min_width() {
    return this.$$.ctx[16];
  }
  set min_width(e) {
    this.$$set({ min_width: e }), flush();
  }
  get gradio() {
    return this.$$.ctx[17];
  }
  set gradio(e) {
    this.$$set({ gradio: e }), flush();
  }
  get file_count() {
    return this.$$.ctx[18];
  }
  set file_count(e) {
    this.$$set({ file_count: e }), flush();
  }
  get file_types() {
    return this.$$.ctx[19];
  }
  set file_types(e) {
    this.$$set({ file_types: e }), flush();
  }
}
export {
  Example as BaseExample,
  File_1 as BaseFile,
  FileUpload as BaseFileUpload,
  FilePreview,
  Index as default
};
